
            (() => {
              var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);

// ../../node_modules/.pnpm/process-es6@0.11.6/node_modules/process-es6/browser.js
var browser_exports = {};
__export(browser_exports, {
  addListener: () => addListener,
  argv: () => argv,
  binding: () => binding,
  browser: () => browser,
  chdir: () => chdir,
  config: () => config,
  cwd: () => cwd,
  default: () => browser_default,
  emit: () => emit,
  env: () => env,
  hrtime: () => hrtime,
  nextTick: () => nextTick,
  off: () => off,
  on: () => on,
  once: () => once,
  platform: () => platform,
  release: () => release,
  removeAllListeners: () => removeAllListeners,
  removeListener: () => removeListener,
  title: () => title,
  umask: () => umask,
  uptime: () => uptime,
  version: () => version,
  versions: () => versions
});
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
function noop() {
}
function binding(name) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1e3;
}
var cachedSetTimeout, cachedClearTimeout, queue, draining, currentQueue, queueIndex, title, platform, browser, env, argv, version, versions, release, config, on, addListener, once, off, removeListener, removeAllListeners, emit, performance, performanceNow, startTime, browser_default;
var init_browser = __esm({
  "../../node_modules/.pnpm/process-es6@0.11.6/node_modules/process-es6/browser.js"() {
    cachedSetTimeout = defaultSetTimout;
    cachedClearTimeout = defaultClearTimeout;
    if (typeof global.setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    }
    if (typeof global.clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    }
    queue = [];
    draining = false;
    queueIndex = -1;
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    title = "browser";
    platform = "browser";
    browser = true;
    env = {};
    argv = [];
    version = "";
    versions = {};
    release = {};
    config = {};
    on = noop;
    addListener = noop;
    once = noop;
    off = noop;
    removeListener = noop;
    removeAllListeners = noop;
    emit = noop;
    performance = global.performance || {};
    performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function() {
      return new Date().getTime();
    };
    startTime = new Date();
    browser_default = {
      nextTick,
      title,
      browser,
      env,
      argv,
      version,
      versions,
      on,
      addListener,
      once,
      off,
      removeListener,
      removeAllListeners,
      emit,
      binding,
      cwd,
      chdir,
      umask,
      hrtime,
      platform,
      release,
      config,
      uptime
    };
  }
});

// ../../node_modules/.pnpm/buffer-es6@4.9.3/node_modules/buffer-es6/base64.js
function init() {
  inited = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
}
function toByteArray(b64) {
  if (!inited) {
    init();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr(len * 3 / 4 - placeHolders);
  l = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 255;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 63];
    output += lookup[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
var lookup, revLookup, Arr, inited;
var init_base64 = __esm({
  "../../node_modules/.pnpm/buffer-es6@4.9.3/node_modules/buffer-es6/base64.js"() {
    lookup = [];
    revLookup = [];
    Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    inited = false;
  }
});

// ../../node_modules/.pnpm/buffer-es6@4.9.3/node_modules/buffer-es6/ieee754.js
function read(buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
}
function write(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer[offset + i - d] |= s * 128;
}
var init_ieee754 = __esm({
  "../../node_modules/.pnpm/buffer-es6@4.9.3/node_modules/buffer-es6/ieee754.js"() {
  }
});

// ../../node_modules/.pnpm/buffer-es6@4.9.3/node_modules/buffer-es6/isArray.js
var toString, isArray_default;
var init_isArray = __esm({
  "../../node_modules/.pnpm/buffer-es6@4.9.3/node_modules/buffer-es6/isArray.js"() {
    toString = {}.toString;
    isArray_default = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// ../../node_modules/.pnpm/buffer-es6@4.9.3/node_modules/buffer-es6/index.js
var buffer_es6_exports = {};
__export(buffer_es6_exports, {
  Buffer: () => Buffer2,
  INSPECT_MAX_BYTES: () => INSPECT_MAX_BYTES,
  SlowBuffer: () => SlowBuffer,
  isBuffer: () => isBuffer,
  kMaxLength: () => _kMaxLength
});
function kMaxLength() {
  return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length);
    that.__proto__ = Buffer2.prototype;
  } else {
    if (that === null) {
      that = new Buffer2(length);
    }
    that.length = length;
  }
  return that;
}
function Buffer2(arg, encodingOrOffset, length) {
  if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
    return new Buffer2(arg, encodingOrOffset, length);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error("If encoding is specified then the first argument must be a string");
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}
function from(that, value, encodingOrOffset, length) {
  if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }
  if (typeof value === "string") {
    return fromString(that, value, encodingOrOffset);
  }
  return fromObject(that, value);
}
function assertSize(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc(that, size, fill2, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill2 !== void 0) {
    return typeof encoding === "string" ? createBuffer(that, size).fill(fill2, encoding) : createBuffer(that, size).fill(fill2);
  }
  return createBuffer(that, size);
}
function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer2.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}
function fromString(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer2.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);
  if (actual !== length) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}
function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length === void 0) {
    array = new Uint8Array(array);
  } else if (length === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer2.prototype;
  } else {
    that = fromArrayLike(that, array);
  }
  return that;
}
function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }
    if (obj.type === "Buffer" && isArray_default(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked(length) {
  if (length >= kMaxLength()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
  }
  return length | 0;
}
function SlowBuffer(length) {
  if (+length != length) {
    length = 0;
  }
  return Buffer2.alloc(+length);
}
function internalIsBuffer(b) {
  return !!(b != null && b._isBuffer);
}
function byteLength(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0)
    return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase)
          return utf8ToBytes(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
function slowToString(encoding, start, end) {
  var loweredCase = false;
  if (start === void 0 || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return "";
  }
  if (end === void 0 || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return "";
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start, end);
      case "ascii":
        return asciiSlice(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice(this, start, end);
      case "base64":
        return base64Slice(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val === "string") {
    val = Buffer2.from(val, encoding);
  }
  if (internalIsBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read2(buf, i2) {
    if (indexSize === 1) {
      return buf[i2];
    } else {
      return buf.readUInt16BE(i2 * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i;
        if (i - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read2(arr, i + j) !== read2(val, j)) {
          found = false;
          break;
        }
      }
      if (found)
        return i;
    }
  }
  return -1;
}
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed))
      return i;
    buf[offset + i] = parsed;
  }
  return i;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 127);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len)
    end = len;
  var out = "";
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = "";
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
function checkInt(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
}
function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 65535 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}
function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 4294967295 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
  }
}
function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
  }
  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
  }
  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
function base64clean(str) {
  str = stringtrim(str).replace(INVALID_BASE64_RE, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim(str) {
  if (str.trim)
    return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex(n) {
  if (n < 16)
    return "0" + n.toString(16);
  return n.toString(16);
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0)
      break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length)
      break;
    dst[i + offset] = src[i];
  }
  return i;
}
function isnan(val) {
  return val !== val;
}
function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
}
var INSPECT_MAX_BYTES, _kMaxLength, MAX_ARGUMENTS_LENGTH, INVALID_BASE64_RE;
var init_buffer_es6 = __esm({
  "../../node_modules/.pnpm/buffer-es6@4.9.3/node_modules/buffer-es6/index.js"() {
    init_base64();
    init_ieee754();
    init_isArray();
    INSPECT_MAX_BYTES = 50;
    Buffer2.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== void 0 ? global.TYPED_ARRAY_SUPPORT : true;
    _kMaxLength = kMaxLength();
    Buffer2.poolSize = 8192;
    Buffer2._augment = function(arr) {
      arr.__proto__ = Buffer2.prototype;
      return arr;
    };
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length);
    };
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      Buffer2.prototype.__proto__ = Uint8Array.prototype;
      Buffer2.__proto__ = Uint8Array;
      if (typeof Symbol !== "undefined" && Symbol.species && Buffer2[Symbol.species] === Buffer2) {
      }
    }
    Buffer2.alloc = function(size, fill2, encoding) {
      return alloc(null, size, fill2, encoding);
    };
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer2.isBuffer = isBuffer;
    Buffer2.compare = function compare(a, b) {
      if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
        throw new TypeError("Arguments must be Buffers");
      }
      if (a === b)
        return 0;
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!isArray_default(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      var i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer = Buffer2.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (!internalIsBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer;
    };
    Buffer2.byteLength = byteLength;
    Buffer2.prototype._isBuffer = true;
    Buffer2.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString2() {
      var length = this.length | 0;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.equals = function equals(b) {
      if (!internalIsBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      var str = "";
      var max = INSPECT_MAX_BYTES;
      if (this.length > 0) {
        str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
        if (this.length > max)
          str += " ... ";
      }
      return "<Buffer " + str + ">";
    };
    Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer(target)) {
        throw new TypeError("Argument must be a Buffer");
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    Buffer2.prototype.write = function write2(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
            return asciiWrite(this, string, offset, length);
          case "latin1":
          case "binary":
            return latin1Write(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    MAX_ARGUMENTS_LENGTH = 4096;
    Buffer2.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf;
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer2.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer2(sliceLen, void 0);
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start];
        }
      }
      return newBuf;
    };
    Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var i = byteLength2;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return read(this, offset, false, 52, 8);
    };
    Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      if (!Buffer2.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (!Buffer2.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      var i;
      if (this === target && start < targetStart && targetStart < end) {
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
      } else if (typeof val === "number") {
        val = val & 255;
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
        var len = bytes.length;
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
  }
});

// ../../node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/setimmediate.js
function setImmediate(callback) {
  if (typeof callback !== "function") {
    callback = new Function("" + callback);
  }
  var args = new Array(arguments.length - 1);
  for (var i = 0; i < args.length; i++) {
    args[i] = arguments[i + 1];
  }
  var task = { callback, args };
  tasksByHandle[nextHandle] = task;
  registerImmediate(nextHandle);
  return nextHandle++;
}
function clearImmediate(handle) {
  delete tasksByHandle[handle];
}
function run(task) {
  var callback = task.callback;
  var args = task.args;
  switch (args.length) {
    case 0:
      callback();
      break;
    case 1:
      callback(args[0]);
      break;
    case 2:
      callback(args[0], args[1]);
      break;
    case 3:
      callback(args[0], args[1], args[2]);
      break;
    default:
      callback.apply(void 0, args);
      break;
  }
}
function runIfPresent(handle) {
  if (currentlyRunningATask) {
    setTimeout(runIfPresent, 0, handle);
  } else {
    var task = tasksByHandle[handle];
    if (task) {
      currentlyRunningATask = true;
      try {
        run(task);
      } finally {
        clearImmediate(handle);
        currentlyRunningATask = false;
      }
    }
  }
}
function installNextTickImplementation() {
  registerImmediate = function(handle) {
    process.nextTick(function() {
      runIfPresent(handle);
    });
  };
}
function canUsePostMessage() {
  if (global.postMessage && !global.importScripts) {
    var postMessageIsAsynchronous = true;
    var oldOnMessage = global.onmessage;
    global.onmessage = function() {
      postMessageIsAsynchronous = false;
    };
    global.postMessage("", "*");
    global.onmessage = oldOnMessage;
    return postMessageIsAsynchronous;
  }
}
function installPostMessageImplementation() {
  var messagePrefix = "setImmediate$" + Math.random() + "$";
  var onGlobalMessage = function(event) {
    if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
      runIfPresent(+event.data.slice(messagePrefix.length));
    }
  };
  if (global.addEventListener) {
    global.addEventListener("message", onGlobalMessage, false);
  } else {
    global.attachEvent("onmessage", onGlobalMessage);
  }
  registerImmediate = function(handle) {
    global.postMessage(messagePrefix + handle, "*");
  };
}
function installMessageChannelImplementation() {
  var channel = new MessageChannel();
  channel.port1.onmessage = function(event) {
    var handle = event.data;
    runIfPresent(handle);
  };
  registerImmediate = function(handle) {
    channel.port2.postMessage(handle);
  };
}
function installReadyStateChangeImplementation() {
  var html = doc.documentElement;
  registerImmediate = function(handle) {
    var script = doc.createElement("script");
    script.onreadystatechange = function() {
      runIfPresent(handle);
      script.onreadystatechange = null;
      html.removeChild(script);
      script = null;
    };
    html.appendChild(script);
  };
}
function installSetTimeoutImplementation() {
  registerImmediate = function(handle) {
    setTimeout(runIfPresent, 0, handle);
  };
}
var nextHandle, tasksByHandle, currentlyRunningATask, doc, registerImmediate, attachTo;
var init_setimmediate = __esm({
  "../../node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/setimmediate.js"() {
    nextHandle = 1;
    tasksByHandle = {};
    currentlyRunningATask = false;
    doc = global.document;
    attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;
    if ({}.toString.call(global.process) === "[object process]") {
      installNextTickImplementation();
    } else if (canUsePostMessage()) {
      installPostMessageImplementation();
    } else if (global.MessageChannel) {
      installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
      installReadyStateChangeImplementation();
    } else {
      installSetTimeoutImplementation();
    }
  }
});

// ../../node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/timers.js
var timers_exports = {};
__export(timers_exports, {
  _unrefActive: () => _unrefActive,
  active: () => active,
  clearImmediate: () => clearImmediate,
  clearInterval: () => clearInterval,
  clearTimeout: () => clearTimeout2,
  default: () => timers_default,
  enroll: () => enroll,
  setImmediate: () => setImmediate,
  setInterval: () => setInterval,
  setTimeout: () => setTimeout2,
  unenroll: () => unenroll
});
function clearInterval(timeout) {
  if (typeof timeout === "number" && typeof global.clearInterval === "function") {
    global.clearInterval(timeout);
  } else {
    clearFn(timeout);
  }
}
function clearTimeout2(timeout) {
  if (typeof timeout === "number" && typeof global.clearTimeout === "function") {
    global.clearTimeout(timeout);
  } else {
    clearFn(timeout);
  }
}
function clearFn(timeout) {
  if (timeout && typeof timeout.close === "function") {
    timeout.close();
  }
}
function setTimeout2() {
  return new Timeout(apply.call(global.setTimeout, window, arguments), clearTimeout2);
}
function setInterval() {
  return new Timeout(apply.call(global.setInterval, window, arguments), clearInterval);
}
function Timeout(id) {
  this._id = id;
}
function enroll(item, msecs) {
  clearTimeout2(item._idleTimeoutId);
  item._idleTimeout = msecs;
}
function unenroll(item) {
  clearTimeout2(item._idleTimeoutId);
  item._idleTimeout = -1;
}
function active(item) {
  clearTimeout2(item._idleTimeoutId);
  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout2(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
}
var apply, _unrefActive, timers_default;
var init_timers = __esm({
  "../../node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/timers.js"() {
    init_setimmediate();
    apply = Function.prototype.apply;
    Timeout.prototype.unref = Timeout.prototype.ref = function() {
    };
    Timeout.prototype.close = function() {
      clearFn(this._id);
    };
    _unrefActive = active;
    timers_default = {
      setImmediate,
      clearImmediate,
      setTimeout: setTimeout2,
      clearTimeout: clearTimeout2,
      setInterval,
      clearInterval,
      active,
      unenroll,
      _unrefActive,
      enroll
    };
  }
});

// ../../node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/punycode.js
function error(type) {
  throw new RangeError(errors[type]);
}
function map(array, fn) {
  var length = array.length;
  var result = [];
  while (length--) {
    result[length] = fn(array[length]);
  }
  return result;
}
function mapDomain(string, fn) {
  var parts = string.split("@");
  var result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    string = parts[1];
  }
  string = string.replace(regexSeparators, ".");
  var labels = string.split(".");
  var encoded = map(labels, fn).join(".");
  return result + encoded;
}
function ucs2decode(string) {
  var output = [], counter = 0, length = string.length, value, extra;
  while (counter < length) {
    value = string.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
function digitToBasic(digit, flag) {
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
}
function adapt(delta, numPoints, firstTime) {
  var k = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  for (; delta > baseMinusTMin * tMax >> 1; k += base) {
    delta = floor(delta / baseMinusTMin);
  }
  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
}
function encode(input) {
  var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
  input = ucs2decode(input);
  inputLength = input.length;
  n = initialN;
  delta = 0;
  bias = initialBias;
  for (j = 0; j < inputLength; ++j) {
    currentValue = input[j];
    if (currentValue < 128) {
      output.push(stringFromCharCode(currentValue));
    }
  }
  handledCPCount = basicLength = output.length;
  if (basicLength) {
    output.push(delimiter);
  }
  while (handledCPCount < inputLength) {
    for (m = maxInt, j = 0; j < inputLength; ++j) {
      currentValue = input[j];
      if (currentValue >= n && currentValue < m) {
        m = currentValue;
      }
    }
    handledCPCountPlusOne = handledCPCount + 1;
    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
      error("overflow");
    }
    delta += (m - n) * handledCPCountPlusOne;
    n = m;
    for (j = 0; j < inputLength; ++j) {
      currentValue = input[j];
      if (currentValue < n && ++delta > maxInt) {
        error("overflow");
      }
      if (currentValue == n) {
        for (q = delta, k = base; ; k += base) {
          t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (q < t) {
            break;
          }
          qMinusT = q - t;
          baseMinusT = base - t;
          output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
          q = floor(qMinusT / baseMinusT);
        }
        output.push(stringFromCharCode(digitToBasic(q, 0)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }
    ++delta;
    ++n;
  }
  return output.join("");
}
function toASCII(input) {
  return mapDomain(input, function(string) {
    return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
  });
}
var maxInt, base, tMin, tMax, skew, damp, initialBias, initialN, delimiter, regexNonASCII, regexSeparators, errors, baseMinusTMin, floor, stringFromCharCode;
var init_punycode = __esm({
  "../../node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/punycode.js"() {
    maxInt = 2147483647;
    base = 36;
    tMin = 1;
    tMax = 26;
    skew = 38;
    damp = 700;
    initialBias = 72;
    initialN = 128;
    delimiter = "-";
    regexNonASCII = /[^\x20-\x7E]/;
    regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    baseMinusTMin = base - tMin;
    floor = Math.floor;
    stringFromCharCode = String.fromCharCode;
  }
});

// ../../node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/qs.js
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function stringifyPrimitive(v) {
  switch (typeof v) {
    case "string":
      return v;
    case "boolean":
      return v ? "true" : "false";
    case "number":
      return isFinite(v) ? v : "";
    default:
      return "";
  }
}
function stringify(obj, sep, eq, name) {
  sep = sep || "&";
  eq = eq || "=";
  if (obj === null) {
    obj = void 0;
  }
  if (typeof obj === "object") {
    return map2(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map2(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);
  }
  if (!name)
    return "";
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
}
function map2(xs, f) {
  if (xs.map)
    return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}
function parse(qs, sep, eq, options) {
  sep = sep || "&";
  eq = eq || "=";
  var obj = {};
  if (typeof qs !== "string" || qs.length === 0) {
    return obj;
  }
  var regexp = /\+/g;
  qs = qs.split(sep);
  var maxKeys = 1e3;
  if (options && typeof options.maxKeys === "number") {
    maxKeys = options.maxKeys;
  }
  var len = qs.length;
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }
  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v;
    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = "";
    }
    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);
    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }
  return obj;
}
var isArray, objectKeys;
var init_qs = __esm({
  "../../node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/qs.js"() {
    isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
    objectKeys = Object.keys || function(obj) {
      var res = [];
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key))
          res.push(key);
      }
      return res;
    };
  }
});

// ../../../node_modules/xtend/immutable.js
var require_immutable = __commonJS({
  "../../../node_modules/xtend/immutable.js"(exports, module2) {
    module2.exports = extend2;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    function extend2() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (hasOwnProperty2.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }
  }
});

// src/_http.js
var http_exports = {};
__export(http_exports, {
  Url: () => Url,
  isNull: () => isNull,
  isNullOrUndefined: () => isNullOrUndefined,
  isObject: () => isObject,
  isString: () => isString,
  request: () => request,
  urlParse: () => urlParse,
  urlResolve: () => urlResolve
});
function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return arg == null;
}
function isString(arg) {
  return typeof arg === "string";
}
function isObject(arg) {
  return typeof arg === "object" && arg !== null;
}
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}
function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url)
    return url;
  var u = new Url();
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}
function parse2(self2, url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }
  var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, "/");
  url = uSplit.join(splitter);
  var rest = url;
  rest = rest.trim();
  if (!slashesDenoteHost && url.split("#").length === 1) {
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      self2.path = rest;
      self2.href = rest;
      self2.pathname = simplePath[1];
      if (simplePath[2]) {
        self2.search = simplePath[2];
        if (parseQueryString) {
          self2.query = parse(self2.search.substr(1));
        } else {
          self2.query = self2.search.substr(1);
        }
      } else if (parseQueryString) {
        self2.search = "";
        self2.query = {};
      }
      return self2;
    }
  }
  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    self2.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      self2.slashes = true;
    }
  }
  var i, hec, l, p;
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    var hostEnd = -1;
    for (i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    var auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      self2.auth = decodeURIComponent(auth);
    }
    hostEnd = -1;
    for (i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    if (hostEnd === -1)
      hostEnd = rest.length;
    self2.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    parseHost(self2);
    self2.hostname = self2.hostname || "";
    var ipv6Hostname = self2.hostname[0] === "[" && self2.hostname[self2.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      var hostparts = self2.hostname.split(/\./);
      for (i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part)
          continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = "";
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              newpart += "x";
            } else {
              newpart += part[j];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = "/" + notHost.join(".") + rest;
            }
            self2.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (self2.hostname.length > hostnameMaxLen) {
      self2.hostname = "";
    } else {
      self2.hostname = self2.hostname.toLowerCase();
    }
    if (!ipv6Hostname) {
      self2.hostname = toASCII(self2.hostname);
    }
    p = self2.port ? ":" + self2.port : "";
    var h = self2.hostname || "";
    self2.host = h + p;
    self2.href += self2.host;
    if (ipv6Hostname) {
      self2.hostname = self2.hostname.substr(1, self2.hostname.length - 2);
      if (rest[0] !== "/") {
        rest = "/" + rest;
      }
    }
  }
  if (!unsafeProtocol[lowerProto]) {
    for (i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }
  var hash = rest.indexOf("#");
  if (hash !== -1) {
    self2.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf("?");
  if (qm !== -1) {
    self2.search = rest.substr(qm);
    self2.query = rest.substr(qm + 1);
    if (parseQueryString) {
      self2.query = parse(self2.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    self2.search = "";
    self2.query = {};
  }
  if (rest)
    self2.pathname = rest;
  if (slashedProtocol[lowerProto] && self2.hostname && !self2.pathname) {
    self2.pathname = "/";
  }
  if (self2.pathname || self2.search) {
    p = self2.pathname || "";
    var s = self2.search || "";
    self2.path = p + s;
  }
  self2.href = format(self2);
  return self2;
}
function format(self2) {
  var auth = self2.auth || "";
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ":");
    auth += "@";
  }
  var protocol = self2.protocol || "", pathname = self2.pathname || "", hash = self2.hash || "", host = false, query = "";
  if (self2.host) {
    host = auth + self2.host;
  } else if (self2.hostname) {
    host = auth + (self2.hostname.indexOf(":") === -1 ? self2.hostname : "[" + this.hostname + "]");
    if (self2.port) {
      host += ":" + self2.port;
    }
  }
  if (self2.query && isObject(self2.query) && Object.keys(self2.query).length) {
    query = stringify(self2.query);
  }
  var search = self2.search || query && "?" + query || "";
  if (protocol && protocol.substr(-1) !== ":")
    protocol += ":";
  if (self2.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = "//" + (host || "");
    if (pathname && pathname.charAt(0) !== "/")
      pathname = "/" + pathname;
  } else if (!host) {
    host = "";
  }
  if (hash && hash.charAt(0) !== "#")
    hash = "#" + hash;
  if (search && search.charAt(0) !== "?")
    search = "?" + search;
  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace("#", "%23");
  return protocol + host + pathname + search + hash;
}
function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}
function parseHost(self2) {
  var host = self2.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ":") {
      self2.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host)
    self2.hostname = host;
}
var extend, request, protocolPattern, portPattern, simplePathPattern, delims, unwise, autoEscape, nonHostChars, hostEndingChars, hostnameMaxLen, hostnamePartPattern, hostnamePartStart, unsafeProtocol, hostlessProtocol, slashedProtocol;
var init_http = __esm({
  "src/_http.js"() {
    init_punycode();
    init_qs();
    extend = require_immutable();
    request = function(opts) {
      if (typeof opts === "string")
        opts = urlParse(opts);
      else
        opts = extend(opts);
      var defaultProtocol = global.location?.protocol.search(/^https?:$/) === -1 ? "http:" : "";
      var protocol = opts.protocol || defaultProtocol;
      var host = opts.hostname || opts.host;
      var port = opts.port;
      var path = opts.path || "/";
      if (host && host.indexOf(":") !== -1)
        host = "[" + host + "]";
      opts.url = (host ? protocol + "//" + host : "") + (port ? ":" + port : "") + path;
      opts.method = (opts.method || "GET").toUpperCase();
      opts.headers = opts.headers || {};
      const [username, password] = opts.auth?.split(":");
      const url = new URL({
        username,
        password,
        protocol,
        port,
        pathname: path,
        host: opts.host,
        hostname: opts.hostname
      });
      return fetch({ method: opts.method, headers: opts.headers, url });
    };
    protocolPattern = /^([a-z0-9.+-]+:)/i;
    portPattern = /:[0-9]*$/;
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
    delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
    unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
    autoEscape = ["'"].concat(unwise);
    nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
    hostEndingChars = ["/", "?", "#"];
    hostnameMaxLen = 255;
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    unsafeProtocol = {
      javascript: true,
      "javascript:": true
    };
    hostlessProtocol = {
      javascript: true,
      "javascript:": true
    };
    slashedProtocol = {
      http: true,
      https: true,
      ftp: true,
      gopher: true,
      file: true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
      return parse2(this, url, parseQueryString, slashesDenoteHost);
    };
    Url.prototype.format = function() {
      return format(this);
    };
    Url.prototype.resolve = function(relative) {
      return this.resolveObject(urlParse(relative, false, true)).format();
    };
    Url.prototype.resolveObject = function(relative) {
      if (isString(relative)) {
        var rel = new Url();
        rel.parse(relative, false, true);
        relative = rel;
      }
      var result = new Url();
      var tkeys = Object.keys(this);
      for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
      }
      result.hash = relative.hash;
      if (relative.href === "") {
        result.href = result.format();
        return result;
      }
      if (relative.slashes && !relative.protocol) {
        var rkeys = Object.keys(relative);
        for (var rk = 0; rk < rkeys.length; rk++) {
          var rkey = rkeys[rk];
          if (rkey !== "protocol")
            result[rkey] = relative[rkey];
        }
        if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
          result.path = result.pathname = "/";
        }
        result.href = result.format();
        return result;
      }
      var relPath;
      if (relative.protocol && relative.protocol !== result.protocol) {
        if (!slashedProtocol[relative.protocol]) {
          var keys = Object.keys(relative);
          for (var v = 0; v < keys.length; v++) {
            var k = keys[v];
            result[k] = relative[k];
          }
          result.href = result.format();
          return result;
        }
        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
          relPath = (relative.pathname || "").split("/");
          while (relPath.length && !(relative.host = relPath.shift()))
            ;
          if (!relative.host)
            relative.host = "";
          if (!relative.hostname)
            relative.hostname = "";
          if (relPath[0] !== "")
            relPath.unshift("");
          if (relPath.length < 2)
            relPath.unshift("");
          result.pathname = relPath.join("/");
        } else {
          result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || "";
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        if (result.pathname || result.search) {
          var p = result.pathname || "";
          var s = result.search || "";
          result.path = p + s;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      }
      var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
      relPath = relative.pathname && relative.pathname.split("/") || [];
      if (psychotic) {
        result.hostname = "";
        result.port = null;
        if (result.host) {
          if (srcPath[0] === "")
            srcPath[0] = result.host;
          else
            srcPath.unshift(result.host);
        }
        result.host = "";
        if (relative.protocol) {
          relative.hostname = null;
          relative.port = null;
          if (relative.host) {
            if (relPath[0] === "")
              relPath[0] = relative.host;
            else
              relPath.unshift(relative.host);
          }
          relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
      }
      var authInHost;
      if (isRelAbs) {
        result.host = relative.host || relative.host === "" ? relative.host : result.host;
        result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
      } else if (relPath.length) {
        if (!srcPath)
          srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
      } else if (!isNullOrUndefined(relative.search)) {
        if (psychotic) {
          result.hostname = result.host = srcPath.shift();
          authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
          }
        }
        result.search = relative.search;
        result.query = relative.query;
        if (!isNull(result.pathname) || !isNull(result.search)) {
          result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.href = result.format();
        return result;
      }
      if (!srcPath.length) {
        result.pathname = null;
        if (result.search) {
          result.path = "/" + result.search;
        } else {
          result.path = null;
        }
        result.href = result.format();
        return result;
      }
      var last = srcPath.slice(-1)[0];
      var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
      var up = 0;
      for (var i = srcPath.length; i >= 0; i--) {
        last = srcPath[i];
        if (last === ".") {
          srcPath.splice(i, 1);
        } else if (last === "..") {
          srcPath.splice(i, 1);
          up++;
        } else if (up) {
          srcPath.splice(i, 1);
          up--;
        }
      }
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift("..");
        }
      }
      if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
        srcPath.unshift("");
      }
      if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
        srcPath.push("");
      }
      var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
      if (psychotic) {
        result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
        authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }
      mustEndAbs = mustEndAbs || result.host && srcPath.length;
      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift("");
      }
      if (!srcPath.length) {
        result.pathname = null;
        result.path = null;
      } else {
        result.pathname = srcPath.join("/");
      }
      if (!isNull(result.pathname) || !isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
      }
      result.auth = relative.auth || result.auth;
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    };
    Url.prototype.parseHost = function() {
      return parseHost(this);
    };
  }
});

// src/xhr.js
var xhr_exports = {};
__export(xhr_exports, {
  XMLHttpRequest: () => XMLHttpRequest,
  XMLHttpRequestEventTarget: () => XMLHttpRequestEventTarget,
  XMLHttpRequestUpload: () => XMLHttpRequestUpload
});
var ProgressEvent, XMLHttpRequestEventTarget, XMLHttpRequestUpload, https, http, urlParse2, urlResolve2, XMLHttpRequest;
var init_xhr = __esm({
  "src/xhr.js"() {
    ProgressEvent = class {
      constructor(type) {
        this.type = type;
        this.target = null;
        this.currentTarget = null;
        this.lengthComputable = false;
        this.loaded = 0;
        this.total = 0;
      }
    };
    ProgressEvent.prototype.bubbles = false;
    ProgressEvent.prototype.cancelable = false;
    ProgressEvent.prototype.target = null;
    ProgressEvent.prototype.loaded = null;
    ProgressEvent.prototype.lengthComputable = null;
    ProgressEvent.prototype.total = null;
    XMLHttpRequestEventTarget = class {
      constructor() {
        this.onloadstart = null;
        this.onprogress = null;
        this.onabort = null;
        this.onerror = null;
        this.onload = null;
        this.ontimeout = null;
        this.onloadend = null;
        this._listeners = {};
      }
      addEventListener(eventType, listener) {
        var base2;
        eventType = eventType.toLowerCase();
        (base2 = this._listeners)[eventType] || (base2[eventType] = []);
        this._listeners[eventType].push(listener);
        return void 0;
      }
      removeEventListener(eventType, listener) {
        var index;
        eventType = eventType.toLowerCase();
        if (this._listeners[eventType]) {
          index = this._listeners[eventType].indexOf(listener);
          if (index !== -1) {
            this._listeners[eventType].splice(index, 1);
          }
        }
        return void 0;
      }
      dispatchEvent(event) {
        var eventType, j, len, listener, listeners;
        event.currentTarget = event.target = this;
        eventType = event.type;
        if (listeners = this._listeners[eventType]) {
          for (j = 0, len = listeners.length; j < len; j++) {
            listener = listeners[j];
            listener.call(this, event);
          }
        }
        if (listener = this[`on${eventType}`]) {
          listener.call(this, event);
        }
        return void 0;
      }
    };
    XMLHttpRequestUpload = class extends XMLHttpRequestEventTarget {
      constructor(request2) {
        super();
        this._request = request2;
        this._reset();
      }
      _reset() {
        this._contentType = null;
        this._body = null;
        return void 0;
      }
      _setData(data) {
        var body, i, j, k, offset, ref, ref1, view;
        if (typeof data === "undefined" || data === null) {
          return;
        }
        if (typeof data === "string") {
          if (data.length !== 0) {
            this._contentType = "text/plain;charset=UTF-8";
          }
          this._body = Buffer.from(data, "utf8");
        } else if (Buffer.isBuffer(data)) {
          this._body = data;
        } else if (data instanceof ArrayBuffer) {
          body = Buffer.alloc(data.byteLength);
          view = new Uint8Array(data);
          for (i = j = 0, ref = data.byteLength; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            body[i] = view[i];
          }
          this._body = body;
        } else if (data.buffer && data.buffer instanceof ArrayBuffer) {
          body = Buffer.alloc(data.byteLength);
          offset = data.byteOffset;
          view = new Uint8Array(data.buffer);
          for (i = k = 0, ref1 = data.byteLength; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
            body[i] = view[i + offset];
          }
          this._body = body;
        } else {
          throw new Error(`Unsupported send() data ${data}`);
        }
        return void 0;
      }
      _finalizeHeaders(headers, loweredHeaders) {
        if (this._contentType) {
          if (!("content-type" in loweredHeaders)) {
            headers["Content-Type"] = this._contentType;
          }
        }
        if (this._body) {
          headers["Content-Length"] = this._body.length.toString();
        }
        return void 0;
      }
      _startUpload(request2) {
        if (this._body) {
          request2.write(this._body);
        }
        request2.end();
        return void 0;
      }
    };
    https = {};
    http = (init_http(), __toCommonJS(http_exports));
    ({ urlParse: urlParse2, urlResolve: urlResolve2 } = (init_http(), __toCommonJS(http_exports)));
    XMLHttpRequest = class extends XMLHttpRequestEventTarget {
      constructor(options) {
        super();
        this.onreadystatechange = null;
        this._anonymous = options && options.anon;
        this.readyState = XMLHttpRequest.UNSENT;
        this.response = null;
        this.responseText = "";
        this.responseType = "";
        this.responseURL = "";
        this.status = 0;
        this.statusText = "";
        this.timeout = 0;
        this.upload = new XMLHttpRequestUpload(this);
        this._method = null;
        this._url = null;
        this._sync = false;
        this._headers = null;
        this._loweredHeaders = null;
        this._mimeOverride = null;
        this._request = null;
        this._response = null;
        this._responseParts = null;
        this._responseHeaders = null;
        this._aborting = null;
        this._error = null;
        this._loadedBytes = 0;
        this._totalBytes = 0;
        this._lengthComputable = false;
      }
      open(method, url, async, user, password) {
        var xhrUrl;
        method = method.toUpperCase();
        if (method in this._restrictedMethods) {
          throw new SecurityError(`HTTP method ${method} is not allowed in XHR`);
        }
        xhrUrl = this._parseUrl(url);
        if (async === void 0) {
          async = true;
        }
        switch (this.readyState) {
          case XMLHttpRequest.UNSENT:
          case XMLHttpRequest.OPENED:
          case XMLHttpRequest.DONE:
            null;
            break;
          case XMLHttpRequest.HEADERS_RECEIVED:
          case XMLHttpRequest.LOADING:
            null;
        }
        this._method = method;
        this._url = xhrUrl;
        this._sync = !async;
        this._headers = {};
        this._loweredHeaders = {};
        this._mimeOverride = null;
        this._setReadyState(XMLHttpRequest.OPENED);
        this._request = null;
        this._response = null;
        this.status = 0;
        this.statusText = "";
        this._responseParts = [];
        this._responseHeaders = null;
        this._loadedBytes = 0;
        this._totalBytes = 0;
        this._lengthComputable = false;
        return void 0;
      }
      setRequestHeader(name, value) {
        var loweredName;
        if (this.readyState !== XMLHttpRequest.OPENED) {
          throw new InvalidStateError("XHR readyState must be OPENED");
        }
        loweredName = name.toLowerCase();
        if (this._restrictedHeaders[loweredName] || /^sec\-/.test(loweredName) || /^proxy-/.test(loweredName)) {
          console.warn(`Refused to set unsafe header "${name}"`);
          return void 0;
        }
        value = value.toString();
        if (loweredName in this._loweredHeaders) {
          name = this._loweredHeaders[loweredName];
          this._headers[name] = this._headers[name] + ", " + value;
        } else {
          this._loweredHeaders[loweredName] = name;
          this._headers[name] = value;
        }
        return void 0;
      }
      send(data) {
        if (this.readyState !== XMLHttpRequest.OPENED) {
          throw new InvalidStateError("XHR readyState must be OPENED");
        }
        if (this._request) {
          throw new InvalidStateError("send() already called");
        }
        switch (this._url.protocol) {
          case "file:":
            this._sendFile(data);
            break;
          case "http:":
          case "https:":
            this._sendHttp(data);
            break;
          default:
            throw new NetworkError(`Unsupported protocol ${this._url.protocol}`);
        }
        return void 0;
      }
      abort() {
        if (!this._request) {
          return;
        }
        this._request.abort();
        this._setError();
        this._dispatchProgress("abort");
        this._dispatchProgress("loadend");
        return void 0;
      }
      getResponseHeader(name) {
        var loweredName;
        if (!this._responseHeaders) {
          return null;
        }
        loweredName = name.toLowerCase();
        if (loweredName in this._responseHeaders) {
          return this._responseHeaders[loweredName];
        } else {
          return null;
        }
      }
      getAllResponseHeaders() {
        var lines, name, value;
        if (!this._responseHeaders) {
          return "";
        }
        lines = function() {
          var ref, results;
          ref = this._responseHeaders;
          results = [];
          for (name in ref) {
            value = ref[name];
            results.push(`${name}: ${value}`);
          }
          return results;
        }.call(this);
        return lines.join("\r\n");
      }
      overrideMimeType(newMimeType) {
        if (this.readyState === XMLHttpRequest.LOADING || this.readyState === XMLHttpRequest.DONE) {
          throw new InvalidStateError("overrideMimeType() not allowed in LOADING or DONE");
        }
        this._mimeOverride = newMimeType.toLowerCase();
        return void 0;
      }
      _setReadyState(newReadyState) {
        var event;
        this.readyState = newReadyState;
        event = new ProgressEvent("readystatechange");
        this.dispatchEvent(event);
        return void 0;
      }
      _sendFile() {
        if (this._url.method !== "GET") {
          throw new NetworkError("The file protocol only supports GET");
        }
        throw new Error("Protocol file: not implemented");
      }
      _sendHttp(data) {
        if (this._sync) {
          throw new Error("Synchronous XHR processing not implemented");
        }
        if (data != null && (this._method === "GET" || this._method === "HEAD")) {
          console.warn(`Discarding entity body for ${this._method} requests`);
          data = null;
        } else {
          data || (data = "");
        }
        this.upload._setData(data);
        this._finalizeHeaders();
        this._sendHxxpRequest();
        return void 0;
      }
      _sendHxxpRequest() {
        var agent, hxxp, request2;
        if (this._url.protocol === "http:") {
          hxxp = http;
          agent = this.nodejsHttpAgent;
        } else {
          hxxp = https;
          agent = this.nodejsHttpsAgent;
        }
        request2 = hxxp.request({
          hostname: this._url.hostname,
          port: this._url.port,
          path: this._url.path,
          auth: this._url.auth,
          method: this._method,
          headers: this._headers
        });
        this._request = request2;
        if (this.timeout) {
          request2.setTimeout(this.timeout, () => {
            return this._onHttpTimeout(request2);
          });
        }
        request2.on("response", (response) => {
          return this._onHttpResponse(request2, response);
        });
        request2.on("error", (error2) => {
          return this._onHttpRequestError(request2, error2);
        });
        this.upload._startUpload(request2);
        if (this._request === request2) {
          this._dispatchProgress("loadstart");
        }
        return void 0;
      }
      _finalizeHeaders() {
        var base2;
        this._headers["Connection"] = "keep-alive";
        this._headers["Host"] = this._url.host;
        if (this._anonymous) {
          this._headers["Referer"] = "about:blank";
        }
        (base2 = this._headers)["User-Agent"] || (base2["User-Agent"] = this._userAgent);
        this.upload._finalizeHeaders(this._headers, this._loweredHeaders);
        return void 0;
      }
      _onHttpResponse(request2, response) {
        var lengthString;
        if (this._request !== request2) {
          return;
        }
        switch (response.statusCode) {
          case 301:
          case 302:
          case 303:
          case 307:
          case 308:
            this._url = this._parseUrl(response.headers["location"]);
            this._method = "GET";
            if ("content-type" in this._loweredHeaders) {
              delete this._headers[this._loweredHeaders["content-type"]];
              delete this._loweredHeaders["content-type"];
            }
            if ("Content-Type" in this._headers) {
              delete this._headers["Content-Type"];
            }
            delete this._headers["Content-Length"];
            this.upload._reset();
            this._finalizeHeaders();
            this._sendHxxpRequest();
            return;
        }
        this._response = response;
        this._response.on("data", (data) => {
          return this._onHttpResponseData(response, data);
        });
        this._response.on("end", () => {
          return this._onHttpResponseEnd(response);
        });
        this._response.on("close", () => {
          return this._onHttpResponseClose(response);
        });
        this.responseURL = this._url.href.split("#")[0];
        this.status = this._response.statusCode;
        this.statusText = http.STATUS_CODES[this.status];
        this._parseResponseHeaders(response);
        if (lengthString = this._responseHeaders["content-length"]) {
          this._totalBytes = parseInt(lengthString);
          this._lengthComputable = true;
        } else {
          this._lengthComputable = false;
        }
        return this._setReadyState(XMLHttpRequest.HEADERS_RECEIVED);
      }
      _onHttpResponseData(response, data) {
        if (this._response !== response) {
          return;
        }
        this._responseParts.push(data);
        this._loadedBytes += data.length;
        if (this.readyState !== XMLHttpRequest.LOADING) {
          this._setReadyState(XMLHttpRequest.LOADING);
        }
        return this._dispatchProgress("progress");
      }
      _onHttpResponseEnd(response) {
        if (this._response !== response) {
          return;
        }
        this._parseResponse();
        this._request = null;
        this._response = null;
        this._setReadyState(XMLHttpRequest.DONE);
        this._dispatchProgress("load");
        return this._dispatchProgress("loadend");
      }
      _onHttpResponseClose(response) {
        var request2;
        if (this._response !== response) {
          return;
        }
        request2 = this._request;
        this._setError();
        request2.abort();
        this._setReadyState(XMLHttpRequest.DONE);
        this._dispatchProgress("error");
        return this._dispatchProgress("loadend");
      }
      _onHttpTimeout(request2) {
        if (this._request !== request2) {
          return;
        }
        this._setError();
        request2.abort();
        this._setReadyState(XMLHttpRequest.DONE);
        this._dispatchProgress("timeout");
        return this._dispatchProgress("loadend");
      }
      _onHttpRequestError(request2, error2) {
        if (this._request !== request2) {
          return;
        }
        this._setError();
        request2.abort();
        this._setReadyState(XMLHttpRequest.DONE);
        this._dispatchProgress("error");
        return this._dispatchProgress("loadend");
      }
      _dispatchProgress(eventType) {
        var event;
        event = new ProgressEvent(eventType);
        event.lengthComputable = this._lengthComputable;
        event.loaded = this._loadedBytes;
        event.total = this._totalBytes;
        this.dispatchEvent(event);
        return void 0;
      }
      _setError() {
        this._request = null;
        this._response = null;
        this._responseHeaders = null;
        this._responseParts = null;
        return void 0;
      }
      _parseUrl(urlString) {
        var absoluteUrlString, index, password, user, xhrUrl;
        if (this.nodejsBaseUrl === null) {
          absoluteUrlString = urlString;
        } else {
          absoluteUrlString = urlResolve2(this.nodejsBaseUrl, urlString);
        }
        xhrUrl = urlParse2(absoluteUrlString, false, true);
        xhrUrl.hash = null;
        if (xhrUrl.auth && (typeof user !== "undefined" && user !== null || typeof password !== "undefined" && password !== null)) {
          index = xhrUrl.auth.indexOf(":");
          if (index === -1) {
            if (!user) {
              user = xhrUrl.auth;
            }
          } else {
            if (!user) {
              user = xhrUrl.substring(0, index);
            }
            if (!password) {
              password = xhrUrl.substring(index + 1);
            }
          }
        }
        if (user || password) {
          xhrUrl.auth = `${user}:${password}`;
        }
        return xhrUrl;
      }
      _parseResponseHeaders(response) {
        var loweredName, name, ref, value;
        this._responseHeaders = {};
        ref = response.headers;
        for (name in ref) {
          value = ref[name];
          loweredName = name.toLowerCase();
          if (this._privateHeaders[loweredName]) {
            continue;
          }
          if (this._mimeOverride !== null && loweredName === "content-type") {
            value = this._mimeOverride;
          }
          this._responseHeaders[loweredName] = value;
        }
        if (this._mimeOverride !== null && !("content-type" in this._responseHeaders)) {
          this._responseHeaders["content-type"] = this._mimeOverride;
        }
        return void 0;
      }
      _parseResponse() {
        var arrayBuffer, buffer, i, j, jsonError, ref, view;
        if (Buffer.concat) {
          buffer = Buffer.concat(this._responseParts);
        } else {
          buffer = this._concatBuffers(this._responseParts);
        }
        this._responseParts = null;
        switch (this.responseType) {
          case "text":
            this._parseTextResponse(buffer);
            break;
          case "json":
            this.responseText = null;
            try {
              this.response = JSON.parse(buffer.toString("utf-8"));
            } catch (error1) {
              jsonError = error1;
              this.response = null;
            }
            break;
          case "buffer":
            this.responseText = null;
            this.response = buffer;
            break;
          case "arraybuffer":
            this.responseText = null;
            arrayBuffer = new ArrayBuffer(buffer.length);
            view = new Uint8Array(arrayBuffer);
            for (i = j = 0, ref = buffer.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
              view[i] = buffer[i];
            }
            this.response = arrayBuffer;
            break;
          default:
            this._parseTextResponse(buffer);
        }
        return void 0;
      }
      _parseTextResponse(buffer) {
        var e;
        try {
          this.responseText = buffer.toString(this._parseResponseEncoding());
        } catch (error1) {
          e = error1;
          this.responseText = buffer.toString("binary");
        }
        this.response = this.responseText;
        return void 0;
      }
      _parseResponseEncoding() {
        var contentType, encoding, match;
        encoding = null;
        if (contentType = this._responseHeaders["content-type"]) {
          if (match = /\;\s*charset\=(.*)$/.exec(contentType)) {
            return match[1];
          }
        }
        return "utf-8";
      }
      _concatBuffers(buffers) {
        var buffer, j, k, len, len1, length, target;
        if (buffers.length === 0) {
          return Buffer.alloc(0);
        }
        if (buffers.length === 1) {
          return buffers[0];
        }
        length = 0;
        for (j = 0, len = buffers.length; j < len; j++) {
          buffer = buffers[j];
          length += buffer.length;
        }
        target = Buffer.alloc(length);
        length = 0;
        for (k = 0, len1 = buffers.length; k < len1; k++) {
          buffer = buffers[k];
          buffer.copy(target, length);
          length += buffer.length;
        }
        return target;
      }
    };
    XMLHttpRequest.prototype.onreadystatechange = null;
    XMLHttpRequest.prototype.readyState = null;
    XMLHttpRequest.prototype.response = null;
    XMLHttpRequest.prototype.responseText = null;
    XMLHttpRequest.prototype.responseType = null;
    XMLHttpRequest.prototype.status = null;
    XMLHttpRequest.prototype.timeout = null;
    XMLHttpRequest.prototype.upload = null;
    XMLHttpRequest.prototype.UNSENT = 0;
    XMLHttpRequest.UNSENT = 0;
    XMLHttpRequest.prototype.OPENED = 1;
    XMLHttpRequest.OPENED = 1;
    XMLHttpRequest.prototype.HEADERS_RECEIVED = 2;
    XMLHttpRequest.HEADERS_RECEIVED = 2;
    XMLHttpRequest.prototype.LOADING = 3;
    XMLHttpRequest.LOADING = 3;
    XMLHttpRequest.prototype.DONE = 4;
    XMLHttpRequest.DONE = 4;
    XMLHttpRequest.prototype.nodejsBaseUrl = null;
    XMLHttpRequest.prototype._restrictedMethods = {
      CONNECT: true,
      TRACE: true,
      TRACK: true
    };
    XMLHttpRequest.prototype._restrictedHeaders = {
      "accept-charset": true,
      "accept-encoding": true,
      "access-control-request-headers": true,
      "access-control-request-method": true,
      connection: true,
      "content-length": true,
      cookie: true,
      cookie2: true,
      date: true,
      dnt: true,
      expect: true,
      host: true,
      "keep-alive": true,
      origin: true,
      referer: true,
      te: true,
      trailer: true,
      "transfer-encoding": true,
      upgrade: true,
      via: true
    };
    XMLHttpRequest.prototype._privateHeaders = {
      "set-cookie": true,
      "set-cookie2": true
    };
    XMLHttpRequest.prototype._userAgent = `Mozilla/5.0 (${"Browser"} ${"javascript"}) node.js/${process.versions.node} v8/${process.versions.v8}`;
  }
});

// src/shimmed.ts
globalThis.global = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
globalThis.process = (init_browser(), __toCommonJS(browser_exports));
globalThis.Buffer = (init_buffer_es6(), __toCommonJS(buffer_es6_exports)).Buffer;
globalThis.setImmediate = (init_timers(), __toCommonJS(timers_exports)).setImmediate;
globalThis.clearImmediate = (init_timers(), __toCommonJS(timers_exports)).clearImmediate;
var xhr = (init_xhr(), __toCommonJS(xhr_exports));
globalThis.XMLHttpRequest = xhr.XMLHttpRequest;
globalThis.XMLHttpRequestUpload = xhr.XMLHttpRequestUpload;
globalThis.XMLHttpRequestEventTarget = xhr.XMLHttpRequestEventTarget;
globalThis.location = {};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/*! https://mths.be/punycode v1.4.1 by @mathias */


            })()
            globalThis.__filename = "/.vpc/dev.js";
            globalThis.__dirname = "/";

        
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/version.js
var require_version = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.versionInfo = exports2.version = void 0;
    var version3 = "16.4.0";
    exports2.version = version3;
    var versionInfo2 = Object.freeze({
      major: 16,
      minor: 4,
      patch: 0,
      preReleaseTag: null
    });
    exports2.versionInfo = versionInfo2;
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/devAssert.js
var require_devAssert = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/devAssert.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.devAssert = devAssert;
    function devAssert(condition, message) {
      const booleanCondition = Boolean(condition);
      if (!booleanCondition) {
        throw new Error(message);
      }
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/isPromise.js
var require_isPromise = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/isPromise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isPromise = isPromise;
    function isPromise(value) {
      return typeof (value === null || value === void 0 ? void 0 : value.then) === "function";
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/isObjectLike.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isObjectLike = isObjectLike;
    function isObjectLike(value) {
      return typeof value == "object" && value !== null;
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/invariant.js
var require_invariant = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/invariant.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.invariant = invariant;
    function invariant(condition, message) {
      const booleanCondition = Boolean(condition);
      if (!booleanCondition) {
        throw new Error(message != null ? message : "Unexpected invariant triggered.");
      }
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/language/location.js
var require_location = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/language/location.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getLocation = getLocation;
    var _invariant = require_invariant();
    var LineRegExp = /\r\n|[\n\r]/g;
    function getLocation(source, position) {
      let lastLineStart = 0;
      let line = 1;
      for (const match of source.body.matchAll(LineRegExp)) {
        typeof match.index === "number" || (0, _invariant.invariant)(false);
        if (match.index >= position) {
          break;
        }
        lastLineStart = match.index + match[0].length;
        line += 1;
      }
      return {
        line,
        column: position + 1 - lastLineStart
      };
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/language/printLocation.js
var require_printLocation = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/language/printLocation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.printLocation = printLocation;
    exports2.printSourceLocation = printSourceLocation;
    var _location = require_location();
    function printLocation(location) {
      return printSourceLocation(location.source, (0, _location.getLocation)(location.source, location.start));
    }
    function printSourceLocation(source, sourceLocation) {
      const firstLineColumnOffset = source.locationOffset.column - 1;
      const body = "".padStart(firstLineColumnOffset) + source.body;
      const lineIndex = sourceLocation.line - 1;
      const lineOffset = source.locationOffset.line - 1;
      const lineNum = sourceLocation.line + lineOffset;
      const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
      const columnNum = sourceLocation.column + columnOffset;
      const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
      const lines = body.split(/\r\n|[\n\r]/g);
      const locationLine = lines[lineIndex];
      if (locationLine.length > 120) {
        const subLineIndex = Math.floor(columnNum / 80);
        const subLineColumnNum = columnNum % 80;
        const subLines = [];
        for (let i = 0; i < locationLine.length; i += 80) {
          subLines.push(locationLine.slice(i, i + 80));
        }
        return locationStr + printPrefixedLines([
          [`${lineNum} |`, subLines[0]],
          ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
          ["|", "^".padStart(subLineColumnNum)],
          ["|", subLines[subLineIndex + 1]]
        ]);
      }
      return locationStr + printPrefixedLines([
        [`${lineNum - 1} |`, lines[lineIndex - 1]],
        [`${lineNum} |`, locationLine],
        ["|", "^".padStart(columnNum)],
        [`${lineNum + 1} |`, lines[lineIndex + 1]]
      ]);
    }
    function printPrefixedLines(lines) {
      const existingLines = lines.filter(([_, line]) => line !== void 0);
      const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
      return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/error/GraphQLError.js
var require_GraphQLError = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/error/GraphQLError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.GraphQLError = void 0;
    exports2.formatError = formatError4;
    exports2.printError = printError;
    var _isObjectLike = require_isObjectLike();
    var _location = require_location();
    var _printLocation = require_printLocation();
    function toNormalizedArgs(args) {
      const firstArg = args[0];
      if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
        return {
          nodes: firstArg,
          source: args[1],
          positions: args[2],
          path: args[3],
          originalError: args[4],
          extensions: args[5]
        };
      }
      return firstArg;
    }
    var GraphQLError4 = class extends Error {
      constructor(message, ...rawArgs) {
        var _this$nodes, _nodeLocations$, _ref;
        const { nodes, source, positions, path, originalError, extensions } = toNormalizedArgs(rawArgs);
        super(message);
        this.name = "GraphQLError";
        this.path = path !== null && path !== void 0 ? path : void 0;
        this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
        this.nodes = undefinedIfEmpty(Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0);
        const nodeLocations = undefinedIfEmpty((_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null));
        this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
        this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
        this.locations = positions && source ? positions.map((pos) => (0, _location.getLocation)(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => (0, _location.getLocation)(loc.source, loc.start));
        const originalExtensions = (0, _isObjectLike.isObjectLike)(originalError === null || originalError === void 0 ? void 0 : originalError.extensions) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
        this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
        Object.defineProperties(this, {
          message: {
            writable: true,
            enumerable: true
          },
          name: {
            enumerable: false
          },
          nodes: {
            enumerable: false
          },
          source: {
            enumerable: false
          },
          positions: {
            enumerable: false
          },
          originalError: {
            enumerable: false
          }
        });
        if (originalError !== null && originalError !== void 0 && originalError.stack) {
          Object.defineProperty(this, "stack", {
            value: originalError.stack,
            writable: true,
            configurable: true
          });
        } else if (Error.captureStackTrace) {
          Error.captureStackTrace(this, GraphQLError4);
        } else {
          Object.defineProperty(this, "stack", {
            value: Error().stack,
            writable: true,
            configurable: true
          });
        }
      }
      get [Symbol.toStringTag]() {
        return "GraphQLError";
      }
      toString() {
        let output = this.message;
        if (this.nodes) {
          for (const node of this.nodes) {
            if (node.loc) {
              output += "\n\n" + (0, _printLocation.printLocation)(node.loc);
            }
          }
        } else if (this.source && this.locations) {
          for (const location of this.locations) {
            output += "\n\n" + (0, _printLocation.printSourceLocation)(this.source, location);
          }
        }
        return output;
      }
      toJSON() {
        const formattedError = {
          message: this.message
        };
        if (this.locations != null) {
          formattedError.locations = this.locations;
        }
        if (this.path != null) {
          formattedError.path = this.path;
        }
        if (this.extensions != null && Object.keys(this.extensions).length > 0) {
          formattedError.extensions = this.extensions;
        }
        return formattedError;
      }
    };
    exports2.GraphQLError = GraphQLError4;
    function undefinedIfEmpty(array) {
      return array === void 0 || array.length === 0 ? void 0 : array;
    }
    function printError(error2) {
      return error2.toString();
    }
    function formatError4(error2) {
      return error2.toJSON();
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/error/syntaxError.js
var require_syntaxError = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/error/syntaxError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.syntaxError = syntaxError;
    var _GraphQLError = require_GraphQLError();
    function syntaxError(source, position, description) {
      return new _GraphQLError.GraphQLError(`Syntax Error: ${description}`, {
        source,
        positions: [position]
      });
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/language/ast.js
var require_ast = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/language/ast.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Token = exports2.QueryDocumentKeys = exports2.OperationTypeNode = exports2.Location = void 0;
    exports2.isNode = isNode;
    var Location = class {
      constructor(startToken, endToken, source) {
        this.start = startToken.start;
        this.end = endToken.end;
        this.startToken = startToken;
        this.endToken = endToken;
        this.source = source;
      }
      get [Symbol.toStringTag]() {
        return "Location";
      }
      toJSON() {
        return {
          start: this.start,
          end: this.end
        };
      }
    };
    exports2.Location = Location;
    var Token = class {
      constructor(kind, start, end, line, column, value) {
        this.kind = kind;
        this.start = start;
        this.end = end;
        this.line = line;
        this.column = column;
        this.value = value;
        this.prev = null;
        this.next = null;
      }
      get [Symbol.toStringTag]() {
        return "Token";
      }
      toJSON() {
        return {
          kind: this.kind,
          value: this.value,
          line: this.line,
          column: this.column
        };
      }
    };
    exports2.Token = Token;
    var QueryDocumentKeys = {
      Name: [],
      Document: ["definitions"],
      OperationDefinition: [
        "name",
        "variableDefinitions",
        "directives",
        "selectionSet"
      ],
      VariableDefinition: ["variable", "type", "defaultValue", "directives"],
      Variable: ["name"],
      SelectionSet: ["selections"],
      Field: ["alias", "name", "arguments", "directives", "selectionSet"],
      Argument: ["name", "value"],
      FragmentSpread: ["name", "directives"],
      InlineFragment: ["typeCondition", "directives", "selectionSet"],
      FragmentDefinition: [
        "name",
        "variableDefinitions",
        "typeCondition",
        "directives",
        "selectionSet"
      ],
      IntValue: [],
      FloatValue: [],
      StringValue: [],
      BooleanValue: [],
      NullValue: [],
      EnumValue: [],
      ListValue: ["values"],
      ObjectValue: ["fields"],
      ObjectField: ["name", "value"],
      Directive: ["name", "arguments"],
      NamedType: ["name"],
      ListType: ["type"],
      NonNullType: ["type"],
      SchemaDefinition: ["description", "directives", "operationTypes"],
      OperationTypeDefinition: ["type"],
      ScalarTypeDefinition: ["description", "name", "directives"],
      ObjectTypeDefinition: [
        "description",
        "name",
        "interfaces",
        "directives",
        "fields"
      ],
      FieldDefinition: ["description", "name", "arguments", "type", "directives"],
      InputValueDefinition: [
        "description",
        "name",
        "type",
        "defaultValue",
        "directives"
      ],
      InterfaceTypeDefinition: [
        "description",
        "name",
        "interfaces",
        "directives",
        "fields"
      ],
      UnionTypeDefinition: ["description", "name", "directives", "types"],
      EnumTypeDefinition: ["description", "name", "directives", "values"],
      EnumValueDefinition: ["description", "name", "directives"],
      InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
      DirectiveDefinition: ["description", "name", "arguments", "locations"],
      SchemaExtension: ["directives", "operationTypes"],
      ScalarTypeExtension: ["name", "directives"],
      ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
      InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
      UnionTypeExtension: ["name", "directives", "types"],
      EnumTypeExtension: ["name", "directives", "values"],
      InputObjectTypeExtension: ["name", "directives", "fields"]
    };
    exports2.QueryDocumentKeys = QueryDocumentKeys;
    var kindValues = new Set(Object.keys(QueryDocumentKeys));
    function isNode(maybeNode) {
      const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
      return typeof maybeKind === "string" && kindValues.has(maybeKind);
    }
    var OperationTypeNode;
    exports2.OperationTypeNode = OperationTypeNode;
    (function(OperationTypeNode2) {
      OperationTypeNode2["QUERY"] = "query";
      OperationTypeNode2["MUTATION"] = "mutation";
      OperationTypeNode2["SUBSCRIPTION"] = "subscription";
    })(OperationTypeNode || (exports2.OperationTypeNode = OperationTypeNode = {}));
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/language/directiveLocation.js
var require_directiveLocation = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/language/directiveLocation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.DirectiveLocation = void 0;
    var DirectiveLocation;
    exports2.DirectiveLocation = DirectiveLocation;
    (function(DirectiveLocation2) {
      DirectiveLocation2["QUERY"] = "QUERY";
      DirectiveLocation2["MUTATION"] = "MUTATION";
      DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
      DirectiveLocation2["FIELD"] = "FIELD";
      DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
      DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
      DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
      DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
      DirectiveLocation2["SCHEMA"] = "SCHEMA";
      DirectiveLocation2["SCALAR"] = "SCALAR";
      DirectiveLocation2["OBJECT"] = "OBJECT";
      DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
      DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
      DirectiveLocation2["INTERFACE"] = "INTERFACE";
      DirectiveLocation2["UNION"] = "UNION";
      DirectiveLocation2["ENUM"] = "ENUM";
      DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
      DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
      DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
    })(DirectiveLocation || (exports2.DirectiveLocation = DirectiveLocation = {}));
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/language/kinds.js
var require_kinds = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/language/kinds.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Kind = void 0;
    var Kind5;
    exports2.Kind = Kind5;
    (function(Kind6) {
      Kind6["NAME"] = "Name";
      Kind6["DOCUMENT"] = "Document";
      Kind6["OPERATION_DEFINITION"] = "OperationDefinition";
      Kind6["VARIABLE_DEFINITION"] = "VariableDefinition";
      Kind6["SELECTION_SET"] = "SelectionSet";
      Kind6["FIELD"] = "Field";
      Kind6["ARGUMENT"] = "Argument";
      Kind6["FRAGMENT_SPREAD"] = "FragmentSpread";
      Kind6["INLINE_FRAGMENT"] = "InlineFragment";
      Kind6["FRAGMENT_DEFINITION"] = "FragmentDefinition";
      Kind6["VARIABLE"] = "Variable";
      Kind6["INT"] = "IntValue";
      Kind6["FLOAT"] = "FloatValue";
      Kind6["STRING"] = "StringValue";
      Kind6["BOOLEAN"] = "BooleanValue";
      Kind6["NULL"] = "NullValue";
      Kind6["ENUM"] = "EnumValue";
      Kind6["LIST"] = "ListValue";
      Kind6["OBJECT"] = "ObjectValue";
      Kind6["OBJECT_FIELD"] = "ObjectField";
      Kind6["DIRECTIVE"] = "Directive";
      Kind6["NAMED_TYPE"] = "NamedType";
      Kind6["LIST_TYPE"] = "ListType";
      Kind6["NON_NULL_TYPE"] = "NonNullType";
      Kind6["SCHEMA_DEFINITION"] = "SchemaDefinition";
      Kind6["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
      Kind6["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
      Kind6["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
      Kind6["FIELD_DEFINITION"] = "FieldDefinition";
      Kind6["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
      Kind6["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
      Kind6["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
      Kind6["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
      Kind6["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
      Kind6["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
      Kind6["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
      Kind6["SCHEMA_EXTENSION"] = "SchemaExtension";
      Kind6["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
      Kind6["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
      Kind6["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
      Kind6["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
      Kind6["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
      Kind6["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
    })(Kind5 || (exports2.Kind = Kind5 = {}));
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/language/characterClasses.js
var require_characterClasses = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/language/characterClasses.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isDigit = isDigit;
    exports2.isLetter = isLetter;
    exports2.isNameContinue = isNameContinue;
    exports2.isNameStart = isNameStart;
    exports2.isWhiteSpace = isWhiteSpace;
    function isWhiteSpace(code) {
      return code === 9 || code === 32;
    }
    function isDigit(code) {
      return code >= 48 && code <= 57;
    }
    function isLetter(code) {
      return code >= 97 && code <= 122 || code >= 65 && code <= 90;
    }
    function isNameStart(code) {
      return isLetter(code) || code === 95;
    }
    function isNameContinue(code) {
      return isLetter(code) || isDigit(code) || code === 95;
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/language/blockString.js
var require_blockString = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/language/blockString.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.dedentBlockStringLines = dedentBlockStringLines;
    exports2.isPrintableAsBlockString = isPrintableAsBlockString;
    exports2.printBlockString = printBlockString2;
    var _characterClasses = require_characterClasses();
    function dedentBlockStringLines(lines) {
      var _firstNonEmptyLine2;
      let commonIndent = Number.MAX_SAFE_INTEGER;
      let firstNonEmptyLine = null;
      let lastNonEmptyLine = -1;
      for (let i = 0; i < lines.length; ++i) {
        var _firstNonEmptyLine;
        const line = lines[i];
        const indent2 = leadingWhitespace2(line);
        if (indent2 === line.length) {
          continue;
        }
        firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;
        lastNonEmptyLine = i;
        if (i !== 0 && indent2 < commonIndent) {
          commonIndent = indent2;
        }
      }
      return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice((_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0, lastNonEmptyLine + 1);
    }
    function leadingWhitespace2(str) {
      let i = 0;
      while (i < str.length && (0, _characterClasses.isWhiteSpace)(str.charCodeAt(i))) {
        ++i;
      }
      return i;
    }
    function isPrintableAsBlockString(value) {
      if (value === "") {
        return true;
      }
      let isEmptyLine = true;
      let hasIndent = false;
      let hasCommonIndent = true;
      let seenNonEmptyLine = false;
      for (let i = 0; i < value.length; ++i) {
        switch (value.codePointAt(i)) {
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 11:
          case 12:
          case 14:
          case 15:
            return false;
          case 13:
            return false;
          case 10:
            if (isEmptyLine && !seenNonEmptyLine) {
              return false;
            }
            seenNonEmptyLine = true;
            isEmptyLine = true;
            hasIndent = false;
            break;
          case 9:
          case 32:
            hasIndent || (hasIndent = isEmptyLine);
            break;
          default:
            hasCommonIndent && (hasCommonIndent = hasIndent);
            isEmptyLine = false;
        }
      }
      if (isEmptyLine) {
        return false;
      }
      if (hasCommonIndent && seenNonEmptyLine) {
        return false;
      }
      return true;
    }
    function printBlockString2(value, options2) {
      const escapedValue = value.replace(/"""/g, '\\"""');
      const lines = escapedValue.split(/\r\n|[\n\r]/g);
      const isSingleLine = lines.length === 1;
      const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || (0, _characterClasses.isWhiteSpace)(line.charCodeAt(0)));
      const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
      const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
      const hasTrailingSlash = value.endsWith("\\");
      const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
      const printAsMultipleLines = !(options2 !== null && options2 !== void 0 && options2.minimize) && (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
      let result = "";
      const skipLeadingNewLine = isSingleLine && (0, _characterClasses.isWhiteSpace)(value.charCodeAt(0));
      if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
        result += "\n";
      }
      result += escapedValue;
      if (printAsMultipleLines || forceTrailingNewline) {
        result += "\n";
      }
      return '"""' + result + '"""';
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/language/tokenKind.js
var require_tokenKind = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/language/tokenKind.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TokenKind = void 0;
    var TokenKind2;
    exports2.TokenKind = TokenKind2;
    (function(TokenKind3) {
      TokenKind3["SOF"] = "<SOF>";
      TokenKind3["EOF"] = "<EOF>";
      TokenKind3["BANG"] = "!";
      TokenKind3["DOLLAR"] = "$";
      TokenKind3["AMP"] = "&";
      TokenKind3["PAREN_L"] = "(";
      TokenKind3["PAREN_R"] = ")";
      TokenKind3["SPREAD"] = "...";
      TokenKind3["COLON"] = ":";
      TokenKind3["EQUALS"] = "=";
      TokenKind3["AT"] = "@";
      TokenKind3["BRACKET_L"] = "[";
      TokenKind3["BRACKET_R"] = "]";
      TokenKind3["BRACE_L"] = "{";
      TokenKind3["PIPE"] = "|";
      TokenKind3["BRACE_R"] = "}";
      TokenKind3["NAME"] = "Name";
      TokenKind3["INT"] = "Int";
      TokenKind3["FLOAT"] = "Float";
      TokenKind3["STRING"] = "String";
      TokenKind3["BLOCK_STRING"] = "BlockString";
      TokenKind3["COMMENT"] = "Comment";
    })(TokenKind2 || (exports2.TokenKind = TokenKind2 = {}));
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/language/lexer.js
var require_lexer = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/language/lexer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Lexer = void 0;
    exports2.isPunctuatorTokenKind = isPunctuatorTokenKind;
    var _syntaxError = require_syntaxError();
    var _ast = require_ast();
    var _blockString = require_blockString();
    var _characterClasses = require_characterClasses();
    var _tokenKind = require_tokenKind();
    var Lexer = class {
      constructor(source) {
        const startOfFileToken = new _ast.Token(_tokenKind.TokenKind.SOF, 0, 0, 0, 0);
        this.source = source;
        this.lastToken = startOfFileToken;
        this.token = startOfFileToken;
        this.line = 1;
        this.lineStart = 0;
      }
      get [Symbol.toStringTag]() {
        return "Lexer";
      }
      advance() {
        this.lastToken = this.token;
        const token = this.token = this.lookahead();
        return token;
      }
      lookahead() {
        let token = this.token;
        if (token.kind !== _tokenKind.TokenKind.EOF) {
          do {
            if (token.next) {
              token = token.next;
            } else {
              const nextToken = readNextToken(this, token.end);
              token.next = nextToken;
              nextToken.prev = token;
              token = nextToken;
            }
          } while (token.kind === _tokenKind.TokenKind.COMMENT);
        }
        return token;
      }
    };
    exports2.Lexer = Lexer;
    function isPunctuatorTokenKind(kind) {
      return kind === _tokenKind.TokenKind.BANG || kind === _tokenKind.TokenKind.DOLLAR || kind === _tokenKind.TokenKind.AMP || kind === _tokenKind.TokenKind.PAREN_L || kind === _tokenKind.TokenKind.PAREN_R || kind === _tokenKind.TokenKind.SPREAD || kind === _tokenKind.TokenKind.COLON || kind === _tokenKind.TokenKind.EQUALS || kind === _tokenKind.TokenKind.AT || kind === _tokenKind.TokenKind.BRACKET_L || kind === _tokenKind.TokenKind.BRACKET_R || kind === _tokenKind.TokenKind.BRACE_L || kind === _tokenKind.TokenKind.PIPE || kind === _tokenKind.TokenKind.BRACE_R;
    }
    function isUnicodeScalarValue(code) {
      return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
    }
    function isSupplementaryCodePoint(body, location) {
      return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
    }
    function isLeadingSurrogate(code) {
      return code >= 55296 && code <= 56319;
    }
    function isTrailingSurrogate(code) {
      return code >= 56320 && code <= 57343;
    }
    function printCodePointAt(lexer, location) {
      const code = lexer.source.body.codePointAt(location);
      if (code === void 0) {
        return _tokenKind.TokenKind.EOF;
      } else if (code >= 32 && code <= 126) {
        const char = String.fromCodePoint(code);
        return char === '"' ? `'"'` : `"${char}"`;
      }
      return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
    }
    function createToken(lexer, kind, start, end, value) {
      const line = lexer.line;
      const col = 1 + start - lexer.lineStart;
      return new _ast.Token(kind, start, end, line, col, value);
    }
    function readNextToken(lexer, start) {
      const body = lexer.source.body;
      const bodyLength = body.length;
      let position = start;
      while (position < bodyLength) {
        const code = body.charCodeAt(position);
        switch (code) {
          case 65279:
          case 9:
          case 32:
          case 44:
            ++position;
            continue;
          case 10:
            ++position;
            ++lexer.line;
            lexer.lineStart = position;
            continue;
          case 13:
            if (body.charCodeAt(position + 1) === 10) {
              position += 2;
            } else {
              ++position;
            }
            ++lexer.line;
            lexer.lineStart = position;
            continue;
          case 35:
            return readComment(lexer, position);
          case 33:
            return createToken(lexer, _tokenKind.TokenKind.BANG, position, position + 1);
          case 36:
            return createToken(lexer, _tokenKind.TokenKind.DOLLAR, position, position + 1);
          case 38:
            return createToken(lexer, _tokenKind.TokenKind.AMP, position, position + 1);
          case 40:
            return createToken(lexer, _tokenKind.TokenKind.PAREN_L, position, position + 1);
          case 41:
            return createToken(lexer, _tokenKind.TokenKind.PAREN_R, position, position + 1);
          case 46:
            if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
              return createToken(lexer, _tokenKind.TokenKind.SPREAD, position, position + 3);
            }
            break;
          case 58:
            return createToken(lexer, _tokenKind.TokenKind.COLON, position, position + 1);
          case 61:
            return createToken(lexer, _tokenKind.TokenKind.EQUALS, position, position + 1);
          case 64:
            return createToken(lexer, _tokenKind.TokenKind.AT, position, position + 1);
          case 91:
            return createToken(lexer, _tokenKind.TokenKind.BRACKET_L, position, position + 1);
          case 93:
            return createToken(lexer, _tokenKind.TokenKind.BRACKET_R, position, position + 1);
          case 123:
            return createToken(lexer, _tokenKind.TokenKind.BRACE_L, position, position + 1);
          case 124:
            return createToken(lexer, _tokenKind.TokenKind.PIPE, position, position + 1);
          case 125:
            return createToken(lexer, _tokenKind.TokenKind.BRACE_R, position, position + 1);
          case 34:
            if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
              return readBlockString(lexer, position);
            }
            return readString(lexer, position);
        }
        if ((0, _characterClasses.isDigit)(code) || code === 45) {
          return readNumber(lexer, position, code);
        }
        if ((0, _characterClasses.isNameStart)(code)) {
          return readName(lexer, position);
        }
        throw (0, _syntaxError.syntaxError)(lexer.source, position, code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`);
      }
      return createToken(lexer, _tokenKind.TokenKind.EOF, bodyLength, bodyLength);
    }
    function readComment(lexer, start) {
      const body = lexer.source.body;
      const bodyLength = body.length;
      let position = start + 1;
      while (position < bodyLength) {
        const code = body.charCodeAt(position);
        if (code === 10 || code === 13) {
          break;
        }
        if (isUnicodeScalarValue(code)) {
          ++position;
        } else if (isSupplementaryCodePoint(body, position)) {
          position += 2;
        } else {
          break;
        }
      }
      return createToken(lexer, _tokenKind.TokenKind.COMMENT, start, position, body.slice(start + 1, position));
    }
    function readNumber(lexer, start, firstCode) {
      const body = lexer.source.body;
      let position = start;
      let code = firstCode;
      let isFloat = false;
      if (code === 45) {
        code = body.charCodeAt(++position);
      }
      if (code === 48) {
        code = body.charCodeAt(++position);
        if ((0, _characterClasses.isDigit)(code)) {
          throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid number, unexpected digit after 0: ${printCodePointAt(lexer, position)}.`);
        }
      } else {
        position = readDigits(lexer, position, code);
        code = body.charCodeAt(position);
      }
      if (code === 46) {
        isFloat = true;
        code = body.charCodeAt(++position);
        position = readDigits(lexer, position, code);
        code = body.charCodeAt(position);
      }
      if (code === 69 || code === 101) {
        isFloat = true;
        code = body.charCodeAt(++position);
        if (code === 43 || code === 45) {
          code = body.charCodeAt(++position);
        }
        position = readDigits(lexer, position, code);
        code = body.charCodeAt(position);
      }
      if (code === 46 || (0, _characterClasses.isNameStart)(code)) {
        throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid number, expected digit but got: ${printCodePointAt(lexer, position)}.`);
      }
      return createToken(lexer, isFloat ? _tokenKind.TokenKind.FLOAT : _tokenKind.TokenKind.INT, start, position, body.slice(start, position));
    }
    function readDigits(lexer, start, firstCode) {
      if (!(0, _characterClasses.isDigit)(firstCode)) {
        throw (0, _syntaxError.syntaxError)(lexer.source, start, `Invalid number, expected digit but got: ${printCodePointAt(lexer, start)}.`);
      }
      const body = lexer.source.body;
      let position = start + 1;
      while ((0, _characterClasses.isDigit)(body.charCodeAt(position))) {
        ++position;
      }
      return position;
    }
    function readString(lexer, start) {
      const body = lexer.source.body;
      const bodyLength = body.length;
      let position = start + 1;
      let chunkStart = position;
      let value = "";
      while (position < bodyLength) {
        const code = body.charCodeAt(position);
        if (code === 34) {
          value += body.slice(chunkStart, position);
          return createToken(lexer, _tokenKind.TokenKind.STRING, start, position + 1, value);
        }
        if (code === 92) {
          value += body.slice(chunkStart, position);
          const escape2 = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
          value += escape2.value;
          position += escape2.size;
          chunkStart = position;
          continue;
        }
        if (code === 10 || code === 13) {
          break;
        }
        if (isUnicodeScalarValue(code)) {
          ++position;
        } else if (isSupplementaryCodePoint(body, position)) {
          position += 2;
        } else {
          throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);
        }
      }
      throw (0, _syntaxError.syntaxError)(lexer.source, position, "Unterminated string.");
    }
    function readEscapedUnicodeVariableWidth(lexer, position) {
      const body = lexer.source.body;
      let point = 0;
      let size = 3;
      while (size < 12) {
        const code = body.charCodeAt(position + size++);
        if (code === 125) {
          if (size < 5 || !isUnicodeScalarValue(point)) {
            break;
          }
          return {
            value: String.fromCodePoint(point),
            size
          };
        }
        point = point << 4 | readHexDigit(code);
        if (point < 0) {
          break;
        }
      }
      throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid Unicode escape sequence: "${body.slice(position, position + size)}".`);
    }
    function readEscapedUnicodeFixedWidth(lexer, position) {
      const body = lexer.source.body;
      const code = read16BitHexCode(body, position + 2);
      if (isUnicodeScalarValue(code)) {
        return {
          value: String.fromCodePoint(code),
          size: 6
        };
      }
      if (isLeadingSurrogate(code)) {
        if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
          const trailingCode = read16BitHexCode(body, position + 8);
          if (isTrailingSurrogate(trailingCode)) {
            return {
              value: String.fromCodePoint(code, trailingCode),
              size: 12
            };
          }
        }
      }
      throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`);
    }
    function read16BitHexCode(body, position) {
      return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
    }
    function readHexDigit(code) {
      return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
    }
    function readEscapedCharacter(lexer, position) {
      const body = lexer.source.body;
      const code = body.charCodeAt(position + 1);
      switch (code) {
        case 34:
          return {
            value: '"',
            size: 2
          };
        case 92:
          return {
            value: "\\",
            size: 2
          };
        case 47:
          return {
            value: "/",
            size: 2
          };
        case 98:
          return {
            value: "\b",
            size: 2
          };
        case 102:
          return {
            value: "\f",
            size: 2
          };
        case 110:
          return {
            value: "\n",
            size: 2
          };
        case 114:
          return {
            value: "\r",
            size: 2
          };
        case 116:
          return {
            value: "	",
            size: 2
          };
      }
      throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid character escape sequence: "${body.slice(position, position + 2)}".`);
    }
    function readBlockString(lexer, start) {
      const body = lexer.source.body;
      const bodyLength = body.length;
      let lineStart = lexer.lineStart;
      let position = start + 3;
      let chunkStart = position;
      let currentLine = "";
      const blockLines = [];
      while (position < bodyLength) {
        const code = body.charCodeAt(position);
        if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
          currentLine += body.slice(chunkStart, position);
          blockLines.push(currentLine);
          const token = createToken(lexer, _tokenKind.TokenKind.BLOCK_STRING, start, position + 3, (0, _blockString.dedentBlockStringLines)(blockLines).join("\n"));
          lexer.line += blockLines.length - 1;
          lexer.lineStart = lineStart;
          return token;
        }
        if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
          currentLine += body.slice(chunkStart, position);
          chunkStart = position + 1;
          position += 4;
          continue;
        }
        if (code === 10 || code === 13) {
          currentLine += body.slice(chunkStart, position);
          blockLines.push(currentLine);
          if (code === 13 && body.charCodeAt(position + 1) === 10) {
            position += 2;
          } else {
            ++position;
          }
          currentLine = "";
          chunkStart = position;
          lineStart = position;
          continue;
        }
        if (isUnicodeScalarValue(code)) {
          ++position;
        } else if (isSupplementaryCodePoint(body, position)) {
          position += 2;
        } else {
          throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);
        }
      }
      throw (0, _syntaxError.syntaxError)(lexer.source, position, "Unterminated string.");
    }
    function readName(lexer, start) {
      const body = lexer.source.body;
      const bodyLength = body.length;
      let position = start + 1;
      while (position < bodyLength) {
        const code = body.charCodeAt(position);
        if ((0, _characterClasses.isNameContinue)(code)) {
          ++position;
        } else {
          break;
        }
      }
      return createToken(lexer, _tokenKind.TokenKind.NAME, start, position, body.slice(start, position));
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/inspect.js
var require_inspect = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/inspect.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.inspect = inspect4;
    var MAX_ARRAY_LENGTH = 10;
    var MAX_RECURSIVE_DEPTH2 = 2;
    function inspect4(value) {
      return formatValue3(value, []);
    }
    function formatValue3(value, seenValues) {
      switch (typeof value) {
        case "string":
          return JSON.stringify(value);
        case "function":
          return value.name ? `[function ${value.name}]` : "[function]";
        case "object":
          return formatObjectValue2(value, seenValues);
        default:
          return String(value);
      }
    }
    function formatObjectValue2(value, previouslySeenValues) {
      if (value === null) {
        return "null";
      }
      if (previouslySeenValues.includes(value)) {
        return "[Circular]";
      }
      const seenValues = [...previouslySeenValues, value];
      if (isJSONable2(value)) {
        const jsonValue = value.toJSON();
        if (jsonValue !== value) {
          return typeof jsonValue === "string" ? jsonValue : formatValue3(jsonValue, seenValues);
        }
      } else if (Array.isArray(value)) {
        return formatArray3(value, seenValues);
      }
      return formatObject2(value, seenValues);
    }
    function isJSONable2(value) {
      return typeof value.toJSON === "function";
    }
    function formatObject2(object, seenValues) {
      const entries = Object.entries(object);
      if (entries.length === 0) {
        return "{}";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
        return "[" + getObjectTag2(object) + "]";
      }
      const properties = entries.map(([key, value]) => key + ": " + formatValue3(value, seenValues));
      return "{ " + properties.join(", ") + " }";
    }
    function formatArray3(array, seenValues) {
      if (array.length === 0) {
        return "[]";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
        return "[Array]";
      }
      const len = Math.min(MAX_ARRAY_LENGTH, array.length);
      const remaining = array.length - len;
      const items = [];
      for (let i = 0; i < len; ++i) {
        items.push(formatValue3(array[i], seenValues));
      }
      if (remaining === 1) {
        items.push("... 1 more item");
      } else if (remaining > 1) {
        items.push(`... ${remaining} more items`);
      }
      return "[" + items.join(", ") + "]";
    }
    function getObjectTag2(object) {
      const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
      if (tag === "Object" && typeof object.constructor === "function") {
        const name = object.constructor.name;
        if (typeof name === "string" && name !== "") {
          return name;
        }
      }
      return tag;
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/instanceOf.js
var require_instanceOf = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/instanceOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.instanceOf = void 0;
    var _inspect = require_inspect();
    var instanceOf = process.env.NODE_ENV === "production" ? function instanceOf2(value, constructor) {
      return value instanceof constructor;
    } : function instanceOf2(value, constructor) {
      if (value instanceof constructor) {
        return true;
      }
      if (typeof value === "object" && value !== null) {
        var _value$constructor;
        const className = constructor.prototype[Symbol.toStringTag];
        const valueClassName = Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name;
        if (className === valueClassName) {
          const stringifiedValue = (0, _inspect.inspect)(value);
          throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
        }
      }
      return false;
    };
    exports2.instanceOf = instanceOf;
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/language/source.js
var require_source = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/language/source.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Source = void 0;
    exports2.isSource = isSource;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _instanceOf = require_instanceOf();
    var Source4 = class {
      constructor(body, name = "GraphQL request", locationOffset = {
        line: 1,
        column: 1
      }) {
        typeof body === "string" || (0, _devAssert.devAssert)(false, `Body must be a string. Received: ${(0, _inspect.inspect)(body)}.`);
        this.body = body;
        this.name = name;
        this.locationOffset = locationOffset;
        this.locationOffset.line > 0 || (0, _devAssert.devAssert)(false, "line in locationOffset is 1-indexed and must be positive.");
        this.locationOffset.column > 0 || (0, _devAssert.devAssert)(false, "column in locationOffset is 1-indexed and must be positive.");
      }
      get [Symbol.toStringTag]() {
        return "Source";
      }
    };
    exports2.Source = Source4;
    function isSource(source) {
      return (0, _instanceOf.instanceOf)(source, Source4);
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/language/parser.js
var require_parser = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/language/parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Parser = void 0;
    exports2.parse = parse6;
    exports2.parseConstValue = parseConstValue;
    exports2.parseType = parseType;
    exports2.parseValue = parseValue;
    var _syntaxError = require_syntaxError();
    var _ast = require_ast();
    var _directiveLocation = require_directiveLocation();
    var _kinds = require_kinds();
    var _lexer = require_lexer();
    var _source = require_source();
    var _tokenKind = require_tokenKind();
    function parse6(source, options2) {
      const parser = new Parser(source, options2);
      return parser.parseDocument();
    }
    function parseValue(source, options2) {
      const parser = new Parser(source, options2);
      parser.expectToken(_tokenKind.TokenKind.SOF);
      const value = parser.parseValueLiteral(false);
      parser.expectToken(_tokenKind.TokenKind.EOF);
      return value;
    }
    function parseConstValue(source, options2) {
      const parser = new Parser(source, options2);
      parser.expectToken(_tokenKind.TokenKind.SOF);
      const value = parser.parseConstValueLiteral();
      parser.expectToken(_tokenKind.TokenKind.EOF);
      return value;
    }
    function parseType(source, options2) {
      const parser = new Parser(source, options2);
      parser.expectToken(_tokenKind.TokenKind.SOF);
      const type = parser.parseTypeReference();
      parser.expectToken(_tokenKind.TokenKind.EOF);
      return type;
    }
    var Parser = class {
      constructor(source, options2) {
        const sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
        this._lexer = new _lexer.Lexer(sourceObj);
        this._options = options2;
      }
      parseName() {
        const token = this.expectToken(_tokenKind.TokenKind.NAME);
        return this.node(token, {
          kind: _kinds.Kind.NAME,
          value: token.value
        });
      }
      parseDocument() {
        return this.node(this._lexer.token, {
          kind: _kinds.Kind.DOCUMENT,
          definitions: this.many(_tokenKind.TokenKind.SOF, this.parseDefinition, _tokenKind.TokenKind.EOF)
        });
      }
      parseDefinition() {
        if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
          return this.parseOperationDefinition();
        }
        const hasDescription = this.peekDescription();
        const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
        if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
          switch (keywordToken.value) {
            case "schema":
              return this.parseSchemaDefinition();
            case "scalar":
              return this.parseScalarTypeDefinition();
            case "type":
              return this.parseObjectTypeDefinition();
            case "interface":
              return this.parseInterfaceTypeDefinition();
            case "union":
              return this.parseUnionTypeDefinition();
            case "enum":
              return this.parseEnumTypeDefinition();
            case "input":
              return this.parseInputObjectTypeDefinition();
            case "directive":
              return this.parseDirectiveDefinition();
          }
          if (hasDescription) {
            throw (0, _syntaxError.syntaxError)(this._lexer.source, this._lexer.token.start, "Unexpected description, descriptions are supported only on type definitions.");
          }
          switch (keywordToken.value) {
            case "query":
            case "mutation":
            case "subscription":
              return this.parseOperationDefinition();
            case "fragment":
              return this.parseFragmentDefinition();
            case "extend":
              return this.parseTypeSystemExtension();
          }
        }
        throw this.unexpected(keywordToken);
      }
      parseOperationDefinition() {
        const start = this._lexer.token;
        if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
          return this.node(start, {
            kind: _kinds.Kind.OPERATION_DEFINITION,
            operation: _ast.OperationTypeNode.QUERY,
            name: void 0,
            variableDefinitions: [],
            directives: [],
            selectionSet: this.parseSelectionSet()
          });
        }
        const operation = this.parseOperationType();
        let name;
        if (this.peek(_tokenKind.TokenKind.NAME)) {
          name = this.parseName();
        }
        return this.node(start, {
          kind: _kinds.Kind.OPERATION_DEFINITION,
          operation,
          name,
          variableDefinitions: this.parseVariableDefinitions(),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      parseOperationType() {
        const operationToken = this.expectToken(_tokenKind.TokenKind.NAME);
        switch (operationToken.value) {
          case "query":
            return _ast.OperationTypeNode.QUERY;
          case "mutation":
            return _ast.OperationTypeNode.MUTATION;
          case "subscription":
            return _ast.OperationTypeNode.SUBSCRIPTION;
        }
        throw this.unexpected(operationToken);
      }
      parseVariableDefinitions() {
        return this.optionalMany(_tokenKind.TokenKind.PAREN_L, this.parseVariableDefinition, _tokenKind.TokenKind.PAREN_R);
      }
      parseVariableDefinition() {
        return this.node(this._lexer.token, {
          kind: _kinds.Kind.VARIABLE_DEFINITION,
          variable: this.parseVariable(),
          type: (this.expectToken(_tokenKind.TokenKind.COLON), this.parseTypeReference()),
          defaultValue: this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
          directives: this.parseConstDirectives()
        });
      }
      parseVariable() {
        const start = this._lexer.token;
        this.expectToken(_tokenKind.TokenKind.DOLLAR);
        return this.node(start, {
          kind: _kinds.Kind.VARIABLE,
          name: this.parseName()
        });
      }
      parseSelectionSet() {
        return this.node(this._lexer.token, {
          kind: _kinds.Kind.SELECTION_SET,
          selections: this.many(_tokenKind.TokenKind.BRACE_L, this.parseSelection, _tokenKind.TokenKind.BRACE_R)
        });
      }
      parseSelection() {
        return this.peek(_tokenKind.TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
      }
      parseField() {
        const start = this._lexer.token;
        const nameOrAlias = this.parseName();
        let alias;
        let name;
        if (this.expectOptionalToken(_tokenKind.TokenKind.COLON)) {
          alias = nameOrAlias;
          name = this.parseName();
        } else {
          name = nameOrAlias;
        }
        return this.node(start, {
          kind: _kinds.Kind.FIELD,
          alias,
          name,
          arguments: this.parseArguments(false),
          directives: this.parseDirectives(false),
          selectionSet: this.peek(_tokenKind.TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
        });
      }
      parseArguments(isConst) {
        const item = isConst ? this.parseConstArgument : this.parseArgument;
        return this.optionalMany(_tokenKind.TokenKind.PAREN_L, item, _tokenKind.TokenKind.PAREN_R);
      }
      parseArgument(isConst = false) {
        const start = this._lexer.token;
        const name = this.parseName();
        this.expectToken(_tokenKind.TokenKind.COLON);
        return this.node(start, {
          kind: _kinds.Kind.ARGUMENT,
          name,
          value: this.parseValueLiteral(isConst)
        });
      }
      parseConstArgument() {
        return this.parseArgument(true);
      }
      parseFragment() {
        const start = this._lexer.token;
        this.expectToken(_tokenKind.TokenKind.SPREAD);
        const hasTypeCondition = this.expectOptionalKeyword("on");
        if (!hasTypeCondition && this.peek(_tokenKind.TokenKind.NAME)) {
          return this.node(start, {
            kind: _kinds.Kind.FRAGMENT_SPREAD,
            name: this.parseFragmentName(),
            directives: this.parseDirectives(false)
          });
        }
        return this.node(start, {
          kind: _kinds.Kind.INLINE_FRAGMENT,
          typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      parseFragmentDefinition() {
        var _this$_options;
        const start = this._lexer.token;
        this.expectKeyword("fragment");
        if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.allowLegacyFragmentVariables) === true) {
          return this.node(start, {
            kind: _kinds.Kind.FRAGMENT_DEFINITION,
            name: this.parseFragmentName(),
            variableDefinitions: this.parseVariableDefinitions(),
            typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
          });
        }
        return this.node(start, {
          kind: _kinds.Kind.FRAGMENT_DEFINITION,
          name: this.parseFragmentName(),
          typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      parseFragmentName() {
        if (this._lexer.token.value === "on") {
          throw this.unexpected();
        }
        return this.parseName();
      }
      parseValueLiteral(isConst) {
        const token = this._lexer.token;
        switch (token.kind) {
          case _tokenKind.TokenKind.BRACKET_L:
            return this.parseList(isConst);
          case _tokenKind.TokenKind.BRACE_L:
            return this.parseObject(isConst);
          case _tokenKind.TokenKind.INT:
            this._lexer.advance();
            return this.node(token, {
              kind: _kinds.Kind.INT,
              value: token.value
            });
          case _tokenKind.TokenKind.FLOAT:
            this._lexer.advance();
            return this.node(token, {
              kind: _kinds.Kind.FLOAT,
              value: token.value
            });
          case _tokenKind.TokenKind.STRING:
          case _tokenKind.TokenKind.BLOCK_STRING:
            return this.parseStringLiteral();
          case _tokenKind.TokenKind.NAME:
            this._lexer.advance();
            switch (token.value) {
              case "true":
                return this.node(token, {
                  kind: _kinds.Kind.BOOLEAN,
                  value: true
                });
              case "false":
                return this.node(token, {
                  kind: _kinds.Kind.BOOLEAN,
                  value: false
                });
              case "null":
                return this.node(token, {
                  kind: _kinds.Kind.NULL
                });
              default:
                return this.node(token, {
                  kind: _kinds.Kind.ENUM,
                  value: token.value
                });
            }
          case _tokenKind.TokenKind.DOLLAR:
            if (isConst) {
              this.expectToken(_tokenKind.TokenKind.DOLLAR);
              if (this._lexer.token.kind === _tokenKind.TokenKind.NAME) {
                const varName = this._lexer.token.value;
                throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Unexpected variable "$${varName}" in constant value.`);
              } else {
                throw this.unexpected(token);
              }
            }
            return this.parseVariable();
          default:
            throw this.unexpected();
        }
      }
      parseConstValueLiteral() {
        return this.parseValueLiteral(true);
      }
      parseStringLiteral() {
        const token = this._lexer.token;
        this._lexer.advance();
        return this.node(token, {
          kind: _kinds.Kind.STRING,
          value: token.value,
          block: token.kind === _tokenKind.TokenKind.BLOCK_STRING
        });
      }
      parseList(isConst) {
        const item = () => this.parseValueLiteral(isConst);
        return this.node(this._lexer.token, {
          kind: _kinds.Kind.LIST,
          values: this.any(_tokenKind.TokenKind.BRACKET_L, item, _tokenKind.TokenKind.BRACKET_R)
        });
      }
      parseObject(isConst) {
        const item = () => this.parseObjectField(isConst);
        return this.node(this._lexer.token, {
          kind: _kinds.Kind.OBJECT,
          fields: this.any(_tokenKind.TokenKind.BRACE_L, item, _tokenKind.TokenKind.BRACE_R)
        });
      }
      parseObjectField(isConst) {
        const start = this._lexer.token;
        const name = this.parseName();
        this.expectToken(_tokenKind.TokenKind.COLON);
        return this.node(start, {
          kind: _kinds.Kind.OBJECT_FIELD,
          name,
          value: this.parseValueLiteral(isConst)
        });
      }
      parseDirectives(isConst) {
        const directives = [];
        while (this.peek(_tokenKind.TokenKind.AT)) {
          directives.push(this.parseDirective(isConst));
        }
        return directives;
      }
      parseConstDirectives() {
        return this.parseDirectives(true);
      }
      parseDirective(isConst) {
        const start = this._lexer.token;
        this.expectToken(_tokenKind.TokenKind.AT);
        return this.node(start, {
          kind: _kinds.Kind.DIRECTIVE,
          name: this.parseName(),
          arguments: this.parseArguments(isConst)
        });
      }
      parseTypeReference() {
        const start = this._lexer.token;
        let type;
        if (this.expectOptionalToken(_tokenKind.TokenKind.BRACKET_L)) {
          const innerType = this.parseTypeReference();
          this.expectToken(_tokenKind.TokenKind.BRACKET_R);
          type = this.node(start, {
            kind: _kinds.Kind.LIST_TYPE,
            type: innerType
          });
        } else {
          type = this.parseNamedType();
        }
        if (this.expectOptionalToken(_tokenKind.TokenKind.BANG)) {
          return this.node(start, {
            kind: _kinds.Kind.NON_NULL_TYPE,
            type
          });
        }
        return type;
      }
      parseNamedType() {
        return this.node(this._lexer.token, {
          kind: _kinds.Kind.NAMED_TYPE,
          name: this.parseName()
        });
      }
      peekDescription() {
        return this.peek(_tokenKind.TokenKind.STRING) || this.peek(_tokenKind.TokenKind.BLOCK_STRING);
      }
      parseDescription() {
        if (this.peekDescription()) {
          return this.parseStringLiteral();
        }
      }
      parseSchemaDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("schema");
        const directives = this.parseConstDirectives();
        const operationTypes = this.many(_tokenKind.TokenKind.BRACE_L, this.parseOperationTypeDefinition, _tokenKind.TokenKind.BRACE_R);
        return this.node(start, {
          kind: _kinds.Kind.SCHEMA_DEFINITION,
          description,
          directives,
          operationTypes
        });
      }
      parseOperationTypeDefinition() {
        const start = this._lexer.token;
        const operation = this.parseOperationType();
        this.expectToken(_tokenKind.TokenKind.COLON);
        const type = this.parseNamedType();
        return this.node(start, {
          kind: _kinds.Kind.OPERATION_TYPE_DEFINITION,
          operation,
          type
        });
      }
      parseScalarTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("scalar");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: _kinds.Kind.SCALAR_TYPE_DEFINITION,
          description,
          name,
          directives
        });
      }
      parseObjectTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("type");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        return this.node(start, {
          kind: _kinds.Kind.OBJECT_TYPE_DEFINITION,
          description,
          name,
          interfaces,
          directives,
          fields
        });
      }
      parseImplementsInterfaces() {
        return this.expectOptionalKeyword("implements") ? this.delimitedMany(_tokenKind.TokenKind.AMP, this.parseNamedType) : [];
      }
      parseFieldsDefinition() {
        return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseFieldDefinition, _tokenKind.TokenKind.BRACE_R);
      }
      parseFieldDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseName();
        const args = this.parseArgumentDefs();
        this.expectToken(_tokenKind.TokenKind.COLON);
        const type = this.parseTypeReference();
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: _kinds.Kind.FIELD_DEFINITION,
          description,
          name,
          arguments: args,
          type,
          directives
        });
      }
      parseArgumentDefs() {
        return this.optionalMany(_tokenKind.TokenKind.PAREN_L, this.parseInputValueDef, _tokenKind.TokenKind.PAREN_R);
      }
      parseInputValueDef() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseName();
        this.expectToken(_tokenKind.TokenKind.COLON);
        const type = this.parseTypeReference();
        let defaultValue;
        if (this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)) {
          defaultValue = this.parseConstValueLiteral();
        }
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: _kinds.Kind.INPUT_VALUE_DEFINITION,
          description,
          name,
          type,
          defaultValue,
          directives
        });
      }
      parseInterfaceTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("interface");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        return this.node(start, {
          kind: _kinds.Kind.INTERFACE_TYPE_DEFINITION,
          description,
          name,
          interfaces,
          directives,
          fields
        });
      }
      parseUnionTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("union");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const types = this.parseUnionMemberTypes();
        return this.node(start, {
          kind: _kinds.Kind.UNION_TYPE_DEFINITION,
          description,
          name,
          directives,
          types
        });
      }
      parseUnionMemberTypes() {
        return this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseNamedType) : [];
      }
      parseEnumTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("enum");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const values = this.parseEnumValuesDefinition();
        return this.node(start, {
          kind: _kinds.Kind.ENUM_TYPE_DEFINITION,
          description,
          name,
          directives,
          values
        });
      }
      parseEnumValuesDefinition() {
        return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseEnumValueDefinition, _tokenKind.TokenKind.BRACE_R);
      }
      parseEnumValueDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseEnumValueName();
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: _kinds.Kind.ENUM_VALUE_DEFINITION,
          description,
          name,
          directives
        });
      }
      parseEnumValueName() {
        if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
          throw (0, _syntaxError.syntaxError)(this._lexer.source, this._lexer.token.start, `${getTokenDesc(this._lexer.token)} is reserved and cannot be used for an enum value.`);
        }
        return this.parseName();
      }
      parseInputObjectTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("input");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const fields = this.parseInputFieldsDefinition();
        return this.node(start, {
          kind: _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION,
          description,
          name,
          directives,
          fields
        });
      }
      parseInputFieldsDefinition() {
        return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseInputValueDef, _tokenKind.TokenKind.BRACE_R);
      }
      parseTypeSystemExtension() {
        const keywordToken = this._lexer.lookahead();
        if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
          switch (keywordToken.value) {
            case "schema":
              return this.parseSchemaExtension();
            case "scalar":
              return this.parseScalarTypeExtension();
            case "type":
              return this.parseObjectTypeExtension();
            case "interface":
              return this.parseInterfaceTypeExtension();
            case "union":
              return this.parseUnionTypeExtension();
            case "enum":
              return this.parseEnumTypeExtension();
            case "input":
              return this.parseInputObjectTypeExtension();
          }
        }
        throw this.unexpected(keywordToken);
      }
      parseSchemaExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("schema");
        const directives = this.parseConstDirectives();
        const operationTypes = this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseOperationTypeDefinition, _tokenKind.TokenKind.BRACE_R);
        if (directives.length === 0 && operationTypes.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.SCHEMA_EXTENSION,
          directives,
          operationTypes
        });
      }
      parseScalarTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("scalar");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        if (directives.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.SCALAR_TYPE_EXTENSION,
          name,
          directives
        });
      }
      parseObjectTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("type");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.OBJECT_TYPE_EXTENSION,
          name,
          interfaces,
          directives,
          fields
        });
      }
      parseInterfaceTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("interface");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
          name,
          interfaces,
          directives,
          fields
        });
      }
      parseUnionTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("union");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const types = this.parseUnionMemberTypes();
        if (directives.length === 0 && types.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.UNION_TYPE_EXTENSION,
          name,
          directives,
          types
        });
      }
      parseEnumTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("enum");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const values = this.parseEnumValuesDefinition();
        if (directives.length === 0 && values.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.ENUM_TYPE_EXTENSION,
          name,
          directives,
          values
        });
      }
      parseInputObjectTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("input");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const fields = this.parseInputFieldsDefinition();
        if (directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,
          name,
          directives,
          fields
        });
      }
      parseDirectiveDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("directive");
        this.expectToken(_tokenKind.TokenKind.AT);
        const name = this.parseName();
        const args = this.parseArgumentDefs();
        const repeatable = this.expectOptionalKeyword("repeatable");
        this.expectKeyword("on");
        const locations = this.parseDirectiveLocations();
        return this.node(start, {
          kind: _kinds.Kind.DIRECTIVE_DEFINITION,
          description,
          name,
          arguments: args,
          repeatable,
          locations
        });
      }
      parseDirectiveLocations() {
        return this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseDirectiveLocation);
      }
      parseDirectiveLocation() {
        const start = this._lexer.token;
        const name = this.parseName();
        if (Object.prototype.hasOwnProperty.call(_directiveLocation.DirectiveLocation, name.value)) {
          return name;
        }
        throw this.unexpected(start);
      }
      node(startToken, node) {
        var _this$_options2;
        if (((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.noLocation) !== true) {
          node.loc = new _ast.Location(startToken, this._lexer.lastToken, this._lexer.source);
        }
        return node;
      }
      peek(kind) {
        return this._lexer.token.kind === kind;
      }
      expectToken(kind) {
        const token = this._lexer.token;
        if (token.kind === kind) {
          this._lexer.advance();
          return token;
        }
        throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`);
      }
      expectOptionalToken(kind) {
        const token = this._lexer.token;
        if (token.kind === kind) {
          this._lexer.advance();
          return true;
        }
        return false;
      }
      expectKeyword(value) {
        const token = this._lexer.token;
        if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
          this._lexer.advance();
        } else {
          throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Expected "${value}", found ${getTokenDesc(token)}.`);
        }
      }
      expectOptionalKeyword(value) {
        const token = this._lexer.token;
        if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
          this._lexer.advance();
          return true;
        }
        return false;
      }
      unexpected(atToken) {
        const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
        return (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Unexpected ${getTokenDesc(token)}.`);
      }
      any(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        const nodes = [];
        while (!this.expectOptionalToken(closeKind)) {
          nodes.push(parseFn.call(this));
        }
        return nodes;
      }
      optionalMany(openKind, parseFn, closeKind) {
        if (this.expectOptionalToken(openKind)) {
          const nodes = [];
          do {
            nodes.push(parseFn.call(this));
          } while (!this.expectOptionalToken(closeKind));
          return nodes;
        }
        return [];
      }
      many(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        const nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (!this.expectOptionalToken(closeKind));
        return nodes;
      }
      delimitedMany(delimiterKind, parseFn) {
        this.expectOptionalToken(delimiterKind);
        const nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (this.expectOptionalToken(delimiterKind));
        return nodes;
      }
    };
    exports2.Parser = Parser;
    function getTokenDesc(token) {
      const value = token.value;
      return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
    }
    function getTokenKindDesc(kind) {
      return (0, _lexer.isPunctuatorTokenKind)(kind) ? `"${kind}"` : kind;
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/didYouMean.js
var require_didYouMean = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/didYouMean.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.didYouMean = didYouMean;
    var MAX_SUGGESTIONS = 5;
    function didYouMean(firstArg, secondArg) {
      const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
      let message = " Did you mean ";
      if (subMessage) {
        message += subMessage + " ";
      }
      const suggestions = suggestionsArg.map((x) => `"${x}"`);
      switch (suggestions.length) {
        case 0:
          return "";
        case 1:
          return message + suggestions[0] + "?";
        case 2:
          return message + suggestions[0] + " or " + suggestions[1] + "?";
      }
      const selected = suggestions.slice(0, MAX_SUGGESTIONS);
      const lastItem = selected.pop();
      return message + selected.join(", ") + ", or " + lastItem + "?";
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/identityFunc.js
var require_identityFunc = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/identityFunc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.identityFunc = identityFunc;
    function identityFunc(x) {
      return x;
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/keyMap.js
var require_keyMap = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/keyMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.keyMap = keyMap;
    function keyMap(list, keyFn) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const item of list) {
        result[keyFn(item)] = item;
      }
      return result;
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/keyValMap.js
var require_keyValMap = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/keyValMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.keyValMap = keyValMap;
    function keyValMap(list, keyFn, valFn) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const item of list) {
        result[keyFn(item)] = valFn(item);
      }
      return result;
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/mapValue.js
var require_mapValue = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/mapValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.mapValue = mapValue;
    function mapValue(map3, fn2) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const key of Object.keys(map3)) {
        result[key] = fn2(map3[key], key);
      }
      return result;
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/naturalCompare.js
var require_naturalCompare = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/naturalCompare.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.naturalCompare = naturalCompare;
    function naturalCompare(aStr, bStr) {
      let aIndex = 0;
      let bIndex = 0;
      while (aIndex < aStr.length && bIndex < bStr.length) {
        let aChar = aStr.charCodeAt(aIndex);
        let bChar = bStr.charCodeAt(bIndex);
        if (isDigit(aChar) && isDigit(bChar)) {
          let aNum = 0;
          do {
            ++aIndex;
            aNum = aNum * 10 + aChar - DIGIT_0;
            aChar = aStr.charCodeAt(aIndex);
          } while (isDigit(aChar) && aNum > 0);
          let bNum = 0;
          do {
            ++bIndex;
            bNum = bNum * 10 + bChar - DIGIT_0;
            bChar = bStr.charCodeAt(bIndex);
          } while (isDigit(bChar) && bNum > 0);
          if (aNum < bNum) {
            return -1;
          }
          if (aNum > bNum) {
            return 1;
          }
        } else {
          if (aChar < bChar) {
            return -1;
          }
          if (aChar > bChar) {
            return 1;
          }
          ++aIndex;
          ++bIndex;
        }
      }
      return aStr.length - bStr.length;
    }
    var DIGIT_0 = 48;
    var DIGIT_9 = 57;
    function isDigit(code) {
      return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/suggestionList.js
var require_suggestionList = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/suggestionList.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.suggestionList = suggestionList;
    var _naturalCompare = require_naturalCompare();
    function suggestionList(input, options2) {
      const optionsByDistance = /* @__PURE__ */ Object.create(null);
      const lexicalDistance = new LexicalDistance(input);
      const threshold = Math.floor(input.length * 0.4) + 1;
      for (const option of options2) {
        const distance = lexicalDistance.measure(option, threshold);
        if (distance !== void 0) {
          optionsByDistance[option] = distance;
        }
      }
      return Object.keys(optionsByDistance).sort((a, b) => {
        const distanceDiff = optionsByDistance[a] - optionsByDistance[b];
        return distanceDiff !== 0 ? distanceDiff : (0, _naturalCompare.naturalCompare)(a, b);
      });
    }
    var LexicalDistance = class {
      constructor(input) {
        this._input = input;
        this._inputLowerCase = input.toLowerCase();
        this._inputArray = stringToArray(this._inputLowerCase);
        this._rows = [
          new Array(input.length + 1).fill(0),
          new Array(input.length + 1).fill(0),
          new Array(input.length + 1).fill(0)
        ];
      }
      measure(option, threshold) {
        if (this._input === option) {
          return 0;
        }
        const optionLowerCase = option.toLowerCase();
        if (this._inputLowerCase === optionLowerCase) {
          return 1;
        }
        let a = stringToArray(optionLowerCase);
        let b = this._inputArray;
        if (a.length < b.length) {
          const tmp = a;
          a = b;
          b = tmp;
        }
        const aLength = a.length;
        const bLength = b.length;
        if (aLength - bLength > threshold) {
          return void 0;
        }
        const rows = this._rows;
        for (let j2 = 0; j2 <= bLength; j2++) {
          rows[0][j2] = j2;
        }
        for (let i = 1; i <= aLength; i++) {
          const upRow = rows[(i - 1) % 3];
          const currentRow = rows[i % 3];
          let smallestCell = currentRow[0] = i;
          for (let j2 = 1; j2 <= bLength; j2++) {
            const cost = a[i - 1] === b[j2 - 1] ? 0 : 1;
            let currentCell = Math.min(upRow[j2] + 1, currentRow[j2 - 1] + 1, upRow[j2 - 1] + cost);
            if (i > 1 && j2 > 1 && a[i - 1] === b[j2 - 2] && a[i - 2] === b[j2 - 1]) {
              const doubleDiagonalCell = rows[(i - 2) % 3][j2 - 2];
              currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
            }
            if (currentCell < smallestCell) {
              smallestCell = currentCell;
            }
            currentRow[j2] = currentCell;
          }
          if (smallestCell > threshold) {
            return void 0;
          }
        }
        const distance = rows[aLength % 3][bLength];
        return distance <= threshold ? distance : void 0;
      }
    };
    function stringToArray(str) {
      const strLength = str.length;
      const array = new Array(strLength);
      for (let i = 0; i < strLength; ++i) {
        array[i] = str.charCodeAt(i);
      }
      return array;
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/toObjMap.js
var require_toObjMap = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/toObjMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.toObjMap = toObjMap;
    function toObjMap(obj) {
      if (obj == null) {
        return /* @__PURE__ */ Object.create(null);
      }
      if (Object.getPrototypeOf(obj) === null) {
        return obj;
      }
      const map3 = /* @__PURE__ */ Object.create(null);
      for (const [key, value] of Object.entries(obj)) {
        map3[key] = value;
      }
      return map3;
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/language/printString.js
var require_printString = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/language/printString.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.printString = printString;
    function printString(str) {
      return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
    }
    var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
    function escapedReplacer(str) {
      return escapeSequences[str.charCodeAt(0)];
    }
    var escapeSequences = [
      "\\u0000",
      "\\u0001",
      "\\u0002",
      "\\u0003",
      "\\u0004",
      "\\u0005",
      "\\u0006",
      "\\u0007",
      "\\b",
      "\\t",
      "\\n",
      "\\u000B",
      "\\f",
      "\\r",
      "\\u000E",
      "\\u000F",
      "\\u0010",
      "\\u0011",
      "\\u0012",
      "\\u0013",
      "\\u0014",
      "\\u0015",
      "\\u0016",
      "\\u0017",
      "\\u0018",
      "\\u0019",
      "\\u001A",
      "\\u001B",
      "\\u001C",
      "\\u001D",
      "\\u001E",
      "\\u001F",
      "",
      "",
      '\\"',
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\\\\",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\\u007F",
      "\\u0080",
      "\\u0081",
      "\\u0082",
      "\\u0083",
      "\\u0084",
      "\\u0085",
      "\\u0086",
      "\\u0087",
      "\\u0088",
      "\\u0089",
      "\\u008A",
      "\\u008B",
      "\\u008C",
      "\\u008D",
      "\\u008E",
      "\\u008F",
      "\\u0090",
      "\\u0091",
      "\\u0092",
      "\\u0093",
      "\\u0094",
      "\\u0095",
      "\\u0096",
      "\\u0097",
      "\\u0098",
      "\\u0099",
      "\\u009A",
      "\\u009B",
      "\\u009C",
      "\\u009D",
      "\\u009E",
      "\\u009F"
    ];
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/language/visitor.js
var require_visitor = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/language/visitor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BREAK = void 0;
    exports2.getEnterLeaveForKind = getEnterLeaveForKind;
    exports2.getVisitFn = getVisitFn;
    exports2.visit = visit3;
    exports2.visitInParallel = visitInParallel;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _ast = require_ast();
    var _kinds = require_kinds();
    var BREAK2 = Object.freeze({});
    exports2.BREAK = BREAK2;
    function visit3(root, visitor, visitorKeys = _ast.QueryDocumentKeys) {
      const enterLeaveMap = /* @__PURE__ */ new Map();
      for (const kind of Object.values(_kinds.Kind)) {
        enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
      }
      let stack = void 0;
      let inArray = Array.isArray(root);
      let keys2 = [root];
      let index = -1;
      let edits = [];
      let node = root;
      let key = void 0;
      let parent = void 0;
      const path = [];
      const ancestors = [];
      do {
        index++;
        const isLeaving = index === keys2.length;
        const isEdited = isLeaving && edits.length !== 0;
        if (isLeaving) {
          key = ancestors.length === 0 ? void 0 : path[path.length - 1];
          node = parent;
          parent = ancestors.pop();
          if (isEdited) {
            if (inArray) {
              node = node.slice();
              let editOffset = 0;
              for (const [editKey, editValue] of edits) {
                const arrayKey = editKey - editOffset;
                if (editValue === null) {
                  node.splice(arrayKey, 1);
                  editOffset++;
                } else {
                  node[arrayKey] = editValue;
                }
              }
            } else {
              node = Object.defineProperties({}, Object.getOwnPropertyDescriptors(node));
              for (const [editKey, editValue] of edits) {
                node[editKey] = editValue;
              }
            }
          }
          index = stack.index;
          keys2 = stack.keys;
          edits = stack.edits;
          inArray = stack.inArray;
          stack = stack.prev;
        } else if (parent) {
          key = inArray ? index : keys2[index];
          node = parent[key];
          if (node === null || node === void 0) {
            continue;
          }
          path.push(key);
        }
        let result;
        if (!Array.isArray(node)) {
          var _enterLeaveMap$get, _enterLeaveMap$get2;
          (0, _ast.isNode)(node) || (0, _devAssert.devAssert)(false, `Invalid AST Node: ${(0, _inspect.inspect)(node)}.`);
          const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
          result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
          if (result === BREAK2) {
            break;
          }
          if (result === false) {
            if (!isLeaving) {
              path.pop();
              continue;
            }
          } else if (result !== void 0) {
            edits.push([key, result]);
            if (!isLeaving) {
              if ((0, _ast.isNode)(result)) {
                node = result;
              } else {
                path.pop();
                continue;
              }
            }
          }
        }
        if (result === void 0 && isEdited) {
          edits.push([key, node]);
        }
        if (isLeaving) {
          path.pop();
        } else {
          var _node$kind;
          stack = {
            inArray,
            index,
            keys: keys2,
            edits,
            prev: stack
          };
          inArray = Array.isArray(node);
          keys2 = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
          index = -1;
          edits = [];
          if (parent) {
            ancestors.push(parent);
          }
          parent = node;
        }
      } while (stack !== void 0);
      if (edits.length !== 0) {
        return edits[edits.length - 1][1];
      }
      return root;
    }
    function visitInParallel(visitors) {
      const skipping = new Array(visitors.length).fill(null);
      const mergedVisitor = /* @__PURE__ */ Object.create(null);
      for (const kind of Object.values(_kinds.Kind)) {
        let hasVisitor = false;
        const enterList = new Array(visitors.length).fill(void 0);
        const leaveList = new Array(visitors.length).fill(void 0);
        for (let i = 0; i < visitors.length; ++i) {
          const { enter, leave } = getEnterLeaveForKind(visitors[i], kind);
          hasVisitor || (hasVisitor = enter != null || leave != null);
          enterList[i] = enter;
          leaveList[i] = leave;
        }
        if (!hasVisitor) {
          continue;
        }
        const mergedEnterLeave = {
          enter(...args) {
            const node = args[0];
            for (let i = 0; i < visitors.length; i++) {
              if (skipping[i] === null) {
                var _enterList$i;
                const result = (_enterList$i = enterList[i]) === null || _enterList$i === void 0 ? void 0 : _enterList$i.apply(visitors[i], args);
                if (result === false) {
                  skipping[i] = node;
                } else if (result === BREAK2) {
                  skipping[i] = BREAK2;
                } else if (result !== void 0) {
                  return result;
                }
              }
            }
          },
          leave(...args) {
            const node = args[0];
            for (let i = 0; i < visitors.length; i++) {
              if (skipping[i] === null) {
                var _leaveList$i;
                const result = (_leaveList$i = leaveList[i]) === null || _leaveList$i === void 0 ? void 0 : _leaveList$i.apply(visitors[i], args);
                if (result === BREAK2) {
                  skipping[i] = BREAK2;
                } else if (result !== void 0 && result !== false) {
                  return result;
                }
              } else if (skipping[i] === node) {
                skipping[i] = null;
              }
            }
          }
        };
        mergedVisitor[kind] = mergedEnterLeave;
      }
      return mergedVisitor;
    }
    function getEnterLeaveForKind(visitor, kind) {
      const kindVisitor = visitor[kind];
      if (typeof kindVisitor === "object") {
        return kindVisitor;
      } else if (typeof kindVisitor === "function") {
        return {
          enter: kindVisitor,
          leave: void 0
        };
      }
      return {
        enter: visitor.enter,
        leave: visitor.leave
      };
    }
    function getVisitFn(visitor, kind, isLeaving) {
      const { enter, leave } = getEnterLeaveForKind(visitor, kind);
      return isLeaving ? leave : enter;
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/language/printer.js
var require_printer = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/language/printer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.print = print5;
    var _blockString = require_blockString();
    var _printString = require_printString();
    var _visitor = require_visitor();
    function print5(ast) {
      return (0, _visitor.visit)(ast, printDocASTReducer2);
    }
    var MAX_LINE_LENGTH2 = 80;
    var printDocASTReducer2 = {
      Name: {
        leave: (node) => node.value
      },
      Variable: {
        leave: (node) => "$" + node.name
      },
      Document: {
        leave: (node) => join3(node.definitions, "\n\n")
      },
      OperationDefinition: {
        leave(node) {
          const varDefs = wrap2("(", join3(node.variableDefinitions, ", "), ")");
          const prefix = join3([
            node.operation,
            join3([node.name, varDefs]),
            join3(node.directives, " ")
          ], " ");
          return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
        }
      },
      VariableDefinition: {
        leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap2(" = ", defaultValue) + wrap2(" ", join3(directives, " "))
      },
      SelectionSet: {
        leave: ({ selections }) => block2(selections)
      },
      Field: {
        leave({ alias, name, arguments: args, directives, selectionSet }) {
          const prefix = wrap2("", alias, ": ") + name;
          let argsLine = prefix + wrap2("(", join3(args, ", "), ")");
          if (argsLine.length > MAX_LINE_LENGTH2) {
            argsLine = prefix + wrap2("(\n", indent2(join3(args, "\n")), "\n)");
          }
          return join3([argsLine, join3(directives, " "), selectionSet], " ");
        }
      },
      Argument: {
        leave: ({ name, value }) => name + ": " + value
      },
      FragmentSpread: {
        leave: ({ name, directives }) => "..." + name + wrap2(" ", join3(directives, " "))
      },
      InlineFragment: {
        leave: ({ typeCondition, directives, selectionSet }) => join3([
          "...",
          wrap2("on ", typeCondition),
          join3(directives, " "),
          selectionSet
        ], " ")
      },
      FragmentDefinition: {
        leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => `fragment ${name}${wrap2("(", join3(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap2("", join3(directives, " "), " ")}` + selectionSet
      },
      IntValue: {
        leave: ({ value }) => value
      },
      FloatValue: {
        leave: ({ value }) => value
      },
      StringValue: {
        leave: ({ value, block: isBlockString }) => isBlockString ? (0, _blockString.printBlockString)(value) : (0, _printString.printString)(value)
      },
      BooleanValue: {
        leave: ({ value }) => value ? "true" : "false"
      },
      NullValue: {
        leave: () => "null"
      },
      EnumValue: {
        leave: ({ value }) => value
      },
      ListValue: {
        leave: ({ values }) => "[" + join3(values, ", ") + "]"
      },
      ObjectValue: {
        leave: ({ fields }) => "{" + join3(fields, ", ") + "}"
      },
      ObjectField: {
        leave: ({ name, value }) => name + ": " + value
      },
      Directive: {
        leave: ({ name, arguments: args }) => "@" + name + wrap2("(", join3(args, ", "), ")")
      },
      NamedType: {
        leave: ({ name }) => name
      },
      ListType: {
        leave: ({ type }) => "[" + type + "]"
      },
      NonNullType: {
        leave: ({ type }) => type + "!"
      },
      SchemaDefinition: {
        leave: ({ description, directives, operationTypes }) => wrap2("", description, "\n") + join3(["schema", join3(directives, " "), block2(operationTypes)], " ")
      },
      OperationTypeDefinition: {
        leave: ({ operation, type }) => operation + ": " + type
      },
      ScalarTypeDefinition: {
        leave: ({ description, name, directives }) => wrap2("", description, "\n") + join3(["scalar", name, join3(directives, " ")], " ")
      },
      ObjectTypeDefinition: {
        leave: ({ description, name, interfaces, directives, fields }) => wrap2("", description, "\n") + join3([
          "type",
          name,
          wrap2("implements ", join3(interfaces, " & ")),
          join3(directives, " "),
          block2(fields)
        ], " ")
      },
      FieldDefinition: {
        leave: ({ description, name, arguments: args, type, directives }) => wrap2("", description, "\n") + name + (hasMultilineItems2(args) ? wrap2("(\n", indent2(join3(args, "\n")), "\n)") : wrap2("(", join3(args, ", "), ")")) + ": " + type + wrap2(" ", join3(directives, " "))
      },
      InputValueDefinition: {
        leave: ({ description, name, type, defaultValue, directives }) => wrap2("", description, "\n") + join3([name + ": " + type, wrap2("= ", defaultValue), join3(directives, " ")], " ")
      },
      InterfaceTypeDefinition: {
        leave: ({ description, name, interfaces, directives, fields }) => wrap2("", description, "\n") + join3([
          "interface",
          name,
          wrap2("implements ", join3(interfaces, " & ")),
          join3(directives, " "),
          block2(fields)
        ], " ")
      },
      UnionTypeDefinition: {
        leave: ({ description, name, directives, types }) => wrap2("", description, "\n") + join3(["union", name, join3(directives, " "), wrap2("= ", join3(types, " | "))], " ")
      },
      EnumTypeDefinition: {
        leave: ({ description, name, directives, values }) => wrap2("", description, "\n") + join3(["enum", name, join3(directives, " "), block2(values)], " ")
      },
      EnumValueDefinition: {
        leave: ({ description, name, directives }) => wrap2("", description, "\n") + join3([name, join3(directives, " ")], " ")
      },
      InputObjectTypeDefinition: {
        leave: ({ description, name, directives, fields }) => wrap2("", description, "\n") + join3(["input", name, join3(directives, " "), block2(fields)], " ")
      },
      DirectiveDefinition: {
        leave: ({ description, name, arguments: args, repeatable, locations }) => wrap2("", description, "\n") + "directive @" + name + (hasMultilineItems2(args) ? wrap2("(\n", indent2(join3(args, "\n")), "\n)") : wrap2("(", join3(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join3(locations, " | ")
      },
      SchemaExtension: {
        leave: ({ directives, operationTypes }) => join3(["extend schema", join3(directives, " "), block2(operationTypes)], " ")
      },
      ScalarTypeExtension: {
        leave: ({ name, directives }) => join3(["extend scalar", name, join3(directives, " ")], " ")
      },
      ObjectTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join3([
          "extend type",
          name,
          wrap2("implements ", join3(interfaces, " & ")),
          join3(directives, " "),
          block2(fields)
        ], " ")
      },
      InterfaceTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join3([
          "extend interface",
          name,
          wrap2("implements ", join3(interfaces, " & ")),
          join3(directives, " "),
          block2(fields)
        ], " ")
      },
      UnionTypeExtension: {
        leave: ({ name, directives, types }) => join3([
          "extend union",
          name,
          join3(directives, " "),
          wrap2("= ", join3(types, " | "))
        ], " ")
      },
      EnumTypeExtension: {
        leave: ({ name, directives, values }) => join3(["extend enum", name, join3(directives, " "), block2(values)], " ")
      },
      InputObjectTypeExtension: {
        leave: ({ name, directives, fields }) => join3(["extend input", name, join3(directives, " "), block2(fields)], " ")
      }
    };
    function join3(maybeArray, separator = "") {
      var _maybeArray$filter$jo;
      return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
    }
    function block2(array) {
      return wrap2("{\n", indent2(join3(array, "\n")), "\n}");
    }
    function wrap2(start, maybeString, end = "") {
      return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
    }
    function indent2(str) {
      return wrap2("  ", str.replace(/\n/g, "\n  "));
    }
    function hasMultilineItems2(maybeArray) {
      var _maybeArray$some;
      return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/valueFromASTUntyped.js
var require_valueFromASTUntyped = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/valueFromASTUntyped.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.valueFromASTUntyped = valueFromASTUntyped;
    var _keyValMap = require_keyValMap();
    var _kinds = require_kinds();
    function valueFromASTUntyped(valueNode, variables) {
      switch (valueNode.kind) {
        case _kinds.Kind.NULL:
          return null;
        case _kinds.Kind.INT:
          return parseInt(valueNode.value, 10);
        case _kinds.Kind.FLOAT:
          return parseFloat(valueNode.value);
        case _kinds.Kind.STRING:
        case _kinds.Kind.ENUM:
        case _kinds.Kind.BOOLEAN:
          return valueNode.value;
        case _kinds.Kind.LIST:
          return valueNode.values.map((node) => valueFromASTUntyped(node, variables));
        case _kinds.Kind.OBJECT:
          return (0, _keyValMap.keyValMap)(valueNode.fields, (field) => field.name.value, (field) => valueFromASTUntyped(field.value, variables));
        case _kinds.Kind.VARIABLE:
          return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
      }
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/type/assertName.js
var require_assertName = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/type/assertName.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assertEnumValueName = assertEnumValueName;
    exports2.assertName = assertName;
    var _devAssert = require_devAssert();
    var _GraphQLError = require_GraphQLError();
    var _characterClasses = require_characterClasses();
    function assertName(name) {
      name != null || (0, _devAssert.devAssert)(false, "Must provide name.");
      typeof name === "string" || (0, _devAssert.devAssert)(false, "Expected name to be a string.");
      if (name.length === 0) {
        throw new _GraphQLError.GraphQLError("Expected name to be a non-empty string.");
      }
      for (let i = 1; i < name.length; ++i) {
        if (!(0, _characterClasses.isNameContinue)(name.charCodeAt(i))) {
          throw new _GraphQLError.GraphQLError(`Names must only contain [_a-zA-Z0-9] but "${name}" does not.`);
        }
      }
      if (!(0, _characterClasses.isNameStart)(name.charCodeAt(0))) {
        throw new _GraphQLError.GraphQLError(`Names must start with [_a-zA-Z] but "${name}" does not.`);
      }
      return name;
    }
    function assertEnumValueName(name) {
      if (name === "true" || name === "false" || name === "null") {
        throw new _GraphQLError.GraphQLError(`Enum values cannot be named: ${name}`);
      }
      return assertName(name);
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/type/definition.js
var require_definition = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/type/definition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.GraphQLUnionType = exports2.GraphQLScalarType = exports2.GraphQLObjectType = exports2.GraphQLNonNull = exports2.GraphQLList = exports2.GraphQLInterfaceType = exports2.GraphQLInputObjectType = exports2.GraphQLEnumType = void 0;
    exports2.argsToArgsConfig = argsToArgsConfig;
    exports2.assertAbstractType = assertAbstractType;
    exports2.assertCompositeType = assertCompositeType;
    exports2.assertEnumType = assertEnumType;
    exports2.assertInputObjectType = assertInputObjectType;
    exports2.assertInputType = assertInputType;
    exports2.assertInterfaceType = assertInterfaceType;
    exports2.assertLeafType = assertLeafType;
    exports2.assertListType = assertListType;
    exports2.assertNamedType = assertNamedType;
    exports2.assertNonNullType = assertNonNullType;
    exports2.assertNullableType = assertNullableType;
    exports2.assertObjectType = assertObjectType;
    exports2.assertOutputType = assertOutputType;
    exports2.assertScalarType = assertScalarType;
    exports2.assertType = assertType;
    exports2.assertUnionType = assertUnionType;
    exports2.assertWrappingType = assertWrappingType;
    exports2.defineArguments = defineArguments;
    exports2.getNamedType = getNamedType5;
    exports2.getNullableType = getNullableType2;
    exports2.isAbstractType = isAbstractType2;
    exports2.isCompositeType = isCompositeType2;
    exports2.isEnumType = isEnumType4;
    exports2.isInputObjectType = isInputObjectType3;
    exports2.isInputType = isInputType;
    exports2.isInterfaceType = isInterfaceType4;
    exports2.isLeafType = isLeafType2;
    exports2.isListType = isListType2;
    exports2.isNamedType = isNamedType2;
    exports2.isNonNullType = isNonNullType2;
    exports2.isNullableType = isNullableType;
    exports2.isObjectType = isObjectType6;
    exports2.isOutputType = isOutputType;
    exports2.isRequiredArgument = isRequiredArgument;
    exports2.isRequiredInputField = isRequiredInputField;
    exports2.isScalarType = isScalarType4;
    exports2.isType = isType;
    exports2.isUnionType = isUnionType4;
    exports2.isWrappingType = isWrappingType;
    exports2.resolveObjMapThunk = resolveObjMapThunk;
    exports2.resolveReadonlyArrayThunk = resolveReadonlyArrayThunk;
    var _devAssert = require_devAssert();
    var _didYouMean = require_didYouMean();
    var _identityFunc = require_identityFunc();
    var _inspect = require_inspect();
    var _instanceOf = require_instanceOf();
    var _isObjectLike = require_isObjectLike();
    var _keyMap = require_keyMap();
    var _keyValMap = require_keyValMap();
    var _mapValue = require_mapValue();
    var _suggestionList = require_suggestionList();
    var _toObjMap = require_toObjMap();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _valueFromASTUntyped = require_valueFromASTUntyped();
    var _assertName = require_assertName();
    function isType(type) {
      return isScalarType4(type) || isObjectType6(type) || isInterfaceType4(type) || isUnionType4(type) || isEnumType4(type) || isInputObjectType3(type) || isListType2(type) || isNonNullType2(type);
    }
    function assertType(type) {
      if (!isType(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL type.`);
      }
      return type;
    }
    function isScalarType4(type) {
      return (0, _instanceOf.instanceOf)(type, GraphQLScalarType4);
    }
    function assertScalarType(type) {
      if (!isScalarType4(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Scalar type.`);
      }
      return type;
    }
    function isObjectType6(type) {
      return (0, _instanceOf.instanceOf)(type, GraphQLObjectType4);
    }
    function assertObjectType(type) {
      if (!isObjectType6(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Object type.`);
      }
      return type;
    }
    function isInterfaceType4(type) {
      return (0, _instanceOf.instanceOf)(type, GraphQLInterfaceType4);
    }
    function assertInterfaceType(type) {
      if (!isInterfaceType4(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Interface type.`);
      }
      return type;
    }
    function isUnionType4(type) {
      return (0, _instanceOf.instanceOf)(type, GraphQLUnionType4);
    }
    function assertUnionType(type) {
      if (!isUnionType4(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Union type.`);
      }
      return type;
    }
    function isEnumType4(type) {
      return (0, _instanceOf.instanceOf)(type, GraphQLEnumType4);
    }
    function assertEnumType(type) {
      if (!isEnumType4(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Enum type.`);
      }
      return type;
    }
    function isInputObjectType3(type) {
      return (0, _instanceOf.instanceOf)(type, GraphQLInputObjectType3);
    }
    function assertInputObjectType(type) {
      if (!isInputObjectType3(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Input Object type.`);
      }
      return type;
    }
    function isListType2(type) {
      return (0, _instanceOf.instanceOf)(type, GraphQLList3);
    }
    function assertListType(type) {
      if (!isListType2(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL List type.`);
      }
      return type;
    }
    function isNonNullType2(type) {
      return (0, _instanceOf.instanceOf)(type, GraphQLNonNull3);
    }
    function assertNonNullType(type) {
      if (!isNonNullType2(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Non-Null type.`);
      }
      return type;
    }
    function isInputType(type) {
      return isScalarType4(type) || isEnumType4(type) || isInputObjectType3(type) || isWrappingType(type) && isInputType(type.ofType);
    }
    function assertInputType(type) {
      if (!isInputType(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL input type.`);
      }
      return type;
    }
    function isOutputType(type) {
      return isScalarType4(type) || isObjectType6(type) || isInterfaceType4(type) || isUnionType4(type) || isEnumType4(type) || isWrappingType(type) && isOutputType(type.ofType);
    }
    function assertOutputType(type) {
      if (!isOutputType(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL output type.`);
      }
      return type;
    }
    function isLeafType2(type) {
      return isScalarType4(type) || isEnumType4(type);
    }
    function assertLeafType(type) {
      if (!isLeafType2(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL leaf type.`);
      }
      return type;
    }
    function isCompositeType2(type) {
      return isObjectType6(type) || isInterfaceType4(type) || isUnionType4(type);
    }
    function assertCompositeType(type) {
      if (!isCompositeType2(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL composite type.`);
      }
      return type;
    }
    function isAbstractType2(type) {
      return isInterfaceType4(type) || isUnionType4(type);
    }
    function assertAbstractType(type) {
      if (!isAbstractType2(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL abstract type.`);
      }
      return type;
    }
    var GraphQLList3 = class {
      constructor(ofType) {
        isType(ofType) || (0, _devAssert.devAssert)(false, `Expected ${(0, _inspect.inspect)(ofType)} to be a GraphQL type.`);
        this.ofType = ofType;
      }
      get [Symbol.toStringTag]() {
        return "GraphQLList";
      }
      toString() {
        return "[" + String(this.ofType) + "]";
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLList = GraphQLList3;
    var GraphQLNonNull3 = class {
      constructor(ofType) {
        isNullableType(ofType) || (0, _devAssert.devAssert)(false, `Expected ${(0, _inspect.inspect)(ofType)} to be a GraphQL nullable type.`);
        this.ofType = ofType;
      }
      get [Symbol.toStringTag]() {
        return "GraphQLNonNull";
      }
      toString() {
        return String(this.ofType) + "!";
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLNonNull = GraphQLNonNull3;
    function isWrappingType(type) {
      return isListType2(type) || isNonNullType2(type);
    }
    function assertWrappingType(type) {
      if (!isWrappingType(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL wrapping type.`);
      }
      return type;
    }
    function isNullableType(type) {
      return isType(type) && !isNonNullType2(type);
    }
    function assertNullableType(type) {
      if (!isNullableType(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL nullable type.`);
      }
      return type;
    }
    function getNullableType2(type) {
      if (type) {
        return isNonNullType2(type) ? type.ofType : type;
      }
    }
    function isNamedType2(type) {
      return isScalarType4(type) || isObjectType6(type) || isInterfaceType4(type) || isUnionType4(type) || isEnumType4(type) || isInputObjectType3(type);
    }
    function assertNamedType(type) {
      if (!isNamedType2(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL named type.`);
      }
      return type;
    }
    function getNamedType5(type) {
      if (type) {
        let unwrappedType = type;
        while (isWrappingType(unwrappedType)) {
          unwrappedType = unwrappedType.ofType;
        }
        return unwrappedType;
      }
    }
    function resolveReadonlyArrayThunk(thunk) {
      return typeof thunk === "function" ? thunk() : thunk;
    }
    function resolveObjMapThunk(thunk) {
      return typeof thunk === "function" ? thunk() : thunk;
    }
    var GraphQLScalarType4 = class {
      constructor(config2) {
        var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
        const parseValue = (_config$parseValue = config2.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : _identityFunc.identityFunc;
        this.name = (0, _assertName.assertName)(config2.name);
        this.description = config2.description;
        this.specifiedByURL = config2.specifiedByURL;
        this.serialize = (_config$serialize = config2.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : _identityFunc.identityFunc;
        this.parseValue = parseValue;
        this.parseLiteral = (_config$parseLiteral = config2.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue((0, _valueFromASTUntyped.valueFromASTUntyped)(node, variables));
        this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN = config2.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
        config2.specifiedByURL == null || typeof config2.specifiedByURL === "string" || (0, _devAssert.devAssert)(false, `${this.name} must provide "specifiedByURL" as a string, but got: ${(0, _inspect.inspect)(config2.specifiedByURL)}.`);
        config2.serialize == null || typeof config2.serialize === "function" || (0, _devAssert.devAssert)(false, `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`);
        if (config2.parseLiteral) {
          typeof config2.parseValue === "function" && typeof config2.parseLiteral === "function" || (0, _devAssert.devAssert)(false, `${this.name} must provide both "parseValue" and "parseLiteral" functions.`);
        }
      }
      get [Symbol.toStringTag]() {
        return "GraphQLScalarType";
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          specifiedByURL: this.specifiedByURL,
          serialize: this.serialize,
          parseValue: this.parseValue,
          parseLiteral: this.parseLiteral,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLScalarType = GraphQLScalarType4;
    var GraphQLObjectType4 = class {
      constructor(config2) {
        var _config$extensionASTN2;
        this.name = (0, _assertName.assertName)(config2.name);
        this.description = config2.description;
        this.isTypeOf = config2.isTypeOf;
        this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN2 = config2.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
        this._fields = () => defineFieldMap(config2);
        this._interfaces = () => defineInterfaces(config2);
        config2.isTypeOf == null || typeof config2.isTypeOf === "function" || (0, _devAssert.devAssert)(false, `${this.name} must provide "isTypeOf" as a function, but got: ${(0, _inspect.inspect)(config2.isTypeOf)}.`);
      }
      get [Symbol.toStringTag]() {
        return "GraphQLObjectType";
      }
      getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      }
      getInterfaces() {
        if (typeof this._interfaces === "function") {
          this._interfaces = this._interfaces();
        }
        return this._interfaces;
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          interfaces: this.getInterfaces(),
          fields: fieldsToFieldsConfig(this.getFields()),
          isTypeOf: this.isTypeOf,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLObjectType = GraphQLObjectType4;
    function defineInterfaces(config2) {
      var _config$interfaces;
      const interfaces = resolveReadonlyArrayThunk((_config$interfaces = config2.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []);
      Array.isArray(interfaces) || (0, _devAssert.devAssert)(false, `${config2.name} interfaces must be an Array or a function which returns an Array.`);
      return interfaces;
    }
    function defineFieldMap(config2) {
      const fieldMap = resolveObjMapThunk(config2.fields);
      isPlainObj(fieldMap) || (0, _devAssert.devAssert)(false, `${config2.name} fields must be an object with field names as keys or a function which returns such an object.`);
      return (0, _mapValue.mapValue)(fieldMap, (fieldConfig, fieldName) => {
        var _fieldConfig$args;
        isPlainObj(fieldConfig) || (0, _devAssert.devAssert)(false, `${config2.name}.${fieldName} field config must be an object.`);
        fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || (0, _devAssert.devAssert)(false, `${config2.name}.${fieldName} field resolver must be a function if provided, but got: ${(0, _inspect.inspect)(fieldConfig.resolve)}.`);
        const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
        isPlainObj(argsConfig) || (0, _devAssert.devAssert)(false, `${config2.name}.${fieldName} args must be an object with argument names as keys.`);
        return {
          name: (0, _assertName.assertName)(fieldName),
          description: fieldConfig.description,
          type: fieldConfig.type,
          args: defineArguments(argsConfig),
          resolve: fieldConfig.resolve,
          subscribe: fieldConfig.subscribe,
          deprecationReason: fieldConfig.deprecationReason,
          extensions: (0, _toObjMap.toObjMap)(fieldConfig.extensions),
          astNode: fieldConfig.astNode
        };
      });
    }
    function defineArguments(config2) {
      return Object.entries(config2).map(([argName, argConfig]) => ({
        name: (0, _assertName.assertName)(argName),
        description: argConfig.description,
        type: argConfig.type,
        defaultValue: argConfig.defaultValue,
        deprecationReason: argConfig.deprecationReason,
        extensions: (0, _toObjMap.toObjMap)(argConfig.extensions),
        astNode: argConfig.astNode
      }));
    }
    function isPlainObj(obj) {
      return (0, _isObjectLike.isObjectLike)(obj) && !Array.isArray(obj);
    }
    function fieldsToFieldsConfig(fields) {
      return (0, _mapValue.mapValue)(fields, (field) => ({
        description: field.description,
        type: field.type,
        args: argsToArgsConfig(field.args),
        resolve: field.resolve,
        subscribe: field.subscribe,
        deprecationReason: field.deprecationReason,
        extensions: field.extensions,
        astNode: field.astNode
      }));
    }
    function argsToArgsConfig(args) {
      return (0, _keyValMap.keyValMap)(args, (arg) => arg.name, (arg) => ({
        description: arg.description,
        type: arg.type,
        defaultValue: arg.defaultValue,
        deprecationReason: arg.deprecationReason,
        extensions: arg.extensions,
        astNode: arg.astNode
      }));
    }
    function isRequiredArgument(arg) {
      return isNonNullType2(arg.type) && arg.defaultValue === void 0;
    }
    var GraphQLInterfaceType4 = class {
      constructor(config2) {
        var _config$extensionASTN3;
        this.name = (0, _assertName.assertName)(config2.name);
        this.description = config2.description;
        this.resolveType = config2.resolveType;
        this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN3 = config2.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
        this._fields = defineFieldMap.bind(void 0, config2);
        this._interfaces = defineInterfaces.bind(void 0, config2);
        config2.resolveType == null || typeof config2.resolveType === "function" || (0, _devAssert.devAssert)(false, `${this.name} must provide "resolveType" as a function, but got: ${(0, _inspect.inspect)(config2.resolveType)}.`);
      }
      get [Symbol.toStringTag]() {
        return "GraphQLInterfaceType";
      }
      getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      }
      getInterfaces() {
        if (typeof this._interfaces === "function") {
          this._interfaces = this._interfaces();
        }
        return this._interfaces;
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          interfaces: this.getInterfaces(),
          fields: fieldsToFieldsConfig(this.getFields()),
          resolveType: this.resolveType,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLInterfaceType = GraphQLInterfaceType4;
    var GraphQLUnionType4 = class {
      constructor(config2) {
        var _config$extensionASTN4;
        this.name = (0, _assertName.assertName)(config2.name);
        this.description = config2.description;
        this.resolveType = config2.resolveType;
        this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN4 = config2.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
        this._types = defineTypes.bind(void 0, config2);
        config2.resolveType == null || typeof config2.resolveType === "function" || (0, _devAssert.devAssert)(false, `${this.name} must provide "resolveType" as a function, but got: ${(0, _inspect.inspect)(config2.resolveType)}.`);
      }
      get [Symbol.toStringTag]() {
        return "GraphQLUnionType";
      }
      getTypes() {
        if (typeof this._types === "function") {
          this._types = this._types();
        }
        return this._types;
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          types: this.getTypes(),
          resolveType: this.resolveType,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLUnionType = GraphQLUnionType4;
    function defineTypes(config2) {
      const types = resolveReadonlyArrayThunk(config2.types);
      Array.isArray(types) || (0, _devAssert.devAssert)(false, `Must provide Array of types or a function which returns such an array for Union ${config2.name}.`);
      return types;
    }
    var GraphQLEnumType4 = class {
      constructor(config2) {
        var _config$extensionASTN5;
        this.name = (0, _assertName.assertName)(config2.name);
        this.description = config2.description;
        this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN5 = config2.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
        this._values = defineEnumValues(this.name, config2.values);
        this._valueLookup = new Map(this._values.map((enumValue) => [enumValue.value, enumValue]));
        this._nameLookup = (0, _keyMap.keyMap)(this._values, (value) => value.name);
      }
      get [Symbol.toStringTag]() {
        return "GraphQLEnumType";
      }
      getValues() {
        return this._values;
      }
      getValue(name) {
        return this._nameLookup[name];
      }
      serialize(outputValue) {
        const enumValue = this._valueLookup.get(outputValue);
        if (enumValue === void 0) {
          throw new _GraphQLError.GraphQLError(`Enum "${this.name}" cannot represent value: ${(0, _inspect.inspect)(outputValue)}`);
        }
        return enumValue.name;
      }
      parseValue(inputValue) {
        if (typeof inputValue !== "string") {
          const valueStr = (0, _inspect.inspect)(inputValue);
          throw new _GraphQLError.GraphQLError(`Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr));
        }
        const enumValue = this.getValue(inputValue);
        if (enumValue == null) {
          throw new _GraphQLError.GraphQLError(`Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue));
        }
        return enumValue.value;
      }
      parseLiteral(valueNode, _variables) {
        if (valueNode.kind !== _kinds.Kind.ENUM) {
          const valueStr = (0, _printer.print)(valueNode);
          throw new _GraphQLError.GraphQLError(`Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr), {
            nodes: valueNode
          });
        }
        const enumValue = this.getValue(valueNode.value);
        if (enumValue == null) {
          const valueStr = (0, _printer.print)(valueNode);
          throw new _GraphQLError.GraphQLError(`Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr), {
            nodes: valueNode
          });
        }
        return enumValue.value;
      }
      toConfig() {
        const values = (0, _keyValMap.keyValMap)(this.getValues(), (value) => value.name, (value) => ({
          description: value.description,
          value: value.value,
          deprecationReason: value.deprecationReason,
          extensions: value.extensions,
          astNode: value.astNode
        }));
        return {
          name: this.name,
          description: this.description,
          values,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLEnumType = GraphQLEnumType4;
    function didYouMeanEnumValue(enumType, unknownValueStr) {
      const allNames = enumType.getValues().map((value) => value.name);
      const suggestedValues = (0, _suggestionList.suggestionList)(unknownValueStr, allNames);
      return (0, _didYouMean.didYouMean)("the enum value", suggestedValues);
    }
    function defineEnumValues(typeName, valueMap) {
      isPlainObj(valueMap) || (0, _devAssert.devAssert)(false, `${typeName} values must be an object with value names as keys.`);
      return Object.entries(valueMap).map(([valueName, valueConfig]) => {
        isPlainObj(valueConfig) || (0, _devAssert.devAssert)(false, `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${(0, _inspect.inspect)(valueConfig)}.`);
        return {
          name: (0, _assertName.assertEnumValueName)(valueName),
          description: valueConfig.description,
          value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
          deprecationReason: valueConfig.deprecationReason,
          extensions: (0, _toObjMap.toObjMap)(valueConfig.extensions),
          astNode: valueConfig.astNode
        };
      });
    }
    var GraphQLInputObjectType3 = class {
      constructor(config2) {
        var _config$extensionASTN6;
        this.name = (0, _assertName.assertName)(config2.name);
        this.description = config2.description;
        this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN6 = config2.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
        this._fields = defineInputFieldMap.bind(void 0, config2);
      }
      get [Symbol.toStringTag]() {
        return "GraphQLInputObjectType";
      }
      getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      }
      toConfig() {
        const fields = (0, _mapValue.mapValue)(this.getFields(), (field) => ({
          description: field.description,
          type: field.type,
          defaultValue: field.defaultValue,
          deprecationReason: field.deprecationReason,
          extensions: field.extensions,
          astNode: field.astNode
        }));
        return {
          name: this.name,
          description: this.description,
          fields,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLInputObjectType = GraphQLInputObjectType3;
    function defineInputFieldMap(config2) {
      const fieldMap = resolveObjMapThunk(config2.fields);
      isPlainObj(fieldMap) || (0, _devAssert.devAssert)(false, `${config2.name} fields must be an object with field names as keys or a function which returns such an object.`);
      return (0, _mapValue.mapValue)(fieldMap, (fieldConfig, fieldName) => {
        !("resolve" in fieldConfig) || (0, _devAssert.devAssert)(false, `${config2.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`);
        return {
          name: (0, _assertName.assertName)(fieldName),
          description: fieldConfig.description,
          type: fieldConfig.type,
          defaultValue: fieldConfig.defaultValue,
          deprecationReason: fieldConfig.deprecationReason,
          extensions: (0, _toObjMap.toObjMap)(fieldConfig.extensions),
          astNode: fieldConfig.astNode
        };
      });
    }
    function isRequiredInputField(field) {
      return isNonNullType2(field.type) && field.defaultValue === void 0;
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/typeComparators.js
var require_typeComparators = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/typeComparators.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.doTypesOverlap = doTypesOverlap2;
    exports2.isEqualType = isEqualType;
    exports2.isTypeSubTypeOf = isTypeSubTypeOf;
    var _definition = require_definition();
    function isEqualType(typeA, typeB) {
      if (typeA === typeB) {
        return true;
      }
      if ((0, _definition.isNonNullType)(typeA) && (0, _definition.isNonNullType)(typeB)) {
        return isEqualType(typeA.ofType, typeB.ofType);
      }
      if ((0, _definition.isListType)(typeA) && (0, _definition.isListType)(typeB)) {
        return isEqualType(typeA.ofType, typeB.ofType);
      }
      return false;
    }
    function isTypeSubTypeOf(schema, maybeSubType, superType) {
      if (maybeSubType === superType) {
        return true;
      }
      if ((0, _definition.isNonNullType)(superType)) {
        if ((0, _definition.isNonNullType)(maybeSubType)) {
          return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
        }
        return false;
      }
      if ((0, _definition.isNonNullType)(maybeSubType)) {
        return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
      }
      if ((0, _definition.isListType)(superType)) {
        if ((0, _definition.isListType)(maybeSubType)) {
          return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
        }
        return false;
      }
      if ((0, _definition.isListType)(maybeSubType)) {
        return false;
      }
      return (0, _definition.isAbstractType)(superType) && ((0, _definition.isInterfaceType)(maybeSubType) || (0, _definition.isObjectType)(maybeSubType)) && schema.isSubType(superType, maybeSubType);
    }
    function doTypesOverlap2(schema, typeA, typeB) {
      if (typeA === typeB) {
        return true;
      }
      if ((0, _definition.isAbstractType)(typeA)) {
        if ((0, _definition.isAbstractType)(typeB)) {
          return schema.getPossibleTypes(typeA).some((type) => schema.isSubType(typeB, type));
        }
        return schema.isSubType(typeA, typeB);
      }
      if ((0, _definition.isAbstractType)(typeB)) {
        return schema.isSubType(typeB, typeA);
      }
      return false;
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/type/scalars.js
var require_scalars = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/type/scalars.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.GraphQLString = exports2.GraphQLInt = exports2.GraphQLID = exports2.GraphQLFloat = exports2.GraphQLBoolean = exports2.GRAPHQL_MIN_INT = exports2.GRAPHQL_MAX_INT = void 0;
    exports2.isSpecifiedScalarType = isSpecifiedScalarType4;
    exports2.specifiedScalarTypes = void 0;
    var _inspect = require_inspect();
    var _isObjectLike = require_isObjectLike();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _definition = require_definition();
    var GRAPHQL_MAX_INT = 2147483647;
    exports2.GRAPHQL_MAX_INT = GRAPHQL_MAX_INT;
    var GRAPHQL_MIN_INT = -2147483648;
    exports2.GRAPHQL_MIN_INT = GRAPHQL_MIN_INT;
    var GraphQLInt5 = new _definition.GraphQLScalarType({
      name: "Int",
      description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "boolean") {
          return coercedValue ? 1 : 0;
        }
        let num = coercedValue;
        if (typeof coercedValue === "string" && coercedValue !== "") {
          num = Number(coercedValue);
        }
        if (typeof num !== "number" || !Number.isInteger(num)) {
          throw new _GraphQLError.GraphQLError(`Int cannot represent non-integer value: ${(0, _inspect.inspect)(coercedValue)}`);
        }
        if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
          throw new _GraphQLError.GraphQLError("Int cannot represent non 32-bit signed integer value: " + (0, _inspect.inspect)(coercedValue));
        }
        return num;
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
          throw new _GraphQLError.GraphQLError(`Int cannot represent non-integer value: ${(0, _inspect.inspect)(inputValue)}`);
        }
        if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
          throw new _GraphQLError.GraphQLError(`Int cannot represent non 32-bit signed integer value: ${inputValue}`);
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.INT) {
          throw new _GraphQLError.GraphQLError(`Int cannot represent non-integer value: ${(0, _printer.print)(valueNode)}`, {
            nodes: valueNode
          });
        }
        const num = parseInt(valueNode.value, 10);
        if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
          throw new _GraphQLError.GraphQLError(`Int cannot represent non 32-bit signed integer value: ${valueNode.value}`, {
            nodes: valueNode
          });
        }
        return num;
      }
    });
    exports2.GraphQLInt = GraphQLInt5;
    var GraphQLFloat5 = new _definition.GraphQLScalarType({
      name: "Float",
      description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "boolean") {
          return coercedValue ? 1 : 0;
        }
        let num = coercedValue;
        if (typeof coercedValue === "string" && coercedValue !== "") {
          num = Number(coercedValue);
        }
        if (typeof num !== "number" || !Number.isFinite(num)) {
          throw new _GraphQLError.GraphQLError(`Float cannot represent non numeric value: ${(0, _inspect.inspect)(coercedValue)}`);
        }
        return num;
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
          throw new _GraphQLError.GraphQLError(`Float cannot represent non numeric value: ${(0, _inspect.inspect)(inputValue)}`);
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.FLOAT && valueNode.kind !== _kinds.Kind.INT) {
          throw new _GraphQLError.GraphQLError(`Float cannot represent non numeric value: ${(0, _printer.print)(valueNode)}`, valueNode);
        }
        return parseFloat(valueNode.value);
      }
    });
    exports2.GraphQLFloat = GraphQLFloat5;
    var GraphQLString5 = new _definition.GraphQLScalarType({
      name: "String",
      description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "string") {
          return coercedValue;
        }
        if (typeof coercedValue === "boolean") {
          return coercedValue ? "true" : "false";
        }
        if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
          return coercedValue.toString();
        }
        throw new _GraphQLError.GraphQLError(`String cannot represent value: ${(0, _inspect.inspect)(outputValue)}`);
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "string") {
          throw new _GraphQLError.GraphQLError(`String cannot represent a non string value: ${(0, _inspect.inspect)(inputValue)}`);
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.STRING) {
          throw new _GraphQLError.GraphQLError(`String cannot represent a non string value: ${(0, _printer.print)(valueNode)}`, {
            nodes: valueNode
          });
        }
        return valueNode.value;
      }
    });
    exports2.GraphQLString = GraphQLString5;
    var GraphQLBoolean5 = new _definition.GraphQLScalarType({
      name: "Boolean",
      description: "The `Boolean` scalar type represents `true` or `false`.",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "boolean") {
          return coercedValue;
        }
        if (Number.isFinite(coercedValue)) {
          return coercedValue !== 0;
        }
        throw new _GraphQLError.GraphQLError(`Boolean cannot represent a non boolean value: ${(0, _inspect.inspect)(coercedValue)}`);
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "boolean") {
          throw new _GraphQLError.GraphQLError(`Boolean cannot represent a non boolean value: ${(0, _inspect.inspect)(inputValue)}`);
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.BOOLEAN) {
          throw new _GraphQLError.GraphQLError(`Boolean cannot represent a non boolean value: ${(0, _printer.print)(valueNode)}`, {
            nodes: valueNode
          });
        }
        return valueNode.value;
      }
    });
    exports2.GraphQLBoolean = GraphQLBoolean5;
    var GraphQLID5 = new _definition.GraphQLScalarType({
      name: "ID",
      description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "string") {
          return coercedValue;
        }
        if (Number.isInteger(coercedValue)) {
          return String(coercedValue);
        }
        throw new _GraphQLError.GraphQLError(`ID cannot represent value: ${(0, _inspect.inspect)(outputValue)}`);
      },
      parseValue(inputValue) {
        if (typeof inputValue === "string") {
          return inputValue;
        }
        if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
          return inputValue.toString();
        }
        throw new _GraphQLError.GraphQLError(`ID cannot represent value: ${(0, _inspect.inspect)(inputValue)}`);
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.STRING && valueNode.kind !== _kinds.Kind.INT) {
          throw new _GraphQLError.GraphQLError("ID cannot represent a non-string and non-integer value: " + (0, _printer.print)(valueNode), {
            nodes: valueNode
          });
        }
        return valueNode.value;
      }
    });
    exports2.GraphQLID = GraphQLID5;
    var specifiedScalarTypes = Object.freeze([
      GraphQLString5,
      GraphQLInt5,
      GraphQLFloat5,
      GraphQLBoolean5,
      GraphQLID5
    ]);
    exports2.specifiedScalarTypes = specifiedScalarTypes;
    function isSpecifiedScalarType4(type) {
      return specifiedScalarTypes.some(({ name }) => type.name === name);
    }
    function serializeObject(outputValue) {
      if ((0, _isObjectLike.isObjectLike)(outputValue)) {
        if (typeof outputValue.valueOf === "function") {
          const valueOfResult = outputValue.valueOf();
          if (!(0, _isObjectLike.isObjectLike)(valueOfResult)) {
            return valueOfResult;
          }
        }
        if (typeof outputValue.toJSON === "function") {
          return outputValue.toJSON();
        }
      }
      return outputValue;
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/type/directives.js
var require_directives = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/type/directives.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.GraphQLSpecifiedByDirective = exports2.GraphQLSkipDirective = exports2.GraphQLIncludeDirective = exports2.GraphQLDirective = exports2.GraphQLDeprecatedDirective = exports2.DEFAULT_DEPRECATION_REASON = void 0;
    exports2.assertDirective = assertDirective;
    exports2.isDirective = isDirective2;
    exports2.isSpecifiedDirective = isSpecifiedDirective2;
    exports2.specifiedDirectives = void 0;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _instanceOf = require_instanceOf();
    var _isObjectLike = require_isObjectLike();
    var _toObjMap = require_toObjMap();
    var _directiveLocation = require_directiveLocation();
    var _assertName = require_assertName();
    var _definition = require_definition();
    var _scalars = require_scalars();
    function isDirective2(directive) {
      return (0, _instanceOf.instanceOf)(directive, GraphQLDirective2);
    }
    function assertDirective(directive) {
      if (!isDirective2(directive)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(directive)} to be a GraphQL directive.`);
      }
      return directive;
    }
    var GraphQLDirective2 = class {
      constructor(config2) {
        var _config$isRepeatable, _config$args;
        this.name = (0, _assertName.assertName)(config2.name);
        this.description = config2.description;
        this.locations = config2.locations;
        this.isRepeatable = (_config$isRepeatable = config2.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
        this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
        this.astNode = config2.astNode;
        Array.isArray(config2.locations) || (0, _devAssert.devAssert)(false, `@${config2.name} locations must be an Array.`);
        const args = (_config$args = config2.args) !== null && _config$args !== void 0 ? _config$args : {};
        (0, _isObjectLike.isObjectLike)(args) && !Array.isArray(args) || (0, _devAssert.devAssert)(false, `@${config2.name} args must be an object with argument names as keys.`);
        this.args = (0, _definition.defineArguments)(args);
      }
      get [Symbol.toStringTag]() {
        return "GraphQLDirective";
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          locations: this.locations,
          args: (0, _definition.argsToArgsConfig)(this.args),
          isRepeatable: this.isRepeatable,
          extensions: this.extensions,
          astNode: this.astNode
        };
      }
      toString() {
        return "@" + this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLDirective = GraphQLDirective2;
    var GraphQLIncludeDirective2 = new GraphQLDirective2({
      name: "include",
      description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
      locations: [
        _directiveLocation.DirectiveLocation.FIELD,
        _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
        _directiveLocation.DirectiveLocation.INLINE_FRAGMENT
      ],
      args: {
        if: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          description: "Included when true."
        }
      }
    });
    exports2.GraphQLIncludeDirective = GraphQLIncludeDirective2;
    var GraphQLSkipDirective2 = new GraphQLDirective2({
      name: "skip",
      description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
      locations: [
        _directiveLocation.DirectiveLocation.FIELD,
        _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
        _directiveLocation.DirectiveLocation.INLINE_FRAGMENT
      ],
      args: {
        if: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          description: "Skipped when true."
        }
      }
    });
    exports2.GraphQLSkipDirective = GraphQLSkipDirective2;
    var DEFAULT_DEPRECATION_REASON = "No longer supported";
    exports2.DEFAULT_DEPRECATION_REASON = DEFAULT_DEPRECATION_REASON;
    var GraphQLDeprecatedDirective2 = new GraphQLDirective2({
      name: "deprecated",
      description: "Marks an element of a GraphQL schema as no longer supported.",
      locations: [
        _directiveLocation.DirectiveLocation.FIELD_DEFINITION,
        _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION,
        _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION,
        _directiveLocation.DirectiveLocation.ENUM_VALUE
      ],
      args: {
        reason: {
          type: _scalars.GraphQLString,
          description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
          defaultValue: DEFAULT_DEPRECATION_REASON
        }
      }
    });
    exports2.GraphQLDeprecatedDirective = GraphQLDeprecatedDirective2;
    var GraphQLSpecifiedByDirective = new GraphQLDirective2({
      name: "specifiedBy",
      description: "Exposes a URL that specifies the behavior of this scalar.",
      locations: [_directiveLocation.DirectiveLocation.SCALAR],
      args: {
        url: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          description: "The URL that specifies the behavior of this scalar."
        }
      }
    });
    exports2.GraphQLSpecifiedByDirective = GraphQLSpecifiedByDirective;
    var specifiedDirectives = Object.freeze([
      GraphQLIncludeDirective2,
      GraphQLSkipDirective2,
      GraphQLDeprecatedDirective2,
      GraphQLSpecifiedByDirective
    ]);
    exports2.specifiedDirectives = specifiedDirectives;
    function isSpecifiedDirective2(directive) {
      return specifiedDirectives.some(({ name }) => name === directive.name);
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/isIterableObject.js
var require_isIterableObject = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/isIterableObject.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isIterableObject = isIterableObject;
    function isIterableObject(maybeIterable) {
      return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/astFromValue.js
var require_astFromValue = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/astFromValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.astFromValue = astFromValue2;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _isIterableObject = require_isIterableObject();
    var _isObjectLike = require_isObjectLike();
    var _kinds = require_kinds();
    var _definition = require_definition();
    var _scalars = require_scalars();
    function astFromValue2(value, type) {
      if ((0, _definition.isNonNullType)(type)) {
        const astValue = astFromValue2(value, type.ofType);
        if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === _kinds.Kind.NULL) {
          return null;
        }
        return astValue;
      }
      if (value === null) {
        return {
          kind: _kinds.Kind.NULL
        };
      }
      if (value === void 0) {
        return null;
      }
      if ((0, _definition.isListType)(type)) {
        const itemType = type.ofType;
        if ((0, _isIterableObject.isIterableObject)(value)) {
          const valuesNodes = [];
          for (const item of value) {
            const itemNode = astFromValue2(item, itemType);
            if (itemNode != null) {
              valuesNodes.push(itemNode);
            }
          }
          return {
            kind: _kinds.Kind.LIST,
            values: valuesNodes
          };
        }
        return astFromValue2(value, itemType);
      }
      if ((0, _definition.isInputObjectType)(type)) {
        if (!(0, _isObjectLike.isObjectLike)(value)) {
          return null;
        }
        const fieldNodes = [];
        for (const field of Object.values(type.getFields())) {
          const fieldValue = astFromValue2(value[field.name], field.type);
          if (fieldValue) {
            fieldNodes.push({
              kind: _kinds.Kind.OBJECT_FIELD,
              name: {
                kind: _kinds.Kind.NAME,
                value: field.name
              },
              value: fieldValue
            });
          }
        }
        return {
          kind: _kinds.Kind.OBJECT,
          fields: fieldNodes
        };
      }
      if ((0, _definition.isLeafType)(type)) {
        const serialized = type.serialize(value);
        if (serialized == null) {
          return null;
        }
        if (typeof serialized === "boolean") {
          return {
            kind: _kinds.Kind.BOOLEAN,
            value: serialized
          };
        }
        if (typeof serialized === "number" && Number.isFinite(serialized)) {
          const stringNum = String(serialized);
          return integerStringRegExp2.test(stringNum) ? {
            kind: _kinds.Kind.INT,
            value: stringNum
          } : {
            kind: _kinds.Kind.FLOAT,
            value: stringNum
          };
        }
        if (typeof serialized === "string") {
          if ((0, _definition.isEnumType)(type)) {
            return {
              kind: _kinds.Kind.ENUM,
              value: serialized
            };
          }
          if (type === _scalars.GraphQLID && integerStringRegExp2.test(serialized)) {
            return {
              kind: _kinds.Kind.INT,
              value: serialized
            };
          }
          return {
            kind: _kinds.Kind.STRING,
            value: serialized
          };
        }
        throw new TypeError(`Cannot convert value to AST: ${(0, _inspect.inspect)(serialized)}.`);
      }
      (0, _invariant.invariant)(false, "Unexpected input type: " + (0, _inspect.inspect)(type));
    }
    var integerStringRegExp2 = /^-?(?:0|[1-9][0-9]*)$/;
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/type/introspection.js
var require_introspection = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/type/introspection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.introspectionTypes = exports2.__TypeKind = exports2.__Type = exports2.__Schema = exports2.__InputValue = exports2.__Field = exports2.__EnumValue = exports2.__DirectiveLocation = exports2.__Directive = exports2.TypeNameMetaFieldDef = exports2.TypeMetaFieldDef = exports2.TypeKind = exports2.SchemaMetaFieldDef = void 0;
    exports2.isIntrospectionType = isIntrospectionType4;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _directiveLocation = require_directiveLocation();
    var _printer = require_printer();
    var _astFromValue = require_astFromValue();
    var _definition = require_definition();
    var _scalars = require_scalars();
    var __Schema = new _definition.GraphQLObjectType({
      name: "__Schema",
      description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
      fields: () => ({
        description: {
          type: _scalars.GraphQLString,
          resolve: (schema) => schema.description
        },
        types: {
          description: "A list of all types supported by this server.",
          type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type))),
          resolve(schema) {
            return Object.values(schema.getTypeMap());
          }
        },
        queryType: {
          description: "The type that query operations will be rooted at.",
          type: new _definition.GraphQLNonNull(__Type),
          resolve: (schema) => schema.getQueryType()
        },
        mutationType: {
          description: "If this server supports mutation, the type that mutation operations will be rooted at.",
          type: __Type,
          resolve: (schema) => schema.getMutationType()
        },
        subscriptionType: {
          description: "If this server support subscription, the type that subscription operations will be rooted at.",
          type: __Type,
          resolve: (schema) => schema.getSubscriptionType()
        },
        directives: {
          description: "A list of all directives supported by this server.",
          type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__Directive))),
          resolve: (schema) => schema.getDirectives()
        }
      })
    });
    exports2.__Schema = __Schema;
    var __Directive = new _definition.GraphQLObjectType({
      name: "__Directive",
      description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
      fields: () => ({
        name: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          resolve: (directive) => directive.name
        },
        description: {
          type: _scalars.GraphQLString,
          resolve: (directive) => directive.description
        },
        isRepeatable: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          resolve: (directive) => directive.isRepeatable
        },
        locations: {
          type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__DirectiveLocation))),
          resolve: (directive) => directive.locations
        },
        args: {
          type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue))),
          args: {
            includeDeprecated: {
              type: _scalars.GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(field, { includeDeprecated }) {
            return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
          }
        }
      })
    });
    exports2.__Directive = __Directive;
    var __DirectiveLocation = new _definition.GraphQLEnumType({
      name: "__DirectiveLocation",
      description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
      values: {
        QUERY: {
          value: _directiveLocation.DirectiveLocation.QUERY,
          description: "Location adjacent to a query operation."
        },
        MUTATION: {
          value: _directiveLocation.DirectiveLocation.MUTATION,
          description: "Location adjacent to a mutation operation."
        },
        SUBSCRIPTION: {
          value: _directiveLocation.DirectiveLocation.SUBSCRIPTION,
          description: "Location adjacent to a subscription operation."
        },
        FIELD: {
          value: _directiveLocation.DirectiveLocation.FIELD,
          description: "Location adjacent to a field."
        },
        FRAGMENT_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION,
          description: "Location adjacent to a fragment definition."
        },
        FRAGMENT_SPREAD: {
          value: _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
          description: "Location adjacent to a fragment spread."
        },
        INLINE_FRAGMENT: {
          value: _directiveLocation.DirectiveLocation.INLINE_FRAGMENT,
          description: "Location adjacent to an inline fragment."
        },
        VARIABLE_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION,
          description: "Location adjacent to a variable definition."
        },
        SCHEMA: {
          value: _directiveLocation.DirectiveLocation.SCHEMA,
          description: "Location adjacent to a schema definition."
        },
        SCALAR: {
          value: _directiveLocation.DirectiveLocation.SCALAR,
          description: "Location adjacent to a scalar definition."
        },
        OBJECT: {
          value: _directiveLocation.DirectiveLocation.OBJECT,
          description: "Location adjacent to an object type definition."
        },
        FIELD_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.FIELD_DEFINITION,
          description: "Location adjacent to a field definition."
        },
        ARGUMENT_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION,
          description: "Location adjacent to an argument definition."
        },
        INTERFACE: {
          value: _directiveLocation.DirectiveLocation.INTERFACE,
          description: "Location adjacent to an interface definition."
        },
        UNION: {
          value: _directiveLocation.DirectiveLocation.UNION,
          description: "Location adjacent to a union definition."
        },
        ENUM: {
          value: _directiveLocation.DirectiveLocation.ENUM,
          description: "Location adjacent to an enum definition."
        },
        ENUM_VALUE: {
          value: _directiveLocation.DirectiveLocation.ENUM_VALUE,
          description: "Location adjacent to an enum value definition."
        },
        INPUT_OBJECT: {
          value: _directiveLocation.DirectiveLocation.INPUT_OBJECT,
          description: "Location adjacent to an input object type definition."
        },
        INPUT_FIELD_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION,
          description: "Location adjacent to an input object field definition."
        }
      }
    });
    exports2.__DirectiveLocation = __DirectiveLocation;
    var __Type = new _definition.GraphQLObjectType({
      name: "__Type",
      description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
      fields: () => ({
        kind: {
          type: new _definition.GraphQLNonNull(__TypeKind),
          resolve(type) {
            if ((0, _definition.isScalarType)(type)) {
              return TypeKind.SCALAR;
            }
            if ((0, _definition.isObjectType)(type)) {
              return TypeKind.OBJECT;
            }
            if ((0, _definition.isInterfaceType)(type)) {
              return TypeKind.INTERFACE;
            }
            if ((0, _definition.isUnionType)(type)) {
              return TypeKind.UNION;
            }
            if ((0, _definition.isEnumType)(type)) {
              return TypeKind.ENUM;
            }
            if ((0, _definition.isInputObjectType)(type)) {
              return TypeKind.INPUT_OBJECT;
            }
            if ((0, _definition.isListType)(type)) {
              return TypeKind.LIST;
            }
            if ((0, _definition.isNonNullType)(type)) {
              return TypeKind.NON_NULL;
            }
            (0, _invariant.invariant)(false, `Unexpected type: "${(0, _inspect.inspect)(type)}".`);
          }
        },
        name: {
          type: _scalars.GraphQLString,
          resolve: (type) => "name" in type ? type.name : void 0
        },
        description: {
          type: _scalars.GraphQLString,
          resolve: (type) => "description" in type ? type.description : void 0
        },
        specifiedByURL: {
          type: _scalars.GraphQLString,
          resolve: (obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0
        },
        fields: {
          type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Field)),
          args: {
            includeDeprecated: {
              type: _scalars.GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(type, { includeDeprecated }) {
            if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
              const fields = Object.values(type.getFields());
              return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
            }
          }
        },
        interfaces: {
          type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
          resolve(type) {
            if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
              return type.getInterfaces();
            }
          }
        },
        possibleTypes: {
          type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
          resolve(type, _args, _context, { schema }) {
            if ((0, _definition.isAbstractType)(type)) {
              return schema.getPossibleTypes(type);
            }
          }
        },
        enumValues: {
          type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__EnumValue)),
          args: {
            includeDeprecated: {
              type: _scalars.GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(type, { includeDeprecated }) {
            if ((0, _definition.isEnumType)(type)) {
              const values = type.getValues();
              return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
            }
          }
        },
        inputFields: {
          type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue)),
          args: {
            includeDeprecated: {
              type: _scalars.GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(type, { includeDeprecated }) {
            if ((0, _definition.isInputObjectType)(type)) {
              const values = Object.values(type.getFields());
              return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
            }
          }
        },
        ofType: {
          type: __Type,
          resolve: (type) => "ofType" in type ? type.ofType : void 0
        }
      })
    });
    exports2.__Type = __Type;
    var __Field = new _definition.GraphQLObjectType({
      name: "__Field",
      description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
      fields: () => ({
        name: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          resolve: (field) => field.name
        },
        description: {
          type: _scalars.GraphQLString,
          resolve: (field) => field.description
        },
        args: {
          type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue))),
          args: {
            includeDeprecated: {
              type: _scalars.GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(field, { includeDeprecated }) {
            return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
          }
        },
        type: {
          type: new _definition.GraphQLNonNull(__Type),
          resolve: (field) => field.type
        },
        isDeprecated: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          resolve: (field) => field.deprecationReason != null
        },
        deprecationReason: {
          type: _scalars.GraphQLString,
          resolve: (field) => field.deprecationReason
        }
      })
    });
    exports2.__Field = __Field;
    var __InputValue = new _definition.GraphQLObjectType({
      name: "__InputValue",
      description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
      fields: () => ({
        name: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          resolve: (inputValue) => inputValue.name
        },
        description: {
          type: _scalars.GraphQLString,
          resolve: (inputValue) => inputValue.description
        },
        type: {
          type: new _definition.GraphQLNonNull(__Type),
          resolve: (inputValue) => inputValue.type
        },
        defaultValue: {
          type: _scalars.GraphQLString,
          description: "A GraphQL-formatted string representing the default value for this input value.",
          resolve(inputValue) {
            const { type, defaultValue } = inputValue;
            const valueAST = (0, _astFromValue.astFromValue)(defaultValue, type);
            return valueAST ? (0, _printer.print)(valueAST) : null;
          }
        },
        isDeprecated: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          resolve: (field) => field.deprecationReason != null
        },
        deprecationReason: {
          type: _scalars.GraphQLString,
          resolve: (obj) => obj.deprecationReason
        }
      })
    });
    exports2.__InputValue = __InputValue;
    var __EnumValue = new _definition.GraphQLObjectType({
      name: "__EnumValue",
      description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
      fields: () => ({
        name: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          resolve: (enumValue) => enumValue.name
        },
        description: {
          type: _scalars.GraphQLString,
          resolve: (enumValue) => enumValue.description
        },
        isDeprecated: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          resolve: (enumValue) => enumValue.deprecationReason != null
        },
        deprecationReason: {
          type: _scalars.GraphQLString,
          resolve: (enumValue) => enumValue.deprecationReason
        }
      })
    });
    exports2.__EnumValue = __EnumValue;
    var TypeKind;
    exports2.TypeKind = TypeKind;
    (function(TypeKind2) {
      TypeKind2["SCALAR"] = "SCALAR";
      TypeKind2["OBJECT"] = "OBJECT";
      TypeKind2["INTERFACE"] = "INTERFACE";
      TypeKind2["UNION"] = "UNION";
      TypeKind2["ENUM"] = "ENUM";
      TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
      TypeKind2["LIST"] = "LIST";
      TypeKind2["NON_NULL"] = "NON_NULL";
    })(TypeKind || (exports2.TypeKind = TypeKind = {}));
    var __TypeKind = new _definition.GraphQLEnumType({
      name: "__TypeKind",
      description: "An enum describing what kind of type a given `__Type` is.",
      values: {
        SCALAR: {
          value: TypeKind.SCALAR,
          description: "Indicates this type is a scalar."
        },
        OBJECT: {
          value: TypeKind.OBJECT,
          description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
        },
        INTERFACE: {
          value: TypeKind.INTERFACE,
          description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
        },
        UNION: {
          value: TypeKind.UNION,
          description: "Indicates this type is a union. `possibleTypes` is a valid field."
        },
        ENUM: {
          value: TypeKind.ENUM,
          description: "Indicates this type is an enum. `enumValues` is a valid field."
        },
        INPUT_OBJECT: {
          value: TypeKind.INPUT_OBJECT,
          description: "Indicates this type is an input object. `inputFields` is a valid field."
        },
        LIST: {
          value: TypeKind.LIST,
          description: "Indicates this type is a list. `ofType` is a valid field."
        },
        NON_NULL: {
          value: TypeKind.NON_NULL,
          description: "Indicates this type is a non-null. `ofType` is a valid field."
        }
      }
    });
    exports2.__TypeKind = __TypeKind;
    var SchemaMetaFieldDef = {
      name: "__schema",
      type: new _definition.GraphQLNonNull(__Schema),
      description: "Access the current type schema of this server.",
      args: [],
      resolve: (_source, _args, _context, { schema }) => schema,
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    };
    exports2.SchemaMetaFieldDef = SchemaMetaFieldDef;
    var TypeMetaFieldDef = {
      name: "__type",
      type: __Type,
      description: "Request the type information of a single type.",
      args: [
        {
          name: "name",
          description: void 0,
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          defaultValue: void 0,
          deprecationReason: void 0,
          extensions: /* @__PURE__ */ Object.create(null),
          astNode: void 0
        }
      ],
      resolve: (_source, { name }, _context, { schema }) => schema.getType(name),
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    };
    exports2.TypeMetaFieldDef = TypeMetaFieldDef;
    var TypeNameMetaFieldDef2 = {
      name: "__typename",
      type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
      description: "The name of the current Object type at runtime.",
      args: [],
      resolve: (_source, _args, _context, { parentType }) => parentType.name,
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    };
    exports2.TypeNameMetaFieldDef = TypeNameMetaFieldDef2;
    var introspectionTypes = Object.freeze([
      __Schema,
      __Directive,
      __DirectiveLocation,
      __Type,
      __Field,
      __InputValue,
      __EnumValue,
      __TypeKind
    ]);
    exports2.introspectionTypes = introspectionTypes;
    function isIntrospectionType4(type) {
      return introspectionTypes.some(({ name }) => type.name === name);
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/type/schema.js
var require_schema = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/type/schema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.GraphQLSchema = void 0;
    exports2.assertSchema = assertSchema;
    exports2.isSchema = isSchema4;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _instanceOf = require_instanceOf();
    var _isObjectLike = require_isObjectLike();
    var _toObjMap = require_toObjMap();
    var _ast = require_ast();
    var _definition = require_definition();
    var _directives = require_directives();
    var _introspection = require_introspection();
    function isSchema4(schema) {
      return (0, _instanceOf.instanceOf)(schema, GraphQLSchema4);
    }
    function assertSchema(schema) {
      if (!isSchema4(schema)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(schema)} to be a GraphQL schema.`);
      }
      return schema;
    }
    var GraphQLSchema4 = class {
      constructor(config2) {
        var _config$extensionASTN, _config$directives;
        this.__validationErrors = config2.assumeValid === true ? [] : void 0;
        (0, _isObjectLike.isObjectLike)(config2) || (0, _devAssert.devAssert)(false, "Must provide configuration object.");
        !config2.types || Array.isArray(config2.types) || (0, _devAssert.devAssert)(false, `"types" must be Array if provided but got: ${(0, _inspect.inspect)(config2.types)}.`);
        !config2.directives || Array.isArray(config2.directives) || (0, _devAssert.devAssert)(false, `"directives" must be Array if provided but got: ${(0, _inspect.inspect)(config2.directives)}.`);
        this.description = config2.description;
        this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN = config2.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
        this._queryType = config2.query;
        this._mutationType = config2.mutation;
        this._subscriptionType = config2.subscription;
        this._directives = (_config$directives = config2.directives) !== null && _config$directives !== void 0 ? _config$directives : _directives.specifiedDirectives;
        const allReferencedTypes = new Set(config2.types);
        if (config2.types != null) {
          for (const type of config2.types) {
            allReferencedTypes.delete(type);
            collectReferencedTypes(type, allReferencedTypes);
          }
        }
        if (this._queryType != null) {
          collectReferencedTypes(this._queryType, allReferencedTypes);
        }
        if (this._mutationType != null) {
          collectReferencedTypes(this._mutationType, allReferencedTypes);
        }
        if (this._subscriptionType != null) {
          collectReferencedTypes(this._subscriptionType, allReferencedTypes);
        }
        for (const directive of this._directives) {
          if ((0, _directives.isDirective)(directive)) {
            for (const arg of directive.args) {
              collectReferencedTypes(arg.type, allReferencedTypes);
            }
          }
        }
        collectReferencedTypes(_introspection.__Schema, allReferencedTypes);
        this._typeMap = /* @__PURE__ */ Object.create(null);
        this._subTypeMap = /* @__PURE__ */ Object.create(null);
        this._implementationsMap = /* @__PURE__ */ Object.create(null);
        for (const namedType of allReferencedTypes) {
          if (namedType == null) {
            continue;
          }
          const typeName = namedType.name;
          typeName || (0, _devAssert.devAssert)(false, "One of the provided types for building the Schema is missing a name.");
          if (this._typeMap[typeName] !== void 0) {
            throw new Error(`Schema must contain uniquely named types but contains multiple types named "${typeName}".`);
          }
          this._typeMap[typeName] = namedType;
          if ((0, _definition.isInterfaceType)(namedType)) {
            for (const iface of namedType.getInterfaces()) {
              if ((0, _definition.isInterfaceType)(iface)) {
                let implementations = this._implementationsMap[iface.name];
                if (implementations === void 0) {
                  implementations = this._implementationsMap[iface.name] = {
                    objects: [],
                    interfaces: []
                  };
                }
                implementations.interfaces.push(namedType);
              }
            }
          } else if ((0, _definition.isObjectType)(namedType)) {
            for (const iface of namedType.getInterfaces()) {
              if ((0, _definition.isInterfaceType)(iface)) {
                let implementations = this._implementationsMap[iface.name];
                if (implementations === void 0) {
                  implementations = this._implementationsMap[iface.name] = {
                    objects: [],
                    interfaces: []
                  };
                }
                implementations.objects.push(namedType);
              }
            }
          }
        }
      }
      get [Symbol.toStringTag]() {
        return "GraphQLSchema";
      }
      getQueryType() {
        return this._queryType;
      }
      getMutationType() {
        return this._mutationType;
      }
      getSubscriptionType() {
        return this._subscriptionType;
      }
      getRootType(operation) {
        switch (operation) {
          case _ast.OperationTypeNode.QUERY:
            return this.getQueryType();
          case _ast.OperationTypeNode.MUTATION:
            return this.getMutationType();
          case _ast.OperationTypeNode.SUBSCRIPTION:
            return this.getSubscriptionType();
        }
      }
      getTypeMap() {
        return this._typeMap;
      }
      getType(name) {
        return this.getTypeMap()[name];
      }
      getPossibleTypes(abstractType) {
        return (0, _definition.isUnionType)(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
      }
      getImplementations(interfaceType) {
        const implementations = this._implementationsMap[interfaceType.name];
        return implementations !== null && implementations !== void 0 ? implementations : {
          objects: [],
          interfaces: []
        };
      }
      isSubType(abstractType, maybeSubType) {
        let map3 = this._subTypeMap[abstractType.name];
        if (map3 === void 0) {
          map3 = /* @__PURE__ */ Object.create(null);
          if ((0, _definition.isUnionType)(abstractType)) {
            for (const type of abstractType.getTypes()) {
              map3[type.name] = true;
            }
          } else {
            const implementations = this.getImplementations(abstractType);
            for (const type of implementations.objects) {
              map3[type.name] = true;
            }
            for (const type of implementations.interfaces) {
              map3[type.name] = true;
            }
          }
          this._subTypeMap[abstractType.name] = map3;
        }
        return map3[maybeSubType.name] !== void 0;
      }
      getDirectives() {
        return this._directives;
      }
      getDirective(name) {
        return this.getDirectives().find((directive) => directive.name === name);
      }
      toConfig() {
        return {
          description: this.description,
          query: this.getQueryType(),
          mutation: this.getMutationType(),
          subscription: this.getSubscriptionType(),
          types: Object.values(this.getTypeMap()),
          directives: this.getDirectives(),
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes,
          assumeValid: this.__validationErrors !== void 0
        };
      }
    };
    exports2.GraphQLSchema = GraphQLSchema4;
    function collectReferencedTypes(type, typeSet) {
      const namedType = (0, _definition.getNamedType)(type);
      if (!typeSet.has(namedType)) {
        typeSet.add(namedType);
        if ((0, _definition.isUnionType)(namedType)) {
          for (const memberType of namedType.getTypes()) {
            collectReferencedTypes(memberType, typeSet);
          }
        } else if ((0, _definition.isObjectType)(namedType) || (0, _definition.isInterfaceType)(namedType)) {
          for (const interfaceType of namedType.getInterfaces()) {
            collectReferencedTypes(interfaceType, typeSet);
          }
          for (const field of Object.values(namedType.getFields())) {
            collectReferencedTypes(field.type, typeSet);
            for (const arg of field.args) {
              collectReferencedTypes(arg.type, typeSet);
            }
          }
        } else if ((0, _definition.isInputObjectType)(namedType)) {
          for (const field of Object.values(namedType.getFields())) {
            collectReferencedTypes(field.type, typeSet);
          }
        }
      }
      return typeSet;
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/type/validate.js
var require_validate = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/type/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assertValidSchema = assertValidSchema;
    exports2.validateSchema = validateSchema;
    var _inspect = require_inspect();
    var _GraphQLError = require_GraphQLError();
    var _ast = require_ast();
    var _typeComparators = require_typeComparators();
    var _definition = require_definition();
    var _directives = require_directives();
    var _introspection = require_introspection();
    var _schema = require_schema();
    function validateSchema(schema) {
      (0, _schema.assertSchema)(schema);
      if (schema.__validationErrors) {
        return schema.__validationErrors;
      }
      const context = new SchemaValidationContext(schema);
      validateRootTypes(context);
      validateDirectives(context);
      validateTypes(context);
      const errors2 = context.getErrors();
      schema.__validationErrors = errors2;
      return errors2;
    }
    function assertValidSchema(schema) {
      const errors2 = validateSchema(schema);
      if (errors2.length !== 0) {
        throw new Error(errors2.map((error2) => error2.message).join("\n\n"));
      }
    }
    var SchemaValidationContext = class {
      constructor(schema) {
        this._errors = [];
        this.schema = schema;
      }
      reportError(message, nodes) {
        const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
        this._errors.push(new _GraphQLError.GraphQLError(message, {
          nodes: _nodes
        }));
      }
      getErrors() {
        return this._errors;
      }
    };
    function validateRootTypes(context) {
      const schema = context.schema;
      const queryType = schema.getQueryType();
      if (!queryType) {
        context.reportError("Query root type must be provided.", schema.astNode);
      } else if (!(0, _definition.isObjectType)(queryType)) {
        var _getOperationTypeNode;
        context.reportError(`Query root type must be Object type, it cannot be ${(0, _inspect.inspect)(queryType)}.`, (_getOperationTypeNode = getOperationTypeNode(schema, _ast.OperationTypeNode.QUERY)) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode);
      }
      const mutationType = schema.getMutationType();
      if (mutationType && !(0, _definition.isObjectType)(mutationType)) {
        var _getOperationTypeNode2;
        context.reportError(`Mutation root type must be Object type if provided, it cannot be ${(0, _inspect.inspect)(mutationType)}.`, (_getOperationTypeNode2 = getOperationTypeNode(schema, _ast.OperationTypeNode.MUTATION)) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode);
      }
      const subscriptionType = schema.getSubscriptionType();
      if (subscriptionType && !(0, _definition.isObjectType)(subscriptionType)) {
        var _getOperationTypeNode3;
        context.reportError(`Subscription root type must be Object type if provided, it cannot be ${(0, _inspect.inspect)(subscriptionType)}.`, (_getOperationTypeNode3 = getOperationTypeNode(schema, _ast.OperationTypeNode.SUBSCRIPTION)) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode);
      }
    }
    function getOperationTypeNode(schema, operation) {
      var _flatMap$find;
      return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes].flatMap((schemaNode) => {
        var _schemaNode$operation;
        return (_schemaNode$operation = schemaNode === null || schemaNode === void 0 ? void 0 : schemaNode.operationTypes) !== null && _schemaNode$operation !== void 0 ? _schemaNode$operation : [];
      }).find((operationNode) => operationNode.operation === operation)) === null || _flatMap$find === void 0 ? void 0 : _flatMap$find.type;
    }
    function validateDirectives(context) {
      for (const directive of context.schema.getDirectives()) {
        if (!(0, _directives.isDirective)(directive)) {
          context.reportError(`Expected directive but got: ${(0, _inspect.inspect)(directive)}.`, directive === null || directive === void 0 ? void 0 : directive.astNode);
          continue;
        }
        validateName(context, directive);
        for (const arg of directive.args) {
          validateName(context, arg);
          if (!(0, _definition.isInputType)(arg.type)) {
            context.reportError(`The type of @${directive.name}(${arg.name}:) must be Input Type but got: ${(0, _inspect.inspect)(arg.type)}.`, arg.astNode);
          }
          if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {
            var _arg$astNode;
            context.reportError(`Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`, [
              getDeprecatedDirectiveNode(arg.astNode),
              (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type
            ]);
          }
        }
      }
    }
    function validateName(context, node) {
      if (node.name.startsWith("__")) {
        context.reportError(`Name "${node.name}" must not begin with "__", which is reserved by GraphQL introspection.`, node.astNode);
      }
    }
    function validateTypes(context) {
      const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);
      const typeMap = context.schema.getTypeMap();
      for (const type of Object.values(typeMap)) {
        if (!(0, _definition.isNamedType)(type)) {
          context.reportError(`Expected GraphQL named type but got: ${(0, _inspect.inspect)(type)}.`, type.astNode);
          continue;
        }
        if (!(0, _introspection.isIntrospectionType)(type)) {
          validateName(context, type);
        }
        if ((0, _definition.isObjectType)(type)) {
          validateFields(context, type);
          validateInterfaces(context, type);
        } else if ((0, _definition.isInterfaceType)(type)) {
          validateFields(context, type);
          validateInterfaces(context, type);
        } else if ((0, _definition.isUnionType)(type)) {
          validateUnionMembers(context, type);
        } else if ((0, _definition.isEnumType)(type)) {
          validateEnumValues(context, type);
        } else if ((0, _definition.isInputObjectType)(type)) {
          validateInputFields(context, type);
          validateInputObjectCircularRefs(type);
        }
      }
    }
    function validateFields(context, type) {
      const fields = Object.values(type.getFields());
      if (fields.length === 0) {
        context.reportError(`Type ${type.name} must define one or more fields.`, [
          type.astNode,
          ...type.extensionASTNodes
        ]);
      }
      for (const field of fields) {
        validateName(context, field);
        if (!(0, _definition.isOutputType)(field.type)) {
          var _field$astNode;
          context.reportError(`The type of ${type.name}.${field.name} must be Output Type but got: ${(0, _inspect.inspect)(field.type)}.`, (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type);
        }
        for (const arg of field.args) {
          const argName = arg.name;
          validateName(context, arg);
          if (!(0, _definition.isInputType)(arg.type)) {
            var _arg$astNode2;
            context.reportError(`The type of ${type.name}.${field.name}(${argName}:) must be Input Type but got: ${(0, _inspect.inspect)(arg.type)}.`, (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type);
          }
          if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {
            var _arg$astNode3;
            context.reportError(`Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`, [
              getDeprecatedDirectiveNode(arg.astNode),
              (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type
            ]);
          }
        }
      }
    }
    function validateInterfaces(context, type) {
      const ifaceTypeNames = /* @__PURE__ */ Object.create(null);
      for (const iface of type.getInterfaces()) {
        if (!(0, _definition.isInterfaceType)(iface)) {
          context.reportError(`Type ${(0, _inspect.inspect)(type)} must only implement Interface types, it cannot implement ${(0, _inspect.inspect)(iface)}.`, getAllImplementsInterfaceNodes(type, iface));
          continue;
        }
        if (type === iface) {
          context.reportError(`Type ${type.name} cannot implement itself because it would create a circular reference.`, getAllImplementsInterfaceNodes(type, iface));
          continue;
        }
        if (ifaceTypeNames[iface.name]) {
          context.reportError(`Type ${type.name} can only implement ${iface.name} once.`, getAllImplementsInterfaceNodes(type, iface));
          continue;
        }
        ifaceTypeNames[iface.name] = true;
        validateTypeImplementsAncestors(context, type, iface);
        validateTypeImplementsInterface(context, type, iface);
      }
    }
    function validateTypeImplementsInterface(context, type, iface) {
      const typeFieldMap = type.getFields();
      for (const ifaceField of Object.values(iface.getFields())) {
        const fieldName = ifaceField.name;
        const typeField = typeFieldMap[fieldName];
        if (!typeField) {
          context.reportError(`Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`, [ifaceField.astNode, type.astNode, ...type.extensionASTNodes]);
          continue;
        }
        if (!(0, _typeComparators.isTypeSubTypeOf)(context.schema, typeField.type, ifaceField.type)) {
          var _ifaceField$astNode, _typeField$astNode;
          context.reportError(`Interface field ${iface.name}.${fieldName} expects type ${(0, _inspect.inspect)(ifaceField.type)} but ${type.name}.${fieldName} is type ${(0, _inspect.inspect)(typeField.type)}.`, [
            (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type,
            (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type
          ]);
        }
        for (const ifaceArg of ifaceField.args) {
          const argName = ifaceArg.name;
          const typeArg = typeField.args.find((arg) => arg.name === argName);
          if (!typeArg) {
            context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`, [ifaceArg.astNode, typeField.astNode]);
            continue;
          }
          if (!(0, _typeComparators.isEqualType)(ifaceArg.type, typeArg.type)) {
            var _ifaceArg$astNode, _typeArg$astNode;
            context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) expects type ${(0, _inspect.inspect)(ifaceArg.type)} but ${type.name}.${fieldName}(${argName}:) is type ${(0, _inspect.inspect)(typeArg.type)}.`, [
              (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type,
              (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type
            ]);
          }
        }
        for (const typeArg of typeField.args) {
          const argName = typeArg.name;
          const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);
          if (!ifaceArg && (0, _definition.isRequiredArgument)(typeArg)) {
            context.reportError(`Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`, [typeArg.astNode, ifaceField.astNode]);
          }
        }
      }
    }
    function validateTypeImplementsAncestors(context, type, iface) {
      const ifaceInterfaces = type.getInterfaces();
      for (const transitive of iface.getInterfaces()) {
        if (!ifaceInterfaces.includes(transitive)) {
          context.reportError(transitive === type ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`, [
            ...getAllImplementsInterfaceNodes(iface, transitive),
            ...getAllImplementsInterfaceNodes(type, iface)
          ]);
        }
      }
    }
    function validateUnionMembers(context, union) {
      const memberTypes = union.getTypes();
      if (memberTypes.length === 0) {
        context.reportError(`Union type ${union.name} must define one or more member types.`, [union.astNode, ...union.extensionASTNodes]);
      }
      const includedTypeNames = /* @__PURE__ */ Object.create(null);
      for (const memberType of memberTypes) {
        if (includedTypeNames[memberType.name]) {
          context.reportError(`Union type ${union.name} can only include type ${memberType.name} once.`, getUnionMemberTypeNodes(union, memberType.name));
          continue;
        }
        includedTypeNames[memberType.name] = true;
        if (!(0, _definition.isObjectType)(memberType)) {
          context.reportError(`Union type ${union.name} can only include Object types, it cannot include ${(0, _inspect.inspect)(memberType)}.`, getUnionMemberTypeNodes(union, String(memberType)));
        }
      }
    }
    function validateEnumValues(context, enumType) {
      const enumValues = enumType.getValues();
      if (enumValues.length === 0) {
        context.reportError(`Enum type ${enumType.name} must define one or more values.`, [enumType.astNode, ...enumType.extensionASTNodes]);
      }
      for (const enumValue of enumValues) {
        validateName(context, enumValue);
      }
    }
    function validateInputFields(context, inputObj) {
      const fields = Object.values(inputObj.getFields());
      if (fields.length === 0) {
        context.reportError(`Input Object type ${inputObj.name} must define one or more fields.`, [inputObj.astNode, ...inputObj.extensionASTNodes]);
      }
      for (const field of fields) {
        validateName(context, field);
        if (!(0, _definition.isInputType)(field.type)) {
          var _field$astNode2;
          context.reportError(`The type of ${inputObj.name}.${field.name} must be Input Type but got: ${(0, _inspect.inspect)(field.type)}.`, (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type);
        }
        if ((0, _definition.isRequiredInputField)(field) && field.deprecationReason != null) {
          var _field$astNode3;
          context.reportError(`Required input field ${inputObj.name}.${field.name} cannot be deprecated.`, [
            getDeprecatedDirectiveNode(field.astNode),
            (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type
          ]);
        }
      }
    }
    function createInputObjectCircularRefsValidator(context) {
      const visitedTypes = /* @__PURE__ */ Object.create(null);
      const fieldPath = [];
      const fieldPathIndexByTypeName = /* @__PURE__ */ Object.create(null);
      return detectCycleRecursive;
      function detectCycleRecursive(inputObj) {
        if (visitedTypes[inputObj.name]) {
          return;
        }
        visitedTypes[inputObj.name] = true;
        fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
        const fields = Object.values(inputObj.getFields());
        for (const field of fields) {
          if ((0, _definition.isNonNullType)(field.type) && (0, _definition.isInputObjectType)(field.type.ofType)) {
            const fieldType = field.type.ofType;
            const cycleIndex = fieldPathIndexByTypeName[fieldType.name];
            fieldPath.push(field);
            if (cycleIndex === void 0) {
              detectCycleRecursive(fieldType);
            } else {
              const cyclePath = fieldPath.slice(cycleIndex);
              const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join(".");
              context.reportError(`Cannot reference Input Object "${fieldType.name}" within itself through a series of non-null fields: "${pathStr}".`, cyclePath.map((fieldObj) => fieldObj.astNode));
            }
            fieldPath.pop();
          }
        }
        fieldPathIndexByTypeName[inputObj.name] = void 0;
      }
    }
    function getAllImplementsInterfaceNodes(type, iface) {
      const { astNode, extensionASTNodes } = type;
      const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
      return nodes.flatMap((typeNode) => {
        var _typeNode$interfaces;
        return (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== void 0 ? _typeNode$interfaces : [];
      }).filter((ifaceNode) => ifaceNode.name.value === iface.name);
    }
    function getUnionMemberTypeNodes(union, typeName) {
      const { astNode, extensionASTNodes } = union;
      const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
      return nodes.flatMap((unionNode) => {
        var _unionNode$types;
        return (_unionNode$types = unionNode.types) !== null && _unionNode$types !== void 0 ? _unionNode$types : [];
      }).filter((typeNode) => typeNode.name.value === typeName);
    }
    function getDeprecatedDirectiveNode(definitionNode) {
      var _definitionNode$direc;
      return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find((node) => node.name.value === _directives.GraphQLDeprecatedDirective.name);
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/typeFromAST.js
var require_typeFromAST = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/typeFromAST.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.typeFromAST = typeFromAST2;
    var _kinds = require_kinds();
    var _definition = require_definition();
    function typeFromAST2(schema, typeNode) {
      switch (typeNode.kind) {
        case _kinds.Kind.LIST_TYPE: {
          const innerType = typeFromAST2(schema, typeNode.type);
          return innerType && new _definition.GraphQLList(innerType);
        }
        case _kinds.Kind.NON_NULL_TYPE: {
          const innerType = typeFromAST2(schema, typeNode.type);
          return innerType && new _definition.GraphQLNonNull(innerType);
        }
        case _kinds.Kind.NAMED_TYPE:
          return schema.getType(typeNode.name.value);
      }
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/TypeInfo.js
var require_TypeInfo = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/TypeInfo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TypeInfo = void 0;
    exports2.visitWithTypeInfo = visitWithTypeInfo;
    var _ast = require_ast();
    var _kinds = require_kinds();
    var _visitor = require_visitor();
    var _definition = require_definition();
    var _introspection = require_introspection();
    var _typeFromAST = require_typeFromAST();
    var TypeInfo = class {
      constructor(schema, initialType, getFieldDefFn) {
        this._schema = schema;
        this._typeStack = [];
        this._parentTypeStack = [];
        this._inputTypeStack = [];
        this._fieldDefStack = [];
        this._defaultValueStack = [];
        this._directive = null;
        this._argument = null;
        this._enumValue = null;
        this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;
        if (initialType) {
          if ((0, _definition.isInputType)(initialType)) {
            this._inputTypeStack.push(initialType);
          }
          if ((0, _definition.isCompositeType)(initialType)) {
            this._parentTypeStack.push(initialType);
          }
          if ((0, _definition.isOutputType)(initialType)) {
            this._typeStack.push(initialType);
          }
        }
      }
      get [Symbol.toStringTag]() {
        return "TypeInfo";
      }
      getType() {
        if (this._typeStack.length > 0) {
          return this._typeStack[this._typeStack.length - 1];
        }
      }
      getParentType() {
        if (this._parentTypeStack.length > 0) {
          return this._parentTypeStack[this._parentTypeStack.length - 1];
        }
      }
      getInputType() {
        if (this._inputTypeStack.length > 0) {
          return this._inputTypeStack[this._inputTypeStack.length - 1];
        }
      }
      getParentInputType() {
        if (this._inputTypeStack.length > 1) {
          return this._inputTypeStack[this._inputTypeStack.length - 2];
        }
      }
      getFieldDef() {
        if (this._fieldDefStack.length > 0) {
          return this._fieldDefStack[this._fieldDefStack.length - 1];
        }
      }
      getDefaultValue() {
        if (this._defaultValueStack.length > 0) {
          return this._defaultValueStack[this._defaultValueStack.length - 1];
        }
      }
      getDirective() {
        return this._directive;
      }
      getArgument() {
        return this._argument;
      }
      getEnumValue() {
        return this._enumValue;
      }
      enter(node) {
        const schema = this._schema;
        switch (node.kind) {
          case _kinds.Kind.SELECTION_SET: {
            const namedType = (0, _definition.getNamedType)(this.getType());
            this._parentTypeStack.push((0, _definition.isCompositeType)(namedType) ? namedType : void 0);
            break;
          }
          case _kinds.Kind.FIELD: {
            const parentType = this.getParentType();
            let fieldDef;
            let fieldType;
            if (parentType) {
              fieldDef = this._getFieldDef(schema, parentType, node);
              if (fieldDef) {
                fieldType = fieldDef.type;
              }
            }
            this._fieldDefStack.push(fieldDef);
            this._typeStack.push((0, _definition.isOutputType)(fieldType) ? fieldType : void 0);
            break;
          }
          case _kinds.Kind.DIRECTIVE:
            this._directive = schema.getDirective(node.name.value);
            break;
          case _kinds.Kind.OPERATION_DEFINITION: {
            const rootType = schema.getRootType(node.operation);
            this._typeStack.push((0, _definition.isObjectType)(rootType) ? rootType : void 0);
            break;
          }
          case _kinds.Kind.INLINE_FRAGMENT:
          case _kinds.Kind.FRAGMENT_DEFINITION: {
            const typeConditionAST = node.typeCondition;
            const outputType = typeConditionAST ? (0, _typeFromAST.typeFromAST)(schema, typeConditionAST) : (0, _definition.getNamedType)(this.getType());
            this._typeStack.push((0, _definition.isOutputType)(outputType) ? outputType : void 0);
            break;
          }
          case _kinds.Kind.VARIABLE_DEFINITION: {
            const inputType = (0, _typeFromAST.typeFromAST)(schema, node.type);
            this._inputTypeStack.push((0, _definition.isInputType)(inputType) ? inputType : void 0);
            break;
          }
          case _kinds.Kind.ARGUMENT: {
            var _this$getDirective;
            let argDef;
            let argType;
            const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();
            if (fieldOrDirective) {
              argDef = fieldOrDirective.args.find((arg) => arg.name === node.name.value);
              if (argDef) {
                argType = argDef.type;
              }
            }
            this._argument = argDef;
            this._defaultValueStack.push(argDef ? argDef.defaultValue : void 0);
            this._inputTypeStack.push((0, _definition.isInputType)(argType) ? argType : void 0);
            break;
          }
          case _kinds.Kind.LIST: {
            const listType = (0, _definition.getNullableType)(this.getInputType());
            const itemType = (0, _definition.isListType)(listType) ? listType.ofType : listType;
            this._defaultValueStack.push(void 0);
            this._inputTypeStack.push((0, _definition.isInputType)(itemType) ? itemType : void 0);
            break;
          }
          case _kinds.Kind.OBJECT_FIELD: {
            const objectType = (0, _definition.getNamedType)(this.getInputType());
            let inputFieldType;
            let inputField;
            if ((0, _definition.isInputObjectType)(objectType)) {
              inputField = objectType.getFields()[node.name.value];
              if (inputField) {
                inputFieldType = inputField.type;
              }
            }
            this._defaultValueStack.push(inputField ? inputField.defaultValue : void 0);
            this._inputTypeStack.push((0, _definition.isInputType)(inputFieldType) ? inputFieldType : void 0);
            break;
          }
          case _kinds.Kind.ENUM: {
            const enumType = (0, _definition.getNamedType)(this.getInputType());
            let enumValue;
            if ((0, _definition.isEnumType)(enumType)) {
              enumValue = enumType.getValue(node.value);
            }
            this._enumValue = enumValue;
            break;
          }
          default:
        }
      }
      leave(node) {
        switch (node.kind) {
          case _kinds.Kind.SELECTION_SET:
            this._parentTypeStack.pop();
            break;
          case _kinds.Kind.FIELD:
            this._fieldDefStack.pop();
            this._typeStack.pop();
            break;
          case _kinds.Kind.DIRECTIVE:
            this._directive = null;
            break;
          case _kinds.Kind.OPERATION_DEFINITION:
          case _kinds.Kind.INLINE_FRAGMENT:
          case _kinds.Kind.FRAGMENT_DEFINITION:
            this._typeStack.pop();
            break;
          case _kinds.Kind.VARIABLE_DEFINITION:
            this._inputTypeStack.pop();
            break;
          case _kinds.Kind.ARGUMENT:
            this._argument = null;
            this._defaultValueStack.pop();
            this._inputTypeStack.pop();
            break;
          case _kinds.Kind.LIST:
          case _kinds.Kind.OBJECT_FIELD:
            this._defaultValueStack.pop();
            this._inputTypeStack.pop();
            break;
          case _kinds.Kind.ENUM:
            this._enumValue = null;
            break;
          default:
        }
      }
    };
    exports2.TypeInfo = TypeInfo;
    function getFieldDef(schema, parentType, fieldNode) {
      const name = fieldNode.name.value;
      if (name === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
        return _introspection.SchemaMetaFieldDef;
      }
      if (name === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
        return _introspection.TypeMetaFieldDef;
      }
      if (name === _introspection.TypeNameMetaFieldDef.name && (0, _definition.isCompositeType)(parentType)) {
        return _introspection.TypeNameMetaFieldDef;
      }
      if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
        return parentType.getFields()[name];
      }
    }
    function visitWithTypeInfo(typeInfo, visitor) {
      return {
        enter(...args) {
          const node = args[0];
          typeInfo.enter(node);
          const fn2 = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).enter;
          if (fn2) {
            const result = fn2.apply(visitor, args);
            if (result !== void 0) {
              typeInfo.leave(node);
              if ((0, _ast.isNode)(result)) {
                typeInfo.enter(result);
              }
            }
            return result;
          }
        },
        leave(...args) {
          const node = args[0];
          const fn2 = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).leave;
          let result;
          if (fn2) {
            result = fn2.apply(visitor, args);
          }
          typeInfo.leave(node);
          return result;
        }
      };
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/language/predicates.js
var require_predicates = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/language/predicates.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isConstValueNode = isConstValueNode;
    exports2.isDefinitionNode = isDefinitionNode2;
    exports2.isExecutableDefinitionNode = isExecutableDefinitionNode;
    exports2.isSelectionNode = isSelectionNode;
    exports2.isTypeDefinitionNode = isTypeDefinitionNode;
    exports2.isTypeExtensionNode = isTypeExtensionNode;
    exports2.isTypeNode = isTypeNode;
    exports2.isTypeSystemDefinitionNode = isTypeSystemDefinitionNode2;
    exports2.isTypeSystemExtensionNode = isTypeSystemExtensionNode;
    exports2.isValueNode = isValueNode;
    var _kinds = require_kinds();
    function isDefinitionNode2(node) {
      return isExecutableDefinitionNode(node) || isTypeSystemDefinitionNode2(node) || isTypeSystemExtensionNode(node);
    }
    function isExecutableDefinitionNode(node) {
      return node.kind === _kinds.Kind.OPERATION_DEFINITION || node.kind === _kinds.Kind.FRAGMENT_DEFINITION;
    }
    function isSelectionNode(node) {
      return node.kind === _kinds.Kind.FIELD || node.kind === _kinds.Kind.FRAGMENT_SPREAD || node.kind === _kinds.Kind.INLINE_FRAGMENT;
    }
    function isValueNode(node) {
      return node.kind === _kinds.Kind.VARIABLE || node.kind === _kinds.Kind.INT || node.kind === _kinds.Kind.FLOAT || node.kind === _kinds.Kind.STRING || node.kind === _kinds.Kind.BOOLEAN || node.kind === _kinds.Kind.NULL || node.kind === _kinds.Kind.ENUM || node.kind === _kinds.Kind.LIST || node.kind === _kinds.Kind.OBJECT;
    }
    function isConstValueNode(node) {
      return isValueNode(node) && (node.kind === _kinds.Kind.LIST ? node.values.some(isConstValueNode) : node.kind === _kinds.Kind.OBJECT ? node.fields.some((field) => isConstValueNode(field.value)) : node.kind !== _kinds.Kind.VARIABLE);
    }
    function isTypeNode(node) {
      return node.kind === _kinds.Kind.NAMED_TYPE || node.kind === _kinds.Kind.LIST_TYPE || node.kind === _kinds.Kind.NON_NULL_TYPE;
    }
    function isTypeSystemDefinitionNode2(node) {
      return node.kind === _kinds.Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === _kinds.Kind.DIRECTIVE_DEFINITION;
    }
    function isTypeDefinitionNode(node) {
      return node.kind === _kinds.Kind.SCALAR_TYPE_DEFINITION || node.kind === _kinds.Kind.OBJECT_TYPE_DEFINITION || node.kind === _kinds.Kind.INTERFACE_TYPE_DEFINITION || node.kind === _kinds.Kind.UNION_TYPE_DEFINITION || node.kind === _kinds.Kind.ENUM_TYPE_DEFINITION || node.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION;
    }
    function isTypeSystemExtensionNode(node) {
      return node.kind === _kinds.Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
    }
    function isTypeExtensionNode(node) {
      return node.kind === _kinds.Kind.SCALAR_TYPE_EXTENSION || node.kind === _kinds.Kind.OBJECT_TYPE_EXTENSION || node.kind === _kinds.Kind.INTERFACE_TYPE_EXTENSION || node.kind === _kinds.Kind.UNION_TYPE_EXTENSION || node.kind === _kinds.Kind.ENUM_TYPE_EXTENSION || node.kind === _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/ExecutableDefinitionsRule.js
var require_ExecutableDefinitionsRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/ExecutableDefinitionsRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ExecutableDefinitionsRule = ExecutableDefinitionsRule;
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _predicates = require_predicates();
    function ExecutableDefinitionsRule(context) {
      return {
        Document(node) {
          for (const definition of node.definitions) {
            if (!(0, _predicates.isExecutableDefinitionNode)(definition)) {
              const defName = definition.kind === _kinds.Kind.SCHEMA_DEFINITION || definition.kind === _kinds.Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
              context.reportError(new _GraphQLError.GraphQLError(`The ${defName} definition is not executable.`, {
                nodes: definition
              }));
            }
          }
          return false;
        }
      };
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js
var require_FieldsOnCorrectTypeRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FieldsOnCorrectTypeRule = FieldsOnCorrectTypeRule;
    var _didYouMean = require_didYouMean();
    var _naturalCompare = require_naturalCompare();
    var _suggestionList = require_suggestionList();
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function FieldsOnCorrectTypeRule(context) {
      return {
        Field(node) {
          const type = context.getParentType();
          if (type) {
            const fieldDef = context.getFieldDef();
            if (!fieldDef) {
              const schema = context.getSchema();
              const fieldName = node.name.value;
              let suggestion = (0, _didYouMean.didYouMean)("to use an inline fragment on", getSuggestedTypeNames(schema, type, fieldName));
              if (suggestion === "") {
                suggestion = (0, _didYouMean.didYouMean)(getSuggestedFieldNames(type, fieldName));
              }
              context.reportError(new _GraphQLError.GraphQLError(`Cannot query field "${fieldName}" on type "${type.name}".` + suggestion, {
                nodes: node
              }));
            }
          }
        }
      };
    }
    function getSuggestedTypeNames(schema, type, fieldName) {
      if (!(0, _definition.isAbstractType)(type)) {
        return [];
      }
      const suggestedTypes = /* @__PURE__ */ new Set();
      const usageCount = /* @__PURE__ */ Object.create(null);
      for (const possibleType of schema.getPossibleTypes(type)) {
        if (!possibleType.getFields()[fieldName]) {
          continue;
        }
        suggestedTypes.add(possibleType);
        usageCount[possibleType.name] = 1;
        for (const possibleInterface of possibleType.getInterfaces()) {
          var _usageCount$possibleI;
          if (!possibleInterface.getFields()[fieldName]) {
            continue;
          }
          suggestedTypes.add(possibleInterface);
          usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
        }
      }
      return [...suggestedTypes].sort((typeA, typeB) => {
        const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
        if (usageCountDiff !== 0) {
          return usageCountDiff;
        }
        if ((0, _definition.isInterfaceType)(typeA) && schema.isSubType(typeA, typeB)) {
          return -1;
        }
        if ((0, _definition.isInterfaceType)(typeB) && schema.isSubType(typeB, typeA)) {
          return 1;
        }
        return (0, _naturalCompare.naturalCompare)(typeA.name, typeB.name);
      }).map((x) => x.name);
    }
    function getSuggestedFieldNames(type, fieldName) {
      if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
        const possibleFieldNames = Object.keys(type.getFields());
        return (0, _suggestionList.suggestionList)(fieldName, possibleFieldNames);
      }
      return [];
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js
var require_FragmentsOnCompositeTypesRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FragmentsOnCompositeTypesRule = FragmentsOnCompositeTypesRule;
    var _GraphQLError = require_GraphQLError();
    var _printer = require_printer();
    var _definition = require_definition();
    var _typeFromAST = require_typeFromAST();
    function FragmentsOnCompositeTypesRule(context) {
      return {
        InlineFragment(node) {
          const typeCondition = node.typeCondition;
          if (typeCondition) {
            const type = (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition);
            if (type && !(0, _definition.isCompositeType)(type)) {
              const typeStr = (0, _printer.print)(typeCondition);
              context.reportError(new _GraphQLError.GraphQLError(`Fragment cannot condition on non composite type "${typeStr}".`, {
                nodes: typeCondition
              }));
            }
          }
        },
        FragmentDefinition(node) {
          const type = (0, _typeFromAST.typeFromAST)(context.getSchema(), node.typeCondition);
          if (type && !(0, _definition.isCompositeType)(type)) {
            const typeStr = (0, _printer.print)(node.typeCondition);
            context.reportError(new _GraphQLError.GraphQLError(`Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`, {
              nodes: node.typeCondition
            }));
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/KnownArgumentNamesRule.js
var require_KnownArgumentNamesRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/KnownArgumentNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.KnownArgumentNamesOnDirectivesRule = KnownArgumentNamesOnDirectivesRule;
    exports2.KnownArgumentNamesRule = KnownArgumentNamesRule;
    var _didYouMean = require_didYouMean();
    var _suggestionList = require_suggestionList();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _directives = require_directives();
    function KnownArgumentNamesRule(context) {
      return {
        ...KnownArgumentNamesOnDirectivesRule(context),
        Argument(argNode) {
          const argDef = context.getArgument();
          const fieldDef = context.getFieldDef();
          const parentType = context.getParentType();
          if (!argDef && fieldDef && parentType) {
            const argName = argNode.name.value;
            const knownArgsNames = fieldDef.args.map((arg) => arg.name);
            const suggestions = (0, _suggestionList.suggestionList)(argName, knownArgsNames);
            context.reportError(new _GraphQLError.GraphQLError(`Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + (0, _didYouMean.didYouMean)(suggestions), {
              nodes: argNode
            }));
          }
        }
      };
    }
    function KnownArgumentNamesOnDirectivesRule(context) {
      const directiveArgs = /* @__PURE__ */ Object.create(null);
      const schema = context.getSchema();
      const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
      for (const directive of definedDirectives) {
        directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
      }
      const astDefinitions = context.getDocument().definitions;
      for (const def of astDefinitions) {
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          var _def$arguments;
          const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
          directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
        }
      }
      return {
        Directive(directiveNode) {
          const directiveName = directiveNode.name.value;
          const knownArgs = directiveArgs[directiveName];
          if (directiveNode.arguments && knownArgs) {
            for (const argNode of directiveNode.arguments) {
              const argName = argNode.name.value;
              if (!knownArgs.includes(argName)) {
                const suggestions = (0, _suggestionList.suggestionList)(argName, knownArgs);
                context.reportError(new _GraphQLError.GraphQLError(`Unknown argument "${argName}" on directive "@${directiveName}".` + (0, _didYouMean.didYouMean)(suggestions), {
                  nodes: argNode
                }));
              }
            }
          }
          return false;
        }
      };
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/KnownDirectivesRule.js
var require_KnownDirectivesRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/KnownDirectivesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.KnownDirectivesRule = KnownDirectivesRule;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _GraphQLError = require_GraphQLError();
    var _ast = require_ast();
    var _directiveLocation = require_directiveLocation();
    var _kinds = require_kinds();
    var _directives = require_directives();
    function KnownDirectivesRule(context) {
      const locationsMap = /* @__PURE__ */ Object.create(null);
      const schema = context.getSchema();
      const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
      for (const directive of definedDirectives) {
        locationsMap[directive.name] = directive.locations;
      }
      const astDefinitions = context.getDocument().definitions;
      for (const def of astDefinitions) {
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          locationsMap[def.name.value] = def.locations.map((name) => name.value);
        }
      }
      return {
        Directive(node, _key, _parent, _path, ancestors) {
          const name = node.name.value;
          const locations = locationsMap[name];
          if (!locations) {
            context.reportError(new _GraphQLError.GraphQLError(`Unknown directive "@${name}".`, {
              nodes: node
            }));
            return;
          }
          const candidateLocation = getDirectiveLocationForASTPath(ancestors);
          if (candidateLocation && !locations.includes(candidateLocation)) {
            context.reportError(new _GraphQLError.GraphQLError(`Directive "@${name}" may not be used on ${candidateLocation}.`, {
              nodes: node
            }));
          }
        }
      };
    }
    function getDirectiveLocationForASTPath(ancestors) {
      const appliedTo = ancestors[ancestors.length - 1];
      "kind" in appliedTo || (0, _invariant.invariant)(false);
      switch (appliedTo.kind) {
        case _kinds.Kind.OPERATION_DEFINITION:
          return getDirectiveLocationForOperation(appliedTo.operation);
        case _kinds.Kind.FIELD:
          return _directiveLocation.DirectiveLocation.FIELD;
        case _kinds.Kind.FRAGMENT_SPREAD:
          return _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD;
        case _kinds.Kind.INLINE_FRAGMENT:
          return _directiveLocation.DirectiveLocation.INLINE_FRAGMENT;
        case _kinds.Kind.FRAGMENT_DEFINITION:
          return _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION;
        case _kinds.Kind.VARIABLE_DEFINITION:
          return _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION;
        case _kinds.Kind.SCHEMA_DEFINITION:
        case _kinds.Kind.SCHEMA_EXTENSION:
          return _directiveLocation.DirectiveLocation.SCHEMA;
        case _kinds.Kind.SCALAR_TYPE_DEFINITION:
        case _kinds.Kind.SCALAR_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.SCALAR;
        case _kinds.Kind.OBJECT_TYPE_DEFINITION:
        case _kinds.Kind.OBJECT_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.OBJECT;
        case _kinds.Kind.FIELD_DEFINITION:
          return _directiveLocation.DirectiveLocation.FIELD_DEFINITION;
        case _kinds.Kind.INTERFACE_TYPE_DEFINITION:
        case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.INTERFACE;
        case _kinds.Kind.UNION_TYPE_DEFINITION:
        case _kinds.Kind.UNION_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.UNION;
        case _kinds.Kind.ENUM_TYPE_DEFINITION:
        case _kinds.Kind.ENUM_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.ENUM;
        case _kinds.Kind.ENUM_VALUE_DEFINITION:
          return _directiveLocation.DirectiveLocation.ENUM_VALUE;
        case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION:
        case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.INPUT_OBJECT;
        case _kinds.Kind.INPUT_VALUE_DEFINITION: {
          const parentNode = ancestors[ancestors.length - 3];
          "kind" in parentNode || (0, _invariant.invariant)(false);
          return parentNode.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION ? _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION : _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION;
        }
        default:
          (0, _invariant.invariant)(false, "Unexpected kind: " + (0, _inspect.inspect)(appliedTo.kind));
      }
    }
    function getDirectiveLocationForOperation(operation) {
      switch (operation) {
        case _ast.OperationTypeNode.QUERY:
          return _directiveLocation.DirectiveLocation.QUERY;
        case _ast.OperationTypeNode.MUTATION:
          return _directiveLocation.DirectiveLocation.MUTATION;
        case _ast.OperationTypeNode.SUBSCRIPTION:
          return _directiveLocation.DirectiveLocation.SUBSCRIPTION;
      }
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/KnownFragmentNamesRule.js
var require_KnownFragmentNamesRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/KnownFragmentNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.KnownFragmentNamesRule = KnownFragmentNamesRule;
    var _GraphQLError = require_GraphQLError();
    function KnownFragmentNamesRule(context) {
      return {
        FragmentSpread(node) {
          const fragmentName = node.name.value;
          const fragment = context.getFragment(fragmentName);
          if (!fragment) {
            context.reportError(new _GraphQLError.GraphQLError(`Unknown fragment "${fragmentName}".`, {
              nodes: node.name
            }));
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/KnownTypeNamesRule.js
var require_KnownTypeNamesRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/KnownTypeNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.KnownTypeNamesRule = KnownTypeNamesRule;
    var _didYouMean = require_didYouMean();
    var _suggestionList = require_suggestionList();
    var _GraphQLError = require_GraphQLError();
    var _predicates = require_predicates();
    var _introspection = require_introspection();
    var _scalars = require_scalars();
    function KnownTypeNamesRule(context) {
      const schema = context.getSchema();
      const existingTypesMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
      const definedTypes = /* @__PURE__ */ Object.create(null);
      for (const def of context.getDocument().definitions) {
        if ((0, _predicates.isTypeDefinitionNode)(def)) {
          definedTypes[def.name.value] = true;
        }
      }
      const typeNames = [
        ...Object.keys(existingTypesMap),
        ...Object.keys(definedTypes)
      ];
      return {
        NamedType(node, _1, parent, _2, ancestors) {
          const typeName = node.name.value;
          if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
            var _ancestors$;
            const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
            const isSDL = definitionNode != null && isSDLNode(definitionNode);
            if (isSDL && standardTypeNames.includes(typeName)) {
              return;
            }
            const suggestedTypes = (0, _suggestionList.suggestionList)(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);
            context.reportError(new _GraphQLError.GraphQLError(`Unknown type "${typeName}".` + (0, _didYouMean.didYouMean)(suggestedTypes), {
              nodes: node
            }));
          }
        }
      };
    }
    var standardTypeNames = [
      ..._scalars.specifiedScalarTypes,
      ..._introspection.introspectionTypes
    ].map((type) => type.name);
    function isSDLNode(value) {
      return "kind" in value && ((0, _predicates.isTypeSystemDefinitionNode)(value) || (0, _predicates.isTypeSystemExtensionNode)(value));
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/LoneAnonymousOperationRule.js
var require_LoneAnonymousOperationRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/LoneAnonymousOperationRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.LoneAnonymousOperationRule = LoneAnonymousOperationRule;
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    function LoneAnonymousOperationRule(context) {
      let operationCount = 0;
      return {
        Document(node) {
          operationCount = node.definitions.filter((definition) => definition.kind === _kinds.Kind.OPERATION_DEFINITION).length;
        },
        OperationDefinition(node) {
          if (!node.name && operationCount > 1) {
            context.reportError(new _GraphQLError.GraphQLError("This anonymous operation must be the only defined operation.", {
              nodes: node
            }));
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.js
var require_LoneSchemaDefinitionRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.LoneSchemaDefinitionRule = LoneSchemaDefinitionRule;
    var _GraphQLError = require_GraphQLError();
    function LoneSchemaDefinitionRule(context) {
      var _ref, _ref2, _oldSchema$astNode;
      const oldSchema = context.getSchema();
      const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
      let schemaDefinitionsCount = 0;
      return {
        SchemaDefinition(node) {
          if (alreadyDefined) {
            context.reportError(new _GraphQLError.GraphQLError("Cannot define a new schema within a schema extension.", {
              nodes: node
            }));
            return;
          }
          if (schemaDefinitionsCount > 0) {
            context.reportError(new _GraphQLError.GraphQLError("Must provide only one schema definition.", {
              nodes: node
            }));
          }
          ++schemaDefinitionsCount;
        }
      };
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/NoFragmentCyclesRule.js
var require_NoFragmentCyclesRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/NoFragmentCyclesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NoFragmentCyclesRule = NoFragmentCyclesRule;
    var _GraphQLError = require_GraphQLError();
    function NoFragmentCyclesRule(context) {
      const visitedFrags = /* @__PURE__ */ Object.create(null);
      const spreadPath = [];
      const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
      return {
        OperationDefinition: () => false,
        FragmentDefinition(node) {
          detectCycleRecursive(node);
          return false;
        }
      };
      function detectCycleRecursive(fragment) {
        if (visitedFrags[fragment.name.value]) {
          return;
        }
        const fragmentName = fragment.name.value;
        visitedFrags[fragmentName] = true;
        const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
        if (spreadNodes.length === 0) {
          return;
        }
        spreadPathIndexByName[fragmentName] = spreadPath.length;
        for (const spreadNode of spreadNodes) {
          const spreadName = spreadNode.name.value;
          const cycleIndex = spreadPathIndexByName[spreadName];
          spreadPath.push(spreadNode);
          if (cycleIndex === void 0) {
            const spreadFragment = context.getFragment(spreadName);
            if (spreadFragment) {
              detectCycleRecursive(spreadFragment);
            }
          } else {
            const cyclePath = spreadPath.slice(cycleIndex);
            const viaPath = cyclePath.slice(0, -1).map((s) => '"' + s.name.value + '"').join(", ");
            context.reportError(new _GraphQLError.GraphQLError(`Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."), {
              nodes: cyclePath
            }));
          }
          spreadPath.pop();
        }
        spreadPathIndexByName[fragmentName] = void 0;
      }
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/NoUndefinedVariablesRule.js
var require_NoUndefinedVariablesRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/NoUndefinedVariablesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NoUndefinedVariablesRule = NoUndefinedVariablesRule;
    var _GraphQLError = require_GraphQLError();
    function NoUndefinedVariablesRule(context) {
      let variableNameDefined = /* @__PURE__ */ Object.create(null);
      return {
        OperationDefinition: {
          enter() {
            variableNameDefined = /* @__PURE__ */ Object.create(null);
          },
          leave(operation) {
            const usages = context.getRecursiveVariableUsages(operation);
            for (const { node } of usages) {
              const varName = node.name.value;
              if (variableNameDefined[varName] !== true) {
                context.reportError(new _GraphQLError.GraphQLError(operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`, {
                  nodes: [node, operation]
                }));
              }
            }
          }
        },
        VariableDefinition(node) {
          variableNameDefined[node.variable.name.value] = true;
        }
      };
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/NoUnusedFragmentsRule.js
var require_NoUnusedFragmentsRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/NoUnusedFragmentsRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NoUnusedFragmentsRule = NoUnusedFragmentsRule;
    var _GraphQLError = require_GraphQLError();
    function NoUnusedFragmentsRule(context) {
      const operationDefs = [];
      const fragmentDefs = [];
      return {
        OperationDefinition(node) {
          operationDefs.push(node);
          return false;
        },
        FragmentDefinition(node) {
          fragmentDefs.push(node);
          return false;
        },
        Document: {
          leave() {
            const fragmentNameUsed = /* @__PURE__ */ Object.create(null);
            for (const operation of operationDefs) {
              for (const fragment of context.getRecursivelyReferencedFragments(operation)) {
                fragmentNameUsed[fragment.name.value] = true;
              }
            }
            for (const fragmentDef of fragmentDefs) {
              const fragName = fragmentDef.name.value;
              if (fragmentNameUsed[fragName] !== true) {
                context.reportError(new _GraphQLError.GraphQLError(`Fragment "${fragName}" is never used.`, {
                  nodes: fragmentDef
                }));
              }
            }
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/NoUnusedVariablesRule.js
var require_NoUnusedVariablesRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/NoUnusedVariablesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NoUnusedVariablesRule = NoUnusedVariablesRule;
    var _GraphQLError = require_GraphQLError();
    function NoUnusedVariablesRule(context) {
      let variableDefs = [];
      return {
        OperationDefinition: {
          enter() {
            variableDefs = [];
          },
          leave(operation) {
            const variableNameUsed = /* @__PURE__ */ Object.create(null);
            const usages = context.getRecursiveVariableUsages(operation);
            for (const { node } of usages) {
              variableNameUsed[node.name.value] = true;
            }
            for (const variableDef of variableDefs) {
              const variableName = variableDef.variable.name.value;
              if (variableNameUsed[variableName] !== true) {
                context.reportError(new _GraphQLError.GraphQLError(operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`, {
                  nodes: variableDef
                }));
              }
            }
          }
        },
        VariableDefinition(def) {
          variableDefs.push(def);
        }
      };
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/sortValueNode.js
var require_sortValueNode = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/sortValueNode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.sortValueNode = sortValueNode;
    var _naturalCompare = require_naturalCompare();
    var _kinds = require_kinds();
    function sortValueNode(valueNode) {
      switch (valueNode.kind) {
        case _kinds.Kind.OBJECT:
          return { ...valueNode, fields: sortFields(valueNode.fields) };
        case _kinds.Kind.LIST:
          return { ...valueNode, values: valueNode.values.map(sortValueNode) };
        case _kinds.Kind.INT:
        case _kinds.Kind.FLOAT:
        case _kinds.Kind.STRING:
        case _kinds.Kind.BOOLEAN:
        case _kinds.Kind.NULL:
        case _kinds.Kind.ENUM:
        case _kinds.Kind.VARIABLE:
          return valueNode;
      }
    }
    function sortFields(fields) {
      return fields.map((fieldNode) => ({
        ...fieldNode,
        value: sortValueNode(fieldNode.value)
      })).sort((fieldA, fieldB) => (0, _naturalCompare.naturalCompare)(fieldA.name.value, fieldB.name.value));
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.js
var require_OverlappingFieldsCanBeMergedRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.OverlappingFieldsCanBeMergedRule = OverlappingFieldsCanBeMergedRule;
    var _inspect = require_inspect();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _definition = require_definition();
    var _sortValueNode = require_sortValueNode();
    var _typeFromAST = require_typeFromAST();
    function reasonMessage(reason) {
      if (Array.isArray(reason)) {
        return reason.map(([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)).join(" and ");
      }
      return reason;
    }
    function OverlappingFieldsCanBeMergedRule(context) {
      const comparedFragmentPairs = new PairSet();
      const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
      return {
        SelectionSet(selectionSet) {
          const conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);
          for (const [[responseName, reason], fields1, fields2] of conflicts) {
            const reasonMsg = reasonMessage(reason);
            context.reportError(new _GraphQLError.GraphQLError(`Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`, {
              nodes: fields1.concat(fields2)
            }));
          }
        }
      };
    }
    function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
      const conflicts = [];
      const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet);
      collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);
      if (fragmentNames.length !== 0) {
        for (let i = 0; i < fragmentNames.length; i++) {
          collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fieldMap, fragmentNames[i]);
          for (let j2 = i + 1; j2 < fragmentNames.length; j2++) {
            collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j2]);
          }
        }
      }
      return conflicts;
    }
    function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        return;
      }
      const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment);
      if (fieldMap === fieldMap2) {
        return;
      }
      collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2);
      for (const referencedFragmentName of referencedFragmentNames) {
        if (comparedFragmentPairs.has(referencedFragmentName, fragmentName, areMutuallyExclusive)) {
          continue;
        }
        comparedFragmentPairs.add(referencedFragmentName, fragmentName, areMutuallyExclusive);
        collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, referencedFragmentName);
      }
    }
    function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
      if (fragmentName1 === fragmentName2) {
        return;
      }
      if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {
        return;
      }
      comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
      const fragment1 = context.getFragment(fragmentName1);
      const fragment2 = context.getFragment(fragmentName2);
      if (!fragment1 || !fragment2) {
        return;
      }
      const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1);
      const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2);
      collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
      for (const referencedFragmentName2 of referencedFragmentNames2) {
        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, referencedFragmentName2);
      }
      for (const referencedFragmentName1 of referencedFragmentNames1) {
        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, referencedFragmentName1, fragmentName2);
      }
    }
    function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
      const conflicts = [];
      const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1);
      const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2);
      collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
      for (const fragmentName2 of fragmentNames2) {
        collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentName2);
      }
      for (const fragmentName1 of fragmentNames1) {
        collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentName1);
      }
      for (const fragmentName1 of fragmentNames1) {
        for (const fragmentName2 of fragmentNames2) {
          collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2);
        }
      }
      return conflicts;
    }
    function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
      for (const [responseName, fields] of Object.entries(fieldMap)) {
        if (fields.length > 1) {
          for (let i = 0; i < fields.length; i++) {
            for (let j2 = i + 1; j2 < fields.length; j2++) {
              const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, responseName, fields[i], fields[j2]);
              if (conflict) {
                conflicts.push(conflict);
              }
            }
          }
        }
      }
    }
    function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
      for (const [responseName, fields1] of Object.entries(fieldMap1)) {
        const fields2 = fieldMap2[responseName];
        if (fields2) {
          for (const field1 of fields1) {
            for (const field2 of fields2) {
              const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2);
              if (conflict) {
                conflicts.push(conflict);
              }
            }
          }
        }
      }
    }
    function findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
      const [parentType1, node1, def1] = field1;
      const [parentType2, node2, def2] = field2;
      const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && (0, _definition.isObjectType)(parentType1) && (0, _definition.isObjectType)(parentType2);
      if (!areMutuallyExclusive) {
        const name1 = node1.name.value;
        const name2 = node2.name.value;
        if (name1 !== name2) {
          return [
            [responseName, `"${name1}" and "${name2}" are different fields`],
            [node1],
            [node2]
          ];
        }
        if (stringifyArguments(node1) !== stringifyArguments(node2)) {
          return [
            [responseName, "they have differing arguments"],
            [node1],
            [node2]
          ];
        }
      }
      const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
      const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
      if (type1 && type2 && doTypesConflict(type1, type2)) {
        return [
          [
            responseName,
            `they return conflicting types "${(0, _inspect.inspect)(type1)}" and "${(0, _inspect.inspect)(type2)}"`
          ],
          [node1],
          [node2]
        ];
      }
      const selectionSet1 = node1.selectionSet;
      const selectionSet2 = node2.selectionSet;
      if (selectionSet1 && selectionSet2) {
        const conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, (0, _definition.getNamedType)(type1), selectionSet1, (0, _definition.getNamedType)(type2), selectionSet2);
        return subfieldConflicts(conflicts, responseName, node1, node2);
      }
    }
    function stringifyArguments(fieldNode) {
      var _fieldNode$arguments;
      const args = (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== void 0 ? _fieldNode$arguments : [];
      const inputObjectWithArgs = {
        kind: _kinds.Kind.OBJECT,
        fields: args.map((argNode) => ({
          kind: _kinds.Kind.OBJECT_FIELD,
          name: argNode.name,
          value: argNode.value
        }))
      };
      return (0, _printer.print)((0, _sortValueNode.sortValueNode)(inputObjectWithArgs));
    }
    function doTypesConflict(type1, type2) {
      if ((0, _definition.isListType)(type1)) {
        return (0, _definition.isListType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
      }
      if ((0, _definition.isListType)(type2)) {
        return true;
      }
      if ((0, _definition.isNonNullType)(type1)) {
        return (0, _definition.isNonNullType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
      }
      if ((0, _definition.isNonNullType)(type2)) {
        return true;
      }
      if ((0, _definition.isLeafType)(type1) || (0, _definition.isLeafType)(type2)) {
        return type1 !== type2;
      }
      return false;
    }
    function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
      const cached = cachedFieldsAndFragmentNames.get(selectionSet);
      if (cached) {
        return cached;
      }
      const nodeAndDefs = /* @__PURE__ */ Object.create(null);
      const fragmentNames = /* @__PURE__ */ Object.create(null);
      _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);
      const result = [nodeAndDefs, Object.keys(fragmentNames)];
      cachedFieldsAndFragmentNames.set(selectionSet, result);
      return result;
    }
    function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
      const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
      if (cached) {
        return cached;
      }
      const fragmentType = (0, _typeFromAST.typeFromAST)(context.getSchema(), fragment.typeCondition);
      return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);
    }
    function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
      for (const selection of selectionSet.selections) {
        switch (selection.kind) {
          case _kinds.Kind.FIELD: {
            const fieldName = selection.name.value;
            let fieldDef;
            if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
              fieldDef = parentType.getFields()[fieldName];
            }
            const responseName = selection.alias ? selection.alias.value : fieldName;
            if (!nodeAndDefs[responseName]) {
              nodeAndDefs[responseName] = [];
            }
            nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
            break;
          }
          case _kinds.Kind.FRAGMENT_SPREAD:
            fragmentNames[selection.name.value] = true;
            break;
          case _kinds.Kind.INLINE_FRAGMENT: {
            const typeCondition = selection.typeCondition;
            const inlineFragmentType = typeCondition ? (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition) : parentType;
            _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);
            break;
          }
        }
      }
    }
    function subfieldConflicts(conflicts, responseName, node1, node2) {
      if (conflicts.length > 0) {
        return [
          [responseName, conflicts.map(([reason]) => reason)],
          [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
          [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
        ];
      }
    }
    var PairSet = class {
      constructor() {
        this._data = /* @__PURE__ */ new Map();
      }
      has(a, b, areMutuallyExclusive) {
        var _this$_data$get;
        const [key1, key2] = a < b ? [a, b] : [b, a];
        const result = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(key2);
        if (result === void 0) {
          return false;
        }
        return areMutuallyExclusive ? true : areMutuallyExclusive === result;
      }
      add(a, b, areMutuallyExclusive) {
        const [key1, key2] = a < b ? [a, b] : [b, a];
        const map3 = this._data.get(key1);
        if (map3 === void 0) {
          this._data.set(key1, /* @__PURE__ */ new Map([[key2, areMutuallyExclusive]]));
        } else {
          map3.set(key2, areMutuallyExclusive);
        }
      }
    };
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js
var require_PossibleFragmentSpreadsRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.PossibleFragmentSpreadsRule = PossibleFragmentSpreadsRule;
    var _inspect = require_inspect();
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    var _typeComparators = require_typeComparators();
    var _typeFromAST = require_typeFromAST();
    function PossibleFragmentSpreadsRule(context) {
      return {
        InlineFragment(node) {
          const fragType = context.getType();
          const parentType = context.getParentType();
          if ((0, _definition.isCompositeType)(fragType) && (0, _definition.isCompositeType)(parentType) && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {
            const parentTypeStr = (0, _inspect.inspect)(parentType);
            const fragTypeStr = (0, _inspect.inspect)(fragType);
            context.reportError(new _GraphQLError.GraphQLError(`Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`, {
              nodes: node
            }));
          }
        },
        FragmentSpread(node) {
          const fragName = node.name.value;
          const fragType = getFragmentType(context, fragName);
          const parentType = context.getParentType();
          if (fragType && parentType && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {
            const parentTypeStr = (0, _inspect.inspect)(parentType);
            const fragTypeStr = (0, _inspect.inspect)(fragType);
            context.reportError(new _GraphQLError.GraphQLError(`Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`, {
              nodes: node
            }));
          }
        }
      };
    }
    function getFragmentType(context, name) {
      const frag = context.getFragment(name);
      if (frag) {
        const type = (0, _typeFromAST.typeFromAST)(context.getSchema(), frag.typeCondition);
        if ((0, _definition.isCompositeType)(type)) {
          return type;
        }
      }
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.js
var require_PossibleTypeExtensionsRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.PossibleTypeExtensionsRule = PossibleTypeExtensionsRule;
    var _didYouMean = require_didYouMean();
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _suggestionList = require_suggestionList();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _predicates = require_predicates();
    var _definition = require_definition();
    function PossibleTypeExtensionsRule(context) {
      const schema = context.getSchema();
      const definedTypes = /* @__PURE__ */ Object.create(null);
      for (const def of context.getDocument().definitions) {
        if ((0, _predicates.isTypeDefinitionNode)(def)) {
          definedTypes[def.name.value] = def;
        }
      }
      return {
        ScalarTypeExtension: checkExtension,
        ObjectTypeExtension: checkExtension,
        InterfaceTypeExtension: checkExtension,
        UnionTypeExtension: checkExtension,
        EnumTypeExtension: checkExtension,
        InputObjectTypeExtension: checkExtension
      };
      function checkExtension(node) {
        const typeName = node.name.value;
        const defNode = definedTypes[typeName];
        const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
        let expectedKind;
        if (defNode) {
          expectedKind = defKindToExtKind[defNode.kind];
        } else if (existingType) {
          expectedKind = typeToExtKind(existingType);
        }
        if (expectedKind) {
          if (expectedKind !== node.kind) {
            const kindStr = extensionKindToTypeName(node.kind);
            context.reportError(new _GraphQLError.GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
              nodes: defNode ? [defNode, node] : node
            }));
          }
        } else {
          const allTypeNames = Object.keys({
            ...definedTypes,
            ...schema === null || schema === void 0 ? void 0 : schema.getTypeMap()
          });
          const suggestedTypes = (0, _suggestionList.suggestionList)(typeName, allTypeNames);
          context.reportError(new _GraphQLError.GraphQLError(`Cannot extend type "${typeName}" because it is not defined.` + (0, _didYouMean.didYouMean)(suggestedTypes), {
            nodes: node.name
          }));
        }
      }
    }
    var defKindToExtKind = {
      [_kinds.Kind.SCALAR_TYPE_DEFINITION]: _kinds.Kind.SCALAR_TYPE_EXTENSION,
      [_kinds.Kind.OBJECT_TYPE_DEFINITION]: _kinds.Kind.OBJECT_TYPE_EXTENSION,
      [_kinds.Kind.INTERFACE_TYPE_DEFINITION]: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
      [_kinds.Kind.UNION_TYPE_DEFINITION]: _kinds.Kind.UNION_TYPE_EXTENSION,
      [_kinds.Kind.ENUM_TYPE_DEFINITION]: _kinds.Kind.ENUM_TYPE_EXTENSION,
      [_kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION]: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION
    };
    function typeToExtKind(type) {
      if ((0, _definition.isScalarType)(type)) {
        return _kinds.Kind.SCALAR_TYPE_EXTENSION;
      }
      if ((0, _definition.isObjectType)(type)) {
        return _kinds.Kind.OBJECT_TYPE_EXTENSION;
      }
      if ((0, _definition.isInterfaceType)(type)) {
        return _kinds.Kind.INTERFACE_TYPE_EXTENSION;
      }
      if ((0, _definition.isUnionType)(type)) {
        return _kinds.Kind.UNION_TYPE_EXTENSION;
      }
      if ((0, _definition.isEnumType)(type)) {
        return _kinds.Kind.ENUM_TYPE_EXTENSION;
      }
      if ((0, _definition.isInputObjectType)(type)) {
        return _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
      }
      (0, _invariant.invariant)(false, "Unexpected type: " + (0, _inspect.inspect)(type));
    }
    function extensionKindToTypeName(kind) {
      switch (kind) {
        case _kinds.Kind.SCALAR_TYPE_EXTENSION:
          return "scalar";
        case _kinds.Kind.OBJECT_TYPE_EXTENSION:
          return "object";
        case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
          return "interface";
        case _kinds.Kind.UNION_TYPE_EXTENSION:
          return "union";
        case _kinds.Kind.ENUM_TYPE_EXTENSION:
          return "enum";
        case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
          return "input object";
        default:
          (0, _invariant.invariant)(false, "Unexpected kind: " + (0, _inspect.inspect)(kind));
      }
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.js
var require_ProvidedRequiredArgumentsRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ProvidedRequiredArgumentsOnDirectivesRule = ProvidedRequiredArgumentsOnDirectivesRule;
    exports2.ProvidedRequiredArgumentsRule = ProvidedRequiredArgumentsRule;
    var _inspect = require_inspect();
    var _keyMap = require_keyMap();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _definition = require_definition();
    var _directives = require_directives();
    function ProvidedRequiredArgumentsRule(context) {
      return {
        ...ProvidedRequiredArgumentsOnDirectivesRule(context),
        Field: {
          leave(fieldNode) {
            var _fieldNode$arguments;
            const fieldDef = context.getFieldDef();
            if (!fieldDef) {
              return false;
            }
            const providedArgs = new Set((_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value));
            for (const argDef of fieldDef.args) {
              if (!providedArgs.has(argDef.name) && (0, _definition.isRequiredArgument)(argDef)) {
                const argTypeStr = (0, _inspect.inspect)(argDef.type);
                context.reportError(new _GraphQLError.GraphQLError(`Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`, {
                  nodes: fieldNode
                }));
              }
            }
          }
        }
      };
    }
    function ProvidedRequiredArgumentsOnDirectivesRule(context) {
      var _schema$getDirectives;
      const requiredArgsMap = /* @__PURE__ */ Object.create(null);
      const schema = context.getSchema();
      const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : _directives.specifiedDirectives;
      for (const directive of definedDirectives) {
        requiredArgsMap[directive.name] = (0, _keyMap.keyMap)(directive.args.filter(_definition.isRequiredArgument), (arg) => arg.name);
      }
      const astDefinitions = context.getDocument().definitions;
      for (const def of astDefinitions) {
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          var _def$arguments;
          const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
          requiredArgsMap[def.name.value] = (0, _keyMap.keyMap)(argNodes.filter(isRequiredArgumentNode), (arg) => arg.name.value);
        }
      }
      return {
        Directive: {
          leave(directiveNode) {
            const directiveName = directiveNode.name.value;
            const requiredArgs = requiredArgsMap[directiveName];
            if (requiredArgs) {
              var _directiveNode$argume;
              const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
              const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
              for (const [argName, argDef] of Object.entries(requiredArgs)) {
                if (!argNodeMap.has(argName)) {
                  const argType = (0, _definition.isType)(argDef.type) ? (0, _inspect.inspect)(argDef.type) : (0, _printer.print)(argDef.type);
                  context.reportError(new _GraphQLError.GraphQLError(`Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`, {
                    nodes: directiveNode
                  }));
                }
              }
            }
          }
        }
      };
    }
    function isRequiredArgumentNode(arg) {
      return arg.type.kind === _kinds.Kind.NON_NULL_TYPE && arg.defaultValue == null;
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/ScalarLeafsRule.js
var require_ScalarLeafsRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/ScalarLeafsRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ScalarLeafsRule = ScalarLeafsRule;
    var _inspect = require_inspect();
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function ScalarLeafsRule(context) {
      return {
        Field(node) {
          const type = context.getType();
          const selectionSet = node.selectionSet;
          if (type) {
            if ((0, _definition.isLeafType)((0, _definition.getNamedType)(type))) {
              if (selectionSet) {
                const fieldName = node.name.value;
                const typeStr = (0, _inspect.inspect)(type);
                context.reportError(new _GraphQLError.GraphQLError(`Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`, {
                  nodes: selectionSet
                }));
              }
            } else if (!selectionSet) {
              const fieldName = node.name.value;
              const typeStr = (0, _inspect.inspect)(type);
              context.reportError(new _GraphQLError.GraphQLError(`Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`, {
                nodes: node
              }));
            }
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/printPathArray.js
var require_printPathArray = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/printPathArray.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.printPathArray = printPathArray;
    function printPathArray(path) {
      return path.map((key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key).join("");
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/Path.js
var require_Path = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/Path.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.addPath = addPath;
    exports2.pathToArray = pathToArray;
    function addPath(prev, key, typename) {
      return {
        prev,
        key,
        typename
      };
    }
    function pathToArray(path) {
      const flattened = [];
      let curr = path;
      while (curr) {
        flattened.push(curr.key);
        curr = curr.prev;
      }
      return flattened.reverse();
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/coerceInputValue.js
var require_coerceInputValue = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/coerceInputValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.coerceInputValue = coerceInputValue;
    var _didYouMean = require_didYouMean();
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _isIterableObject = require_isIterableObject();
    var _isObjectLike = require_isObjectLike();
    var _Path = require_Path();
    var _printPathArray = require_printPathArray();
    var _suggestionList = require_suggestionList();
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function coerceInputValue(inputValue, type, onError = defaultOnError) {
      return coerceInputValueImpl(inputValue, type, onError, void 0);
    }
    function defaultOnError(path, invalidValue, error2) {
      let errorPrefix = "Invalid value " + (0, _inspect.inspect)(invalidValue);
      if (path.length > 0) {
        errorPrefix += ` at "value${(0, _printPathArray.printPathArray)(path)}"`;
      }
      error2.message = errorPrefix + ": " + error2.message;
      throw error2;
    }
    function coerceInputValueImpl(inputValue, type, onError, path) {
      if ((0, _definition.isNonNullType)(type)) {
        if (inputValue != null) {
          return coerceInputValueImpl(inputValue, type.ofType, onError, path);
        }
        onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Expected non-nullable type "${(0, _inspect.inspect)(type)}" not to be null.`));
        return;
      }
      if (inputValue == null) {
        return null;
      }
      if ((0, _definition.isListType)(type)) {
        const itemType = type.ofType;
        if ((0, _isIterableObject.isIterableObject)(inputValue)) {
          return Array.from(inputValue, (itemValue, index) => {
            const itemPath = (0, _Path.addPath)(path, index, void 0);
            return coerceInputValueImpl(itemValue, itemType, onError, itemPath);
          });
        }
        return [coerceInputValueImpl(inputValue, itemType, onError, path)];
      }
      if ((0, _definition.isInputObjectType)(type)) {
        if (!(0, _isObjectLike.isObjectLike)(inputValue)) {
          onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Expected type "${type.name}" to be an object.`));
          return;
        }
        const coercedValue = {};
        const fieldDefs = type.getFields();
        for (const field of Object.values(fieldDefs)) {
          const fieldValue = inputValue[field.name];
          if (fieldValue === void 0) {
            if (field.defaultValue !== void 0) {
              coercedValue[field.name] = field.defaultValue;
            } else if ((0, _definition.isNonNullType)(field.type)) {
              const typeStr = (0, _inspect.inspect)(field.type);
              onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Field "${field.name}" of required type "${typeStr}" was not provided.`));
            }
            continue;
          }
          coercedValue[field.name] = coerceInputValueImpl(fieldValue, field.type, onError, (0, _Path.addPath)(path, field.name, type.name));
        }
        for (const fieldName of Object.keys(inputValue)) {
          if (!fieldDefs[fieldName]) {
            const suggestions = (0, _suggestionList.suggestionList)(fieldName, Object.keys(type.getFields()));
            onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Field "${fieldName}" is not defined by type "${type.name}".` + (0, _didYouMean.didYouMean)(suggestions)));
          }
        }
        return coercedValue;
      }
      if ((0, _definition.isLeafType)(type)) {
        let parseResult;
        try {
          parseResult = type.parseValue(inputValue);
        } catch (error2) {
          if (error2 instanceof _GraphQLError.GraphQLError) {
            onError((0, _Path.pathToArray)(path), inputValue, error2);
          } else {
            onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Expected type "${type.name}". ` + error2.message, {
              originalError: error2
            }));
          }
          return;
        }
        if (parseResult === void 0) {
          onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Expected type "${type.name}".`));
        }
        return parseResult;
      }
      (0, _invariant.invariant)(false, "Unexpected input type: " + (0, _inspect.inspect)(type));
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/valueFromAST.js
var require_valueFromAST = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/valueFromAST.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.valueFromAST = valueFromAST2;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _keyMap = require_keyMap();
    var _kinds = require_kinds();
    var _definition = require_definition();
    function valueFromAST2(valueNode, type, variables) {
      if (!valueNode) {
        return;
      }
      if (valueNode.kind === _kinds.Kind.VARIABLE) {
        const variableName = valueNode.name.value;
        if (variables == null || variables[variableName] === void 0) {
          return;
        }
        const variableValue = variables[variableName];
        if (variableValue === null && (0, _definition.isNonNullType)(type)) {
          return;
        }
        return variableValue;
      }
      if ((0, _definition.isNonNullType)(type)) {
        if (valueNode.kind === _kinds.Kind.NULL) {
          return;
        }
        return valueFromAST2(valueNode, type.ofType, variables);
      }
      if (valueNode.kind === _kinds.Kind.NULL) {
        return null;
      }
      if ((0, _definition.isListType)(type)) {
        const itemType = type.ofType;
        if (valueNode.kind === _kinds.Kind.LIST) {
          const coercedValues = [];
          for (const itemNode of valueNode.values) {
            if (isMissingVariable(itemNode, variables)) {
              if ((0, _definition.isNonNullType)(itemType)) {
                return;
              }
              coercedValues.push(null);
            } else {
              const itemValue = valueFromAST2(itemNode, itemType, variables);
              if (itemValue === void 0) {
                return;
              }
              coercedValues.push(itemValue);
            }
          }
          return coercedValues;
        }
        const coercedValue = valueFromAST2(valueNode, itemType, variables);
        if (coercedValue === void 0) {
          return;
        }
        return [coercedValue];
      }
      if ((0, _definition.isInputObjectType)(type)) {
        if (valueNode.kind !== _kinds.Kind.OBJECT) {
          return;
        }
        const coercedObj = /* @__PURE__ */ Object.create(null);
        const fieldNodes = (0, _keyMap.keyMap)(valueNode.fields, (field) => field.name.value);
        for (const field of Object.values(type.getFields())) {
          const fieldNode = fieldNodes[field.name];
          if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
            if (field.defaultValue !== void 0) {
              coercedObj[field.name] = field.defaultValue;
            } else if ((0, _definition.isNonNullType)(field.type)) {
              return;
            }
            continue;
          }
          const fieldValue = valueFromAST2(fieldNode.value, field.type, variables);
          if (fieldValue === void 0) {
            return;
          }
          coercedObj[field.name] = fieldValue;
        }
        return coercedObj;
      }
      if ((0, _definition.isLeafType)(type)) {
        let result;
        try {
          result = type.parseLiteral(valueNode, variables);
        } catch (_error) {
          return;
        }
        if (result === void 0) {
          return;
        }
        return result;
      }
      (0, _invariant.invariant)(false, "Unexpected input type: " + (0, _inspect.inspect)(type));
    }
    function isMissingVariable(valueNode, variables) {
      return valueNode.kind === _kinds.Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/execution/values.js
var require_values = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/execution/values.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getArgumentValues = getArgumentValues2;
    exports2.getDirectiveValues = getDirectiveValues2;
    exports2.getVariableValues = getVariableValues;
    var _inspect = require_inspect();
    var _keyMap = require_keyMap();
    var _printPathArray = require_printPathArray();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _definition = require_definition();
    var _coerceInputValue = require_coerceInputValue();
    var _typeFromAST = require_typeFromAST();
    var _valueFromAST = require_valueFromAST();
    function getVariableValues(schema, varDefNodes, inputs, options2) {
      const errors2 = [];
      const maxErrors = options2 === null || options2 === void 0 ? void 0 : options2.maxErrors;
      try {
        const coerced = coerceVariableValues(schema, varDefNodes, inputs, (error2) => {
          if (maxErrors != null && errors2.length >= maxErrors) {
            throw new _GraphQLError.GraphQLError("Too many errors processing variables, error limit reached. Execution aborted.");
          }
          errors2.push(error2);
        });
        if (errors2.length === 0) {
          return {
            coerced
          };
        }
      } catch (error2) {
        errors2.push(error2);
      }
      return {
        errors: errors2
      };
    }
    function coerceVariableValues(schema, varDefNodes, inputs, onError) {
      const coercedValues = {};
      for (const varDefNode of varDefNodes) {
        const varName = varDefNode.variable.name.value;
        const varType = (0, _typeFromAST.typeFromAST)(schema, varDefNode.type);
        if (!(0, _definition.isInputType)(varType)) {
          const varTypeStr = (0, _printer.print)(varDefNode.type);
          onError(new _GraphQLError.GraphQLError(`Variable "$${varName}" expected value of type "${varTypeStr}" which cannot be used as an input type.`, {
            nodes: varDefNode.type
          }));
          continue;
        }
        if (!hasOwnProperty3(inputs, varName)) {
          if (varDefNode.defaultValue) {
            coercedValues[varName] = (0, _valueFromAST.valueFromAST)(varDefNode.defaultValue, varType);
          } else if ((0, _definition.isNonNullType)(varType)) {
            const varTypeStr = (0, _inspect.inspect)(varType);
            onError(new _GraphQLError.GraphQLError(`Variable "$${varName}" of required type "${varTypeStr}" was not provided.`, {
              nodes: varDefNode
            }));
          }
          continue;
        }
        const value = inputs[varName];
        if (value === null && (0, _definition.isNonNullType)(varType)) {
          const varTypeStr = (0, _inspect.inspect)(varType);
          onError(new _GraphQLError.GraphQLError(`Variable "$${varName}" of non-null type "${varTypeStr}" must not be null.`, {
            nodes: varDefNode
          }));
          continue;
        }
        coercedValues[varName] = (0, _coerceInputValue.coerceInputValue)(value, varType, (path, invalidValue, error2) => {
          let prefix = `Variable "$${varName}" got invalid value ` + (0, _inspect.inspect)(invalidValue);
          if (path.length > 0) {
            prefix += ` at "${varName}${(0, _printPathArray.printPathArray)(path)}"`;
          }
          onError(new _GraphQLError.GraphQLError(prefix + "; " + error2.message, {
            nodes: varDefNode,
            originalError: error2.originalError
          }));
        });
      }
      return coercedValues;
    }
    function getArgumentValues2(def, node, variableValues) {
      var _node$arguments;
      const coercedValues = {};
      const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
      const argNodeMap = (0, _keyMap.keyMap)(argumentNodes, (arg) => arg.name.value);
      for (const argDef of def.args) {
        const name = argDef.name;
        const argType = argDef.type;
        const argumentNode = argNodeMap[name];
        if (!argumentNode) {
          if (argDef.defaultValue !== void 0) {
            coercedValues[name] = argDef.defaultValue;
          } else if ((0, _definition.isNonNullType)(argType)) {
            throw new _GraphQLError.GraphQLError(`Argument "${name}" of required type "${(0, _inspect.inspect)(argType)}" was not provided.`, {
              nodes: node
            });
          }
          continue;
        }
        const valueNode = argumentNode.value;
        let isNull2 = valueNode.kind === _kinds.Kind.NULL;
        if (valueNode.kind === _kinds.Kind.VARIABLE) {
          const variableName = valueNode.name.value;
          if (variableValues == null || !hasOwnProperty3(variableValues, variableName)) {
            if (argDef.defaultValue !== void 0) {
              coercedValues[name] = argDef.defaultValue;
            } else if ((0, _definition.isNonNullType)(argType)) {
              throw new _GraphQLError.GraphQLError(`Argument "${name}" of required type "${(0, _inspect.inspect)(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`, {
                nodes: valueNode
              });
            }
            continue;
          }
          isNull2 = variableValues[variableName] == null;
        }
        if (isNull2 && (0, _definition.isNonNullType)(argType)) {
          throw new _GraphQLError.GraphQLError(`Argument "${name}" of non-null type "${(0, _inspect.inspect)(argType)}" must not be null.`, {
            nodes: valueNode
          });
        }
        const coercedValue = (0, _valueFromAST.valueFromAST)(valueNode, argType, variableValues);
        if (coercedValue === void 0) {
          throw new _GraphQLError.GraphQLError(`Argument "${name}" has invalid value ${(0, _printer.print)(valueNode)}.`, {
            nodes: valueNode
          });
        }
        coercedValues[name] = coercedValue;
      }
      return coercedValues;
    }
    function getDirectiveValues2(directiveDef, node, variableValues) {
      var _node$directives;
      const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find((directive) => directive.name.value === directiveDef.name);
      if (directiveNode) {
        return getArgumentValues2(directiveDef, directiveNode, variableValues);
      }
    }
    function hasOwnProperty3(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/execution/collectFields.js
var require_collectFields = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/execution/collectFields.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.collectFields = collectFields2;
    exports2.collectSubfields = collectSubfields;
    var _kinds = require_kinds();
    var _definition = require_definition();
    var _directives = require_directives();
    var _typeFromAST = require_typeFromAST();
    var _values = require_values();
    function collectFields2(schema, fragments, variableValues, runtimeType, selectionSet) {
      const fields = /* @__PURE__ */ new Map();
      collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, /* @__PURE__ */ new Set());
      return fields;
    }
    function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
      const subFieldNodes = /* @__PURE__ */ new Map();
      const visitedFragmentNames = /* @__PURE__ */ new Set();
      for (const node of fieldNodes) {
        if (node.selectionSet) {
          collectFieldsImpl(schema, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, visitedFragmentNames);
        }
      }
      return subFieldNodes;
    }
    function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
      for (const selection of selectionSet.selections) {
        switch (selection.kind) {
          case _kinds.Kind.FIELD: {
            if (!shouldIncludeNode2(variableValues, selection)) {
              continue;
            }
            const name = getFieldEntryKey2(selection);
            const fieldList = fields.get(name);
            if (fieldList !== void 0) {
              fieldList.push(selection);
            } else {
              fields.set(name, [selection]);
            }
            break;
          }
          case _kinds.Kind.INLINE_FRAGMENT: {
            if (!shouldIncludeNode2(variableValues, selection) || !doesFragmentConditionMatch2(schema, selection, runtimeType)) {
              continue;
            }
            collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
            break;
          }
          case _kinds.Kind.FRAGMENT_SPREAD: {
            const fragName = selection.name.value;
            if (visitedFragmentNames.has(fragName) || !shouldIncludeNode2(variableValues, selection)) {
              continue;
            }
            visitedFragmentNames.add(fragName);
            const fragment = fragments[fragName];
            if (!fragment || !doesFragmentConditionMatch2(schema, fragment, runtimeType)) {
              continue;
            }
            collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
            break;
          }
        }
      }
    }
    function shouldIncludeNode2(variableValues, node) {
      const skip = (0, _values.getDirectiveValues)(_directives.GraphQLSkipDirective, node, variableValues);
      if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
        return false;
      }
      const include = (0, _values.getDirectiveValues)(_directives.GraphQLIncludeDirective, node, variableValues);
      if ((include === null || include === void 0 ? void 0 : include.if) === false) {
        return false;
      }
      return true;
    }
    function doesFragmentConditionMatch2(schema, fragment, type) {
      const typeConditionNode = fragment.typeCondition;
      if (!typeConditionNode) {
        return true;
      }
      const conditionalType = (0, _typeFromAST.typeFromAST)(schema, typeConditionNode);
      if (conditionalType === type) {
        return true;
      }
      if ((0, _definition.isAbstractType)(conditionalType)) {
        return schema.isSubType(conditionalType, type);
      }
      return false;
    }
    function getFieldEntryKey2(node) {
      return node.alias ? node.alias.value : node.name.value;
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.js
var require_SingleFieldSubscriptionsRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.SingleFieldSubscriptionsRule = SingleFieldSubscriptionsRule;
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _collectFields = require_collectFields();
    function SingleFieldSubscriptionsRule(context) {
      return {
        OperationDefinition(node) {
          if (node.operation === "subscription") {
            const schema = context.getSchema();
            const subscriptionType = schema.getSubscriptionType();
            if (subscriptionType) {
              const operationName = node.name ? node.name.value : null;
              const variableValues = /* @__PURE__ */ Object.create(null);
              const document = context.getDocument();
              const fragments = /* @__PURE__ */ Object.create(null);
              for (const definition of document.definitions) {
                if (definition.kind === _kinds.Kind.FRAGMENT_DEFINITION) {
                  fragments[definition.name.value] = definition;
                }
              }
              const fields = (0, _collectFields.collectFields)(schema, fragments, variableValues, subscriptionType, node.selectionSet);
              if (fields.size > 1) {
                const fieldSelectionLists = [...fields.values()];
                const extraFieldSelectionLists = fieldSelectionLists.slice(1);
                const extraFieldSelections = extraFieldSelectionLists.flat();
                context.reportError(new _GraphQLError.GraphQLError(operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.", {
                  nodes: extraFieldSelections
                }));
              }
              for (const fieldNodes of fields.values()) {
                const field = fieldNodes[0];
                const fieldName = field.name.value;
                if (fieldName.startsWith("__")) {
                  context.reportError(new _GraphQLError.GraphQLError(operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.", {
                    nodes: fieldNodes
                  }));
                }
              }
            }
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/groupBy.js
var require_groupBy = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/groupBy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.groupBy = groupBy;
    function groupBy(list, keyFn) {
      const result = /* @__PURE__ */ new Map();
      for (const item of list) {
        const key = keyFn(item);
        const group = result.get(key);
        if (group === void 0) {
          result.set(key, [item]);
        } else {
          group.push(item);
        }
      }
      return result;
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.js
var require_UniqueArgumentDefinitionNamesRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueArgumentDefinitionNamesRule = UniqueArgumentDefinitionNamesRule;
    var _groupBy = require_groupBy();
    var _GraphQLError = require_GraphQLError();
    function UniqueArgumentDefinitionNamesRule(context) {
      return {
        DirectiveDefinition(directiveNode) {
          var _directiveNode$argume;
          const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
          return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
        },
        InterfaceTypeDefinition: checkArgUniquenessPerField,
        InterfaceTypeExtension: checkArgUniquenessPerField,
        ObjectTypeDefinition: checkArgUniquenessPerField,
        ObjectTypeExtension: checkArgUniquenessPerField
      };
      function checkArgUniquenessPerField(typeNode) {
        var _typeNode$fields;
        const typeName = typeNode.name.value;
        const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
        for (const fieldDef of fieldNodes) {
          var _fieldDef$arguments;
          const fieldName = fieldDef.name.value;
          const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
          checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
        }
        return false;
      }
      function checkArgUniqueness(parentName, argumentNodes) {
        const seenArgs = (0, _groupBy.groupBy)(argumentNodes, (arg) => arg.name.value);
        for (const [argName, argNodes] of seenArgs) {
          if (argNodes.length > 1) {
            context.reportError(new _GraphQLError.GraphQLError(`Argument "${parentName}(${argName}:)" can only be defined once.`, {
              nodes: argNodes.map((node) => node.name)
            }));
          }
        }
        return false;
      }
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/UniqueArgumentNamesRule.js
var require_UniqueArgumentNamesRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/UniqueArgumentNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueArgumentNamesRule = UniqueArgumentNamesRule;
    var _groupBy = require_groupBy();
    var _GraphQLError = require_GraphQLError();
    function UniqueArgumentNamesRule(context) {
      return {
        Field: checkArgUniqueness,
        Directive: checkArgUniqueness
      };
      function checkArgUniqueness(parentNode) {
        var _parentNode$arguments;
        const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
        const seenArgs = (0, _groupBy.groupBy)(argumentNodes, (arg) => arg.name.value);
        for (const [argName, argNodes] of seenArgs) {
          if (argNodes.length > 1) {
            context.reportError(new _GraphQLError.GraphQLError(`There can be only one argument named "${argName}".`, {
              nodes: argNodes.map((node) => node.name)
            }));
          }
        }
      }
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.js
var require_UniqueDirectiveNamesRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueDirectiveNamesRule = UniqueDirectiveNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueDirectiveNamesRule(context) {
      const knownDirectiveNames = /* @__PURE__ */ Object.create(null);
      const schema = context.getSchema();
      return {
        DirectiveDefinition(node) {
          const directiveName = node.name.value;
          if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
            context.reportError(new _GraphQLError.GraphQLError(`Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`, {
              nodes: node.name
            }));
            return;
          }
          if (knownDirectiveNames[directiveName]) {
            context.reportError(new _GraphQLError.GraphQLError(`There can be only one directive named "@${directiveName}".`, {
              nodes: [knownDirectiveNames[directiveName], node.name]
            }));
          } else {
            knownDirectiveNames[directiveName] = node.name;
          }
          return false;
        }
      };
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.js
var require_UniqueDirectivesPerLocationRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueDirectivesPerLocationRule = UniqueDirectivesPerLocationRule;
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _predicates = require_predicates();
    var _directives = require_directives();
    function UniqueDirectivesPerLocationRule(context) {
      const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
      const schema = context.getSchema();
      const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
      for (const directive of definedDirectives) {
        uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
      }
      const astDefinitions = context.getDocument().definitions;
      for (const def of astDefinitions) {
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          uniqueDirectiveMap[def.name.value] = !def.repeatable;
        }
      }
      const schemaDirectives = /* @__PURE__ */ Object.create(null);
      const typeDirectivesMap = /* @__PURE__ */ Object.create(null);
      return {
        enter(node) {
          if (!("directives" in node) || !node.directives) {
            return;
          }
          let seenDirectives;
          if (node.kind === _kinds.Kind.SCHEMA_DEFINITION || node.kind === _kinds.Kind.SCHEMA_EXTENSION) {
            seenDirectives = schemaDirectives;
          } else if ((0, _predicates.isTypeDefinitionNode)(node) || (0, _predicates.isTypeExtensionNode)(node)) {
            const typeName = node.name.value;
            seenDirectives = typeDirectivesMap[typeName];
            if (seenDirectives === void 0) {
              typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
            }
          } else {
            seenDirectives = /* @__PURE__ */ Object.create(null);
          }
          for (const directive of node.directives) {
            const directiveName = directive.name.value;
            if (uniqueDirectiveMap[directiveName]) {
              if (seenDirectives[directiveName]) {
                context.reportError(new _GraphQLError.GraphQLError(`The directive "@${directiveName}" can only be used once at this location.`, {
                  nodes: [seenDirectives[directiveName], directive]
                }));
              } else {
                seenDirectives[directiveName] = directive;
              }
            }
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.js
var require_UniqueEnumValueNamesRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueEnumValueNamesRule = UniqueEnumValueNamesRule;
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function UniqueEnumValueNamesRule(context) {
      const schema = context.getSchema();
      const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
      const knownValueNames = /* @__PURE__ */ Object.create(null);
      return {
        EnumTypeDefinition: checkValueUniqueness,
        EnumTypeExtension: checkValueUniqueness
      };
      function checkValueUniqueness(node) {
        var _node$values;
        const typeName = node.name.value;
        if (!knownValueNames[typeName]) {
          knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
        }
        const valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
        const valueNames = knownValueNames[typeName];
        for (const valueDef of valueNodes) {
          const valueName = valueDef.name.value;
          const existingType = existingTypeMap[typeName];
          if ((0, _definition.isEnumType)(existingType) && existingType.getValue(valueName)) {
            context.reportError(new _GraphQLError.GraphQLError(`Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`, {
              nodes: valueDef.name
            }));
          } else if (valueNames[valueName]) {
            context.reportError(new _GraphQLError.GraphQLError(`Enum value "${typeName}.${valueName}" can only be defined once.`, {
              nodes: [valueNames[valueName], valueDef.name]
            }));
          } else {
            valueNames[valueName] = valueDef.name;
          }
        }
        return false;
      }
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.js
var require_UniqueFieldDefinitionNamesRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueFieldDefinitionNamesRule = UniqueFieldDefinitionNamesRule;
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function UniqueFieldDefinitionNamesRule(context) {
      const schema = context.getSchema();
      const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
      const knownFieldNames = /* @__PURE__ */ Object.create(null);
      return {
        InputObjectTypeDefinition: checkFieldUniqueness,
        InputObjectTypeExtension: checkFieldUniqueness,
        InterfaceTypeDefinition: checkFieldUniqueness,
        InterfaceTypeExtension: checkFieldUniqueness,
        ObjectTypeDefinition: checkFieldUniqueness,
        ObjectTypeExtension: checkFieldUniqueness
      };
      function checkFieldUniqueness(node) {
        var _node$fields;
        const typeName = node.name.value;
        if (!knownFieldNames[typeName]) {
          knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
        }
        const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
        const fieldNames = knownFieldNames[typeName];
        for (const fieldDef of fieldNodes) {
          const fieldName = fieldDef.name.value;
          if (hasField(existingTypeMap[typeName], fieldName)) {
            context.reportError(new _GraphQLError.GraphQLError(`Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`, {
              nodes: fieldDef.name
            }));
          } else if (fieldNames[fieldName]) {
            context.reportError(new _GraphQLError.GraphQLError(`Field "${typeName}.${fieldName}" can only be defined once.`, {
              nodes: [fieldNames[fieldName], fieldDef.name]
            }));
          } else {
            fieldNames[fieldName] = fieldDef.name;
          }
        }
        return false;
      }
    }
    function hasField(type, fieldName) {
      if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type) || (0, _definition.isInputObjectType)(type)) {
        return type.getFields()[fieldName] != null;
      }
      return false;
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/UniqueFragmentNamesRule.js
var require_UniqueFragmentNamesRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/UniqueFragmentNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueFragmentNamesRule = UniqueFragmentNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueFragmentNamesRule(context) {
      const knownFragmentNames = /* @__PURE__ */ Object.create(null);
      return {
        OperationDefinition: () => false,
        FragmentDefinition(node) {
          const fragmentName = node.name.value;
          if (knownFragmentNames[fragmentName]) {
            context.reportError(new _GraphQLError.GraphQLError(`There can be only one fragment named "${fragmentName}".`, {
              nodes: [knownFragmentNames[fragmentName], node.name]
            }));
          } else {
            knownFragmentNames[fragmentName] = node.name;
          }
          return false;
        }
      };
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.js
var require_UniqueInputFieldNamesRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueInputFieldNamesRule = UniqueInputFieldNamesRule;
    var _invariant = require_invariant();
    var _GraphQLError = require_GraphQLError();
    function UniqueInputFieldNamesRule(context) {
      const knownNameStack = [];
      let knownNames = /* @__PURE__ */ Object.create(null);
      return {
        ObjectValue: {
          enter() {
            knownNameStack.push(knownNames);
            knownNames = /* @__PURE__ */ Object.create(null);
          },
          leave() {
            const prevKnownNames = knownNameStack.pop();
            prevKnownNames || (0, _invariant.invariant)(false);
            knownNames = prevKnownNames;
          }
        },
        ObjectField(node) {
          const fieldName = node.name.value;
          if (knownNames[fieldName]) {
            context.reportError(new _GraphQLError.GraphQLError(`There can be only one input field named "${fieldName}".`, {
              nodes: [knownNames[fieldName], node.name]
            }));
          } else {
            knownNames[fieldName] = node.name;
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/UniqueOperationNamesRule.js
var require_UniqueOperationNamesRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/UniqueOperationNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueOperationNamesRule = UniqueOperationNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueOperationNamesRule(context) {
      const knownOperationNames = /* @__PURE__ */ Object.create(null);
      return {
        OperationDefinition(node) {
          const operationName = node.name;
          if (operationName) {
            if (knownOperationNames[operationName.value]) {
              context.reportError(new _GraphQLError.GraphQLError(`There can be only one operation named "${operationName.value}".`, {
                nodes: [
                  knownOperationNames[operationName.value],
                  operationName
                ]
              }));
            } else {
              knownOperationNames[operationName.value] = operationName;
            }
          }
          return false;
        },
        FragmentDefinition: () => false
      };
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/UniqueOperationTypesRule.js
var require_UniqueOperationTypesRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/UniqueOperationTypesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueOperationTypesRule = UniqueOperationTypesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueOperationTypesRule(context) {
      const schema = context.getSchema();
      const definedOperationTypes = /* @__PURE__ */ Object.create(null);
      const existingOperationTypes = schema ? {
        query: schema.getQueryType(),
        mutation: schema.getMutationType(),
        subscription: schema.getSubscriptionType()
      } : {};
      return {
        SchemaDefinition: checkOperationTypes,
        SchemaExtension: checkOperationTypes
      };
      function checkOperationTypes(node) {
        var _node$operationTypes;
        const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
        for (const operationType of operationTypesNodes) {
          const operation = operationType.operation;
          const alreadyDefinedOperationType = definedOperationTypes[operation];
          if (existingOperationTypes[operation]) {
            context.reportError(new _GraphQLError.GraphQLError(`Type for ${operation} already defined in the schema. It cannot be redefined.`, {
              nodes: operationType
            }));
          } else if (alreadyDefinedOperationType) {
            context.reportError(new _GraphQLError.GraphQLError(`There can be only one ${operation} type in schema.`, {
              nodes: [alreadyDefinedOperationType, operationType]
            }));
          } else {
            definedOperationTypes[operation] = operationType;
          }
        }
        return false;
      }
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/UniqueTypeNamesRule.js
var require_UniqueTypeNamesRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/UniqueTypeNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueTypeNamesRule = UniqueTypeNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueTypeNamesRule(context) {
      const knownTypeNames = /* @__PURE__ */ Object.create(null);
      const schema = context.getSchema();
      return {
        ScalarTypeDefinition: checkTypeName,
        ObjectTypeDefinition: checkTypeName,
        InterfaceTypeDefinition: checkTypeName,
        UnionTypeDefinition: checkTypeName,
        EnumTypeDefinition: checkTypeName,
        InputObjectTypeDefinition: checkTypeName
      };
      function checkTypeName(node) {
        const typeName = node.name.value;
        if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
          context.reportError(new _GraphQLError.GraphQLError(`Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`, {
            nodes: node.name
          }));
          return;
        }
        if (knownTypeNames[typeName]) {
          context.reportError(new _GraphQLError.GraphQLError(`There can be only one type named "${typeName}".`, {
            nodes: [knownTypeNames[typeName], node.name]
          }));
        } else {
          knownTypeNames[typeName] = node.name;
        }
        return false;
      }
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/UniqueVariableNamesRule.js
var require_UniqueVariableNamesRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/UniqueVariableNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueVariableNamesRule = UniqueVariableNamesRule;
    var _groupBy = require_groupBy();
    var _GraphQLError = require_GraphQLError();
    function UniqueVariableNamesRule(context) {
      return {
        OperationDefinition(operationNode) {
          var _operationNode$variab;
          const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
          const seenVariableDefinitions = (0, _groupBy.groupBy)(variableDefinitions, (node) => node.variable.name.value);
          for (const [variableName, variableNodes] of seenVariableDefinitions) {
            if (variableNodes.length > 1) {
              context.reportError(new _GraphQLError.GraphQLError(`There can be only one variable named "$${variableName}".`, {
                nodes: variableNodes.map((node) => node.variable.name)
              }));
            }
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js
var require_ValuesOfCorrectTypeRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ValuesOfCorrectTypeRule = ValuesOfCorrectTypeRule;
    var _didYouMean = require_didYouMean();
    var _inspect = require_inspect();
    var _keyMap = require_keyMap();
    var _suggestionList = require_suggestionList();
    var _GraphQLError = require_GraphQLError();
    var _printer = require_printer();
    var _definition = require_definition();
    function ValuesOfCorrectTypeRule(context) {
      return {
        ListValue(node) {
          const type = (0, _definition.getNullableType)(context.getParentInputType());
          if (!(0, _definition.isListType)(type)) {
            isValidValueNode(context, node);
            return false;
          }
        },
        ObjectValue(node) {
          const type = (0, _definition.getNamedType)(context.getInputType());
          if (!(0, _definition.isInputObjectType)(type)) {
            isValidValueNode(context, node);
            return false;
          }
          const fieldNodeMap = (0, _keyMap.keyMap)(node.fields, (field) => field.name.value);
          for (const fieldDef of Object.values(type.getFields())) {
            const fieldNode = fieldNodeMap[fieldDef.name];
            if (!fieldNode && (0, _definition.isRequiredInputField)(fieldDef)) {
              const typeStr = (0, _inspect.inspect)(fieldDef.type);
              context.reportError(new _GraphQLError.GraphQLError(`Field "${type.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`, {
                nodes: node
              }));
            }
          }
        },
        ObjectField(node) {
          const parentType = (0, _definition.getNamedType)(context.getParentInputType());
          const fieldType = context.getInputType();
          if (!fieldType && (0, _definition.isInputObjectType)(parentType)) {
            const suggestions = (0, _suggestionList.suggestionList)(node.name.value, Object.keys(parentType.getFields()));
            context.reportError(new _GraphQLError.GraphQLError(`Field "${node.name.value}" is not defined by type "${parentType.name}".` + (0, _didYouMean.didYouMean)(suggestions), {
              nodes: node
            }));
          }
        },
        NullValue(node) {
          const type = context.getInputType();
          if ((0, _definition.isNonNullType)(type)) {
            context.reportError(new _GraphQLError.GraphQLError(`Expected value of type "${(0, _inspect.inspect)(type)}", found ${(0, _printer.print)(node)}.`, {
              nodes: node
            }));
          }
        },
        EnumValue: (node) => isValidValueNode(context, node),
        IntValue: (node) => isValidValueNode(context, node),
        FloatValue: (node) => isValidValueNode(context, node),
        StringValue: (node) => isValidValueNode(context, node),
        BooleanValue: (node) => isValidValueNode(context, node)
      };
    }
    function isValidValueNode(context, node) {
      const locationType = context.getInputType();
      if (!locationType) {
        return;
      }
      const type = (0, _definition.getNamedType)(locationType);
      if (!(0, _definition.isLeafType)(type)) {
        const typeStr = (0, _inspect.inspect)(locationType);
        context.reportError(new _GraphQLError.GraphQLError(`Expected value of type "${typeStr}", found ${(0, _printer.print)(node)}.`, {
          nodes: node
        }));
        return;
      }
      try {
        const parseResult = type.parseLiteral(node, void 0);
        if (parseResult === void 0) {
          const typeStr = (0, _inspect.inspect)(locationType);
          context.reportError(new _GraphQLError.GraphQLError(`Expected value of type "${typeStr}", found ${(0, _printer.print)(node)}.`, {
            nodes: node
          }));
        }
      } catch (error2) {
        const typeStr = (0, _inspect.inspect)(locationType);
        if (error2 instanceof _GraphQLError.GraphQLError) {
          context.reportError(error2);
        } else {
          context.reportError(new _GraphQLError.GraphQLError(`Expected value of type "${typeStr}", found ${(0, _printer.print)(node)}; ` + error2.message, {
            nodes: node,
            originalError: error2
          }));
        }
      }
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/VariablesAreInputTypesRule.js
var require_VariablesAreInputTypesRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/VariablesAreInputTypesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.VariablesAreInputTypesRule = VariablesAreInputTypesRule;
    var _GraphQLError = require_GraphQLError();
    var _printer = require_printer();
    var _definition = require_definition();
    var _typeFromAST = require_typeFromAST();
    function VariablesAreInputTypesRule(context) {
      return {
        VariableDefinition(node) {
          const type = (0, _typeFromAST.typeFromAST)(context.getSchema(), node.type);
          if (type !== void 0 && !(0, _definition.isInputType)(type)) {
            const variableName = node.variable.name.value;
            const typeName = (0, _printer.print)(node.type);
            context.reportError(new _GraphQLError.GraphQLError(`Variable "$${variableName}" cannot be non-input type "${typeName}".`, {
              nodes: node.type
            }));
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.js
var require_VariablesInAllowedPositionRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.VariablesInAllowedPositionRule = VariablesInAllowedPositionRule;
    var _inspect = require_inspect();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _definition = require_definition();
    var _typeComparators = require_typeComparators();
    var _typeFromAST = require_typeFromAST();
    function VariablesInAllowedPositionRule(context) {
      let varDefMap = /* @__PURE__ */ Object.create(null);
      return {
        OperationDefinition: {
          enter() {
            varDefMap = /* @__PURE__ */ Object.create(null);
          },
          leave(operation) {
            const usages = context.getRecursiveVariableUsages(operation);
            for (const { node, type, defaultValue } of usages) {
              const varName = node.name.value;
              const varDef = varDefMap[varName];
              if (varDef && type) {
                const schema = context.getSchema();
                const varType = (0, _typeFromAST.typeFromAST)(schema, varDef.type);
                if (varType && !allowedVariableUsage(schema, varType, varDef.defaultValue, type, defaultValue)) {
                  const varTypeStr = (0, _inspect.inspect)(varType);
                  const typeStr = (0, _inspect.inspect)(type);
                  context.reportError(new _GraphQLError.GraphQLError(`Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`, {
                    nodes: [varDef, node]
                  }));
                }
              }
            }
          }
        },
        VariableDefinition(node) {
          varDefMap[node.variable.name.value] = node;
        }
      };
    }
    function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
      if ((0, _definition.isNonNullType)(locationType) && !(0, _definition.isNonNullType)(varType)) {
        const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== _kinds.Kind.NULL;
        const hasLocationDefaultValue = locationDefaultValue !== void 0;
        if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
          return false;
        }
        const nullableLocationType = locationType.ofType;
        return (0, _typeComparators.isTypeSubTypeOf)(schema, varType, nullableLocationType);
      }
      return (0, _typeComparators.isTypeSubTypeOf)(schema, varType, locationType);
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/specifiedRules.js
var require_specifiedRules = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/specifiedRules.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.specifiedSDLRules = exports2.specifiedRules = void 0;
    var _ExecutableDefinitionsRule = require_ExecutableDefinitionsRule();
    var _FieldsOnCorrectTypeRule = require_FieldsOnCorrectTypeRule();
    var _FragmentsOnCompositeTypesRule = require_FragmentsOnCompositeTypesRule();
    var _KnownArgumentNamesRule = require_KnownArgumentNamesRule();
    var _KnownDirectivesRule = require_KnownDirectivesRule();
    var _KnownFragmentNamesRule = require_KnownFragmentNamesRule();
    var _KnownTypeNamesRule = require_KnownTypeNamesRule();
    var _LoneAnonymousOperationRule = require_LoneAnonymousOperationRule();
    var _LoneSchemaDefinitionRule = require_LoneSchemaDefinitionRule();
    var _NoFragmentCyclesRule = require_NoFragmentCyclesRule();
    var _NoUndefinedVariablesRule = require_NoUndefinedVariablesRule();
    var _NoUnusedFragmentsRule = require_NoUnusedFragmentsRule();
    var _NoUnusedVariablesRule = require_NoUnusedVariablesRule();
    var _OverlappingFieldsCanBeMergedRule = require_OverlappingFieldsCanBeMergedRule();
    var _PossibleFragmentSpreadsRule = require_PossibleFragmentSpreadsRule();
    var _PossibleTypeExtensionsRule = require_PossibleTypeExtensionsRule();
    var _ProvidedRequiredArgumentsRule = require_ProvidedRequiredArgumentsRule();
    var _ScalarLeafsRule = require_ScalarLeafsRule();
    var _SingleFieldSubscriptionsRule = require_SingleFieldSubscriptionsRule();
    var _UniqueArgumentDefinitionNamesRule = require_UniqueArgumentDefinitionNamesRule();
    var _UniqueArgumentNamesRule = require_UniqueArgumentNamesRule();
    var _UniqueDirectiveNamesRule = require_UniqueDirectiveNamesRule();
    var _UniqueDirectivesPerLocationRule = require_UniqueDirectivesPerLocationRule();
    var _UniqueEnumValueNamesRule = require_UniqueEnumValueNamesRule();
    var _UniqueFieldDefinitionNamesRule = require_UniqueFieldDefinitionNamesRule();
    var _UniqueFragmentNamesRule = require_UniqueFragmentNamesRule();
    var _UniqueInputFieldNamesRule = require_UniqueInputFieldNamesRule();
    var _UniqueOperationNamesRule = require_UniqueOperationNamesRule();
    var _UniqueOperationTypesRule = require_UniqueOperationTypesRule();
    var _UniqueTypeNamesRule = require_UniqueTypeNamesRule();
    var _UniqueVariableNamesRule = require_UniqueVariableNamesRule();
    var _ValuesOfCorrectTypeRule = require_ValuesOfCorrectTypeRule();
    var _VariablesAreInputTypesRule = require_VariablesAreInputTypesRule();
    var _VariablesInAllowedPositionRule = require_VariablesInAllowedPositionRule();
    var specifiedRules3 = Object.freeze([
      _ExecutableDefinitionsRule.ExecutableDefinitionsRule,
      _UniqueOperationNamesRule.UniqueOperationNamesRule,
      _LoneAnonymousOperationRule.LoneAnonymousOperationRule,
      _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule,
      _KnownTypeNamesRule.KnownTypeNamesRule,
      _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule,
      _VariablesAreInputTypesRule.VariablesAreInputTypesRule,
      _ScalarLeafsRule.ScalarLeafsRule,
      _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule,
      _UniqueFragmentNamesRule.UniqueFragmentNamesRule,
      _KnownFragmentNamesRule.KnownFragmentNamesRule,
      _NoUnusedFragmentsRule.NoUnusedFragmentsRule,
      _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule,
      _NoFragmentCyclesRule.NoFragmentCyclesRule,
      _UniqueVariableNamesRule.UniqueVariableNamesRule,
      _NoUndefinedVariablesRule.NoUndefinedVariablesRule,
      _NoUnusedVariablesRule.NoUnusedVariablesRule,
      _KnownDirectivesRule.KnownDirectivesRule,
      _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule,
      _KnownArgumentNamesRule.KnownArgumentNamesRule,
      _UniqueArgumentNamesRule.UniqueArgumentNamesRule,
      _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule,
      _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule,
      _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule,
      _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule,
      _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule
    ]);
    exports2.specifiedRules = specifiedRules3;
    var specifiedSDLRules = Object.freeze([
      _LoneSchemaDefinitionRule.LoneSchemaDefinitionRule,
      _UniqueOperationTypesRule.UniqueOperationTypesRule,
      _UniqueTypeNamesRule.UniqueTypeNamesRule,
      _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule,
      _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule,
      _UniqueArgumentDefinitionNamesRule.UniqueArgumentDefinitionNamesRule,
      _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule,
      _KnownTypeNamesRule.KnownTypeNamesRule,
      _KnownDirectivesRule.KnownDirectivesRule,
      _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule,
      _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule,
      _KnownArgumentNamesRule.KnownArgumentNamesOnDirectivesRule,
      _UniqueArgumentNamesRule.UniqueArgumentNamesRule,
      _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule,
      _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsOnDirectivesRule
    ]);
    exports2.specifiedSDLRules = specifiedSDLRules;
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/ValidationContext.js
var require_ValidationContext = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/ValidationContext.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ValidationContext = exports2.SDLValidationContext = exports2.ASTValidationContext = void 0;
    var _kinds = require_kinds();
    var _visitor = require_visitor();
    var _TypeInfo = require_TypeInfo();
    var ASTValidationContext = class {
      constructor(ast, onError) {
        this._ast = ast;
        this._fragments = void 0;
        this._fragmentSpreads = /* @__PURE__ */ new Map();
        this._recursivelyReferencedFragments = /* @__PURE__ */ new Map();
        this._onError = onError;
      }
      get [Symbol.toStringTag]() {
        return "ASTValidationContext";
      }
      reportError(error2) {
        this._onError(error2);
      }
      getDocument() {
        return this._ast;
      }
      getFragment(name) {
        let fragments;
        if (this._fragments) {
          fragments = this._fragments;
        } else {
          fragments = /* @__PURE__ */ Object.create(null);
          for (const defNode of this.getDocument().definitions) {
            if (defNode.kind === _kinds.Kind.FRAGMENT_DEFINITION) {
              fragments[defNode.name.value] = defNode;
            }
          }
          this._fragments = fragments;
        }
        return fragments[name];
      }
      getFragmentSpreads(node) {
        let spreads = this._fragmentSpreads.get(node);
        if (!spreads) {
          spreads = [];
          const setsToVisit = [node];
          let set;
          while (set = setsToVisit.pop()) {
            for (const selection of set.selections) {
              if (selection.kind === _kinds.Kind.FRAGMENT_SPREAD) {
                spreads.push(selection);
              } else if (selection.selectionSet) {
                setsToVisit.push(selection.selectionSet);
              }
            }
          }
          this._fragmentSpreads.set(node, spreads);
        }
        return spreads;
      }
      getRecursivelyReferencedFragments(operation) {
        let fragments = this._recursivelyReferencedFragments.get(operation);
        if (!fragments) {
          fragments = [];
          const collectedNames = /* @__PURE__ */ Object.create(null);
          const nodesToVisit = [operation.selectionSet];
          let node;
          while (node = nodesToVisit.pop()) {
            for (const spread of this.getFragmentSpreads(node)) {
              const fragName = spread.name.value;
              if (collectedNames[fragName] !== true) {
                collectedNames[fragName] = true;
                const fragment = this.getFragment(fragName);
                if (fragment) {
                  fragments.push(fragment);
                  nodesToVisit.push(fragment.selectionSet);
                }
              }
            }
          }
          this._recursivelyReferencedFragments.set(operation, fragments);
        }
        return fragments;
      }
    };
    exports2.ASTValidationContext = ASTValidationContext;
    var SDLValidationContext = class extends ASTValidationContext {
      constructor(ast, schema, onError) {
        super(ast, onError);
        this._schema = schema;
      }
      get [Symbol.toStringTag]() {
        return "SDLValidationContext";
      }
      getSchema() {
        return this._schema;
      }
    };
    exports2.SDLValidationContext = SDLValidationContext;
    var ValidationContext = class extends ASTValidationContext {
      constructor(schema, ast, typeInfo, onError) {
        super(ast, onError);
        this._schema = schema;
        this._typeInfo = typeInfo;
        this._variableUsages = /* @__PURE__ */ new Map();
        this._recursiveVariableUsages = /* @__PURE__ */ new Map();
      }
      get [Symbol.toStringTag]() {
        return "ValidationContext";
      }
      getSchema() {
        return this._schema;
      }
      getVariableUsages(node) {
        let usages = this._variableUsages.get(node);
        if (!usages) {
          const newUsages = [];
          const typeInfo = new _TypeInfo.TypeInfo(this._schema);
          (0, _visitor.visit)(node, (0, _TypeInfo.visitWithTypeInfo)(typeInfo, {
            VariableDefinition: () => false,
            Variable(variable) {
              newUsages.push({
                node: variable,
                type: typeInfo.getInputType(),
                defaultValue: typeInfo.getDefaultValue()
              });
            }
          }));
          usages = newUsages;
          this._variableUsages.set(node, usages);
        }
        return usages;
      }
      getRecursiveVariableUsages(operation) {
        let usages = this._recursiveVariableUsages.get(operation);
        if (!usages) {
          usages = this.getVariableUsages(operation);
          for (const frag of this.getRecursivelyReferencedFragments(operation)) {
            usages = usages.concat(this.getVariableUsages(frag));
          }
          this._recursiveVariableUsages.set(operation, usages);
        }
        return usages;
      }
      getType() {
        return this._typeInfo.getType();
      }
      getParentType() {
        return this._typeInfo.getParentType();
      }
      getInputType() {
        return this._typeInfo.getInputType();
      }
      getParentInputType() {
        return this._typeInfo.getParentInputType();
      }
      getFieldDef() {
        return this._typeInfo.getFieldDef();
      }
      getDirective() {
        return this._typeInfo.getDirective();
      }
      getArgument() {
        return this._typeInfo.getArgument();
      }
      getEnumValue() {
        return this._typeInfo.getEnumValue();
      }
    };
    exports2.ValidationContext = ValidationContext;
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/validate.js
var require_validate2 = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assertValidSDL = assertValidSDL;
    exports2.assertValidSDLExtension = assertValidSDLExtension;
    exports2.validate = validate3;
    exports2.validateSDL = validateSDL;
    var _devAssert = require_devAssert();
    var _GraphQLError = require_GraphQLError();
    var _visitor = require_visitor();
    var _validate = require_validate();
    var _TypeInfo = require_TypeInfo();
    var _specifiedRules = require_specifiedRules();
    var _ValidationContext = require_ValidationContext();
    function validate3(schema, documentAST, rules = _specifiedRules.specifiedRules, options2, typeInfo = new _TypeInfo.TypeInfo(schema)) {
      var _options$maxErrors;
      const maxErrors = (_options$maxErrors = options2 === null || options2 === void 0 ? void 0 : options2.maxErrors) !== null && _options$maxErrors !== void 0 ? _options$maxErrors : 100;
      documentAST || (0, _devAssert.devAssert)(false, "Must provide document.");
      (0, _validate.assertValidSchema)(schema);
      const abortObj = Object.freeze({});
      const errors2 = [];
      const context = new _ValidationContext.ValidationContext(schema, documentAST, typeInfo, (error2) => {
        if (errors2.length >= maxErrors) {
          errors2.push(new _GraphQLError.GraphQLError("Too many validation errors, error limit reached. Validation aborted."));
          throw abortObj;
        }
        errors2.push(error2);
      });
      const visitor = (0, _visitor.visitInParallel)(rules.map((rule) => rule(context)));
      try {
        (0, _visitor.visit)(documentAST, (0, _TypeInfo.visitWithTypeInfo)(typeInfo, visitor));
      } catch (e2) {
        if (e2 !== abortObj) {
          throw e2;
        }
      }
      return errors2;
    }
    function validateSDL(documentAST, schemaToExtend, rules = _specifiedRules.specifiedSDLRules) {
      const errors2 = [];
      const context = new _ValidationContext.SDLValidationContext(documentAST, schemaToExtend, (error2) => {
        errors2.push(error2);
      });
      const visitors = rules.map((rule) => rule(context));
      (0, _visitor.visit)(documentAST, (0, _visitor.visitInParallel)(visitors));
      return errors2;
    }
    function assertValidSDL(documentAST) {
      const errors2 = validateSDL(documentAST);
      if (errors2.length !== 0) {
        throw new Error(errors2.map((error2) => error2.message).join("\n\n"));
      }
    }
    function assertValidSDLExtension(documentAST, schema) {
      const errors2 = validateSDL(documentAST, schema);
      if (errors2.length !== 0) {
        throw new Error(errors2.map((error2) => error2.message).join("\n\n"));
      }
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/memoize3.js
var require_memoize3 = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/memoize3.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.memoize3 = memoize3;
    function memoize3(fn2) {
      let cache0;
      return function memoized(a1, a2, a3) {
        if (cache0 === void 0) {
          cache0 = /* @__PURE__ */ new WeakMap();
        }
        let cache1 = cache0.get(a1);
        if (cache1 === void 0) {
          cache1 = /* @__PURE__ */ new WeakMap();
          cache0.set(a1, cache1);
        }
        let cache2 = cache1.get(a2);
        if (cache2 === void 0) {
          cache2 = /* @__PURE__ */ new WeakMap();
          cache1.set(a2, cache2);
        }
        let fnResult = cache2.get(a3);
        if (fnResult === void 0) {
          fnResult = fn2(a1, a2, a3);
          cache2.set(a3, fnResult);
        }
        return fnResult;
      };
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/promiseForObject.js
var require_promiseForObject = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/promiseForObject.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.promiseForObject = promiseForObject;
    function promiseForObject(object) {
      return Promise.all(Object.values(object)).then((resolvedValues) => {
        const resolvedObject = /* @__PURE__ */ Object.create(null);
        for (const [i, key] of Object.keys(object).entries()) {
          resolvedObject[key] = resolvedValues[i];
        }
        return resolvedObject;
      });
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/promiseReduce.js
var require_promiseReduce = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/promiseReduce.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.promiseReduce = promiseReduce;
    var _isPromise = require_isPromise();
    function promiseReduce(values, callbackFn, initialValue) {
      let accumulator = initialValue;
      for (const value of values) {
        accumulator = (0, _isPromise.isPromise)(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value)) : callbackFn(accumulator, value);
      }
      return accumulator;
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/toError.js
var require_toError = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/toError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.toError = toError;
    var _inspect = require_inspect();
    function toError(thrownValue) {
      return thrownValue instanceof Error ? thrownValue : new NonErrorThrown(thrownValue);
    }
    var NonErrorThrown = class extends Error {
      constructor(thrownValue) {
        super("Unexpected error value: " + (0, _inspect.inspect)(thrownValue));
        this.name = "NonErrorThrown";
        this.thrownValue = thrownValue;
      }
    };
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/error/locatedError.js
var require_locatedError = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/error/locatedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.locatedError = locatedError;
    var _toError = require_toError();
    var _GraphQLError = require_GraphQLError();
    function locatedError(rawOriginalError, nodes, path) {
      var _nodes;
      const originalError = (0, _toError.toError)(rawOriginalError);
      if (isLocatedGraphQLError(originalError)) {
        return originalError;
      }
      return new _GraphQLError.GraphQLError(originalError.message, {
        nodes: (_nodes = originalError.nodes) !== null && _nodes !== void 0 ? _nodes : nodes,
        source: originalError.source,
        positions: originalError.positions,
        path,
        originalError
      });
    }
    function isLocatedGraphQLError(error2) {
      return Array.isArray(error2.path);
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/execution/execute.js
var require_execute = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/execution/execute.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assertValidExecutionArguments = assertValidExecutionArguments;
    exports2.buildExecutionContext = buildExecutionContext;
    exports2.buildResolveInfo = buildResolveInfo;
    exports2.defaultTypeResolver = exports2.defaultFieldResolver = void 0;
    exports2.execute = execute2;
    exports2.executeSync = executeSync;
    exports2.getFieldDef = getFieldDef;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _isIterableObject = require_isIterableObject();
    var _isObjectLike = require_isObjectLike();
    var _isPromise = require_isPromise();
    var _memoize = require_memoize3();
    var _Path = require_Path();
    var _promiseForObject = require_promiseForObject();
    var _promiseReduce = require_promiseReduce();
    var _GraphQLError = require_GraphQLError();
    var _locatedError = require_locatedError();
    var _ast = require_ast();
    var _kinds = require_kinds();
    var _definition = require_definition();
    var _introspection = require_introspection();
    var _validate = require_validate();
    var _collectFields = require_collectFields();
    var _values = require_values();
    var collectSubfields = (0, _memoize.memoize3)((exeContext, returnType, fieldNodes) => (0, _collectFields.collectSubfields)(exeContext.schema, exeContext.fragments, exeContext.variableValues, returnType, fieldNodes));
    function execute2(args) {
      arguments.length < 2 || (0, _devAssert.devAssert)(false, "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.");
      const { schema, document, variableValues, rootValue } = args;
      assertValidExecutionArguments(schema, document, variableValues);
      const exeContext = buildExecutionContext(args);
      if (!("schema" in exeContext)) {
        return {
          errors: exeContext
        };
      }
      try {
        const { operation } = exeContext;
        const result = executeOperation(exeContext, operation, rootValue);
        if ((0, _isPromise.isPromise)(result)) {
          return result.then((data) => buildResponse(data, exeContext.errors), (error2) => {
            exeContext.errors.push(error2);
            return buildResponse(null, exeContext.errors);
          });
        }
        return buildResponse(result, exeContext.errors);
      } catch (error2) {
        exeContext.errors.push(error2);
        return buildResponse(null, exeContext.errors);
      }
    }
    function executeSync(args) {
      const result = execute2(args);
      if ((0, _isPromise.isPromise)(result)) {
        throw new Error("GraphQL execution failed to complete synchronously.");
      }
      return result;
    }
    function buildResponse(data, errors2) {
      return errors2.length === 0 ? {
        data
      } : {
        errors: errors2,
        data
      };
    }
    function assertValidExecutionArguments(schema, document, rawVariableValues) {
      document || (0, _devAssert.devAssert)(false, "Must provide document.");
      (0, _validate.assertValidSchema)(schema);
      rawVariableValues == null || (0, _isObjectLike.isObjectLike)(rawVariableValues) || (0, _devAssert.devAssert)(false, "Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.");
    }
    function buildExecutionContext(args) {
      var _definition$name, _operation$variableDe;
      const {
        schema,
        document,
        rootValue,
        contextValue,
        variableValues: rawVariableValues,
        operationName,
        fieldResolver,
        typeResolver,
        subscribeFieldResolver
      } = args;
      let operation;
      const fragments = /* @__PURE__ */ Object.create(null);
      for (const definition of document.definitions) {
        switch (definition.kind) {
          case _kinds.Kind.OPERATION_DEFINITION:
            if (operationName == null) {
              if (operation !== void 0) {
                return [
                  new _GraphQLError.GraphQLError("Must provide operation name if query contains multiple operations.")
                ];
              }
              operation = definition;
            } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
              operation = definition;
            }
            break;
          case _kinds.Kind.FRAGMENT_DEFINITION:
            fragments[definition.name.value] = definition;
            break;
          default:
        }
      }
      if (!operation) {
        if (operationName != null) {
          return [
            new _GraphQLError.GraphQLError(`Unknown operation named "${operationName}".`)
          ];
        }
        return [new _GraphQLError.GraphQLError("Must provide an operation.")];
      }
      const variableDefinitions = (_operation$variableDe = operation.variableDefinitions) !== null && _operation$variableDe !== void 0 ? _operation$variableDe : [];
      const coercedVariableValues = (0, _values.getVariableValues)(schema, variableDefinitions, rawVariableValues !== null && rawVariableValues !== void 0 ? rawVariableValues : {}, {
        maxErrors: 50
      });
      if (coercedVariableValues.errors) {
        return coercedVariableValues.errors;
      }
      return {
        schema,
        fragments,
        rootValue,
        contextValue,
        operation,
        variableValues: coercedVariableValues.coerced,
        fieldResolver: fieldResolver !== null && fieldResolver !== void 0 ? fieldResolver : defaultFieldResolver5,
        typeResolver: typeResolver !== null && typeResolver !== void 0 ? typeResolver : defaultTypeResolver2,
        subscribeFieldResolver: subscribeFieldResolver !== null && subscribeFieldResolver !== void 0 ? subscribeFieldResolver : defaultFieldResolver5,
        errors: []
      };
    }
    function executeOperation(exeContext, operation, rootValue) {
      const rootType = exeContext.schema.getRootType(operation.operation);
      if (rootType == null) {
        throw new _GraphQLError.GraphQLError(`Schema is not configured to execute ${operation.operation} operation.`, {
          nodes: operation
        });
      }
      const rootFields = (0, _collectFields.collectFields)(exeContext.schema, exeContext.fragments, exeContext.variableValues, rootType, operation.selectionSet);
      const path = void 0;
      switch (operation.operation) {
        case _ast.OperationTypeNode.QUERY:
          return executeFields(exeContext, rootType, rootValue, path, rootFields);
        case _ast.OperationTypeNode.MUTATION:
          return executeFieldsSerially(exeContext, rootType, rootValue, path, rootFields);
        case _ast.OperationTypeNode.SUBSCRIPTION:
          return executeFields(exeContext, rootType, rootValue, path, rootFields);
      }
    }
    function executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {
      return (0, _promiseReduce.promiseReduce)(fields.entries(), (results, [responseName, fieldNodes]) => {
        const fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);
        const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);
        if (result === void 0) {
          return results;
        }
        if ((0, _isPromise.isPromise)(result)) {
          return result.then((resolvedResult) => {
            results[responseName] = resolvedResult;
            return results;
          });
        }
        results[responseName] = result;
        return results;
      }, /* @__PURE__ */ Object.create(null));
    }
    function executeFields(exeContext, parentType, sourceValue, path, fields) {
      const results = /* @__PURE__ */ Object.create(null);
      let containsPromise = false;
      for (const [responseName, fieldNodes] of fields.entries()) {
        const fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);
        const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);
        if (result !== void 0) {
          results[responseName] = result;
          if ((0, _isPromise.isPromise)(result)) {
            containsPromise = true;
          }
        }
      }
      if (!containsPromise) {
        return results;
      }
      return (0, _promiseForObject.promiseForObject)(results);
    }
    function executeField(exeContext, parentType, source, fieldNodes, path) {
      var _fieldDef$resolve;
      const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);
      if (!fieldDef) {
        return;
      }
      const returnType = fieldDef.type;
      const resolveFn = (_fieldDef$resolve = fieldDef.resolve) !== null && _fieldDef$resolve !== void 0 ? _fieldDef$resolve : exeContext.fieldResolver;
      const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path);
      try {
        const args = (0, _values.getArgumentValues)(fieldDef, fieldNodes[0], exeContext.variableValues);
        const contextValue = exeContext.contextValue;
        const result = resolveFn(source, args, contextValue, info);
        let completed;
        if ((0, _isPromise.isPromise)(result)) {
          completed = result.then((resolved) => completeValue(exeContext, returnType, fieldNodes, info, path, resolved));
        } else {
          completed = completeValue(exeContext, returnType, fieldNodes, info, path, result);
        }
        if ((0, _isPromise.isPromise)(completed)) {
          return completed.then(void 0, (rawError) => {
            const error2 = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(path));
            return handleFieldError(error2, returnType, exeContext);
          });
        }
        return completed;
      } catch (rawError) {
        const error2 = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(path));
        return handleFieldError(error2, returnType, exeContext);
      }
    }
    function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
      return {
        fieldName: fieldDef.name,
        fieldNodes,
        returnType: fieldDef.type,
        parentType,
        path,
        schema: exeContext.schema,
        fragments: exeContext.fragments,
        rootValue: exeContext.rootValue,
        operation: exeContext.operation,
        variableValues: exeContext.variableValues
      };
    }
    function handleFieldError(error2, returnType, exeContext) {
      if ((0, _definition.isNonNullType)(returnType)) {
        throw error2;
      }
      exeContext.errors.push(error2);
      return null;
    }
    function completeValue(exeContext, returnType, fieldNodes, info, path, result) {
      if (result instanceof Error) {
        throw result;
      }
      if ((0, _definition.isNonNullType)(returnType)) {
        const completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result);
        if (completed === null) {
          throw new Error(`Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`);
        }
        return completed;
      }
      if (result == null) {
        return null;
      }
      if ((0, _definition.isListType)(returnType)) {
        return completeListValue(exeContext, returnType, fieldNodes, info, path, result);
      }
      if ((0, _definition.isLeafType)(returnType)) {
        return completeLeafValue(returnType, result);
      }
      if ((0, _definition.isAbstractType)(returnType)) {
        return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result);
      }
      if ((0, _definition.isObjectType)(returnType)) {
        return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result);
      }
      (0, _invariant.invariant)(false, "Cannot complete value of unexpected output type: " + (0, _inspect.inspect)(returnType));
    }
    function completeListValue(exeContext, returnType, fieldNodes, info, path, result) {
      if (!(0, _isIterableObject.isIterableObject)(result)) {
        throw new _GraphQLError.GraphQLError(`Expected Iterable, but did not find one for field "${info.parentType.name}.${info.fieldName}".`);
      }
      const itemType = returnType.ofType;
      let containsPromise = false;
      const completedResults = Array.from(result, (item, index) => {
        const itemPath = (0, _Path.addPath)(path, index, void 0);
        try {
          let completedItem;
          if ((0, _isPromise.isPromise)(item)) {
            completedItem = item.then((resolved) => completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved));
          } else {
            completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item);
          }
          if ((0, _isPromise.isPromise)(completedItem)) {
            containsPromise = true;
            return completedItem.then(void 0, (rawError) => {
              const error2 = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(itemPath));
              return handleFieldError(error2, itemType, exeContext);
            });
          }
          return completedItem;
        } catch (rawError) {
          const error2 = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(itemPath));
          return handleFieldError(error2, itemType, exeContext);
        }
      });
      return containsPromise ? Promise.all(completedResults) : completedResults;
    }
    function completeLeafValue(returnType, result) {
      const serializedResult = returnType.serialize(result);
      if (serializedResult == null) {
        throw new Error(`Expected \`${(0, _inspect.inspect)(returnType)}.serialize(${(0, _inspect.inspect)(result)})\` to return non-nullable value, returned: ${(0, _inspect.inspect)(serializedResult)}`);
      }
      return serializedResult;
    }
    function completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result) {
      var _returnType$resolveTy;
      const resolveTypeFn = (_returnType$resolveTy = returnType.resolveType) !== null && _returnType$resolveTy !== void 0 ? _returnType$resolveTy : exeContext.typeResolver;
      const contextValue = exeContext.contextValue;
      const runtimeType = resolveTypeFn(result, contextValue, info, returnType);
      if ((0, _isPromise.isPromise)(runtimeType)) {
        return runtimeType.then((resolvedRuntimeType) => completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result));
      }
      return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);
    }
    function ensureValidRuntimeType(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {
      if (runtimeTypeName == null) {
        throw new _GraphQLError.GraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}". Either the "${returnType.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`, fieldNodes);
      }
      if ((0, _definition.isObjectType)(runtimeTypeName)) {
        throw new _GraphQLError.GraphQLError("Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.");
      }
      if (typeof runtimeTypeName !== "string") {
        throw new _GraphQLError.GraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}" with value ${(0, _inspect.inspect)(result)}, received "${(0, _inspect.inspect)(runtimeTypeName)}".`);
      }
      const runtimeType = exeContext.schema.getType(runtimeTypeName);
      if (runtimeType == null) {
        throw new _GraphQLError.GraphQLError(`Abstract type "${returnType.name}" was resolved to a type "${runtimeTypeName}" that does not exist inside the schema.`, {
          nodes: fieldNodes
        });
      }
      if (!(0, _definition.isObjectType)(runtimeType)) {
        throw new _GraphQLError.GraphQLError(`Abstract type "${returnType.name}" was resolved to a non-object type "${runtimeTypeName}".`, {
          nodes: fieldNodes
        });
      }
      if (!exeContext.schema.isSubType(returnType, runtimeType)) {
        throw new _GraphQLError.GraphQLError(`Runtime Object type "${runtimeType.name}" is not a possible type for "${returnType.name}".`, {
          nodes: fieldNodes
        });
      }
      return runtimeType;
    }
    function completeObjectValue(exeContext, returnType, fieldNodes, info, path, result) {
      const subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes);
      if (returnType.isTypeOf) {
        const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
        if ((0, _isPromise.isPromise)(isTypeOf)) {
          return isTypeOf.then((resolvedIsTypeOf) => {
            if (!resolvedIsTypeOf) {
              throw invalidReturnTypeError(returnType, result, fieldNodes);
            }
            return executeFields(exeContext, returnType, result, path, subFieldNodes);
          });
        }
        if (!isTypeOf) {
          throw invalidReturnTypeError(returnType, result, fieldNodes);
        }
      }
      return executeFields(exeContext, returnType, result, path, subFieldNodes);
    }
    function invalidReturnTypeError(returnType, result, fieldNodes) {
      return new _GraphQLError.GraphQLError(`Expected value of type "${returnType.name}" but got: ${(0, _inspect.inspect)(result)}.`, {
        nodes: fieldNodes
      });
    }
    var defaultTypeResolver2 = function(value, contextValue, info, abstractType) {
      if ((0, _isObjectLike.isObjectLike)(value) && typeof value.__typename === "string") {
        return value.__typename;
      }
      const possibleTypes = info.schema.getPossibleTypes(abstractType);
      const promisedIsTypeOfResults = [];
      for (let i = 0; i < possibleTypes.length; i++) {
        const type = possibleTypes[i];
        if (type.isTypeOf) {
          const isTypeOfResult = type.isTypeOf(value, contextValue, info);
          if ((0, _isPromise.isPromise)(isTypeOfResult)) {
            promisedIsTypeOfResults[i] = isTypeOfResult;
          } else if (isTypeOfResult) {
            return type.name;
          }
        }
      }
      if (promisedIsTypeOfResults.length) {
        return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {
          for (let i = 0; i < isTypeOfResults.length; i++) {
            if (isTypeOfResults[i]) {
              return possibleTypes[i].name;
            }
          }
        });
      }
    };
    exports2.defaultTypeResolver = defaultTypeResolver2;
    var defaultFieldResolver5 = function(source, args, contextValue, info) {
      if ((0, _isObjectLike.isObjectLike)(source) || typeof source === "function") {
        const property = source[info.fieldName];
        if (typeof property === "function") {
          return source[info.fieldName](args, contextValue, info);
        }
        return property;
      }
    };
    exports2.defaultFieldResolver = defaultFieldResolver5;
    function getFieldDef(schema, parentType, fieldNode) {
      const fieldName = fieldNode.name.value;
      if (fieldName === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
        return _introspection.SchemaMetaFieldDef;
      } else if (fieldName === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
        return _introspection.TypeMetaFieldDef;
      } else if (fieldName === _introspection.TypeNameMetaFieldDef.name) {
        return _introspection.TypeNameMetaFieldDef;
      }
      return parentType.getFields()[fieldName];
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/graphql.js
var require_graphql = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/graphql.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.graphql = graphql;
    exports2.graphqlSync = graphqlSync;
    var _devAssert = require_devAssert();
    var _isPromise = require_isPromise();
    var _parser = require_parser();
    var _validate = require_validate();
    var _validate2 = require_validate2();
    var _execute = require_execute();
    function graphql(args) {
      return new Promise((resolve2) => resolve2(graphqlImpl(args)));
    }
    function graphqlSync(args) {
      const result = graphqlImpl(args);
      if ((0, _isPromise.isPromise)(result)) {
        throw new Error("GraphQL execution failed to complete synchronously.");
      }
      return result;
    }
    function graphqlImpl(args) {
      arguments.length < 2 || (0, _devAssert.devAssert)(false, "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.");
      const {
        schema,
        source,
        rootValue,
        contextValue,
        variableValues,
        operationName,
        fieldResolver,
        typeResolver
      } = args;
      const schemaValidationErrors = (0, _validate.validateSchema)(schema);
      if (schemaValidationErrors.length > 0) {
        return {
          errors: schemaValidationErrors
        };
      }
      let document;
      try {
        document = (0, _parser.parse)(source);
      } catch (syntaxError) {
        return {
          errors: [syntaxError]
        };
      }
      const validationErrors = (0, _validate2.validate)(schema, document);
      if (validationErrors.length > 0) {
        return {
          errors: validationErrors
        };
      }
      return (0, _execute.execute)({
        schema,
        document,
        rootValue,
        contextValue,
        variableValues,
        operationName,
        fieldResolver,
        typeResolver
      });
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/type/index.js
var require_type = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/type/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "DEFAULT_DEPRECATION_REASON", {
      enumerable: true,
      get: function() {
        return _directives.DEFAULT_DEPRECATION_REASON;
      }
    });
    Object.defineProperty(exports2, "GRAPHQL_MAX_INT", {
      enumerable: true,
      get: function() {
        return _scalars.GRAPHQL_MAX_INT;
      }
    });
    Object.defineProperty(exports2, "GRAPHQL_MIN_INT", {
      enumerable: true,
      get: function() {
        return _scalars.GRAPHQL_MIN_INT;
      }
    });
    Object.defineProperty(exports2, "GraphQLBoolean", {
      enumerable: true,
      get: function() {
        return _scalars.GraphQLBoolean;
      }
    });
    Object.defineProperty(exports2, "GraphQLDeprecatedDirective", {
      enumerable: true,
      get: function() {
        return _directives.GraphQLDeprecatedDirective;
      }
    });
    Object.defineProperty(exports2, "GraphQLDirective", {
      enumerable: true,
      get: function() {
        return _directives.GraphQLDirective;
      }
    });
    Object.defineProperty(exports2, "GraphQLEnumType", {
      enumerable: true,
      get: function() {
        return _definition.GraphQLEnumType;
      }
    });
    Object.defineProperty(exports2, "GraphQLFloat", {
      enumerable: true,
      get: function() {
        return _scalars.GraphQLFloat;
      }
    });
    Object.defineProperty(exports2, "GraphQLID", {
      enumerable: true,
      get: function() {
        return _scalars.GraphQLID;
      }
    });
    Object.defineProperty(exports2, "GraphQLIncludeDirective", {
      enumerable: true,
      get: function() {
        return _directives.GraphQLIncludeDirective;
      }
    });
    Object.defineProperty(exports2, "GraphQLInputObjectType", {
      enumerable: true,
      get: function() {
        return _definition.GraphQLInputObjectType;
      }
    });
    Object.defineProperty(exports2, "GraphQLInt", {
      enumerable: true,
      get: function() {
        return _scalars.GraphQLInt;
      }
    });
    Object.defineProperty(exports2, "GraphQLInterfaceType", {
      enumerable: true,
      get: function() {
        return _definition.GraphQLInterfaceType;
      }
    });
    Object.defineProperty(exports2, "GraphQLList", {
      enumerable: true,
      get: function() {
        return _definition.GraphQLList;
      }
    });
    Object.defineProperty(exports2, "GraphQLNonNull", {
      enumerable: true,
      get: function() {
        return _definition.GraphQLNonNull;
      }
    });
    Object.defineProperty(exports2, "GraphQLObjectType", {
      enumerable: true,
      get: function() {
        return _definition.GraphQLObjectType;
      }
    });
    Object.defineProperty(exports2, "GraphQLScalarType", {
      enumerable: true,
      get: function() {
        return _definition.GraphQLScalarType;
      }
    });
    Object.defineProperty(exports2, "GraphQLSchema", {
      enumerable: true,
      get: function() {
        return _schema.GraphQLSchema;
      }
    });
    Object.defineProperty(exports2, "GraphQLSkipDirective", {
      enumerable: true,
      get: function() {
        return _directives.GraphQLSkipDirective;
      }
    });
    Object.defineProperty(exports2, "GraphQLSpecifiedByDirective", {
      enumerable: true,
      get: function() {
        return _directives.GraphQLSpecifiedByDirective;
      }
    });
    Object.defineProperty(exports2, "GraphQLString", {
      enumerable: true,
      get: function() {
        return _scalars.GraphQLString;
      }
    });
    Object.defineProperty(exports2, "GraphQLUnionType", {
      enumerable: true,
      get: function() {
        return _definition.GraphQLUnionType;
      }
    });
    Object.defineProperty(exports2, "SchemaMetaFieldDef", {
      enumerable: true,
      get: function() {
        return _introspection.SchemaMetaFieldDef;
      }
    });
    Object.defineProperty(exports2, "TypeKind", {
      enumerable: true,
      get: function() {
        return _introspection.TypeKind;
      }
    });
    Object.defineProperty(exports2, "TypeMetaFieldDef", {
      enumerable: true,
      get: function() {
        return _introspection.TypeMetaFieldDef;
      }
    });
    Object.defineProperty(exports2, "TypeNameMetaFieldDef", {
      enumerable: true,
      get: function() {
        return _introspection.TypeNameMetaFieldDef;
      }
    });
    Object.defineProperty(exports2, "__Directive", {
      enumerable: true,
      get: function() {
        return _introspection.__Directive;
      }
    });
    Object.defineProperty(exports2, "__DirectiveLocation", {
      enumerable: true,
      get: function() {
        return _introspection.__DirectiveLocation;
      }
    });
    Object.defineProperty(exports2, "__EnumValue", {
      enumerable: true,
      get: function() {
        return _introspection.__EnumValue;
      }
    });
    Object.defineProperty(exports2, "__Field", {
      enumerable: true,
      get: function() {
        return _introspection.__Field;
      }
    });
    Object.defineProperty(exports2, "__InputValue", {
      enumerable: true,
      get: function() {
        return _introspection.__InputValue;
      }
    });
    Object.defineProperty(exports2, "__Schema", {
      enumerable: true,
      get: function() {
        return _introspection.__Schema;
      }
    });
    Object.defineProperty(exports2, "__Type", {
      enumerable: true,
      get: function() {
        return _introspection.__Type;
      }
    });
    Object.defineProperty(exports2, "__TypeKind", {
      enumerable: true,
      get: function() {
        return _introspection.__TypeKind;
      }
    });
    Object.defineProperty(exports2, "assertAbstractType", {
      enumerable: true,
      get: function() {
        return _definition.assertAbstractType;
      }
    });
    Object.defineProperty(exports2, "assertCompositeType", {
      enumerable: true,
      get: function() {
        return _definition.assertCompositeType;
      }
    });
    Object.defineProperty(exports2, "assertDirective", {
      enumerable: true,
      get: function() {
        return _directives.assertDirective;
      }
    });
    Object.defineProperty(exports2, "assertEnumType", {
      enumerable: true,
      get: function() {
        return _definition.assertEnumType;
      }
    });
    Object.defineProperty(exports2, "assertEnumValueName", {
      enumerable: true,
      get: function() {
        return _assertName.assertEnumValueName;
      }
    });
    Object.defineProperty(exports2, "assertInputObjectType", {
      enumerable: true,
      get: function() {
        return _definition.assertInputObjectType;
      }
    });
    Object.defineProperty(exports2, "assertInputType", {
      enumerable: true,
      get: function() {
        return _definition.assertInputType;
      }
    });
    Object.defineProperty(exports2, "assertInterfaceType", {
      enumerable: true,
      get: function() {
        return _definition.assertInterfaceType;
      }
    });
    Object.defineProperty(exports2, "assertLeafType", {
      enumerable: true,
      get: function() {
        return _definition.assertLeafType;
      }
    });
    Object.defineProperty(exports2, "assertListType", {
      enumerable: true,
      get: function() {
        return _definition.assertListType;
      }
    });
    Object.defineProperty(exports2, "assertName", {
      enumerable: true,
      get: function() {
        return _assertName.assertName;
      }
    });
    Object.defineProperty(exports2, "assertNamedType", {
      enumerable: true,
      get: function() {
        return _definition.assertNamedType;
      }
    });
    Object.defineProperty(exports2, "assertNonNullType", {
      enumerable: true,
      get: function() {
        return _definition.assertNonNullType;
      }
    });
    Object.defineProperty(exports2, "assertNullableType", {
      enumerable: true,
      get: function() {
        return _definition.assertNullableType;
      }
    });
    Object.defineProperty(exports2, "assertObjectType", {
      enumerable: true,
      get: function() {
        return _definition.assertObjectType;
      }
    });
    Object.defineProperty(exports2, "assertOutputType", {
      enumerable: true,
      get: function() {
        return _definition.assertOutputType;
      }
    });
    Object.defineProperty(exports2, "assertScalarType", {
      enumerable: true,
      get: function() {
        return _definition.assertScalarType;
      }
    });
    Object.defineProperty(exports2, "assertSchema", {
      enumerable: true,
      get: function() {
        return _schema.assertSchema;
      }
    });
    Object.defineProperty(exports2, "assertType", {
      enumerable: true,
      get: function() {
        return _definition.assertType;
      }
    });
    Object.defineProperty(exports2, "assertUnionType", {
      enumerable: true,
      get: function() {
        return _definition.assertUnionType;
      }
    });
    Object.defineProperty(exports2, "assertValidSchema", {
      enumerable: true,
      get: function() {
        return _validate.assertValidSchema;
      }
    });
    Object.defineProperty(exports2, "assertWrappingType", {
      enumerable: true,
      get: function() {
        return _definition.assertWrappingType;
      }
    });
    Object.defineProperty(exports2, "getNamedType", {
      enumerable: true,
      get: function() {
        return _definition.getNamedType;
      }
    });
    Object.defineProperty(exports2, "getNullableType", {
      enumerable: true,
      get: function() {
        return _definition.getNullableType;
      }
    });
    Object.defineProperty(exports2, "introspectionTypes", {
      enumerable: true,
      get: function() {
        return _introspection.introspectionTypes;
      }
    });
    Object.defineProperty(exports2, "isAbstractType", {
      enumerable: true,
      get: function() {
        return _definition.isAbstractType;
      }
    });
    Object.defineProperty(exports2, "isCompositeType", {
      enumerable: true,
      get: function() {
        return _definition.isCompositeType;
      }
    });
    Object.defineProperty(exports2, "isDirective", {
      enumerable: true,
      get: function() {
        return _directives.isDirective;
      }
    });
    Object.defineProperty(exports2, "isEnumType", {
      enumerable: true,
      get: function() {
        return _definition.isEnumType;
      }
    });
    Object.defineProperty(exports2, "isInputObjectType", {
      enumerable: true,
      get: function() {
        return _definition.isInputObjectType;
      }
    });
    Object.defineProperty(exports2, "isInputType", {
      enumerable: true,
      get: function() {
        return _definition.isInputType;
      }
    });
    Object.defineProperty(exports2, "isInterfaceType", {
      enumerable: true,
      get: function() {
        return _definition.isInterfaceType;
      }
    });
    Object.defineProperty(exports2, "isIntrospectionType", {
      enumerable: true,
      get: function() {
        return _introspection.isIntrospectionType;
      }
    });
    Object.defineProperty(exports2, "isLeafType", {
      enumerable: true,
      get: function() {
        return _definition.isLeafType;
      }
    });
    Object.defineProperty(exports2, "isListType", {
      enumerable: true,
      get: function() {
        return _definition.isListType;
      }
    });
    Object.defineProperty(exports2, "isNamedType", {
      enumerable: true,
      get: function() {
        return _definition.isNamedType;
      }
    });
    Object.defineProperty(exports2, "isNonNullType", {
      enumerable: true,
      get: function() {
        return _definition.isNonNullType;
      }
    });
    Object.defineProperty(exports2, "isNullableType", {
      enumerable: true,
      get: function() {
        return _definition.isNullableType;
      }
    });
    Object.defineProperty(exports2, "isObjectType", {
      enumerable: true,
      get: function() {
        return _definition.isObjectType;
      }
    });
    Object.defineProperty(exports2, "isOutputType", {
      enumerable: true,
      get: function() {
        return _definition.isOutputType;
      }
    });
    Object.defineProperty(exports2, "isRequiredArgument", {
      enumerable: true,
      get: function() {
        return _definition.isRequiredArgument;
      }
    });
    Object.defineProperty(exports2, "isRequiredInputField", {
      enumerable: true,
      get: function() {
        return _definition.isRequiredInputField;
      }
    });
    Object.defineProperty(exports2, "isScalarType", {
      enumerable: true,
      get: function() {
        return _definition.isScalarType;
      }
    });
    Object.defineProperty(exports2, "isSchema", {
      enumerable: true,
      get: function() {
        return _schema.isSchema;
      }
    });
    Object.defineProperty(exports2, "isSpecifiedDirective", {
      enumerable: true,
      get: function() {
        return _directives.isSpecifiedDirective;
      }
    });
    Object.defineProperty(exports2, "isSpecifiedScalarType", {
      enumerable: true,
      get: function() {
        return _scalars.isSpecifiedScalarType;
      }
    });
    Object.defineProperty(exports2, "isType", {
      enumerable: true,
      get: function() {
        return _definition.isType;
      }
    });
    Object.defineProperty(exports2, "isUnionType", {
      enumerable: true,
      get: function() {
        return _definition.isUnionType;
      }
    });
    Object.defineProperty(exports2, "isWrappingType", {
      enumerable: true,
      get: function() {
        return _definition.isWrappingType;
      }
    });
    Object.defineProperty(exports2, "resolveObjMapThunk", {
      enumerable: true,
      get: function() {
        return _definition.resolveObjMapThunk;
      }
    });
    Object.defineProperty(exports2, "resolveReadonlyArrayThunk", {
      enumerable: true,
      get: function() {
        return _definition.resolveReadonlyArrayThunk;
      }
    });
    Object.defineProperty(exports2, "specifiedDirectives", {
      enumerable: true,
      get: function() {
        return _directives.specifiedDirectives;
      }
    });
    Object.defineProperty(exports2, "specifiedScalarTypes", {
      enumerable: true,
      get: function() {
        return _scalars.specifiedScalarTypes;
      }
    });
    Object.defineProperty(exports2, "validateSchema", {
      enumerable: true,
      get: function() {
        return _validate.validateSchema;
      }
    });
    var _schema = require_schema();
    var _definition = require_definition();
    var _directives = require_directives();
    var _scalars = require_scalars();
    var _introspection = require_introspection();
    var _validate = require_validate();
    var _assertName = require_assertName();
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/language/index.js
var require_language = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/language/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "BREAK", {
      enumerable: true,
      get: function() {
        return _visitor.BREAK;
      }
    });
    Object.defineProperty(exports2, "DirectiveLocation", {
      enumerable: true,
      get: function() {
        return _directiveLocation.DirectiveLocation;
      }
    });
    Object.defineProperty(exports2, "Kind", {
      enumerable: true,
      get: function() {
        return _kinds.Kind;
      }
    });
    Object.defineProperty(exports2, "Lexer", {
      enumerable: true,
      get: function() {
        return _lexer.Lexer;
      }
    });
    Object.defineProperty(exports2, "Location", {
      enumerable: true,
      get: function() {
        return _ast.Location;
      }
    });
    Object.defineProperty(exports2, "OperationTypeNode", {
      enumerable: true,
      get: function() {
        return _ast.OperationTypeNode;
      }
    });
    Object.defineProperty(exports2, "Source", {
      enumerable: true,
      get: function() {
        return _source.Source;
      }
    });
    Object.defineProperty(exports2, "Token", {
      enumerable: true,
      get: function() {
        return _ast.Token;
      }
    });
    Object.defineProperty(exports2, "TokenKind", {
      enumerable: true,
      get: function() {
        return _tokenKind.TokenKind;
      }
    });
    Object.defineProperty(exports2, "getEnterLeaveForKind", {
      enumerable: true,
      get: function() {
        return _visitor.getEnterLeaveForKind;
      }
    });
    Object.defineProperty(exports2, "getLocation", {
      enumerable: true,
      get: function() {
        return _location.getLocation;
      }
    });
    Object.defineProperty(exports2, "getVisitFn", {
      enumerable: true,
      get: function() {
        return _visitor.getVisitFn;
      }
    });
    Object.defineProperty(exports2, "isConstValueNode", {
      enumerable: true,
      get: function() {
        return _predicates.isConstValueNode;
      }
    });
    Object.defineProperty(exports2, "isDefinitionNode", {
      enumerable: true,
      get: function() {
        return _predicates.isDefinitionNode;
      }
    });
    Object.defineProperty(exports2, "isExecutableDefinitionNode", {
      enumerable: true,
      get: function() {
        return _predicates.isExecutableDefinitionNode;
      }
    });
    Object.defineProperty(exports2, "isSelectionNode", {
      enumerable: true,
      get: function() {
        return _predicates.isSelectionNode;
      }
    });
    Object.defineProperty(exports2, "isTypeDefinitionNode", {
      enumerable: true,
      get: function() {
        return _predicates.isTypeDefinitionNode;
      }
    });
    Object.defineProperty(exports2, "isTypeExtensionNode", {
      enumerable: true,
      get: function() {
        return _predicates.isTypeExtensionNode;
      }
    });
    Object.defineProperty(exports2, "isTypeNode", {
      enumerable: true,
      get: function() {
        return _predicates.isTypeNode;
      }
    });
    Object.defineProperty(exports2, "isTypeSystemDefinitionNode", {
      enumerable: true,
      get: function() {
        return _predicates.isTypeSystemDefinitionNode;
      }
    });
    Object.defineProperty(exports2, "isTypeSystemExtensionNode", {
      enumerable: true,
      get: function() {
        return _predicates.isTypeSystemExtensionNode;
      }
    });
    Object.defineProperty(exports2, "isValueNode", {
      enumerable: true,
      get: function() {
        return _predicates.isValueNode;
      }
    });
    Object.defineProperty(exports2, "parse", {
      enumerable: true,
      get: function() {
        return _parser.parse;
      }
    });
    Object.defineProperty(exports2, "parseConstValue", {
      enumerable: true,
      get: function() {
        return _parser.parseConstValue;
      }
    });
    Object.defineProperty(exports2, "parseType", {
      enumerable: true,
      get: function() {
        return _parser.parseType;
      }
    });
    Object.defineProperty(exports2, "parseValue", {
      enumerable: true,
      get: function() {
        return _parser.parseValue;
      }
    });
    Object.defineProperty(exports2, "print", {
      enumerable: true,
      get: function() {
        return _printer.print;
      }
    });
    Object.defineProperty(exports2, "printLocation", {
      enumerable: true,
      get: function() {
        return _printLocation.printLocation;
      }
    });
    Object.defineProperty(exports2, "printSourceLocation", {
      enumerable: true,
      get: function() {
        return _printLocation.printSourceLocation;
      }
    });
    Object.defineProperty(exports2, "visit", {
      enumerable: true,
      get: function() {
        return _visitor.visit;
      }
    });
    Object.defineProperty(exports2, "visitInParallel", {
      enumerable: true,
      get: function() {
        return _visitor.visitInParallel;
      }
    });
    var _source = require_source();
    var _location = require_location();
    var _printLocation = require_printLocation();
    var _kinds = require_kinds();
    var _tokenKind = require_tokenKind();
    var _lexer = require_lexer();
    var _parser = require_parser();
    var _printer = require_printer();
    var _visitor = require_visitor();
    var _ast = require_ast();
    var _predicates = require_predicates();
    var _directiveLocation = require_directiveLocation();
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/isAsyncIterable.js
var require_isAsyncIterable = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/jsutils/isAsyncIterable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isAsyncIterable = isAsyncIterable3;
    function isAsyncIterable3(maybeAsyncIterable) {
      return typeof (maybeAsyncIterable === null || maybeAsyncIterable === void 0 ? void 0 : maybeAsyncIterable[Symbol.asyncIterator]) === "function";
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/execution/mapAsyncIterator.js
var require_mapAsyncIterator = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/execution/mapAsyncIterator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.mapAsyncIterator = mapAsyncIterator2;
    function mapAsyncIterator2(iterable, callback) {
      const iterator = iterable[Symbol.asyncIterator]();
      async function mapResult(result) {
        if (result.done) {
          return result;
        }
        try {
          return {
            value: await callback(result.value),
            done: false
          };
        } catch (error2) {
          if (typeof iterator.return === "function") {
            try {
              await iterator.return();
            } catch (_e) {
            }
          }
          throw error2;
        }
      }
      return {
        async next() {
          return mapResult(await iterator.next());
        },
        async return() {
          return typeof iterator.return === "function" ? mapResult(await iterator.return()) : {
            value: void 0,
            done: true
          };
        },
        async throw(error2) {
          if (typeof iterator.throw === "function") {
            return mapResult(await iterator.throw(error2));
          }
          throw error2;
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/execution/subscribe.js
var require_subscribe = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/execution/subscribe.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createSourceEventStream = createSourceEventStream;
    exports2.subscribe = subscribe2;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _isAsyncIterable = require_isAsyncIterable();
    var _Path = require_Path();
    var _GraphQLError = require_GraphQLError();
    var _locatedError = require_locatedError();
    var _collectFields = require_collectFields();
    var _execute = require_execute();
    var _mapAsyncIterator = require_mapAsyncIterator();
    var _values = require_values();
    async function subscribe2(args) {
      arguments.length < 2 || (0, _devAssert.devAssert)(false, "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.");
      const {
        schema,
        document,
        rootValue,
        contextValue,
        variableValues,
        operationName,
        fieldResolver,
        subscribeFieldResolver
      } = args;
      const resultOrStream = await createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, subscribeFieldResolver);
      if (!(0, _isAsyncIterable.isAsyncIterable)(resultOrStream)) {
        return resultOrStream;
      }
      const mapSourceToResponse = (payload) => (0, _execute.execute)({
        schema,
        document,
        rootValue: payload,
        contextValue,
        variableValues,
        operationName,
        fieldResolver
      });
      return (0, _mapAsyncIterator.mapAsyncIterator)(resultOrStream, mapSourceToResponse);
    }
    async function createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, subscribeFieldResolver) {
      (0, _execute.assertValidExecutionArguments)(schema, document, variableValues);
      const exeContext = (0, _execute.buildExecutionContext)({
        schema,
        document,
        rootValue,
        contextValue,
        variableValues,
        operationName,
        subscribeFieldResolver
      });
      if (!("schema" in exeContext)) {
        return {
          errors: exeContext
        };
      }
      try {
        const eventStream = await executeSubscription(exeContext);
        if (!(0, _isAsyncIterable.isAsyncIterable)(eventStream)) {
          throw new Error(`Subscription field must return Async Iterable. Received: ${(0, _inspect.inspect)(eventStream)}.`);
        }
        return eventStream;
      } catch (error2) {
        if (error2 instanceof _GraphQLError.GraphQLError) {
          return {
            errors: [error2]
          };
        }
        throw error2;
      }
    }
    async function executeSubscription(exeContext) {
      const { schema, fragments, operation, variableValues, rootValue } = exeContext;
      const rootType = schema.getSubscriptionType();
      if (rootType == null) {
        throw new _GraphQLError.GraphQLError("Schema is not configured to execute subscription operation.", {
          nodes: operation
        });
      }
      const rootFields = (0, _collectFields.collectFields)(schema, fragments, variableValues, rootType, operation.selectionSet);
      const [responseName, fieldNodes] = [...rootFields.entries()][0];
      const fieldDef = (0, _execute.getFieldDef)(schema, rootType, fieldNodes[0]);
      if (!fieldDef) {
        const fieldName = fieldNodes[0].name.value;
        throw new _GraphQLError.GraphQLError(`The subscription field "${fieldName}" is not defined.`, {
          nodes: fieldNodes
        });
      }
      const path = (0, _Path.addPath)(void 0, responseName, rootType.name);
      const info = (0, _execute.buildResolveInfo)(exeContext, fieldDef, fieldNodes, rootType, path);
      try {
        var _fieldDef$subscribe;
        const args = (0, _values.getArgumentValues)(fieldDef, fieldNodes[0], variableValues);
        const contextValue = exeContext.contextValue;
        const resolveFn = (_fieldDef$subscribe = fieldDef.subscribe) !== null && _fieldDef$subscribe !== void 0 ? _fieldDef$subscribe : exeContext.subscribeFieldResolver;
        const eventStream = await resolveFn(rootValue, args, contextValue, info);
        if (eventStream instanceof Error) {
          throw eventStream;
        }
        return eventStream;
      } catch (error2) {
        throw (0, _locatedError.locatedError)(error2, fieldNodes, (0, _Path.pathToArray)(path));
      }
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/execution/index.js
var require_execution = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/execution/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "createSourceEventStream", {
      enumerable: true,
      get: function() {
        return _subscribe.createSourceEventStream;
      }
    });
    Object.defineProperty(exports2, "defaultFieldResolver", {
      enumerable: true,
      get: function() {
        return _execute.defaultFieldResolver;
      }
    });
    Object.defineProperty(exports2, "defaultTypeResolver", {
      enumerable: true,
      get: function() {
        return _execute.defaultTypeResolver;
      }
    });
    Object.defineProperty(exports2, "execute", {
      enumerable: true,
      get: function() {
        return _execute.execute;
      }
    });
    Object.defineProperty(exports2, "executeSync", {
      enumerable: true,
      get: function() {
        return _execute.executeSync;
      }
    });
    Object.defineProperty(exports2, "getArgumentValues", {
      enumerable: true,
      get: function() {
        return _values.getArgumentValues;
      }
    });
    Object.defineProperty(exports2, "getDirectiveValues", {
      enumerable: true,
      get: function() {
        return _values.getDirectiveValues;
      }
    });
    Object.defineProperty(exports2, "getVariableValues", {
      enumerable: true,
      get: function() {
        return _values.getVariableValues;
      }
    });
    Object.defineProperty(exports2, "responsePathAsArray", {
      enumerable: true,
      get: function() {
        return _Path.pathToArray;
      }
    });
    Object.defineProperty(exports2, "subscribe", {
      enumerable: true,
      get: function() {
        return _subscribe.subscribe;
      }
    });
    var _Path = require_Path();
    var _execute = require_execute();
    var _subscribe = require_subscribe();
    var _values = require_values();
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.js
var require_NoDeprecatedCustomRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NoDeprecatedCustomRule = NoDeprecatedCustomRule;
    var _invariant = require_invariant();
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function NoDeprecatedCustomRule(context) {
      return {
        Field(node) {
          const fieldDef = context.getFieldDef();
          const deprecationReason = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.deprecationReason;
          if (fieldDef && deprecationReason != null) {
            const parentType = context.getParentType();
            parentType != null || (0, _invariant.invariant)(false);
            context.reportError(new _GraphQLError.GraphQLError(`The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`, {
              nodes: node
            }));
          }
        },
        Argument(node) {
          const argDef = context.getArgument();
          const deprecationReason = argDef === null || argDef === void 0 ? void 0 : argDef.deprecationReason;
          if (argDef && deprecationReason != null) {
            const directiveDef = context.getDirective();
            if (directiveDef != null) {
              context.reportError(new _GraphQLError.GraphQLError(`Directive "@${directiveDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`, {
                nodes: node
              }));
            } else {
              const parentType = context.getParentType();
              const fieldDef = context.getFieldDef();
              parentType != null && fieldDef != null || (0, _invariant.invariant)(false);
              context.reportError(new _GraphQLError.GraphQLError(`Field "${parentType.name}.${fieldDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`, {
                nodes: node
              }));
            }
          }
        },
        ObjectField(node) {
          const inputObjectDef = (0, _definition.getNamedType)(context.getParentInputType());
          if ((0, _definition.isInputObjectType)(inputObjectDef)) {
            const inputFieldDef = inputObjectDef.getFields()[node.name.value];
            const deprecationReason = inputFieldDef === null || inputFieldDef === void 0 ? void 0 : inputFieldDef.deprecationReason;
            if (deprecationReason != null) {
              context.reportError(new _GraphQLError.GraphQLError(`The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`, {
                nodes: node
              }));
            }
          }
        },
        EnumValue(node) {
          const enumValueDef = context.getEnumValue();
          const deprecationReason = enumValueDef === null || enumValueDef === void 0 ? void 0 : enumValueDef.deprecationReason;
          if (enumValueDef && deprecationReason != null) {
            const enumTypeDef = (0, _definition.getNamedType)(context.getInputType());
            enumTypeDef != null || (0, _invariant.invariant)(false);
            context.reportError(new _GraphQLError.GraphQLError(`The enum value "${enumTypeDef.name}.${enumValueDef.name}" is deprecated. ${deprecationReason}`, {
              nodes: node
            }));
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.js
var require_NoSchemaIntrospectionCustomRule = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NoSchemaIntrospectionCustomRule = NoSchemaIntrospectionCustomRule;
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    var _introspection = require_introspection();
    function NoSchemaIntrospectionCustomRule(context) {
      return {
        Field(node) {
          const type = (0, _definition.getNamedType)(context.getType());
          if (type && (0, _introspection.isIntrospectionType)(type)) {
            context.reportError(new _GraphQLError.GraphQLError(`GraphQL introspection has been disabled, but the requested query contained the field "${node.name.value}".`, {
              nodes: node
            }));
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/index.js
var require_validation = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/validation/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "ExecutableDefinitionsRule", {
      enumerable: true,
      get: function() {
        return _ExecutableDefinitionsRule.ExecutableDefinitionsRule;
      }
    });
    Object.defineProperty(exports2, "FieldsOnCorrectTypeRule", {
      enumerable: true,
      get: function() {
        return _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule;
      }
    });
    Object.defineProperty(exports2, "FragmentsOnCompositeTypesRule", {
      enumerable: true,
      get: function() {
        return _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule;
      }
    });
    Object.defineProperty(exports2, "KnownArgumentNamesRule", {
      enumerable: true,
      get: function() {
        return _KnownArgumentNamesRule.KnownArgumentNamesRule;
      }
    });
    Object.defineProperty(exports2, "KnownDirectivesRule", {
      enumerable: true,
      get: function() {
        return _KnownDirectivesRule.KnownDirectivesRule;
      }
    });
    Object.defineProperty(exports2, "KnownFragmentNamesRule", {
      enumerable: true,
      get: function() {
        return _KnownFragmentNamesRule.KnownFragmentNamesRule;
      }
    });
    Object.defineProperty(exports2, "KnownTypeNamesRule", {
      enumerable: true,
      get: function() {
        return _KnownTypeNamesRule.KnownTypeNamesRule;
      }
    });
    Object.defineProperty(exports2, "LoneAnonymousOperationRule", {
      enumerable: true,
      get: function() {
        return _LoneAnonymousOperationRule.LoneAnonymousOperationRule;
      }
    });
    Object.defineProperty(exports2, "LoneSchemaDefinitionRule", {
      enumerable: true,
      get: function() {
        return _LoneSchemaDefinitionRule.LoneSchemaDefinitionRule;
      }
    });
    Object.defineProperty(exports2, "NoDeprecatedCustomRule", {
      enumerable: true,
      get: function() {
        return _NoDeprecatedCustomRule.NoDeprecatedCustomRule;
      }
    });
    Object.defineProperty(exports2, "NoFragmentCyclesRule", {
      enumerable: true,
      get: function() {
        return _NoFragmentCyclesRule.NoFragmentCyclesRule;
      }
    });
    Object.defineProperty(exports2, "NoSchemaIntrospectionCustomRule", {
      enumerable: true,
      get: function() {
        return _NoSchemaIntrospectionCustomRule.NoSchemaIntrospectionCustomRule;
      }
    });
    Object.defineProperty(exports2, "NoUndefinedVariablesRule", {
      enumerable: true,
      get: function() {
        return _NoUndefinedVariablesRule.NoUndefinedVariablesRule;
      }
    });
    Object.defineProperty(exports2, "NoUnusedFragmentsRule", {
      enumerable: true,
      get: function() {
        return _NoUnusedFragmentsRule.NoUnusedFragmentsRule;
      }
    });
    Object.defineProperty(exports2, "NoUnusedVariablesRule", {
      enumerable: true,
      get: function() {
        return _NoUnusedVariablesRule.NoUnusedVariablesRule;
      }
    });
    Object.defineProperty(exports2, "OverlappingFieldsCanBeMergedRule", {
      enumerable: true,
      get: function() {
        return _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule;
      }
    });
    Object.defineProperty(exports2, "PossibleFragmentSpreadsRule", {
      enumerable: true,
      get: function() {
        return _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule;
      }
    });
    Object.defineProperty(exports2, "PossibleTypeExtensionsRule", {
      enumerable: true,
      get: function() {
        return _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule;
      }
    });
    Object.defineProperty(exports2, "ProvidedRequiredArgumentsRule", {
      enumerable: true,
      get: function() {
        return _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule;
      }
    });
    Object.defineProperty(exports2, "ScalarLeafsRule", {
      enumerable: true,
      get: function() {
        return _ScalarLeafsRule.ScalarLeafsRule;
      }
    });
    Object.defineProperty(exports2, "SingleFieldSubscriptionsRule", {
      enumerable: true,
      get: function() {
        return _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule;
      }
    });
    Object.defineProperty(exports2, "UniqueArgumentDefinitionNamesRule", {
      enumerable: true,
      get: function() {
        return _UniqueArgumentDefinitionNamesRule.UniqueArgumentDefinitionNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueArgumentNamesRule", {
      enumerable: true,
      get: function() {
        return _UniqueArgumentNamesRule.UniqueArgumentNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueDirectiveNamesRule", {
      enumerable: true,
      get: function() {
        return _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueDirectivesPerLocationRule", {
      enumerable: true,
      get: function() {
        return _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule;
      }
    });
    Object.defineProperty(exports2, "UniqueEnumValueNamesRule", {
      enumerable: true,
      get: function() {
        return _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueFieldDefinitionNamesRule", {
      enumerable: true,
      get: function() {
        return _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueFragmentNamesRule", {
      enumerable: true,
      get: function() {
        return _UniqueFragmentNamesRule.UniqueFragmentNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueInputFieldNamesRule", {
      enumerable: true,
      get: function() {
        return _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueOperationNamesRule", {
      enumerable: true,
      get: function() {
        return _UniqueOperationNamesRule.UniqueOperationNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueOperationTypesRule", {
      enumerable: true,
      get: function() {
        return _UniqueOperationTypesRule.UniqueOperationTypesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueTypeNamesRule", {
      enumerable: true,
      get: function() {
        return _UniqueTypeNamesRule.UniqueTypeNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueVariableNamesRule", {
      enumerable: true,
      get: function() {
        return _UniqueVariableNamesRule.UniqueVariableNamesRule;
      }
    });
    Object.defineProperty(exports2, "ValidationContext", {
      enumerable: true,
      get: function() {
        return _ValidationContext.ValidationContext;
      }
    });
    Object.defineProperty(exports2, "ValuesOfCorrectTypeRule", {
      enumerable: true,
      get: function() {
        return _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule;
      }
    });
    Object.defineProperty(exports2, "VariablesAreInputTypesRule", {
      enumerable: true,
      get: function() {
        return _VariablesAreInputTypesRule.VariablesAreInputTypesRule;
      }
    });
    Object.defineProperty(exports2, "VariablesInAllowedPositionRule", {
      enumerable: true,
      get: function() {
        return _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule;
      }
    });
    Object.defineProperty(exports2, "specifiedRules", {
      enumerable: true,
      get: function() {
        return _specifiedRules.specifiedRules;
      }
    });
    Object.defineProperty(exports2, "validate", {
      enumerable: true,
      get: function() {
        return _validate.validate;
      }
    });
    var _validate = require_validate2();
    var _ValidationContext = require_ValidationContext();
    var _specifiedRules = require_specifiedRules();
    var _ExecutableDefinitionsRule = require_ExecutableDefinitionsRule();
    var _FieldsOnCorrectTypeRule = require_FieldsOnCorrectTypeRule();
    var _FragmentsOnCompositeTypesRule = require_FragmentsOnCompositeTypesRule();
    var _KnownArgumentNamesRule = require_KnownArgumentNamesRule();
    var _KnownDirectivesRule = require_KnownDirectivesRule();
    var _KnownFragmentNamesRule = require_KnownFragmentNamesRule();
    var _KnownTypeNamesRule = require_KnownTypeNamesRule();
    var _LoneAnonymousOperationRule = require_LoneAnonymousOperationRule();
    var _NoFragmentCyclesRule = require_NoFragmentCyclesRule();
    var _NoUndefinedVariablesRule = require_NoUndefinedVariablesRule();
    var _NoUnusedFragmentsRule = require_NoUnusedFragmentsRule();
    var _NoUnusedVariablesRule = require_NoUnusedVariablesRule();
    var _OverlappingFieldsCanBeMergedRule = require_OverlappingFieldsCanBeMergedRule();
    var _PossibleFragmentSpreadsRule = require_PossibleFragmentSpreadsRule();
    var _ProvidedRequiredArgumentsRule = require_ProvidedRequiredArgumentsRule();
    var _ScalarLeafsRule = require_ScalarLeafsRule();
    var _SingleFieldSubscriptionsRule = require_SingleFieldSubscriptionsRule();
    var _UniqueArgumentNamesRule = require_UniqueArgumentNamesRule();
    var _UniqueDirectivesPerLocationRule = require_UniqueDirectivesPerLocationRule();
    var _UniqueFragmentNamesRule = require_UniqueFragmentNamesRule();
    var _UniqueInputFieldNamesRule = require_UniqueInputFieldNamesRule();
    var _UniqueOperationNamesRule = require_UniqueOperationNamesRule();
    var _UniqueVariableNamesRule = require_UniqueVariableNamesRule();
    var _ValuesOfCorrectTypeRule = require_ValuesOfCorrectTypeRule();
    var _VariablesAreInputTypesRule = require_VariablesAreInputTypesRule();
    var _VariablesInAllowedPositionRule = require_VariablesInAllowedPositionRule();
    var _LoneSchemaDefinitionRule = require_LoneSchemaDefinitionRule();
    var _UniqueOperationTypesRule = require_UniqueOperationTypesRule();
    var _UniqueTypeNamesRule = require_UniqueTypeNamesRule();
    var _UniqueEnumValueNamesRule = require_UniqueEnumValueNamesRule();
    var _UniqueFieldDefinitionNamesRule = require_UniqueFieldDefinitionNamesRule();
    var _UniqueArgumentDefinitionNamesRule = require_UniqueArgumentDefinitionNamesRule();
    var _UniqueDirectiveNamesRule = require_UniqueDirectiveNamesRule();
    var _PossibleTypeExtensionsRule = require_PossibleTypeExtensionsRule();
    var _NoDeprecatedCustomRule = require_NoDeprecatedCustomRule();
    var _NoSchemaIntrospectionCustomRule = require_NoSchemaIntrospectionCustomRule();
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/error/index.js
var require_error = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/error/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "GraphQLError", {
      enumerable: true,
      get: function() {
        return _GraphQLError.GraphQLError;
      }
    });
    Object.defineProperty(exports2, "formatError", {
      enumerable: true,
      get: function() {
        return _GraphQLError.formatError;
      }
    });
    Object.defineProperty(exports2, "locatedError", {
      enumerable: true,
      get: function() {
        return _locatedError.locatedError;
      }
    });
    Object.defineProperty(exports2, "printError", {
      enumerable: true,
      get: function() {
        return _GraphQLError.printError;
      }
    });
    Object.defineProperty(exports2, "syntaxError", {
      enumerable: true,
      get: function() {
        return _syntaxError.syntaxError;
      }
    });
    var _GraphQLError = require_GraphQLError();
    var _syntaxError = require_syntaxError();
    var _locatedError = require_locatedError();
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/getIntrospectionQuery.js
var require_getIntrospectionQuery = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/getIntrospectionQuery.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getIntrospectionQuery = getIntrospectionQuery;
    function getIntrospectionQuery(options2) {
      const optionsWithDefault = {
        descriptions: true,
        specifiedByUrl: false,
        directiveIsRepeatable: false,
        schemaDescription: false,
        inputValueDeprecation: false,
        ...options2
      };
      const descriptions = optionsWithDefault.descriptions ? "description" : "";
      const specifiedByUrl = optionsWithDefault.specifiedByUrl ? "specifiedByURL" : "";
      const directiveIsRepeatable = optionsWithDefault.directiveIsRepeatable ? "isRepeatable" : "";
      const schemaDescription = optionsWithDefault.schemaDescription ? descriptions : "";
      function inputDeprecation(str) {
        return optionsWithDefault.inputValueDeprecation ? str : "";
      }
      return `
    query IntrospectionQuery {
      __schema {
        ${schemaDescription}
        queryType { name }
        mutationType { name }
        subscriptionType { name }
        types {
          ...FullType
        }
        directives {
          name
          ${descriptions}
          ${directiveIsRepeatable}
          locations
          args${inputDeprecation("(includeDeprecated: true)")} {
            ...InputValue
          }
        }
      }
    }

    fragment FullType on __Type {
      kind
      name
      ${descriptions}
      ${specifiedByUrl}
      fields(includeDeprecated: true) {
        name
        ${descriptions}
        args${inputDeprecation("(includeDeprecated: true)")} {
          ...InputValue
        }
        type {
          ...TypeRef
        }
        isDeprecated
        deprecationReason
      }
      inputFields${inputDeprecation("(includeDeprecated: true)")} {
        ...InputValue
      }
      interfaces {
        ...TypeRef
      }
      enumValues(includeDeprecated: true) {
        name
        ${descriptions}
        isDeprecated
        deprecationReason
      }
      possibleTypes {
        ...TypeRef
      }
    }

    fragment InputValue on __InputValue {
      name
      ${descriptions}
      type { ...TypeRef }
      defaultValue
      ${inputDeprecation("isDeprecated")}
      ${inputDeprecation("deprecationReason")}
    }

    fragment TypeRef on __Type {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                  }
                }
              }
            }
          }
        }
      }
    }
  `;
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/getOperationAST.js
var require_getOperationAST = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/getOperationAST.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getOperationAST = getOperationAST4;
    var _kinds = require_kinds();
    function getOperationAST4(documentAST, operationName) {
      let operation = null;
      for (const definition of documentAST.definitions) {
        if (definition.kind === _kinds.Kind.OPERATION_DEFINITION) {
          var _definition$name;
          if (operationName == null) {
            if (operation) {
              return null;
            }
            operation = definition;
          } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
            return definition;
          }
        }
      }
      return operation;
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/getOperationRootType.js
var require_getOperationRootType = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/getOperationRootType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getOperationRootType = getOperationRootType2;
    var _GraphQLError = require_GraphQLError();
    function getOperationRootType2(schema, operation) {
      if (operation.operation === "query") {
        const queryType = schema.getQueryType();
        if (!queryType) {
          throw new _GraphQLError.GraphQLError("Schema does not define the required query root type.", {
            nodes: operation
          });
        }
        return queryType;
      }
      if (operation.operation === "mutation") {
        const mutationType = schema.getMutationType();
        if (!mutationType) {
          throw new _GraphQLError.GraphQLError("Schema is not configured for mutations.", {
            nodes: operation
          });
        }
        return mutationType;
      }
      if (operation.operation === "subscription") {
        const subscriptionType = schema.getSubscriptionType();
        if (!subscriptionType) {
          throw new _GraphQLError.GraphQLError("Schema is not configured for subscriptions.", {
            nodes: operation
          });
        }
        return subscriptionType;
      }
      throw new _GraphQLError.GraphQLError("Can only have query, mutation and subscription operations.", {
        nodes: operation
      });
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/introspectionFromSchema.js
var require_introspectionFromSchema = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/introspectionFromSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.introspectionFromSchema = introspectionFromSchema;
    var _invariant = require_invariant();
    var _parser = require_parser();
    var _execute = require_execute();
    var _getIntrospectionQuery = require_getIntrospectionQuery();
    function introspectionFromSchema(schema, options2) {
      const optionsWithDefaults = {
        specifiedByUrl: true,
        directiveIsRepeatable: true,
        schemaDescription: true,
        inputValueDeprecation: true,
        ...options2
      };
      const document = (0, _parser.parse)((0, _getIntrospectionQuery.getIntrospectionQuery)(optionsWithDefaults));
      const result = (0, _execute.executeSync)({
        schema,
        document
      });
      !result.errors && result.data || (0, _invariant.invariant)(false);
      return result.data;
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/buildClientSchema.js
var require_buildClientSchema = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/buildClientSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.buildClientSchema = buildClientSchema2;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _isObjectLike = require_isObjectLike();
    var _keyValMap = require_keyValMap();
    var _parser = require_parser();
    var _definition = require_definition();
    var _directives = require_directives();
    var _introspection = require_introspection();
    var _scalars = require_scalars();
    var _schema = require_schema();
    var _valueFromAST = require_valueFromAST();
    function buildClientSchema2(introspection, options2) {
      (0, _isObjectLike.isObjectLike)(introspection) && (0, _isObjectLike.isObjectLike)(introspection.__schema) || (0, _devAssert.devAssert)(false, `Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: ${(0, _inspect.inspect)(introspection)}.`);
      const schemaIntrospection = introspection.__schema;
      const typeMap = (0, _keyValMap.keyValMap)(schemaIntrospection.types, (typeIntrospection) => typeIntrospection.name, (typeIntrospection) => buildType(typeIntrospection));
      for (const stdType of [
        ..._scalars.specifiedScalarTypes,
        ..._introspection.introspectionTypes
      ]) {
        if (typeMap[stdType.name]) {
          typeMap[stdType.name] = stdType;
        }
      }
      const queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;
      const mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;
      const subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null;
      const directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : [];
      return new _schema.GraphQLSchema({
        description: schemaIntrospection.description,
        query: queryType,
        mutation: mutationType,
        subscription: subscriptionType,
        types: Object.values(typeMap),
        directives,
        assumeValid: options2 === null || options2 === void 0 ? void 0 : options2.assumeValid
      });
      function getType(typeRef) {
        if (typeRef.kind === _introspection.TypeKind.LIST) {
          const itemRef = typeRef.ofType;
          if (!itemRef) {
            throw new Error("Decorated type deeper than introspection query.");
          }
          return new _definition.GraphQLList(getType(itemRef));
        }
        if (typeRef.kind === _introspection.TypeKind.NON_NULL) {
          const nullableRef = typeRef.ofType;
          if (!nullableRef) {
            throw new Error("Decorated type deeper than introspection query.");
          }
          const nullableType = getType(nullableRef);
          return new _definition.GraphQLNonNull((0, _definition.assertNullableType)(nullableType));
        }
        return getNamedType5(typeRef);
      }
      function getNamedType5(typeRef) {
        const typeName = typeRef.name;
        if (!typeName) {
          throw new Error(`Unknown type reference: ${(0, _inspect.inspect)(typeRef)}.`);
        }
        const type = typeMap[typeName];
        if (!type) {
          throw new Error(`Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`);
        }
        return type;
      }
      function getObjectType(typeRef) {
        return (0, _definition.assertObjectType)(getNamedType5(typeRef));
      }
      function getInterfaceType(typeRef) {
        return (0, _definition.assertInterfaceType)(getNamedType5(typeRef));
      }
      function buildType(type) {
        if (type != null && type.name != null && type.kind != null) {
          switch (type.kind) {
            case _introspection.TypeKind.SCALAR:
              return buildScalarDef(type);
            case _introspection.TypeKind.OBJECT:
              return buildObjectDef(type);
            case _introspection.TypeKind.INTERFACE:
              return buildInterfaceDef(type);
            case _introspection.TypeKind.UNION:
              return buildUnionDef(type);
            case _introspection.TypeKind.ENUM:
              return buildEnumDef(type);
            case _introspection.TypeKind.INPUT_OBJECT:
              return buildInputObjectDef(type);
          }
        }
        const typeStr = (0, _inspect.inspect)(type);
        throw new Error(`Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`);
      }
      function buildScalarDef(scalarIntrospection) {
        return new _definition.GraphQLScalarType({
          name: scalarIntrospection.name,
          description: scalarIntrospection.description,
          specifiedByURL: scalarIntrospection.specifiedByURL
        });
      }
      function buildImplementationsList(implementingIntrospection) {
        if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === _introspection.TypeKind.INTERFACE) {
          return [];
        }
        if (!implementingIntrospection.interfaces) {
          const implementingIntrospectionStr = (0, _inspect.inspect)(implementingIntrospection);
          throw new Error(`Introspection result missing interfaces: ${implementingIntrospectionStr}.`);
        }
        return implementingIntrospection.interfaces.map(getInterfaceType);
      }
      function buildObjectDef(objectIntrospection) {
        return new _definition.GraphQLObjectType({
          name: objectIntrospection.name,
          description: objectIntrospection.description,
          interfaces: () => buildImplementationsList(objectIntrospection),
          fields: () => buildFieldDefMap(objectIntrospection)
        });
      }
      function buildInterfaceDef(interfaceIntrospection) {
        return new _definition.GraphQLInterfaceType({
          name: interfaceIntrospection.name,
          description: interfaceIntrospection.description,
          interfaces: () => buildImplementationsList(interfaceIntrospection),
          fields: () => buildFieldDefMap(interfaceIntrospection)
        });
      }
      function buildUnionDef(unionIntrospection) {
        if (!unionIntrospection.possibleTypes) {
          const unionIntrospectionStr = (0, _inspect.inspect)(unionIntrospection);
          throw new Error(`Introspection result missing possibleTypes: ${unionIntrospectionStr}.`);
        }
        return new _definition.GraphQLUnionType({
          name: unionIntrospection.name,
          description: unionIntrospection.description,
          types: () => unionIntrospection.possibleTypes.map(getObjectType)
        });
      }
      function buildEnumDef(enumIntrospection) {
        if (!enumIntrospection.enumValues) {
          const enumIntrospectionStr = (0, _inspect.inspect)(enumIntrospection);
          throw new Error(`Introspection result missing enumValues: ${enumIntrospectionStr}.`);
        }
        return new _definition.GraphQLEnumType({
          name: enumIntrospection.name,
          description: enumIntrospection.description,
          values: (0, _keyValMap.keyValMap)(enumIntrospection.enumValues, (valueIntrospection) => valueIntrospection.name, (valueIntrospection) => ({
            description: valueIntrospection.description,
            deprecationReason: valueIntrospection.deprecationReason
          }))
        });
      }
      function buildInputObjectDef(inputObjectIntrospection) {
        if (!inputObjectIntrospection.inputFields) {
          const inputObjectIntrospectionStr = (0, _inspect.inspect)(inputObjectIntrospection);
          throw new Error(`Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`);
        }
        return new _definition.GraphQLInputObjectType({
          name: inputObjectIntrospection.name,
          description: inputObjectIntrospection.description,
          fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields)
        });
      }
      function buildFieldDefMap(typeIntrospection) {
        if (!typeIntrospection.fields) {
          throw new Error(`Introspection result missing fields: ${(0, _inspect.inspect)(typeIntrospection)}.`);
        }
        return (0, _keyValMap.keyValMap)(typeIntrospection.fields, (fieldIntrospection) => fieldIntrospection.name, buildField);
      }
      function buildField(fieldIntrospection) {
        const type = getType(fieldIntrospection.type);
        if (!(0, _definition.isOutputType)(type)) {
          const typeStr = (0, _inspect.inspect)(type);
          throw new Error(`Introspection must provide output type for fields, but received: ${typeStr}.`);
        }
        if (!fieldIntrospection.args) {
          const fieldIntrospectionStr = (0, _inspect.inspect)(fieldIntrospection);
          throw new Error(`Introspection result missing field args: ${fieldIntrospectionStr}.`);
        }
        return {
          description: fieldIntrospection.description,
          deprecationReason: fieldIntrospection.deprecationReason,
          type,
          args: buildInputValueDefMap(fieldIntrospection.args)
        };
      }
      function buildInputValueDefMap(inputValueIntrospections) {
        return (0, _keyValMap.keyValMap)(inputValueIntrospections, (inputValue) => inputValue.name, buildInputValue);
      }
      function buildInputValue(inputValueIntrospection) {
        const type = getType(inputValueIntrospection.type);
        if (!(0, _definition.isInputType)(type)) {
          const typeStr = (0, _inspect.inspect)(type);
          throw new Error(`Introspection must provide input type for arguments, but received: ${typeStr}.`);
        }
        const defaultValue = inputValueIntrospection.defaultValue != null ? (0, _valueFromAST.valueFromAST)((0, _parser.parseValue)(inputValueIntrospection.defaultValue), type) : void 0;
        return {
          description: inputValueIntrospection.description,
          type,
          defaultValue,
          deprecationReason: inputValueIntrospection.deprecationReason
        };
      }
      function buildDirective(directiveIntrospection) {
        if (!directiveIntrospection.args) {
          const directiveIntrospectionStr = (0, _inspect.inspect)(directiveIntrospection);
          throw new Error(`Introspection result missing directive args: ${directiveIntrospectionStr}.`);
        }
        if (!directiveIntrospection.locations) {
          const directiveIntrospectionStr = (0, _inspect.inspect)(directiveIntrospection);
          throw new Error(`Introspection result missing directive locations: ${directiveIntrospectionStr}.`);
        }
        return new _directives.GraphQLDirective({
          name: directiveIntrospection.name,
          description: directiveIntrospection.description,
          isRepeatable: directiveIntrospection.isRepeatable,
          locations: directiveIntrospection.locations.slice(),
          args: buildInputValueDefMap(directiveIntrospection.args)
        });
      }
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/extendSchema.js
var require_extendSchema = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/extendSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.extendSchema = extendSchema;
    exports2.extendSchemaImpl = extendSchemaImpl;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _keyMap = require_keyMap();
    var _mapValue = require_mapValue();
    var _kinds = require_kinds();
    var _predicates = require_predicates();
    var _definition = require_definition();
    var _directives = require_directives();
    var _introspection = require_introspection();
    var _scalars = require_scalars();
    var _schema = require_schema();
    var _validate = require_validate2();
    var _values = require_values();
    var _valueFromAST = require_valueFromAST();
    function extendSchema(schema, documentAST, options2) {
      (0, _schema.assertSchema)(schema);
      documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.devAssert)(false, "Must provide valid Document AST.");
      if ((options2 === null || options2 === void 0 ? void 0 : options2.assumeValid) !== true && (options2 === null || options2 === void 0 ? void 0 : options2.assumeValidSDL) !== true) {
        (0, _validate.assertValidSDLExtension)(documentAST, schema);
      }
      const schemaConfig = schema.toConfig();
      const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options2);
      return schemaConfig === extendedConfig ? schema : new _schema.GraphQLSchema(extendedConfig);
    }
    function extendSchemaImpl(schemaConfig, documentAST, options2) {
      var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;
      const typeDefs = [];
      const typeExtensionsMap = /* @__PURE__ */ Object.create(null);
      const directiveDefs = [];
      let schemaDef;
      const schemaExtensions = [];
      for (const def of documentAST.definitions) {
        if (def.kind === _kinds.Kind.SCHEMA_DEFINITION) {
          schemaDef = def;
        } else if (def.kind === _kinds.Kind.SCHEMA_EXTENSION) {
          schemaExtensions.push(def);
        } else if ((0, _predicates.isTypeDefinitionNode)(def)) {
          typeDefs.push(def);
        } else if ((0, _predicates.isTypeExtensionNode)(def)) {
          const extendedTypeName = def.name.value;
          const existingTypeExtensions = typeExtensionsMap[extendedTypeName];
          typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];
        } else if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          directiveDefs.push(def);
        }
      }
      if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {
        return schemaConfig;
      }
      const typeMap = /* @__PURE__ */ Object.create(null);
      for (const existingType of schemaConfig.types) {
        typeMap[existingType.name] = extendNamedType(existingType);
      }
      for (const typeNode of typeDefs) {
        var _stdTypeMap$name;
        const name = typeNode.name.value;
        typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);
      }
      const operationTypes = {
        query: schemaConfig.query && replaceNamedType(schemaConfig.query),
        mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),
        subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),
        ...schemaDef && getOperationTypes([schemaDef]),
        ...getOperationTypes(schemaExtensions)
      };
      return {
        description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value,
        ...operationTypes,
        types: Object.values(typeMap),
        directives: [
          ...schemaConfig.directives.map(replaceDirective),
          ...directiveDefs.map(buildDirective)
        ],
        extensions: /* @__PURE__ */ Object.create(null),
        astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,
        extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),
        assumeValid: (_options$assumeValid = options2 === null || options2 === void 0 ? void 0 : options2.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false
      };
      function replaceType(type) {
        if ((0, _definition.isListType)(type)) {
          return new _definition.GraphQLList(replaceType(type.ofType));
        }
        if ((0, _definition.isNonNullType)(type)) {
          return new _definition.GraphQLNonNull(replaceType(type.ofType));
        }
        return replaceNamedType(type);
      }
      function replaceNamedType(type) {
        return typeMap[type.name];
      }
      function replaceDirective(directive) {
        const config2 = directive.toConfig();
        return new _directives.GraphQLDirective({
          ...config2,
          args: (0, _mapValue.mapValue)(config2.args, extendArg)
        });
      }
      function extendNamedType(type) {
        if ((0, _introspection.isIntrospectionType)(type) || (0, _scalars.isSpecifiedScalarType)(type)) {
          return type;
        }
        if ((0, _definition.isScalarType)(type)) {
          return extendScalarType(type);
        }
        if ((0, _definition.isObjectType)(type)) {
          return extendObjectType(type);
        }
        if ((0, _definition.isInterfaceType)(type)) {
          return extendInterfaceType(type);
        }
        if ((0, _definition.isUnionType)(type)) {
          return extendUnionType(type);
        }
        if ((0, _definition.isEnumType)(type)) {
          return extendEnumType(type);
        }
        if ((0, _definition.isInputObjectType)(type)) {
          return extendInputObjectType(type);
        }
        (0, _invariant.invariant)(false, "Unexpected type: " + (0, _inspect.inspect)(type));
      }
      function extendInputObjectType(type) {
        var _typeExtensionsMap$co;
        const config2 = type.toConfig();
        const extensions = (_typeExtensionsMap$co = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];
        return new _definition.GraphQLInputObjectType({
          ...config2,
          fields: () => ({
            ...(0, _mapValue.mapValue)(config2.fields, (field) => ({
              ...field,
              type: replaceType(field.type)
            })),
            ...buildInputFieldMap(extensions)
          }),
          extensionASTNodes: config2.extensionASTNodes.concat(extensions)
        });
      }
      function extendEnumType(type) {
        var _typeExtensionsMap$ty;
        const config2 = type.toConfig();
        const extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];
        return new _definition.GraphQLEnumType({
          ...config2,
          values: { ...config2.values, ...buildEnumValueMap(extensions) },
          extensionASTNodes: config2.extensionASTNodes.concat(extensions)
        });
      }
      function extendScalarType(type) {
        var _typeExtensionsMap$co2;
        const config2 = type.toConfig();
        const extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];
        let specifiedByURL = config2.specifiedByURL;
        for (const extensionNode of extensions) {
          var _getSpecifiedByURL;
          specifiedByURL = (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null && _getSpecifiedByURL !== void 0 ? _getSpecifiedByURL : specifiedByURL;
        }
        return new _definition.GraphQLScalarType({
          ...config2,
          specifiedByURL,
          extensionASTNodes: config2.extensionASTNodes.concat(extensions)
        });
      }
      function extendObjectType(type) {
        var _typeExtensionsMap$co3;
        const config2 = type.toConfig();
        const extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];
        return new _definition.GraphQLObjectType({
          ...config2,
          interfaces: () => [
            ...type.getInterfaces().map(replaceNamedType),
            ...buildInterfaces(extensions)
          ],
          fields: () => ({
            ...(0, _mapValue.mapValue)(config2.fields, extendField),
            ...buildFieldMap(extensions)
          }),
          extensionASTNodes: config2.extensionASTNodes.concat(extensions)
        });
      }
      function extendInterfaceType(type) {
        var _typeExtensionsMap$co4;
        const config2 = type.toConfig();
        const extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];
        return new _definition.GraphQLInterfaceType({
          ...config2,
          interfaces: () => [
            ...type.getInterfaces().map(replaceNamedType),
            ...buildInterfaces(extensions)
          ],
          fields: () => ({
            ...(0, _mapValue.mapValue)(config2.fields, extendField),
            ...buildFieldMap(extensions)
          }),
          extensionASTNodes: config2.extensionASTNodes.concat(extensions)
        });
      }
      function extendUnionType(type) {
        var _typeExtensionsMap$co5;
        const config2 = type.toConfig();
        const extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];
        return new _definition.GraphQLUnionType({
          ...config2,
          types: () => [
            ...type.getTypes().map(replaceNamedType),
            ...buildUnionTypes(extensions)
          ],
          extensionASTNodes: config2.extensionASTNodes.concat(extensions)
        });
      }
      function extendField(field) {
        return {
          ...field,
          type: replaceType(field.type),
          args: field.args && (0, _mapValue.mapValue)(field.args, extendArg)
        };
      }
      function extendArg(arg) {
        return { ...arg, type: replaceType(arg.type) };
      }
      function getOperationTypes(nodes) {
        const opTypes = {};
        for (const node of nodes) {
          var _node$operationTypes;
          const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
          for (const operationType of operationTypesNodes) {
            opTypes[operationType.operation] = getNamedType5(operationType.type);
          }
        }
        return opTypes;
      }
      function getNamedType5(node) {
        var _stdTypeMap$name2;
        const name = node.name.value;
        const type = (_stdTypeMap$name2 = stdTypeMap[name]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name];
        if (type === void 0) {
          throw new Error(`Unknown type: "${name}".`);
        }
        return type;
      }
      function getWrappedType(node) {
        if (node.kind === _kinds.Kind.LIST_TYPE) {
          return new _definition.GraphQLList(getWrappedType(node.type));
        }
        if (node.kind === _kinds.Kind.NON_NULL_TYPE) {
          return new _definition.GraphQLNonNull(getWrappedType(node.type));
        }
        return getNamedType5(node);
      }
      function buildDirective(node) {
        var _node$description;
        return new _directives.GraphQLDirective({
          name: node.name.value,
          description: (_node$description = node.description) === null || _node$description === void 0 ? void 0 : _node$description.value,
          locations: node.locations.map(({ value }) => value),
          isRepeatable: node.repeatable,
          args: buildArgumentMap(node.arguments),
          astNode: node
        });
      }
      function buildFieldMap(nodes) {
        const fieldConfigMap = /* @__PURE__ */ Object.create(null);
        for (const node of nodes) {
          var _node$fields;
          const nodeFields = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
          for (const field of nodeFields) {
            var _field$description;
            fieldConfigMap[field.name.value] = {
              type: getWrappedType(field.type),
              description: (_field$description = field.description) === null || _field$description === void 0 ? void 0 : _field$description.value,
              args: buildArgumentMap(field.arguments),
              deprecationReason: getDeprecationReason(field),
              astNode: field
            };
          }
        }
        return fieldConfigMap;
      }
      function buildArgumentMap(args) {
        const argsNodes = args !== null && args !== void 0 ? args : [];
        const argConfigMap = /* @__PURE__ */ Object.create(null);
        for (const arg of argsNodes) {
          var _arg$description;
          const type = getWrappedType(arg.type);
          argConfigMap[arg.name.value] = {
            type,
            description: (_arg$description = arg.description) === null || _arg$description === void 0 ? void 0 : _arg$description.value,
            defaultValue: (0, _valueFromAST.valueFromAST)(arg.defaultValue, type),
            deprecationReason: getDeprecationReason(arg),
            astNode: arg
          };
        }
        return argConfigMap;
      }
      function buildInputFieldMap(nodes) {
        const inputFieldMap = /* @__PURE__ */ Object.create(null);
        for (const node of nodes) {
          var _node$fields2;
          const fieldsNodes = (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : [];
          for (const field of fieldsNodes) {
            var _field$description2;
            const type = getWrappedType(field.type);
            inputFieldMap[field.name.value] = {
              type,
              description: (_field$description2 = field.description) === null || _field$description2 === void 0 ? void 0 : _field$description2.value,
              defaultValue: (0, _valueFromAST.valueFromAST)(field.defaultValue, type),
              deprecationReason: getDeprecationReason(field),
              astNode: field
            };
          }
        }
        return inputFieldMap;
      }
      function buildEnumValueMap(nodes) {
        const enumValueMap = /* @__PURE__ */ Object.create(null);
        for (const node of nodes) {
          var _node$values;
          const valuesNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
          for (const value of valuesNodes) {
            var _value$description;
            enumValueMap[value.name.value] = {
              description: (_value$description = value.description) === null || _value$description === void 0 ? void 0 : _value$description.value,
              deprecationReason: getDeprecationReason(value),
              astNode: value
            };
          }
        }
        return enumValueMap;
      }
      function buildInterfaces(nodes) {
        return nodes.flatMap((node) => {
          var _node$interfaces$map, _node$interfaces;
          return (_node$interfaces$map = (_node$interfaces = node.interfaces) === null || _node$interfaces === void 0 ? void 0 : _node$interfaces.map(getNamedType5)) !== null && _node$interfaces$map !== void 0 ? _node$interfaces$map : [];
        });
      }
      function buildUnionTypes(nodes) {
        return nodes.flatMap((node) => {
          var _node$types$map, _node$types;
          return (_node$types$map = (_node$types = node.types) === null || _node$types === void 0 ? void 0 : _node$types.map(getNamedType5)) !== null && _node$types$map !== void 0 ? _node$types$map : [];
        });
      }
      function buildType(astNode) {
        var _typeExtensionsMap$na;
        const name = astNode.name.value;
        const extensionASTNodes = (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];
        switch (astNode.kind) {
          case _kinds.Kind.OBJECT_TYPE_DEFINITION: {
            var _astNode$description;
            const allNodes = [astNode, ...extensionASTNodes];
            return new _definition.GraphQLObjectType({
              name,
              description: (_astNode$description = astNode.description) === null || _astNode$description === void 0 ? void 0 : _astNode$description.value,
              interfaces: () => buildInterfaces(allNodes),
              fields: () => buildFieldMap(allNodes),
              astNode,
              extensionASTNodes
            });
          }
          case _kinds.Kind.INTERFACE_TYPE_DEFINITION: {
            var _astNode$description2;
            const allNodes = [astNode, ...extensionASTNodes];
            return new _definition.GraphQLInterfaceType({
              name,
              description: (_astNode$description2 = astNode.description) === null || _astNode$description2 === void 0 ? void 0 : _astNode$description2.value,
              interfaces: () => buildInterfaces(allNodes),
              fields: () => buildFieldMap(allNodes),
              astNode,
              extensionASTNodes
            });
          }
          case _kinds.Kind.ENUM_TYPE_DEFINITION: {
            var _astNode$description3;
            const allNodes = [astNode, ...extensionASTNodes];
            return new _definition.GraphQLEnumType({
              name,
              description: (_astNode$description3 = astNode.description) === null || _astNode$description3 === void 0 ? void 0 : _astNode$description3.value,
              values: buildEnumValueMap(allNodes),
              astNode,
              extensionASTNodes
            });
          }
          case _kinds.Kind.UNION_TYPE_DEFINITION: {
            var _astNode$description4;
            const allNodes = [astNode, ...extensionASTNodes];
            return new _definition.GraphQLUnionType({
              name,
              description: (_astNode$description4 = astNode.description) === null || _astNode$description4 === void 0 ? void 0 : _astNode$description4.value,
              types: () => buildUnionTypes(allNodes),
              astNode,
              extensionASTNodes
            });
          }
          case _kinds.Kind.SCALAR_TYPE_DEFINITION: {
            var _astNode$description5;
            return new _definition.GraphQLScalarType({
              name,
              description: (_astNode$description5 = astNode.description) === null || _astNode$description5 === void 0 ? void 0 : _astNode$description5.value,
              specifiedByURL: getSpecifiedByURL(astNode),
              astNode,
              extensionASTNodes
            });
          }
          case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION: {
            var _astNode$description6;
            const allNodes = [astNode, ...extensionASTNodes];
            return new _definition.GraphQLInputObjectType({
              name,
              description: (_astNode$description6 = astNode.description) === null || _astNode$description6 === void 0 ? void 0 : _astNode$description6.value,
              fields: () => buildInputFieldMap(allNodes),
              astNode,
              extensionASTNodes
            });
          }
        }
      }
    }
    var stdTypeMap = (0, _keyMap.keyMap)([..._scalars.specifiedScalarTypes, ..._introspection.introspectionTypes], (type) => type.name);
    function getDeprecationReason(node) {
      const deprecated = (0, _values.getDirectiveValues)(_directives.GraphQLDeprecatedDirective, node);
      return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;
    }
    function getSpecifiedByURL(node) {
      const specifiedBy = (0, _values.getDirectiveValues)(_directives.GraphQLSpecifiedByDirective, node);
      return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/buildASTSchema.js
var require_buildASTSchema = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/buildASTSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.buildASTSchema = buildASTSchema3;
    exports2.buildSchema = buildSchema2;
    var _devAssert = require_devAssert();
    var _kinds = require_kinds();
    var _parser = require_parser();
    var _directives = require_directives();
    var _schema = require_schema();
    var _validate = require_validate2();
    var _extendSchema = require_extendSchema();
    function buildASTSchema3(documentAST, options2) {
      documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.devAssert)(false, "Must provide valid Document AST.");
      if ((options2 === null || options2 === void 0 ? void 0 : options2.assumeValid) !== true && (options2 === null || options2 === void 0 ? void 0 : options2.assumeValidSDL) !== true) {
        (0, _validate.assertValidSDL)(documentAST);
      }
      const emptySchemaConfig = {
        description: void 0,
        types: [],
        directives: [],
        extensions: /* @__PURE__ */ Object.create(null),
        extensionASTNodes: [],
        assumeValid: false
      };
      const config2 = (0, _extendSchema.extendSchemaImpl)(emptySchemaConfig, documentAST, options2);
      if (config2.astNode == null) {
        for (const type of config2.types) {
          switch (type.name) {
            case "Query":
              config2.query = type;
              break;
            case "Mutation":
              config2.mutation = type;
              break;
            case "Subscription":
              config2.subscription = type;
              break;
          }
        }
      }
      const directives = [
        ...config2.directives,
        ..._directives.specifiedDirectives.filter((stdDirective) => config2.directives.every((directive) => directive.name !== stdDirective.name))
      ];
      return new _schema.GraphQLSchema({ ...config2, directives });
    }
    function buildSchema2(source, options2) {
      const document = (0, _parser.parse)(source, {
        noLocation: options2 === null || options2 === void 0 ? void 0 : options2.noLocation,
        allowLegacyFragmentVariables: options2 === null || options2 === void 0 ? void 0 : options2.allowLegacyFragmentVariables
      });
      return buildASTSchema3(document, {
        assumeValidSDL: options2 === null || options2 === void 0 ? void 0 : options2.assumeValidSDL,
        assumeValid: options2 === null || options2 === void 0 ? void 0 : options2.assumeValid
      });
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/lexicographicSortSchema.js
var require_lexicographicSortSchema = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/lexicographicSortSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.lexicographicSortSchema = lexicographicSortSchema2;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _keyValMap = require_keyValMap();
    var _naturalCompare = require_naturalCompare();
    var _definition = require_definition();
    var _directives = require_directives();
    var _introspection = require_introspection();
    var _schema = require_schema();
    function lexicographicSortSchema2(schema) {
      const schemaConfig = schema.toConfig();
      const typeMap = (0, _keyValMap.keyValMap)(sortByName(schemaConfig.types), (type) => type.name, sortNamedType);
      return new _schema.GraphQLSchema({
        ...schemaConfig,
        types: Object.values(typeMap),
        directives: sortByName(schemaConfig.directives).map(sortDirective),
        query: replaceMaybeType(schemaConfig.query),
        mutation: replaceMaybeType(schemaConfig.mutation),
        subscription: replaceMaybeType(schemaConfig.subscription)
      });
      function replaceType(type) {
        if ((0, _definition.isListType)(type)) {
          return new _definition.GraphQLList(replaceType(type.ofType));
        } else if ((0, _definition.isNonNullType)(type)) {
          return new _definition.GraphQLNonNull(replaceType(type.ofType));
        }
        return replaceNamedType(type);
      }
      function replaceNamedType(type) {
        return typeMap[type.name];
      }
      function replaceMaybeType(maybeType) {
        return maybeType && replaceNamedType(maybeType);
      }
      function sortDirective(directive) {
        const config2 = directive.toConfig();
        return new _directives.GraphQLDirective({
          ...config2,
          locations: sortBy(config2.locations, (x) => x),
          args: sortArgs(config2.args)
        });
      }
      function sortArgs(args) {
        return sortObjMap(args, (arg) => ({ ...arg, type: replaceType(arg.type) }));
      }
      function sortFields(fieldsMap) {
        return sortObjMap(fieldsMap, (field) => ({
          ...field,
          type: replaceType(field.type),
          args: field.args && sortArgs(field.args)
        }));
      }
      function sortInputFields(fieldsMap) {
        return sortObjMap(fieldsMap, (field) => ({
          ...field,
          type: replaceType(field.type)
        }));
      }
      function sortTypes(array) {
        return sortByName(array).map(replaceNamedType);
      }
      function sortNamedType(type) {
        if ((0, _definition.isScalarType)(type) || (0, _introspection.isIntrospectionType)(type)) {
          return type;
        }
        if ((0, _definition.isObjectType)(type)) {
          const config2 = type.toConfig();
          return new _definition.GraphQLObjectType({
            ...config2,
            interfaces: () => sortTypes(config2.interfaces),
            fields: () => sortFields(config2.fields)
          });
        }
        if ((0, _definition.isInterfaceType)(type)) {
          const config2 = type.toConfig();
          return new _definition.GraphQLInterfaceType({
            ...config2,
            interfaces: () => sortTypes(config2.interfaces),
            fields: () => sortFields(config2.fields)
          });
        }
        if ((0, _definition.isUnionType)(type)) {
          const config2 = type.toConfig();
          return new _definition.GraphQLUnionType({
            ...config2,
            types: () => sortTypes(config2.types)
          });
        }
        if ((0, _definition.isEnumType)(type)) {
          const config2 = type.toConfig();
          return new _definition.GraphQLEnumType({
            ...config2,
            values: sortObjMap(config2.values, (value) => value)
          });
        }
        if ((0, _definition.isInputObjectType)(type)) {
          const config2 = type.toConfig();
          return new _definition.GraphQLInputObjectType({
            ...config2,
            fields: () => sortInputFields(config2.fields)
          });
        }
        (0, _invariant.invariant)(false, "Unexpected type: " + (0, _inspect.inspect)(type));
      }
    }
    function sortObjMap(map3, sortValueFn) {
      const sortedMap = /* @__PURE__ */ Object.create(null);
      for (const key of Object.keys(map3).sort(_naturalCompare.naturalCompare)) {
        sortedMap[key] = sortValueFn(map3[key]);
      }
      return sortedMap;
    }
    function sortByName(array) {
      return sortBy(array, (obj) => obj.name);
    }
    function sortBy(array, mapToKey) {
      return array.slice().sort((obj1, obj2) => {
        const key1 = mapToKey(obj1);
        const key2 = mapToKey(obj2);
        return (0, _naturalCompare.naturalCompare)(key1, key2);
      });
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/printSchema.js
var require_printSchema = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/printSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.printIntrospectionSchema = printIntrospectionSchema;
    exports2.printSchema = printSchema;
    exports2.printType = printType;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _blockString = require_blockString();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _definition = require_definition();
    var _directives = require_directives();
    var _introspection = require_introspection();
    var _scalars = require_scalars();
    var _astFromValue = require_astFromValue();
    function printSchema(schema) {
      return printFilteredSchema(schema, (n) => !(0, _directives.isSpecifiedDirective)(n), isDefinedType);
    }
    function printIntrospectionSchema(schema) {
      return printFilteredSchema(schema, _directives.isSpecifiedDirective, _introspection.isIntrospectionType);
    }
    function isDefinedType(type) {
      return !(0, _scalars.isSpecifiedScalarType)(type) && !(0, _introspection.isIntrospectionType)(type);
    }
    function printFilteredSchema(schema, directiveFilter, typeFilter) {
      const directives = schema.getDirectives().filter(directiveFilter);
      const types = Object.values(schema.getTypeMap()).filter(typeFilter);
      return [
        printSchemaDefinition(schema),
        ...directives.map((directive) => printDirective(directive)),
        ...types.map((type) => printType(type))
      ].filter(Boolean).join("\n\n");
    }
    function printSchemaDefinition(schema) {
      if (schema.description == null && isSchemaOfCommonNames(schema)) {
        return;
      }
      const operationTypes = [];
      const queryType = schema.getQueryType();
      if (queryType) {
        operationTypes.push(`  query: ${queryType.name}`);
      }
      const mutationType = schema.getMutationType();
      if (mutationType) {
        operationTypes.push(`  mutation: ${mutationType.name}`);
      }
      const subscriptionType = schema.getSubscriptionType();
      if (subscriptionType) {
        operationTypes.push(`  subscription: ${subscriptionType.name}`);
      }
      return printDescription(schema) + `schema {
${operationTypes.join("\n")}
}`;
    }
    function isSchemaOfCommonNames(schema) {
      const queryType = schema.getQueryType();
      if (queryType && queryType.name !== "Query") {
        return false;
      }
      const mutationType = schema.getMutationType();
      if (mutationType && mutationType.name !== "Mutation") {
        return false;
      }
      const subscriptionType = schema.getSubscriptionType();
      if (subscriptionType && subscriptionType.name !== "Subscription") {
        return false;
      }
      return true;
    }
    function printType(type) {
      if ((0, _definition.isScalarType)(type)) {
        return printScalar(type);
      }
      if ((0, _definition.isObjectType)(type)) {
        return printObject(type);
      }
      if ((0, _definition.isInterfaceType)(type)) {
        return printInterface(type);
      }
      if ((0, _definition.isUnionType)(type)) {
        return printUnion(type);
      }
      if ((0, _definition.isEnumType)(type)) {
        return printEnum(type);
      }
      if ((0, _definition.isInputObjectType)(type)) {
        return printInputObject(type);
      }
      (0, _invariant.invariant)(false, "Unexpected type: " + (0, _inspect.inspect)(type));
    }
    function printScalar(type) {
      return printDescription(type) + `scalar ${type.name}` + printSpecifiedByURL(type);
    }
    function printImplementedInterfaces(type) {
      const interfaces = type.getInterfaces();
      return interfaces.length ? " implements " + interfaces.map((i) => i.name).join(" & ") : "";
    }
    function printObject(type) {
      return printDescription(type) + `type ${type.name}` + printImplementedInterfaces(type) + printFields(type);
    }
    function printInterface(type) {
      return printDescription(type) + `interface ${type.name}` + printImplementedInterfaces(type) + printFields(type);
    }
    function printUnion(type) {
      const types = type.getTypes();
      const possibleTypes = types.length ? " = " + types.join(" | ") : "";
      return printDescription(type) + "union " + type.name + possibleTypes;
    }
    function printEnum(type) {
      const values = type.getValues().map((value, i) => printDescription(value, "  ", !i) + "  " + value.name + printDeprecated(value.deprecationReason));
      return printDescription(type) + `enum ${type.name}` + printBlock(values);
    }
    function printInputObject(type) {
      const fields = Object.values(type.getFields()).map((f, i) => printDescription(f, "  ", !i) + "  " + printInputValue(f));
      return printDescription(type) + `input ${type.name}` + printBlock(fields);
    }
    function printFields(type) {
      const fields = Object.values(type.getFields()).map((f, i) => printDescription(f, "  ", !i) + "  " + f.name + printArgs(f.args, "  ") + ": " + String(f.type) + printDeprecated(f.deprecationReason));
      return printBlock(fields);
    }
    function printBlock(items) {
      return items.length !== 0 ? " {\n" + items.join("\n") + "\n}" : "";
    }
    function printArgs(args, indentation = "") {
      if (args.length === 0) {
        return "";
      }
      if (args.every((arg) => !arg.description)) {
        return "(" + args.map(printInputValue).join(", ") + ")";
      }
      return "(\n" + args.map((arg, i) => printDescription(arg, "  " + indentation, !i) + "  " + indentation + printInputValue(arg)).join("\n") + "\n" + indentation + ")";
    }
    function printInputValue(arg) {
      const defaultAST = (0, _astFromValue.astFromValue)(arg.defaultValue, arg.type);
      let argDecl = arg.name + ": " + String(arg.type);
      if (defaultAST) {
        argDecl += ` = ${(0, _printer.print)(defaultAST)}`;
      }
      return argDecl + printDeprecated(arg.deprecationReason);
    }
    function printDirective(directive) {
      return printDescription(directive) + "directive @" + directive.name + printArgs(directive.args) + (directive.isRepeatable ? " repeatable" : "") + " on " + directive.locations.join(" | ");
    }
    function printDeprecated(reason) {
      if (reason == null) {
        return "";
      }
      if (reason !== _directives.DEFAULT_DEPRECATION_REASON) {
        const astValue = (0, _printer.print)({
          kind: _kinds.Kind.STRING,
          value: reason
        });
        return ` @deprecated(reason: ${astValue})`;
      }
      return " @deprecated";
    }
    function printSpecifiedByURL(scalar) {
      if (scalar.specifiedByURL == null) {
        return "";
      }
      const astValue = (0, _printer.print)({
        kind: _kinds.Kind.STRING,
        value: scalar.specifiedByURL
      });
      return ` @specifiedBy(url: ${astValue})`;
    }
    function printDescription(def, indentation = "", firstInBlock = true) {
      const { description } = def;
      if (description == null) {
        return "";
      }
      const blockString = (0, _printer.print)({
        kind: _kinds.Kind.STRING,
        value: description,
        block: (0, _blockString.isPrintableAsBlockString)(description)
      });
      const prefix = indentation && !firstInBlock ? "\n" + indentation : indentation;
      return prefix + blockString.replace(/\n/g, "\n" + indentation) + "\n";
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/concatAST.js
var require_concatAST = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/concatAST.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.concatAST = concatAST2;
    var _kinds = require_kinds();
    function concatAST2(documents) {
      const definitions = [];
      for (const doc of documents) {
        definitions.push(...doc.definitions);
      }
      return {
        kind: _kinds.Kind.DOCUMENT,
        definitions
      };
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/separateOperations.js
var require_separateOperations = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/separateOperations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.separateOperations = separateOperations;
    var _kinds = require_kinds();
    var _visitor = require_visitor();
    function separateOperations(documentAST) {
      const operations = [];
      const depGraph = /* @__PURE__ */ Object.create(null);
      for (const definitionNode of documentAST.definitions) {
        switch (definitionNode.kind) {
          case _kinds.Kind.OPERATION_DEFINITION:
            operations.push(definitionNode);
            break;
          case _kinds.Kind.FRAGMENT_DEFINITION:
            depGraph[definitionNode.name.value] = collectDependencies(definitionNode.selectionSet);
            break;
          default:
        }
      }
      const separatedDocumentASTs = /* @__PURE__ */ Object.create(null);
      for (const operation of operations) {
        const dependencies = /* @__PURE__ */ new Set();
        for (const fragmentName of collectDependencies(operation.selectionSet)) {
          collectTransitiveDependencies(dependencies, depGraph, fragmentName);
        }
        const operationName = operation.name ? operation.name.value : "";
        separatedDocumentASTs[operationName] = {
          kind: _kinds.Kind.DOCUMENT,
          definitions: documentAST.definitions.filter((node) => node === operation || node.kind === _kinds.Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value))
        };
      }
      return separatedDocumentASTs;
    }
    function collectTransitiveDependencies(collected, depGraph, fromName) {
      if (!collected.has(fromName)) {
        collected.add(fromName);
        const immediateDeps = depGraph[fromName];
        if (immediateDeps !== void 0) {
          for (const toName of immediateDeps) {
            collectTransitiveDependencies(collected, depGraph, toName);
          }
        }
      }
    }
    function collectDependencies(selectionSet) {
      const dependencies = [];
      (0, _visitor.visit)(selectionSet, {
        FragmentSpread(node) {
          dependencies.push(node.name.value);
        }
      });
      return dependencies;
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/stripIgnoredCharacters.js
var require_stripIgnoredCharacters = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/stripIgnoredCharacters.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.stripIgnoredCharacters = stripIgnoredCharacters;
    var _blockString = require_blockString();
    var _lexer = require_lexer();
    var _source = require_source();
    var _tokenKind = require_tokenKind();
    function stripIgnoredCharacters(source) {
      const sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
      const body = sourceObj.body;
      const lexer = new _lexer.Lexer(sourceObj);
      let strippedBody = "";
      let wasLastAddedTokenNonPunctuator = false;
      while (lexer.advance().kind !== _tokenKind.TokenKind.EOF) {
        const currentToken = lexer.token;
        const tokenKind = currentToken.kind;
        const isNonPunctuator = !(0, _lexer.isPunctuatorTokenKind)(currentToken.kind);
        if (wasLastAddedTokenNonPunctuator) {
          if (isNonPunctuator || currentToken.kind === _tokenKind.TokenKind.SPREAD) {
            strippedBody += " ";
          }
        }
        const tokenBody = body.slice(currentToken.start, currentToken.end);
        if (tokenKind === _tokenKind.TokenKind.BLOCK_STRING) {
          strippedBody += (0, _blockString.printBlockString)(currentToken.value, {
            minimize: true
          });
        } else {
          strippedBody += tokenBody;
        }
        wasLastAddedTokenNonPunctuator = isNonPunctuator;
      }
      return strippedBody;
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/assertValidName.js
var require_assertValidName = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/assertValidName.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assertValidName = assertValidName;
    exports2.isValidNameError = isValidNameError;
    var _devAssert = require_devAssert();
    var _GraphQLError = require_GraphQLError();
    var _assertName = require_assertName();
    function assertValidName(name) {
      const error2 = isValidNameError(name);
      if (error2) {
        throw error2;
      }
      return name;
    }
    function isValidNameError(name) {
      typeof name === "string" || (0, _devAssert.devAssert)(false, "Expected name to be a string.");
      if (name.startsWith("__")) {
        return new _GraphQLError.GraphQLError(`Name "${name}" must not begin with "__", which is reserved by GraphQL introspection.`);
      }
      try {
        (0, _assertName.assertName)(name);
      } catch (error2) {
        return error2;
      }
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/findBreakingChanges.js
var require_findBreakingChanges = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/findBreakingChanges.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.DangerousChangeType = exports2.BreakingChangeType = void 0;
    exports2.findBreakingChanges = findBreakingChanges;
    exports2.findDangerousChanges = findDangerousChanges;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _keyMap = require_keyMap();
    var _printer = require_printer();
    var _definition = require_definition();
    var _scalars = require_scalars();
    var _astFromValue = require_astFromValue();
    var _sortValueNode = require_sortValueNode();
    var BreakingChangeType;
    exports2.BreakingChangeType = BreakingChangeType;
    (function(BreakingChangeType2) {
      BreakingChangeType2["TYPE_REMOVED"] = "TYPE_REMOVED";
      BreakingChangeType2["TYPE_CHANGED_KIND"] = "TYPE_CHANGED_KIND";
      BreakingChangeType2["TYPE_REMOVED_FROM_UNION"] = "TYPE_REMOVED_FROM_UNION";
      BreakingChangeType2["VALUE_REMOVED_FROM_ENUM"] = "VALUE_REMOVED_FROM_ENUM";
      BreakingChangeType2["REQUIRED_INPUT_FIELD_ADDED"] = "REQUIRED_INPUT_FIELD_ADDED";
      BreakingChangeType2["IMPLEMENTED_INTERFACE_REMOVED"] = "IMPLEMENTED_INTERFACE_REMOVED";
      BreakingChangeType2["FIELD_REMOVED"] = "FIELD_REMOVED";
      BreakingChangeType2["FIELD_CHANGED_KIND"] = "FIELD_CHANGED_KIND";
      BreakingChangeType2["REQUIRED_ARG_ADDED"] = "REQUIRED_ARG_ADDED";
      BreakingChangeType2["ARG_REMOVED"] = "ARG_REMOVED";
      BreakingChangeType2["ARG_CHANGED_KIND"] = "ARG_CHANGED_KIND";
      BreakingChangeType2["DIRECTIVE_REMOVED"] = "DIRECTIVE_REMOVED";
      BreakingChangeType2["DIRECTIVE_ARG_REMOVED"] = "DIRECTIVE_ARG_REMOVED";
      BreakingChangeType2["REQUIRED_DIRECTIVE_ARG_ADDED"] = "REQUIRED_DIRECTIVE_ARG_ADDED";
      BreakingChangeType2["DIRECTIVE_REPEATABLE_REMOVED"] = "DIRECTIVE_REPEATABLE_REMOVED";
      BreakingChangeType2["DIRECTIVE_LOCATION_REMOVED"] = "DIRECTIVE_LOCATION_REMOVED";
    })(BreakingChangeType || (exports2.BreakingChangeType = BreakingChangeType = {}));
    var DangerousChangeType;
    exports2.DangerousChangeType = DangerousChangeType;
    (function(DangerousChangeType2) {
      DangerousChangeType2["VALUE_ADDED_TO_ENUM"] = "VALUE_ADDED_TO_ENUM";
      DangerousChangeType2["TYPE_ADDED_TO_UNION"] = "TYPE_ADDED_TO_UNION";
      DangerousChangeType2["OPTIONAL_INPUT_FIELD_ADDED"] = "OPTIONAL_INPUT_FIELD_ADDED";
      DangerousChangeType2["OPTIONAL_ARG_ADDED"] = "OPTIONAL_ARG_ADDED";
      DangerousChangeType2["IMPLEMENTED_INTERFACE_ADDED"] = "IMPLEMENTED_INTERFACE_ADDED";
      DangerousChangeType2["ARG_DEFAULT_VALUE_CHANGE"] = "ARG_DEFAULT_VALUE_CHANGE";
    })(DangerousChangeType || (exports2.DangerousChangeType = DangerousChangeType = {}));
    function findBreakingChanges(oldSchema, newSchema) {
      return findSchemaChanges(oldSchema, newSchema).filter((change) => change.type in BreakingChangeType);
    }
    function findDangerousChanges(oldSchema, newSchema) {
      return findSchemaChanges(oldSchema, newSchema).filter((change) => change.type in DangerousChangeType);
    }
    function findSchemaChanges(oldSchema, newSchema) {
      return [
        ...findTypeChanges(oldSchema, newSchema),
        ...findDirectiveChanges(oldSchema, newSchema)
      ];
    }
    function findDirectiveChanges(oldSchema, newSchema) {
      const schemaChanges = [];
      const directivesDiff = diff(oldSchema.getDirectives(), newSchema.getDirectives());
      for (const oldDirective of directivesDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.DIRECTIVE_REMOVED,
          description: `${oldDirective.name} was removed.`
        });
      }
      for (const [oldDirective, newDirective] of directivesDiff.persisted) {
        const argsDiff = diff(oldDirective.args, newDirective.args);
        for (const newArg of argsDiff.added) {
          if ((0, _definition.isRequiredArgument)(newArg)) {
            schemaChanges.push({
              type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,
              description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`
            });
          }
        }
        for (const oldArg of argsDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,
            description: `${oldArg.name} was removed from ${oldDirective.name}.`
          });
        }
        if (oldDirective.isRepeatable && !newDirective.isRepeatable) {
          schemaChanges.push({
            type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,
            description: `Repeatable flag was removed from ${oldDirective.name}.`
          });
        }
        for (const location of oldDirective.locations) {
          if (!newDirective.locations.includes(location)) {
            schemaChanges.push({
              type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,
              description: `${location} was removed from ${oldDirective.name}.`
            });
          }
        }
      }
      return schemaChanges;
    }
    function findTypeChanges(oldSchema, newSchema) {
      const schemaChanges = [];
      const typesDiff = diff(Object.values(oldSchema.getTypeMap()), Object.values(newSchema.getTypeMap()));
      for (const oldType of typesDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.TYPE_REMOVED,
          description: (0, _scalars.isSpecifiedScalarType)(oldType) ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.` : `${oldType.name} was removed.`
        });
      }
      for (const [oldType, newType] of typesDiff.persisted) {
        if ((0, _definition.isEnumType)(oldType) && (0, _definition.isEnumType)(newType)) {
          schemaChanges.push(...findEnumTypeChanges(oldType, newType));
        } else if ((0, _definition.isUnionType)(oldType) && (0, _definition.isUnionType)(newType)) {
          schemaChanges.push(...findUnionTypeChanges(oldType, newType));
        } else if ((0, _definition.isInputObjectType)(oldType) && (0, _definition.isInputObjectType)(newType)) {
          schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));
        } else if ((0, _definition.isObjectType)(oldType) && (0, _definition.isObjectType)(newType)) {
          schemaChanges.push(...findFieldChanges(oldType, newType), ...findImplementedInterfacesChanges(oldType, newType));
        } else if ((0, _definition.isInterfaceType)(oldType) && (0, _definition.isInterfaceType)(newType)) {
          schemaChanges.push(...findFieldChanges(oldType, newType), ...findImplementedInterfacesChanges(oldType, newType));
        } else if (oldType.constructor !== newType.constructor) {
          schemaChanges.push({
            type: BreakingChangeType.TYPE_CHANGED_KIND,
            description: `${oldType.name} changed from ${typeKindName(oldType)} to ${typeKindName(newType)}.`
          });
        }
      }
      return schemaChanges;
    }
    function findInputObjectTypeChanges(oldType, newType) {
      const schemaChanges = [];
      const fieldsDiff = diff(Object.values(oldType.getFields()), Object.values(newType.getFields()));
      for (const newField of fieldsDiff.added) {
        if ((0, _definition.isRequiredInputField)(newField)) {
          schemaChanges.push({
            type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,
            description: `A required field ${newField.name} on input type ${oldType.name} was added.`
          });
        } else {
          schemaChanges.push({
            type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,
            description: `An optional field ${newField.name} on input type ${oldType.name} was added.`
          });
        }
      }
      for (const oldField of fieldsDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.FIELD_REMOVED,
          description: `${oldType.name}.${oldField.name} was removed.`
        });
      }
      for (const [oldField, newField] of fieldsDiff.persisted) {
        const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldField.type, newField.type);
        if (!isSafe) {
          schemaChanges.push({
            type: BreakingChangeType.FIELD_CHANGED_KIND,
            description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`
          });
        }
      }
      return schemaChanges;
    }
    function findUnionTypeChanges(oldType, newType) {
      const schemaChanges = [];
      const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());
      for (const newPossibleType of possibleTypesDiff.added) {
        schemaChanges.push({
          type: DangerousChangeType.TYPE_ADDED_TO_UNION,
          description: `${newPossibleType.name} was added to union type ${oldType.name}.`
        });
      }
      for (const oldPossibleType of possibleTypesDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
          description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`
        });
      }
      return schemaChanges;
    }
    function findEnumTypeChanges(oldType, newType) {
      const schemaChanges = [];
      const valuesDiff = diff(oldType.getValues(), newType.getValues());
      for (const newValue of valuesDiff.added) {
        schemaChanges.push({
          type: DangerousChangeType.VALUE_ADDED_TO_ENUM,
          description: `${newValue.name} was added to enum type ${oldType.name}.`
        });
      }
      for (const oldValue of valuesDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
          description: `${oldValue.name} was removed from enum type ${oldType.name}.`
        });
      }
      return schemaChanges;
    }
    function findImplementedInterfacesChanges(oldType, newType) {
      const schemaChanges = [];
      const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());
      for (const newInterface of interfacesDiff.added) {
        schemaChanges.push({
          type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,
          description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`
        });
      }
      for (const oldInterface of interfacesDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,
          description: `${oldType.name} no longer implements interface ${oldInterface.name}.`
        });
      }
      return schemaChanges;
    }
    function findFieldChanges(oldType, newType) {
      const schemaChanges = [];
      const fieldsDiff = diff(Object.values(oldType.getFields()), Object.values(newType.getFields()));
      for (const oldField of fieldsDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.FIELD_REMOVED,
          description: `${oldType.name}.${oldField.name} was removed.`
        });
      }
      for (const [oldField, newField] of fieldsDiff.persisted) {
        schemaChanges.push(...findArgChanges(oldType, oldField, newField));
        const isSafe = isChangeSafeForObjectOrInterfaceField(oldField.type, newField.type);
        if (!isSafe) {
          schemaChanges.push({
            type: BreakingChangeType.FIELD_CHANGED_KIND,
            description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`
          });
        }
      }
      return schemaChanges;
    }
    function findArgChanges(oldType, oldField, newField) {
      const schemaChanges = [];
      const argsDiff = diff(oldField.args, newField.args);
      for (const oldArg of argsDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.ARG_REMOVED,
          description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`
        });
      }
      for (const [oldArg, newArg] of argsDiff.persisted) {
        const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldArg.type, newArg.type);
        if (!isSafe) {
          schemaChanges.push({
            type: BreakingChangeType.ARG_CHANGED_KIND,
            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ${String(oldArg.type)} to ${String(newArg.type)}.`
          });
        } else if (oldArg.defaultValue !== void 0) {
          if (newArg.defaultValue === void 0) {
            schemaChanges.push({
              type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
              description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`
            });
          } else {
            const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);
            const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);
            if (oldValueStr !== newValueStr) {
              schemaChanges.push({
                type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
                description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`
              });
            }
          }
        }
      }
      for (const newArg of argsDiff.added) {
        if ((0, _definition.isRequiredArgument)(newArg)) {
          schemaChanges.push({
            type: BreakingChangeType.REQUIRED_ARG_ADDED,
            description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
          });
        } else {
          schemaChanges.push({
            type: DangerousChangeType.OPTIONAL_ARG_ADDED,
            description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
          });
        }
      }
      return schemaChanges;
    }
    function isChangeSafeForObjectOrInterfaceField(oldType, newType) {
      if ((0, _definition.isListType)(oldType)) {
        return (0, _definition.isListType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) || (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType);
      }
      if ((0, _definition.isNonNullType)(oldType)) {
        return (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);
      }
      return (0, _definition.isNamedType)(newType) && oldType.name === newType.name || (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType);
    }
    function isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {
      if ((0, _definition.isListType)(oldType)) {
        return (0, _definition.isListType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);
      }
      if ((0, _definition.isNonNullType)(oldType)) {
        return (0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) || !(0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType);
      }
      return (0, _definition.isNamedType)(newType) && oldType.name === newType.name;
    }
    function typeKindName(type) {
      if ((0, _definition.isScalarType)(type)) {
        return "a Scalar type";
      }
      if ((0, _definition.isObjectType)(type)) {
        return "an Object type";
      }
      if ((0, _definition.isInterfaceType)(type)) {
        return "an Interface type";
      }
      if ((0, _definition.isUnionType)(type)) {
        return "a Union type";
      }
      if ((0, _definition.isEnumType)(type)) {
        return "an Enum type";
      }
      if ((0, _definition.isInputObjectType)(type)) {
        return "an Input type";
      }
      (0, _invariant.invariant)(false, "Unexpected type: " + (0, _inspect.inspect)(type));
    }
    function stringifyValue(value, type) {
      const ast = (0, _astFromValue.astFromValue)(value, type);
      ast != null || (0, _invariant.invariant)(false);
      return (0, _printer.print)((0, _sortValueNode.sortValueNode)(ast));
    }
    function diff(oldArray, newArray) {
      const added = [];
      const removed = [];
      const persisted = [];
      const oldMap = (0, _keyMap.keyMap)(oldArray, ({ name }) => name);
      const newMap = (0, _keyMap.keyMap)(newArray, ({ name }) => name);
      for (const oldItem of oldArray) {
        const newItem = newMap[oldItem.name];
        if (newItem === void 0) {
          removed.push(oldItem);
        } else {
          persisted.push([oldItem, newItem]);
        }
      }
      for (const newItem of newArray) {
        if (oldMap[newItem.name] === void 0) {
          added.push(newItem);
        }
      }
      return {
        added,
        persisted,
        removed
      };
    }
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/index.js
var require_utilities = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/utilities/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "BreakingChangeType", {
      enumerable: true,
      get: function() {
        return _findBreakingChanges.BreakingChangeType;
      }
    });
    Object.defineProperty(exports2, "DangerousChangeType", {
      enumerable: true,
      get: function() {
        return _findBreakingChanges.DangerousChangeType;
      }
    });
    Object.defineProperty(exports2, "TypeInfo", {
      enumerable: true,
      get: function() {
        return _TypeInfo.TypeInfo;
      }
    });
    Object.defineProperty(exports2, "assertValidName", {
      enumerable: true,
      get: function() {
        return _assertValidName.assertValidName;
      }
    });
    Object.defineProperty(exports2, "astFromValue", {
      enumerable: true,
      get: function() {
        return _astFromValue.astFromValue;
      }
    });
    Object.defineProperty(exports2, "buildASTSchema", {
      enumerable: true,
      get: function() {
        return _buildASTSchema.buildASTSchema;
      }
    });
    Object.defineProperty(exports2, "buildClientSchema", {
      enumerable: true,
      get: function() {
        return _buildClientSchema.buildClientSchema;
      }
    });
    Object.defineProperty(exports2, "buildSchema", {
      enumerable: true,
      get: function() {
        return _buildASTSchema.buildSchema;
      }
    });
    Object.defineProperty(exports2, "coerceInputValue", {
      enumerable: true,
      get: function() {
        return _coerceInputValue.coerceInputValue;
      }
    });
    Object.defineProperty(exports2, "concatAST", {
      enumerable: true,
      get: function() {
        return _concatAST.concatAST;
      }
    });
    Object.defineProperty(exports2, "doTypesOverlap", {
      enumerable: true,
      get: function() {
        return _typeComparators.doTypesOverlap;
      }
    });
    Object.defineProperty(exports2, "extendSchema", {
      enumerable: true,
      get: function() {
        return _extendSchema.extendSchema;
      }
    });
    Object.defineProperty(exports2, "findBreakingChanges", {
      enumerable: true,
      get: function() {
        return _findBreakingChanges.findBreakingChanges;
      }
    });
    Object.defineProperty(exports2, "findDangerousChanges", {
      enumerable: true,
      get: function() {
        return _findBreakingChanges.findDangerousChanges;
      }
    });
    Object.defineProperty(exports2, "getIntrospectionQuery", {
      enumerable: true,
      get: function() {
        return _getIntrospectionQuery.getIntrospectionQuery;
      }
    });
    Object.defineProperty(exports2, "getOperationAST", {
      enumerable: true,
      get: function() {
        return _getOperationAST.getOperationAST;
      }
    });
    Object.defineProperty(exports2, "getOperationRootType", {
      enumerable: true,
      get: function() {
        return _getOperationRootType.getOperationRootType;
      }
    });
    Object.defineProperty(exports2, "introspectionFromSchema", {
      enumerable: true,
      get: function() {
        return _introspectionFromSchema.introspectionFromSchema;
      }
    });
    Object.defineProperty(exports2, "isEqualType", {
      enumerable: true,
      get: function() {
        return _typeComparators.isEqualType;
      }
    });
    Object.defineProperty(exports2, "isTypeSubTypeOf", {
      enumerable: true,
      get: function() {
        return _typeComparators.isTypeSubTypeOf;
      }
    });
    Object.defineProperty(exports2, "isValidNameError", {
      enumerable: true,
      get: function() {
        return _assertValidName.isValidNameError;
      }
    });
    Object.defineProperty(exports2, "lexicographicSortSchema", {
      enumerable: true,
      get: function() {
        return _lexicographicSortSchema.lexicographicSortSchema;
      }
    });
    Object.defineProperty(exports2, "printIntrospectionSchema", {
      enumerable: true,
      get: function() {
        return _printSchema.printIntrospectionSchema;
      }
    });
    Object.defineProperty(exports2, "printSchema", {
      enumerable: true,
      get: function() {
        return _printSchema.printSchema;
      }
    });
    Object.defineProperty(exports2, "printType", {
      enumerable: true,
      get: function() {
        return _printSchema.printType;
      }
    });
    Object.defineProperty(exports2, "separateOperations", {
      enumerable: true,
      get: function() {
        return _separateOperations.separateOperations;
      }
    });
    Object.defineProperty(exports2, "stripIgnoredCharacters", {
      enumerable: true,
      get: function() {
        return _stripIgnoredCharacters.stripIgnoredCharacters;
      }
    });
    Object.defineProperty(exports2, "typeFromAST", {
      enumerable: true,
      get: function() {
        return _typeFromAST.typeFromAST;
      }
    });
    Object.defineProperty(exports2, "valueFromAST", {
      enumerable: true,
      get: function() {
        return _valueFromAST.valueFromAST;
      }
    });
    Object.defineProperty(exports2, "valueFromASTUntyped", {
      enumerable: true,
      get: function() {
        return _valueFromASTUntyped.valueFromASTUntyped;
      }
    });
    Object.defineProperty(exports2, "visitWithTypeInfo", {
      enumerable: true,
      get: function() {
        return _TypeInfo.visitWithTypeInfo;
      }
    });
    var _getIntrospectionQuery = require_getIntrospectionQuery();
    var _getOperationAST = require_getOperationAST();
    var _getOperationRootType = require_getOperationRootType();
    var _introspectionFromSchema = require_introspectionFromSchema();
    var _buildClientSchema = require_buildClientSchema();
    var _buildASTSchema = require_buildASTSchema();
    var _extendSchema = require_extendSchema();
    var _lexicographicSortSchema = require_lexicographicSortSchema();
    var _printSchema = require_printSchema();
    var _typeFromAST = require_typeFromAST();
    var _valueFromAST = require_valueFromAST();
    var _valueFromASTUntyped = require_valueFromASTUntyped();
    var _astFromValue = require_astFromValue();
    var _TypeInfo = require_TypeInfo();
    var _coerceInputValue = require_coerceInputValue();
    var _concatAST = require_concatAST();
    var _separateOperations = require_separateOperations();
    var _stripIgnoredCharacters = require_stripIgnoredCharacters();
    var _typeComparators = require_typeComparators();
    var _assertValidName = require_assertValidName();
    var _findBreakingChanges = require_findBreakingChanges();
  }
});

// node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/index.js
var require_graphql2 = __commonJS({
  "node_modules/.pnpm/graphql@16.4.0/node_modules/graphql/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "BREAK", {
      enumerable: true,
      get: function() {
        return _index2.BREAK;
      }
    });
    Object.defineProperty(exports2, "BreakingChangeType", {
      enumerable: true,
      get: function() {
        return _index6.BreakingChangeType;
      }
    });
    Object.defineProperty(exports2, "DEFAULT_DEPRECATION_REASON", {
      enumerable: true,
      get: function() {
        return _index.DEFAULT_DEPRECATION_REASON;
      }
    });
    Object.defineProperty(exports2, "DangerousChangeType", {
      enumerable: true,
      get: function() {
        return _index6.DangerousChangeType;
      }
    });
    Object.defineProperty(exports2, "DirectiveLocation", {
      enumerable: true,
      get: function() {
        return _index2.DirectiveLocation;
      }
    });
    Object.defineProperty(exports2, "ExecutableDefinitionsRule", {
      enumerable: true,
      get: function() {
        return _index4.ExecutableDefinitionsRule;
      }
    });
    Object.defineProperty(exports2, "FieldsOnCorrectTypeRule", {
      enumerable: true,
      get: function() {
        return _index4.FieldsOnCorrectTypeRule;
      }
    });
    Object.defineProperty(exports2, "FragmentsOnCompositeTypesRule", {
      enumerable: true,
      get: function() {
        return _index4.FragmentsOnCompositeTypesRule;
      }
    });
    Object.defineProperty(exports2, "GRAPHQL_MAX_INT", {
      enumerable: true,
      get: function() {
        return _index.GRAPHQL_MAX_INT;
      }
    });
    Object.defineProperty(exports2, "GRAPHQL_MIN_INT", {
      enumerable: true,
      get: function() {
        return _index.GRAPHQL_MIN_INT;
      }
    });
    Object.defineProperty(exports2, "GraphQLBoolean", {
      enumerable: true,
      get: function() {
        return _index.GraphQLBoolean;
      }
    });
    Object.defineProperty(exports2, "GraphQLDeprecatedDirective", {
      enumerable: true,
      get: function() {
        return _index.GraphQLDeprecatedDirective;
      }
    });
    Object.defineProperty(exports2, "GraphQLDirective", {
      enumerable: true,
      get: function() {
        return _index.GraphQLDirective;
      }
    });
    Object.defineProperty(exports2, "GraphQLEnumType", {
      enumerable: true,
      get: function() {
        return _index.GraphQLEnumType;
      }
    });
    Object.defineProperty(exports2, "GraphQLError", {
      enumerable: true,
      get: function() {
        return _index5.GraphQLError;
      }
    });
    Object.defineProperty(exports2, "GraphQLFloat", {
      enumerable: true,
      get: function() {
        return _index.GraphQLFloat;
      }
    });
    Object.defineProperty(exports2, "GraphQLID", {
      enumerable: true,
      get: function() {
        return _index.GraphQLID;
      }
    });
    Object.defineProperty(exports2, "GraphQLIncludeDirective", {
      enumerable: true,
      get: function() {
        return _index.GraphQLIncludeDirective;
      }
    });
    Object.defineProperty(exports2, "GraphQLInputObjectType", {
      enumerable: true,
      get: function() {
        return _index.GraphQLInputObjectType;
      }
    });
    Object.defineProperty(exports2, "GraphQLInt", {
      enumerable: true,
      get: function() {
        return _index.GraphQLInt;
      }
    });
    Object.defineProperty(exports2, "GraphQLInterfaceType", {
      enumerable: true,
      get: function() {
        return _index.GraphQLInterfaceType;
      }
    });
    Object.defineProperty(exports2, "GraphQLList", {
      enumerable: true,
      get: function() {
        return _index.GraphQLList;
      }
    });
    Object.defineProperty(exports2, "GraphQLNonNull", {
      enumerable: true,
      get: function() {
        return _index.GraphQLNonNull;
      }
    });
    Object.defineProperty(exports2, "GraphQLObjectType", {
      enumerable: true,
      get: function() {
        return _index.GraphQLObjectType;
      }
    });
    Object.defineProperty(exports2, "GraphQLScalarType", {
      enumerable: true,
      get: function() {
        return _index.GraphQLScalarType;
      }
    });
    Object.defineProperty(exports2, "GraphQLSchema", {
      enumerable: true,
      get: function() {
        return _index.GraphQLSchema;
      }
    });
    Object.defineProperty(exports2, "GraphQLSkipDirective", {
      enumerable: true,
      get: function() {
        return _index.GraphQLSkipDirective;
      }
    });
    Object.defineProperty(exports2, "GraphQLSpecifiedByDirective", {
      enumerable: true,
      get: function() {
        return _index.GraphQLSpecifiedByDirective;
      }
    });
    Object.defineProperty(exports2, "GraphQLString", {
      enumerable: true,
      get: function() {
        return _index.GraphQLString;
      }
    });
    Object.defineProperty(exports2, "GraphQLUnionType", {
      enumerable: true,
      get: function() {
        return _index.GraphQLUnionType;
      }
    });
    Object.defineProperty(exports2, "Kind", {
      enumerable: true,
      get: function() {
        return _index2.Kind;
      }
    });
    Object.defineProperty(exports2, "KnownArgumentNamesRule", {
      enumerable: true,
      get: function() {
        return _index4.KnownArgumentNamesRule;
      }
    });
    Object.defineProperty(exports2, "KnownDirectivesRule", {
      enumerable: true,
      get: function() {
        return _index4.KnownDirectivesRule;
      }
    });
    Object.defineProperty(exports2, "KnownFragmentNamesRule", {
      enumerable: true,
      get: function() {
        return _index4.KnownFragmentNamesRule;
      }
    });
    Object.defineProperty(exports2, "KnownTypeNamesRule", {
      enumerable: true,
      get: function() {
        return _index4.KnownTypeNamesRule;
      }
    });
    Object.defineProperty(exports2, "Lexer", {
      enumerable: true,
      get: function() {
        return _index2.Lexer;
      }
    });
    Object.defineProperty(exports2, "Location", {
      enumerable: true,
      get: function() {
        return _index2.Location;
      }
    });
    Object.defineProperty(exports2, "LoneAnonymousOperationRule", {
      enumerable: true,
      get: function() {
        return _index4.LoneAnonymousOperationRule;
      }
    });
    Object.defineProperty(exports2, "LoneSchemaDefinitionRule", {
      enumerable: true,
      get: function() {
        return _index4.LoneSchemaDefinitionRule;
      }
    });
    Object.defineProperty(exports2, "NoDeprecatedCustomRule", {
      enumerable: true,
      get: function() {
        return _index4.NoDeprecatedCustomRule;
      }
    });
    Object.defineProperty(exports2, "NoFragmentCyclesRule", {
      enumerable: true,
      get: function() {
        return _index4.NoFragmentCyclesRule;
      }
    });
    Object.defineProperty(exports2, "NoSchemaIntrospectionCustomRule", {
      enumerable: true,
      get: function() {
        return _index4.NoSchemaIntrospectionCustomRule;
      }
    });
    Object.defineProperty(exports2, "NoUndefinedVariablesRule", {
      enumerable: true,
      get: function() {
        return _index4.NoUndefinedVariablesRule;
      }
    });
    Object.defineProperty(exports2, "NoUnusedFragmentsRule", {
      enumerable: true,
      get: function() {
        return _index4.NoUnusedFragmentsRule;
      }
    });
    Object.defineProperty(exports2, "NoUnusedVariablesRule", {
      enumerable: true,
      get: function() {
        return _index4.NoUnusedVariablesRule;
      }
    });
    Object.defineProperty(exports2, "OperationTypeNode", {
      enumerable: true,
      get: function() {
        return _index2.OperationTypeNode;
      }
    });
    Object.defineProperty(exports2, "OverlappingFieldsCanBeMergedRule", {
      enumerable: true,
      get: function() {
        return _index4.OverlappingFieldsCanBeMergedRule;
      }
    });
    Object.defineProperty(exports2, "PossibleFragmentSpreadsRule", {
      enumerable: true,
      get: function() {
        return _index4.PossibleFragmentSpreadsRule;
      }
    });
    Object.defineProperty(exports2, "PossibleTypeExtensionsRule", {
      enumerable: true,
      get: function() {
        return _index4.PossibleTypeExtensionsRule;
      }
    });
    Object.defineProperty(exports2, "ProvidedRequiredArgumentsRule", {
      enumerable: true,
      get: function() {
        return _index4.ProvidedRequiredArgumentsRule;
      }
    });
    Object.defineProperty(exports2, "ScalarLeafsRule", {
      enumerable: true,
      get: function() {
        return _index4.ScalarLeafsRule;
      }
    });
    Object.defineProperty(exports2, "SchemaMetaFieldDef", {
      enumerable: true,
      get: function() {
        return _index.SchemaMetaFieldDef;
      }
    });
    Object.defineProperty(exports2, "SingleFieldSubscriptionsRule", {
      enumerable: true,
      get: function() {
        return _index4.SingleFieldSubscriptionsRule;
      }
    });
    Object.defineProperty(exports2, "Source", {
      enumerable: true,
      get: function() {
        return _index2.Source;
      }
    });
    Object.defineProperty(exports2, "Token", {
      enumerable: true,
      get: function() {
        return _index2.Token;
      }
    });
    Object.defineProperty(exports2, "TokenKind", {
      enumerable: true,
      get: function() {
        return _index2.TokenKind;
      }
    });
    Object.defineProperty(exports2, "TypeInfo", {
      enumerable: true,
      get: function() {
        return _index6.TypeInfo;
      }
    });
    Object.defineProperty(exports2, "TypeKind", {
      enumerable: true,
      get: function() {
        return _index.TypeKind;
      }
    });
    Object.defineProperty(exports2, "TypeMetaFieldDef", {
      enumerable: true,
      get: function() {
        return _index.TypeMetaFieldDef;
      }
    });
    Object.defineProperty(exports2, "TypeNameMetaFieldDef", {
      enumerable: true,
      get: function() {
        return _index.TypeNameMetaFieldDef;
      }
    });
    Object.defineProperty(exports2, "UniqueArgumentDefinitionNamesRule", {
      enumerable: true,
      get: function() {
        return _index4.UniqueArgumentDefinitionNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueArgumentNamesRule", {
      enumerable: true,
      get: function() {
        return _index4.UniqueArgumentNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueDirectiveNamesRule", {
      enumerable: true,
      get: function() {
        return _index4.UniqueDirectiveNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueDirectivesPerLocationRule", {
      enumerable: true,
      get: function() {
        return _index4.UniqueDirectivesPerLocationRule;
      }
    });
    Object.defineProperty(exports2, "UniqueEnumValueNamesRule", {
      enumerable: true,
      get: function() {
        return _index4.UniqueEnumValueNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueFieldDefinitionNamesRule", {
      enumerable: true,
      get: function() {
        return _index4.UniqueFieldDefinitionNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueFragmentNamesRule", {
      enumerable: true,
      get: function() {
        return _index4.UniqueFragmentNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueInputFieldNamesRule", {
      enumerable: true,
      get: function() {
        return _index4.UniqueInputFieldNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueOperationNamesRule", {
      enumerable: true,
      get: function() {
        return _index4.UniqueOperationNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueOperationTypesRule", {
      enumerable: true,
      get: function() {
        return _index4.UniqueOperationTypesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueTypeNamesRule", {
      enumerable: true,
      get: function() {
        return _index4.UniqueTypeNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueVariableNamesRule", {
      enumerable: true,
      get: function() {
        return _index4.UniqueVariableNamesRule;
      }
    });
    Object.defineProperty(exports2, "ValidationContext", {
      enumerable: true,
      get: function() {
        return _index4.ValidationContext;
      }
    });
    Object.defineProperty(exports2, "ValuesOfCorrectTypeRule", {
      enumerable: true,
      get: function() {
        return _index4.ValuesOfCorrectTypeRule;
      }
    });
    Object.defineProperty(exports2, "VariablesAreInputTypesRule", {
      enumerable: true,
      get: function() {
        return _index4.VariablesAreInputTypesRule;
      }
    });
    Object.defineProperty(exports2, "VariablesInAllowedPositionRule", {
      enumerable: true,
      get: function() {
        return _index4.VariablesInAllowedPositionRule;
      }
    });
    Object.defineProperty(exports2, "__Directive", {
      enumerable: true,
      get: function() {
        return _index.__Directive;
      }
    });
    Object.defineProperty(exports2, "__DirectiveLocation", {
      enumerable: true,
      get: function() {
        return _index.__DirectiveLocation;
      }
    });
    Object.defineProperty(exports2, "__EnumValue", {
      enumerable: true,
      get: function() {
        return _index.__EnumValue;
      }
    });
    Object.defineProperty(exports2, "__Field", {
      enumerable: true,
      get: function() {
        return _index.__Field;
      }
    });
    Object.defineProperty(exports2, "__InputValue", {
      enumerable: true,
      get: function() {
        return _index.__InputValue;
      }
    });
    Object.defineProperty(exports2, "__Schema", {
      enumerable: true,
      get: function() {
        return _index.__Schema;
      }
    });
    Object.defineProperty(exports2, "__Type", {
      enumerable: true,
      get: function() {
        return _index.__Type;
      }
    });
    Object.defineProperty(exports2, "__TypeKind", {
      enumerable: true,
      get: function() {
        return _index.__TypeKind;
      }
    });
    Object.defineProperty(exports2, "assertAbstractType", {
      enumerable: true,
      get: function() {
        return _index.assertAbstractType;
      }
    });
    Object.defineProperty(exports2, "assertCompositeType", {
      enumerable: true,
      get: function() {
        return _index.assertCompositeType;
      }
    });
    Object.defineProperty(exports2, "assertDirective", {
      enumerable: true,
      get: function() {
        return _index.assertDirective;
      }
    });
    Object.defineProperty(exports2, "assertEnumType", {
      enumerable: true,
      get: function() {
        return _index.assertEnumType;
      }
    });
    Object.defineProperty(exports2, "assertEnumValueName", {
      enumerable: true,
      get: function() {
        return _index.assertEnumValueName;
      }
    });
    Object.defineProperty(exports2, "assertInputObjectType", {
      enumerable: true,
      get: function() {
        return _index.assertInputObjectType;
      }
    });
    Object.defineProperty(exports2, "assertInputType", {
      enumerable: true,
      get: function() {
        return _index.assertInputType;
      }
    });
    Object.defineProperty(exports2, "assertInterfaceType", {
      enumerable: true,
      get: function() {
        return _index.assertInterfaceType;
      }
    });
    Object.defineProperty(exports2, "assertLeafType", {
      enumerable: true,
      get: function() {
        return _index.assertLeafType;
      }
    });
    Object.defineProperty(exports2, "assertListType", {
      enumerable: true,
      get: function() {
        return _index.assertListType;
      }
    });
    Object.defineProperty(exports2, "assertName", {
      enumerable: true,
      get: function() {
        return _index.assertName;
      }
    });
    Object.defineProperty(exports2, "assertNamedType", {
      enumerable: true,
      get: function() {
        return _index.assertNamedType;
      }
    });
    Object.defineProperty(exports2, "assertNonNullType", {
      enumerable: true,
      get: function() {
        return _index.assertNonNullType;
      }
    });
    Object.defineProperty(exports2, "assertNullableType", {
      enumerable: true,
      get: function() {
        return _index.assertNullableType;
      }
    });
    Object.defineProperty(exports2, "assertObjectType", {
      enumerable: true,
      get: function() {
        return _index.assertObjectType;
      }
    });
    Object.defineProperty(exports2, "assertOutputType", {
      enumerable: true,
      get: function() {
        return _index.assertOutputType;
      }
    });
    Object.defineProperty(exports2, "assertScalarType", {
      enumerable: true,
      get: function() {
        return _index.assertScalarType;
      }
    });
    Object.defineProperty(exports2, "assertSchema", {
      enumerable: true,
      get: function() {
        return _index.assertSchema;
      }
    });
    Object.defineProperty(exports2, "assertType", {
      enumerable: true,
      get: function() {
        return _index.assertType;
      }
    });
    Object.defineProperty(exports2, "assertUnionType", {
      enumerable: true,
      get: function() {
        return _index.assertUnionType;
      }
    });
    Object.defineProperty(exports2, "assertValidName", {
      enumerable: true,
      get: function() {
        return _index6.assertValidName;
      }
    });
    Object.defineProperty(exports2, "assertValidSchema", {
      enumerable: true,
      get: function() {
        return _index.assertValidSchema;
      }
    });
    Object.defineProperty(exports2, "assertWrappingType", {
      enumerable: true,
      get: function() {
        return _index.assertWrappingType;
      }
    });
    Object.defineProperty(exports2, "astFromValue", {
      enumerable: true,
      get: function() {
        return _index6.astFromValue;
      }
    });
    Object.defineProperty(exports2, "buildASTSchema", {
      enumerable: true,
      get: function() {
        return _index6.buildASTSchema;
      }
    });
    Object.defineProperty(exports2, "buildClientSchema", {
      enumerable: true,
      get: function() {
        return _index6.buildClientSchema;
      }
    });
    Object.defineProperty(exports2, "buildSchema", {
      enumerable: true,
      get: function() {
        return _index6.buildSchema;
      }
    });
    Object.defineProperty(exports2, "coerceInputValue", {
      enumerable: true,
      get: function() {
        return _index6.coerceInputValue;
      }
    });
    Object.defineProperty(exports2, "concatAST", {
      enumerable: true,
      get: function() {
        return _index6.concatAST;
      }
    });
    Object.defineProperty(exports2, "createSourceEventStream", {
      enumerable: true,
      get: function() {
        return _index3.createSourceEventStream;
      }
    });
    Object.defineProperty(exports2, "defaultFieldResolver", {
      enumerable: true,
      get: function() {
        return _index3.defaultFieldResolver;
      }
    });
    Object.defineProperty(exports2, "defaultTypeResolver", {
      enumerable: true,
      get: function() {
        return _index3.defaultTypeResolver;
      }
    });
    Object.defineProperty(exports2, "doTypesOverlap", {
      enumerable: true,
      get: function() {
        return _index6.doTypesOverlap;
      }
    });
    Object.defineProperty(exports2, "execute", {
      enumerable: true,
      get: function() {
        return _index3.execute;
      }
    });
    Object.defineProperty(exports2, "executeSync", {
      enumerable: true,
      get: function() {
        return _index3.executeSync;
      }
    });
    Object.defineProperty(exports2, "extendSchema", {
      enumerable: true,
      get: function() {
        return _index6.extendSchema;
      }
    });
    Object.defineProperty(exports2, "findBreakingChanges", {
      enumerable: true,
      get: function() {
        return _index6.findBreakingChanges;
      }
    });
    Object.defineProperty(exports2, "findDangerousChanges", {
      enumerable: true,
      get: function() {
        return _index6.findDangerousChanges;
      }
    });
    Object.defineProperty(exports2, "formatError", {
      enumerable: true,
      get: function() {
        return _index5.formatError;
      }
    });
    Object.defineProperty(exports2, "getArgumentValues", {
      enumerable: true,
      get: function() {
        return _index3.getArgumentValues;
      }
    });
    Object.defineProperty(exports2, "getDirectiveValues", {
      enumerable: true,
      get: function() {
        return _index3.getDirectiveValues;
      }
    });
    Object.defineProperty(exports2, "getEnterLeaveForKind", {
      enumerable: true,
      get: function() {
        return _index2.getEnterLeaveForKind;
      }
    });
    Object.defineProperty(exports2, "getIntrospectionQuery", {
      enumerable: true,
      get: function() {
        return _index6.getIntrospectionQuery;
      }
    });
    Object.defineProperty(exports2, "getLocation", {
      enumerable: true,
      get: function() {
        return _index2.getLocation;
      }
    });
    Object.defineProperty(exports2, "getNamedType", {
      enumerable: true,
      get: function() {
        return _index.getNamedType;
      }
    });
    Object.defineProperty(exports2, "getNullableType", {
      enumerable: true,
      get: function() {
        return _index.getNullableType;
      }
    });
    Object.defineProperty(exports2, "getOperationAST", {
      enumerable: true,
      get: function() {
        return _index6.getOperationAST;
      }
    });
    Object.defineProperty(exports2, "getOperationRootType", {
      enumerable: true,
      get: function() {
        return _index6.getOperationRootType;
      }
    });
    Object.defineProperty(exports2, "getVariableValues", {
      enumerable: true,
      get: function() {
        return _index3.getVariableValues;
      }
    });
    Object.defineProperty(exports2, "getVisitFn", {
      enumerable: true,
      get: function() {
        return _index2.getVisitFn;
      }
    });
    Object.defineProperty(exports2, "graphql", {
      enumerable: true,
      get: function() {
        return _graphql.graphql;
      }
    });
    Object.defineProperty(exports2, "graphqlSync", {
      enumerable: true,
      get: function() {
        return _graphql.graphqlSync;
      }
    });
    Object.defineProperty(exports2, "introspectionFromSchema", {
      enumerable: true,
      get: function() {
        return _index6.introspectionFromSchema;
      }
    });
    Object.defineProperty(exports2, "introspectionTypes", {
      enumerable: true,
      get: function() {
        return _index.introspectionTypes;
      }
    });
    Object.defineProperty(exports2, "isAbstractType", {
      enumerable: true,
      get: function() {
        return _index.isAbstractType;
      }
    });
    Object.defineProperty(exports2, "isCompositeType", {
      enumerable: true,
      get: function() {
        return _index.isCompositeType;
      }
    });
    Object.defineProperty(exports2, "isConstValueNode", {
      enumerable: true,
      get: function() {
        return _index2.isConstValueNode;
      }
    });
    Object.defineProperty(exports2, "isDefinitionNode", {
      enumerable: true,
      get: function() {
        return _index2.isDefinitionNode;
      }
    });
    Object.defineProperty(exports2, "isDirective", {
      enumerable: true,
      get: function() {
        return _index.isDirective;
      }
    });
    Object.defineProperty(exports2, "isEnumType", {
      enumerable: true,
      get: function() {
        return _index.isEnumType;
      }
    });
    Object.defineProperty(exports2, "isEqualType", {
      enumerable: true,
      get: function() {
        return _index6.isEqualType;
      }
    });
    Object.defineProperty(exports2, "isExecutableDefinitionNode", {
      enumerable: true,
      get: function() {
        return _index2.isExecutableDefinitionNode;
      }
    });
    Object.defineProperty(exports2, "isInputObjectType", {
      enumerable: true,
      get: function() {
        return _index.isInputObjectType;
      }
    });
    Object.defineProperty(exports2, "isInputType", {
      enumerable: true,
      get: function() {
        return _index.isInputType;
      }
    });
    Object.defineProperty(exports2, "isInterfaceType", {
      enumerable: true,
      get: function() {
        return _index.isInterfaceType;
      }
    });
    Object.defineProperty(exports2, "isIntrospectionType", {
      enumerable: true,
      get: function() {
        return _index.isIntrospectionType;
      }
    });
    Object.defineProperty(exports2, "isLeafType", {
      enumerable: true,
      get: function() {
        return _index.isLeafType;
      }
    });
    Object.defineProperty(exports2, "isListType", {
      enumerable: true,
      get: function() {
        return _index.isListType;
      }
    });
    Object.defineProperty(exports2, "isNamedType", {
      enumerable: true,
      get: function() {
        return _index.isNamedType;
      }
    });
    Object.defineProperty(exports2, "isNonNullType", {
      enumerable: true,
      get: function() {
        return _index.isNonNullType;
      }
    });
    Object.defineProperty(exports2, "isNullableType", {
      enumerable: true,
      get: function() {
        return _index.isNullableType;
      }
    });
    Object.defineProperty(exports2, "isObjectType", {
      enumerable: true,
      get: function() {
        return _index.isObjectType;
      }
    });
    Object.defineProperty(exports2, "isOutputType", {
      enumerable: true,
      get: function() {
        return _index.isOutputType;
      }
    });
    Object.defineProperty(exports2, "isRequiredArgument", {
      enumerable: true,
      get: function() {
        return _index.isRequiredArgument;
      }
    });
    Object.defineProperty(exports2, "isRequiredInputField", {
      enumerable: true,
      get: function() {
        return _index.isRequiredInputField;
      }
    });
    Object.defineProperty(exports2, "isScalarType", {
      enumerable: true,
      get: function() {
        return _index.isScalarType;
      }
    });
    Object.defineProperty(exports2, "isSchema", {
      enumerable: true,
      get: function() {
        return _index.isSchema;
      }
    });
    Object.defineProperty(exports2, "isSelectionNode", {
      enumerable: true,
      get: function() {
        return _index2.isSelectionNode;
      }
    });
    Object.defineProperty(exports2, "isSpecifiedDirective", {
      enumerable: true,
      get: function() {
        return _index.isSpecifiedDirective;
      }
    });
    Object.defineProperty(exports2, "isSpecifiedScalarType", {
      enumerable: true,
      get: function() {
        return _index.isSpecifiedScalarType;
      }
    });
    Object.defineProperty(exports2, "isType", {
      enumerable: true,
      get: function() {
        return _index.isType;
      }
    });
    Object.defineProperty(exports2, "isTypeDefinitionNode", {
      enumerable: true,
      get: function() {
        return _index2.isTypeDefinitionNode;
      }
    });
    Object.defineProperty(exports2, "isTypeExtensionNode", {
      enumerable: true,
      get: function() {
        return _index2.isTypeExtensionNode;
      }
    });
    Object.defineProperty(exports2, "isTypeNode", {
      enumerable: true,
      get: function() {
        return _index2.isTypeNode;
      }
    });
    Object.defineProperty(exports2, "isTypeSubTypeOf", {
      enumerable: true,
      get: function() {
        return _index6.isTypeSubTypeOf;
      }
    });
    Object.defineProperty(exports2, "isTypeSystemDefinitionNode", {
      enumerable: true,
      get: function() {
        return _index2.isTypeSystemDefinitionNode;
      }
    });
    Object.defineProperty(exports2, "isTypeSystemExtensionNode", {
      enumerable: true,
      get: function() {
        return _index2.isTypeSystemExtensionNode;
      }
    });
    Object.defineProperty(exports2, "isUnionType", {
      enumerable: true,
      get: function() {
        return _index.isUnionType;
      }
    });
    Object.defineProperty(exports2, "isValidNameError", {
      enumerable: true,
      get: function() {
        return _index6.isValidNameError;
      }
    });
    Object.defineProperty(exports2, "isValueNode", {
      enumerable: true,
      get: function() {
        return _index2.isValueNode;
      }
    });
    Object.defineProperty(exports2, "isWrappingType", {
      enumerable: true,
      get: function() {
        return _index.isWrappingType;
      }
    });
    Object.defineProperty(exports2, "lexicographicSortSchema", {
      enumerable: true,
      get: function() {
        return _index6.lexicographicSortSchema;
      }
    });
    Object.defineProperty(exports2, "locatedError", {
      enumerable: true,
      get: function() {
        return _index5.locatedError;
      }
    });
    Object.defineProperty(exports2, "parse", {
      enumerable: true,
      get: function() {
        return _index2.parse;
      }
    });
    Object.defineProperty(exports2, "parseConstValue", {
      enumerable: true,
      get: function() {
        return _index2.parseConstValue;
      }
    });
    Object.defineProperty(exports2, "parseType", {
      enumerable: true,
      get: function() {
        return _index2.parseType;
      }
    });
    Object.defineProperty(exports2, "parseValue", {
      enumerable: true,
      get: function() {
        return _index2.parseValue;
      }
    });
    Object.defineProperty(exports2, "print", {
      enumerable: true,
      get: function() {
        return _index2.print;
      }
    });
    Object.defineProperty(exports2, "printError", {
      enumerable: true,
      get: function() {
        return _index5.printError;
      }
    });
    Object.defineProperty(exports2, "printIntrospectionSchema", {
      enumerable: true,
      get: function() {
        return _index6.printIntrospectionSchema;
      }
    });
    Object.defineProperty(exports2, "printLocation", {
      enumerable: true,
      get: function() {
        return _index2.printLocation;
      }
    });
    Object.defineProperty(exports2, "printSchema", {
      enumerable: true,
      get: function() {
        return _index6.printSchema;
      }
    });
    Object.defineProperty(exports2, "printSourceLocation", {
      enumerable: true,
      get: function() {
        return _index2.printSourceLocation;
      }
    });
    Object.defineProperty(exports2, "printType", {
      enumerable: true,
      get: function() {
        return _index6.printType;
      }
    });
    Object.defineProperty(exports2, "resolveObjMapThunk", {
      enumerable: true,
      get: function() {
        return _index.resolveObjMapThunk;
      }
    });
    Object.defineProperty(exports2, "resolveReadonlyArrayThunk", {
      enumerable: true,
      get: function() {
        return _index.resolveReadonlyArrayThunk;
      }
    });
    Object.defineProperty(exports2, "responsePathAsArray", {
      enumerable: true,
      get: function() {
        return _index3.responsePathAsArray;
      }
    });
    Object.defineProperty(exports2, "separateOperations", {
      enumerable: true,
      get: function() {
        return _index6.separateOperations;
      }
    });
    Object.defineProperty(exports2, "specifiedDirectives", {
      enumerable: true,
      get: function() {
        return _index.specifiedDirectives;
      }
    });
    Object.defineProperty(exports2, "specifiedRules", {
      enumerable: true,
      get: function() {
        return _index4.specifiedRules;
      }
    });
    Object.defineProperty(exports2, "specifiedScalarTypes", {
      enumerable: true,
      get: function() {
        return _index.specifiedScalarTypes;
      }
    });
    Object.defineProperty(exports2, "stripIgnoredCharacters", {
      enumerable: true,
      get: function() {
        return _index6.stripIgnoredCharacters;
      }
    });
    Object.defineProperty(exports2, "subscribe", {
      enumerable: true,
      get: function() {
        return _index3.subscribe;
      }
    });
    Object.defineProperty(exports2, "syntaxError", {
      enumerable: true,
      get: function() {
        return _index5.syntaxError;
      }
    });
    Object.defineProperty(exports2, "typeFromAST", {
      enumerable: true,
      get: function() {
        return _index6.typeFromAST;
      }
    });
    Object.defineProperty(exports2, "validate", {
      enumerable: true,
      get: function() {
        return _index4.validate;
      }
    });
    Object.defineProperty(exports2, "validateSchema", {
      enumerable: true,
      get: function() {
        return _index.validateSchema;
      }
    });
    Object.defineProperty(exports2, "valueFromAST", {
      enumerable: true,
      get: function() {
        return _index6.valueFromAST;
      }
    });
    Object.defineProperty(exports2, "valueFromASTUntyped", {
      enumerable: true,
      get: function() {
        return _index6.valueFromASTUntyped;
      }
    });
    Object.defineProperty(exports2, "version", {
      enumerable: true,
      get: function() {
        return _version.version;
      }
    });
    Object.defineProperty(exports2, "versionInfo", {
      enumerable: true,
      get: function() {
        return _version.versionInfo;
      }
    });
    Object.defineProperty(exports2, "visit", {
      enumerable: true,
      get: function() {
        return _index2.visit;
      }
    });
    Object.defineProperty(exports2, "visitInParallel", {
      enumerable: true,
      get: function() {
        return _index2.visitInParallel;
      }
    });
    Object.defineProperty(exports2, "visitWithTypeInfo", {
      enumerable: true,
      get: function() {
        return _index6.visitWithTypeInfo;
      }
    });
    var _version = require_version();
    var _graphql = require_graphql();
    var _index = require_type();
    var _index2 = require_language();
    var _index3 = require_execution();
    var _index4 = require_validation();
    var _index5 = require_error();
    var _index6 = require_utilities();
  }
});

// node_modules/.pnpm/tiny-lru@7.0.6/node_modules/tiny-lru/lib/tiny-lru.cjs.js
var require_tiny_lru_cjs = __commonJS({
  "node_modules/.pnpm/tiny-lru@7.0.6/node_modules/tiny-lru/lib/tiny-lru.cjs.js"(exports2, module2) {
    "use strict";
    var LRU = class {
      constructor(max = 0, ttl = 0) {
        this.first = null;
        this.items = /* @__PURE__ */ Object.create(null);
        this.last = null;
        this.max = max;
        this.size = 0;
        this.ttl = ttl;
      }
      has(key) {
        return key in this.items;
      }
      clear() {
        this.first = null;
        this.items = /* @__PURE__ */ Object.create(null);
        this.last = null;
        this.size = 0;
        return this;
      }
      delete(key) {
        if (this.has(key)) {
          const item = this.items[key];
          delete this.items[key];
          this.size--;
          if (item.prev !== null) {
            item.prev.next = item.next;
          }
          if (item.next !== null) {
            item.next.prev = item.prev;
          }
          if (this.first === item) {
            this.first = item.next;
          }
          if (this.last === item) {
            this.last = item.prev;
          }
        }
        return this;
      }
      evict() {
        const item = this.first;
        delete this.items[item.key];
        this.first = item.next;
        this.first.prev = null;
        this.size--;
        return this;
      }
      get(key) {
        let result;
        if (this.has(key)) {
          const item = this.items[key];
          if (this.ttl > 0 && item.expiry <= new Date().getTime()) {
            this.delete(key);
          } else {
            result = item.value;
            this.set(key, result, true);
          }
        }
        return result;
      }
      keys() {
        return Object.keys(this.items);
      }
      set(key, value, bypass = false) {
        let item;
        if (bypass || this.has(key)) {
          item = this.items[key];
          item.value = value;
          if (bypass === false) {
            item.expiry = this.ttl > 0 ? new Date().getTime() + this.ttl : this.ttl;
          }
          if (this.last !== item) {
            const last = this.last, next = item.next, prev = item.prev;
            if (this.first === item) {
              this.first = item.next;
            }
            item.next = null;
            item.prev = this.last;
            last.next = item;
            if (prev !== null) {
              prev.next = next;
            }
            if (next !== null) {
              next.prev = prev;
            }
          }
        } else {
          if (this.max > 0 && this.size === this.max) {
            this.evict();
          }
          item = this.items[key] = {
            expiry: this.ttl > 0 ? new Date().getTime() + this.ttl : this.ttl,
            key,
            prev: this.last,
            next: null,
            value
          };
          if (++this.size === 1) {
            this.first = item;
          } else {
            this.last.next = item;
          }
        }
        this.last = item;
        return this;
      }
    };
    function factory(max = 1e3, ttl = 0) {
      if (isNaN(max) || max < 0) {
        throw new TypeError("Invalid max value");
      }
      if (isNaN(ttl) || ttl < 0) {
        throw new TypeError("Invalid ttl value");
      }
      return new LRU(max, ttl);
    }
    module2.exports = factory;
  }
});

// node_modules/.pnpm/event-target-shim@5.0.1/node_modules/event-target-shim/dist/event-target-shim.js
var require_event_target_shim = __commonJS({
  "node_modules/.pnpm/event-target-shim@5.0.1/node_modules/event-target-shim/dist/event-target-shim.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var privateData = /* @__PURE__ */ new WeakMap();
    var wrappers = /* @__PURE__ */ new WeakMap();
    function pd(event) {
      const retv = privateData.get(event);
      console.assert(retv != null, "'this' is expected an Event object, but got", event);
      return retv;
    }
    function setCancelFlag(data) {
      if (data.passiveListener != null) {
        if (typeof console !== "undefined" && typeof console.error === "function") {
          console.error("Unable to preventDefault inside passive event listener invocation.", data.passiveListener);
        }
        return;
      }
      if (!data.event.cancelable) {
        return;
      }
      data.canceled = true;
      if (typeof data.event.preventDefault === "function") {
        data.event.preventDefault();
      }
    }
    function Event(eventTarget, event) {
      privateData.set(this, {
        eventTarget,
        event,
        eventPhase: 2,
        currentTarget: eventTarget,
        canceled: false,
        stopped: false,
        immediateStopped: false,
        passiveListener: null,
        timeStamp: event.timeStamp || Date.now()
      });
      Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });
      const keys2 = Object.keys(event);
      for (let i = 0; i < keys2.length; ++i) {
        const key = keys2[i];
        if (!(key in this)) {
          Object.defineProperty(this, key, defineRedirectDescriptor(key));
        }
      }
    }
    Event.prototype = {
      get type() {
        return pd(this).event.type;
      },
      get target() {
        return pd(this).eventTarget;
      },
      get currentTarget() {
        return pd(this).currentTarget;
      },
      composedPath() {
        const currentTarget = pd(this).currentTarget;
        if (currentTarget == null) {
          return [];
        }
        return [currentTarget];
      },
      get NONE() {
        return 0;
      },
      get CAPTURING_PHASE() {
        return 1;
      },
      get AT_TARGET() {
        return 2;
      },
      get BUBBLING_PHASE() {
        return 3;
      },
      get eventPhase() {
        return pd(this).eventPhase;
      },
      stopPropagation() {
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.stopPropagation === "function") {
          data.event.stopPropagation();
        }
      },
      stopImmediatePropagation() {
        const data = pd(this);
        data.stopped = true;
        data.immediateStopped = true;
        if (typeof data.event.stopImmediatePropagation === "function") {
          data.event.stopImmediatePropagation();
        }
      },
      get bubbles() {
        return Boolean(pd(this).event.bubbles);
      },
      get cancelable() {
        return Boolean(pd(this).event.cancelable);
      },
      preventDefault() {
        setCancelFlag(pd(this));
      },
      get defaultPrevented() {
        return pd(this).canceled;
      },
      get composed() {
        return Boolean(pd(this).event.composed);
      },
      get timeStamp() {
        return pd(this).timeStamp;
      },
      get srcElement() {
        return pd(this).eventTarget;
      },
      get cancelBubble() {
        return pd(this).stopped;
      },
      set cancelBubble(value) {
        if (!value) {
          return;
        }
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.cancelBubble === "boolean") {
          data.event.cancelBubble = true;
        }
      },
      get returnValue() {
        return !pd(this).canceled;
      },
      set returnValue(value) {
        if (!value) {
          setCancelFlag(pd(this));
        }
      },
      initEvent() {
      }
    };
    Object.defineProperty(Event.prototype, "constructor", {
      value: Event,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
      Object.setPrototypeOf(Event.prototype, window.Event.prototype);
      wrappers.set(window.Event.prototype, Event);
    }
    function defineRedirectDescriptor(key) {
      return {
        get() {
          return pd(this).event[key];
        },
        set(value) {
          pd(this).event[key] = value;
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineCallDescriptor(key) {
      return {
        value() {
          const event = pd(this).event;
          return event[key].apply(event, arguments);
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineWrapper(BaseEvent, proto) {
      const keys2 = Object.keys(proto);
      if (keys2.length === 0) {
        return BaseEvent;
      }
      function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
      }
      CustomEvent.prototype = Object.create(BaseEvent.prototype, {
        constructor: { value: CustomEvent, configurable: true, writable: true }
      });
      for (let i = 0; i < keys2.length; ++i) {
        const key = keys2[i];
        if (!(key in BaseEvent.prototype)) {
          const descriptor = Object.getOwnPropertyDescriptor(proto, key);
          const isFunc = typeof descriptor.value === "function";
          Object.defineProperty(CustomEvent.prototype, key, isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key));
        }
      }
      return CustomEvent;
    }
    function getWrapper(proto) {
      if (proto == null || proto === Object.prototype) {
        return Event;
      }
      let wrapper = wrappers.get(proto);
      if (wrapper == null) {
        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
        wrappers.set(proto, wrapper);
      }
      return wrapper;
    }
    function wrapEvent(eventTarget, event) {
      const Wrapper = getWrapper(Object.getPrototypeOf(event));
      return new Wrapper(eventTarget, event);
    }
    function isStopped(event) {
      return pd(event).immediateStopped;
    }
    function setEventPhase(event, eventPhase) {
      pd(event).eventPhase = eventPhase;
    }
    function setCurrentTarget(event, currentTarget) {
      pd(event).currentTarget = currentTarget;
    }
    function setPassiveListener(event, passiveListener) {
      pd(event).passiveListener = passiveListener;
    }
    var listenersMap = /* @__PURE__ */ new WeakMap();
    var CAPTURE = 1;
    var BUBBLE = 2;
    var ATTRIBUTE = 3;
    function isObject3(x) {
      return x !== null && typeof x === "object";
    }
    function getListeners(eventTarget) {
      const listeners2 = listenersMap.get(eventTarget);
      if (listeners2 == null) {
        throw new TypeError("'this' is expected an EventTarget object, but got another value.");
      }
      return listeners2;
    }
    function defineEventAttributeDescriptor(eventName) {
      return {
        get() {
          const listeners2 = getListeners(this);
          let node = listeners2.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              return node.listener;
            }
            node = node.next;
          }
          return null;
        },
        set(listener) {
          if (typeof listener !== "function" && !isObject3(listener)) {
            listener = null;
          }
          const listeners2 = getListeners(this);
          let prev = null;
          let node = listeners2.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              if (prev !== null) {
                prev.next = node.next;
              } else if (node.next !== null) {
                listeners2.set(eventName, node.next);
              } else {
                listeners2.delete(eventName);
              }
            } else {
              prev = node;
            }
            node = node.next;
          }
          if (listener !== null) {
            const newNode = {
              listener,
              listenerType: ATTRIBUTE,
              passive: false,
              once: false,
              next: null
            };
            if (prev === null) {
              listeners2.set(eventName, newNode);
            } else {
              prev.next = newNode;
            }
          }
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineEventAttribute(eventTargetPrototype, eventName) {
      Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));
    }
    function defineCustomEventTarget(eventNames2) {
      function CustomEventTarget() {
        EventTarget.call(this);
      }
      CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
        constructor: {
          value: CustomEventTarget,
          configurable: true,
          writable: true
        }
      });
      for (let i = 0; i < eventNames2.length; ++i) {
        defineEventAttribute(CustomEventTarget.prototype, eventNames2[i]);
      }
      return CustomEventTarget;
    }
    function EventTarget() {
      if (this instanceof EventTarget) {
        listenersMap.set(this, /* @__PURE__ */ new Map());
        return;
      }
      if (arguments.length === 1 && Array.isArray(arguments[0])) {
        return defineCustomEventTarget(arguments[0]);
      }
      if (arguments.length > 0) {
        const types = new Array(arguments.length);
        for (let i = 0; i < arguments.length; ++i) {
          types[i] = arguments[i];
        }
        return defineCustomEventTarget(types);
      }
      throw new TypeError("Cannot call a class as a function");
    }
    EventTarget.prototype = {
      addEventListener(eventName, listener, options2) {
        if (listener == null) {
          return;
        }
        if (typeof listener !== "function" && !isObject3(listener)) {
          throw new TypeError("'listener' should be a function or an object.");
        }
        const listeners2 = getListeners(this);
        const optionsIsObj = isObject3(options2);
        const capture = optionsIsObj ? Boolean(options2.capture) : Boolean(options2);
        const listenerType = capture ? CAPTURE : BUBBLE;
        const newNode = {
          listener,
          listenerType,
          passive: optionsIsObj && Boolean(options2.passive),
          once: optionsIsObj && Boolean(options2.once),
          next: null
        };
        let node = listeners2.get(eventName);
        if (node === void 0) {
          listeners2.set(eventName, newNode);
          return;
        }
        let prev = null;
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            return;
          }
          prev = node;
          node = node.next;
        }
        prev.next = newNode;
      },
      removeEventListener(eventName, listener, options2) {
        if (listener == null) {
          return;
        }
        const listeners2 = getListeners(this);
        const capture = isObject3(options2) ? Boolean(options2.capture) : Boolean(options2);
        const listenerType = capture ? CAPTURE : BUBBLE;
        let prev = null;
        let node = listeners2.get(eventName);
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners2.set(eventName, node.next);
            } else {
              listeners2.delete(eventName);
            }
            return;
          }
          prev = node;
          node = node.next;
        }
      },
      dispatchEvent(event) {
        if (event == null || typeof event.type !== "string") {
          throw new TypeError('"event.type" should be a string.');
        }
        const listeners2 = getListeners(this);
        const eventName = event.type;
        let node = listeners2.get(eventName);
        if (node == null) {
          return true;
        }
        const wrappedEvent = wrapEvent(this, event);
        let prev = null;
        while (node != null) {
          if (node.once) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners2.set(eventName, node.next);
            } else {
              listeners2.delete(eventName);
            }
          } else {
            prev = node;
          }
          setPassiveListener(wrappedEvent, node.passive ? node.listener : null);
          if (typeof node.listener === "function") {
            try {
              node.listener.call(this, wrappedEvent);
            } catch (err2) {
              if (typeof console !== "undefined" && typeof console.error === "function") {
                console.error(err2);
              }
            }
          } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
            node.listener.handleEvent(wrappedEvent);
          }
          if (isStopped(wrappedEvent)) {
            break;
          }
          node = node.next;
        }
        setPassiveListener(wrappedEvent, null);
        setEventPhase(wrappedEvent, 0);
        setCurrentTarget(wrappedEvent, null);
        return !wrappedEvent.defaultPrevented;
      }
    };
    Object.defineProperty(EventTarget.prototype, "constructor", {
      value: EventTarget,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
      Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
    }
    exports2.defineEventAttribute = defineEventAttribute;
    exports2.EventTarget = EventTarget;
    exports2.default = EventTarget;
    module2.exports = EventTarget;
    module2.exports.EventTarget = module2.exports["default"] = EventTarget;
    module2.exports.defineEventAttribute = defineEventAttribute;
  }
});

// node_modules/.pnpm/abort-controller@3.0.0/node_modules/abort-controller/dist/abort-controller.js
var require_abort_controller = __commonJS({
  "node_modules/.pnpm/abort-controller@3.0.0/node_modules/abort-controller/dist/abort-controller.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var eventTargetShim = require_event_target_shim();
    var AbortSignal = class extends eventTargetShim.EventTarget {
      constructor() {
        super();
        throw new TypeError("AbortSignal cannot be constructed directly");
      }
      get aborted() {
        const aborted = abortedFlags.get(this);
        if (typeof aborted !== "boolean") {
          throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        }
        return aborted;
      }
    };
    eventTargetShim.defineEventAttribute(AbortSignal.prototype, "abort");
    function createAbortSignal() {
      const signal = Object.create(AbortSignal.prototype);
      eventTargetShim.EventTarget.call(signal);
      abortedFlags.set(signal, false);
      return signal;
    }
    function abortSignal(signal) {
      if (abortedFlags.get(signal) !== false) {
        return;
      }
      abortedFlags.set(signal, true);
      signal.dispatchEvent({ type: "abort" });
    }
    var abortedFlags = /* @__PURE__ */ new WeakMap();
    Object.defineProperties(AbortSignal.prototype, {
      aborted: { enumerable: true }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortSignal"
      });
    }
    var AbortController2 = class {
      constructor() {
        signals.set(this, createAbortSignal());
      }
      get signal() {
        return getSignal(this);
      }
      abort() {
        abortSignal(getSignal(this));
      }
    };
    var signals = /* @__PURE__ */ new WeakMap();
    function getSignal(controller) {
      const signal = signals.get(controller);
      if (signal == null) {
        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
      }
      return signal;
    }
    Object.defineProperties(AbortController2.prototype, {
      signal: { enumerable: true },
      abort: { enumerable: true }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortController2.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortController"
      });
    }
    exports2.AbortController = AbortController2;
    exports2.AbortSignal = AbortSignal;
    exports2.default = AbortController2;
    module2.exports = AbortController2;
    module2.exports.AbortController = module2.exports["default"] = AbortController2;
    module2.exports.AbortSignal = AbortSignal;
  }
});

// polyfill:/home/isak/code/prisma-data-cockroach/node_modules/.pnpm/buffer-es6@4.9.3/node_modules/buffer-es6/index.js
var buffer_es6_exports = {};
__export(buffer_es6_exports, {
  Buffer: () => Buffer2,
  default: () => Buffer_default,
  isBuffer: () => isBuffer
});
var Buffer2, isBuffer, Buffer_default;
var init_buffer_es6 = __esm({
  "polyfill:/home/isak/code/prisma-data-cockroach/node_modules/.pnpm/buffer-es6@4.9.3/node_modules/buffer-es6/index.js"() {
    Buffer2 = globalThis.Buffer;
    ({ isBuffer } = Buffer2);
    Buffer_default = Buffer2;
  }
});

// polyfill:/home/isak/code/prisma-data-cockroach/node_modules/.pnpm/process-es6@0.11.6/node_modules/process-es6/browser.js
var nextTick, title, browser, env, argv, version, versions, on2, addListener, once, off, removeListener, removeAllListeners, emit, binding, cwd, chdir, umask, hrtime, platform, release, config, uptime, process_default;
var init_browser = __esm({
  "polyfill:/home/isak/code/prisma-data-cockroach/node_modules/.pnpm/process-es6@0.11.6/node_modules/process-es6/browser.js"() {
    ({
      nextTick,
      title,
      browser,
      env,
      argv,
      version,
      versions,
      on: on2,
      addListener,
      once,
      off,
      removeListener,
      removeAllListeners,
      emit,
      binding,
      cwd,
      chdir,
      umask,
      hrtime,
      platform,
      release,
      config,
      uptime
    } = globalThis.process);
    process_default = {
      nextTick,
      title,
      browser,
      env,
      argv,
      version,
      versions,
      on: on2,
      addListener,
      once,
      off,
      removeListener,
      removeAllListeners,
      emit,
      binding,
      cwd,
      chdir,
      umask,
      hrtime,
      platform,
      release,
      config,
      uptime
    };
  }
});

// polyfill:./inherits
var require_inherits = __commonJS({
  "polyfill:./inherits"(exports2, module2) {
    function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype || null, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
    module2.exports = inherits2;
  }
});

// node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/util.js
var util_exports = {};
__export(util_exports, {
  _extend: () => _extend,
  debuglog: () => debuglog,
  default: () => util_default,
  deprecate: () => deprecate,
  format: () => format,
  inherits: () => import_inherits.default,
  inspect: () => inspect2,
  isArray: () => isArray,
  isBoolean: () => isBoolean,
  isBuffer: () => isBuffer2,
  isDate: () => isDate,
  isError: () => isError,
  isFunction: () => isFunction,
  isNull: () => isNull,
  isNullOrUndefined: () => isNullOrUndefined,
  isNumber: () => isNumber,
  isObject: () => isObject2,
  isPrimitive: () => isPrimitive,
  isRegExp: () => isRegExp,
  isString: () => isString,
  isSymbol: () => isSymbol,
  isUndefined: () => isUndefined,
  log: () => log
});
function format(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect2(arguments[i]));
    }
    return objects.join(" ");
  }
  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x2) {
    if (x2 === "%%")
      return "%";
    if (i >= len)
      return x2;
    switch (x2) {
      case "%s":
        return String(args[i++]);
      case "%d":
        return Number(args[i++]);
      case "%j":
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return "[Circular]";
        }
      default:
        return x2;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject2(x)) {
      str += " " + x;
    } else {
      str += " " + inspect2(x);
    }
  }
  return str;
}
function deprecate(fn2, msg) {
  if (isUndefined(global.process)) {
    return function() {
      return deprecate(fn2, msg).apply(this, arguments);
    };
  }
  if (process_default.noDeprecation === true) {
    return fn2;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process_default.throwDeprecation) {
        throw new Error(msg);
      } else if (process_default.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn2.apply(this, arguments);
  }
  return deprecated;
}
function debuglog(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process_default.env.NODE_DEBUG || "";
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
      var pid = 0;
      debugs[set] = function() {
        var msg = format.apply(null, arguments);
        console.error("%s %d: %s", set, pid, msg);
      };
    } else {
      debugs[set] = function() {
      };
    }
  }
  return debugs[set];
}
function inspect2(obj, opts) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (arguments.length >= 3)
    ctx.depth = arguments[2];
  if (arguments.length >= 4)
    ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    ctx.showHidden = opts;
  } else if (opts) {
    _extend(ctx, opts);
  }
  if (isUndefined(ctx.showHidden))
    ctx.showHidden = false;
  if (isUndefined(ctx.depth))
    ctx.depth = 2;
  if (isUndefined(ctx.colors))
    ctx.colors = false;
  if (isUndefined(ctx.customInspect))
    ctx.customInspect = true;
  if (ctx.colors)
    ctx.stylize = stylizeWithColor;
  return formatValue2(ctx, obj, ctx.depth);
}
function stylizeWithColor(str, styleType) {
  var style = inspect2.styles[styleType];
  if (style) {
    return "\x1B[" + inspect2.colors[style][0] + "m" + str + "\x1B[" + inspect2.colors[style][1] + "m";
  } else {
    return str;
  }
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash = {};
  array.forEach(function(val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue2(ctx, value, recurseTimes) {
  if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== inspect2 && !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue2(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }
  var keys2 = Object.keys(value);
  var visibleKeys = arrayToHash(keys2);
  if (ctx.showHidden) {
    keys2 = Object.getOwnPropertyNames(value);
  }
  if (isError(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
    return formatError3(value);
  }
  if (keys2.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ": " + value.name : "";
      return ctx.stylize("[Function" + name + "]", "special");
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), "date");
    }
    if (isError(value)) {
      return formatError3(value);
    }
  }
  var base2 = "", array = false, braces = ["{", "}"];
  if (isArray(value)) {
    array = true;
    braces = ["[", "]"];
  }
  if (isFunction(value)) {
    var n = value.name ? ": " + value.name : "";
    base2 = " [Function" + n + "]";
  }
  if (isRegExp(value)) {
    base2 = " " + RegExp.prototype.toString.call(value);
  }
  if (isDate(value)) {
    base2 = " " + Date.prototype.toUTCString.call(value);
  }
  if (isError(value)) {
    base2 = " " + formatError3(value);
  }
  if (keys2.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base2 + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    } else {
      return ctx.stylize("[Object]", "special");
    }
  }
  ctx.seen.push(value);
  var output;
  if (array) {
    output = formatArray2(ctx, value, recurseTimes, visibleKeys, keys2);
  } else {
    output = keys2.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output, base2, braces);
}
function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize("undefined", "undefined");
  if (isString(value)) {
    var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber(value))
    return ctx.stylize("" + value, "number");
  if (isBoolean(value))
    return ctx.stylize("" + value, "boolean");
  if (isNull(value))
    return ctx.stylize("null", "null");
}
function formatError3(value) {
  return "[" + Error.prototype.toString.call(value) + "]";
}
function formatArray2(ctx, value, recurseTimes, visibleKeys, keys2) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push("");
    }
  }
  keys2.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize("[Getter/Setter]", "special");
    } else {
      str = ctx.stylize("[Getter]", "special");
    }
  } else {
    if (desc.set) {
      str = ctx.stylize("[Setter]", "special");
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = "[" + key + "]";
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue2(ctx, desc.value, null);
      } else {
        str = formatValue2(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf("\n") > -1) {
        if (array) {
          str = str.split("\n").map(function(line) {
            return "  " + line;
          }).join("\n").substr(2);
        } else {
          str = "\n" + str.split("\n").map(function(line) {
            return "   " + line;
          }).join("\n");
        }
      }
    } else {
      str = ctx.stylize("[Circular]", "special");
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify("" + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, "name");
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, "string");
    }
  }
  return name + ": " + str;
}
function reduceToSingleString(output, base2, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf("\n") >= 0)
      numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length > 60) {
    return braces[0] + (base2 === "" ? "" : base2 + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
  }
  return braces[0] + base2 + " " + output.join(", ") + " " + braces[1];
}
function isArray(ar) {
  return Array.isArray(ar);
}
function isBoolean(arg) {
  return typeof arg === "boolean";
}
function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return arg == null;
}
function isNumber(arg) {
  return typeof arg === "number";
}
function isString(arg) {
  return typeof arg === "string";
}
function isSymbol(arg) {
  return typeof arg === "symbol";
}
function isUndefined(arg) {
  return arg === void 0;
}
function isRegExp(re) {
  return isObject2(re) && objectToString(re) === "[object RegExp]";
}
function isObject2(arg) {
  return typeof arg === "object" && arg !== null;
}
function isDate(d2) {
  return isObject2(d2) && objectToString(d2) === "[object Date]";
}
function isError(e2) {
  return isObject2(e2) && (objectToString(e2) === "[object Error]" || e2 instanceof Error);
}
function isFunction(arg) {
  return typeof arg === "function";
}
function isPrimitive(arg) {
  return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
}
function isBuffer2(maybeBuf) {
  return Buffer.isBuffer(maybeBuf);
}
function objectToString(o) {
  return Object.prototype.toString.call(o);
}
function pad(n) {
  return n < 10 ? "0" + n.toString(10) : n.toString(10);
}
function timestamp() {
  var d2 = new Date();
  var time = [
    pad(d2.getHours()),
    pad(d2.getMinutes()),
    pad(d2.getSeconds())
  ].join(":");
  return [d2.getDate(), months[d2.getMonth()], time].join(" ");
}
function log() {
  console.log("%s - %s", timestamp(), format.apply(null, arguments));
}
function _extend(origin, add) {
  if (!add || !isObject2(add))
    return origin;
  var keys2 = Object.keys(add);
  var i = keys2.length;
  while (i--) {
    origin[keys2[i]] = add[keys2[i]];
  }
  return origin;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var import_inherits, formatRegExp, debugs, debugEnviron, months, util_default;
var init_util = __esm({
  "node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/util.js"() {
    init_browser();
    import_inherits = __toESM(require_inherits());
    formatRegExp = /%[sdj%]/g;
    debugs = {};
    inspect2.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect2.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      "regexp": "red"
    };
    months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    util_default = {
      inherits: import_inherits.default,
      _extend,
      log,
      isBuffer: isBuffer2,
      isPrimitive,
      isFunction,
      isError,
      isDate,
      isObject: isObject2,
      isRegExp,
      isUndefined,
      isSymbol,
      isString,
      isNumber,
      isNullOrUndefined,
      isNull,
      isBoolean,
      isArray,
      inspect: inspect2,
      deprecate,
      format,
      debuglog
    };
  }
});

// node_modules/.pnpm/web-streams-polyfill@4.0.0-beta.1/node_modules/web-streams-polyfill/dist/ponyfill.js
var require_ponyfill = __commonJS({
  "node_modules/.pnpm/web-streams-polyfill@4.0.0-beta.1/node_modules/web-streams-polyfill/dist/ponyfill.js"(exports2, module2) {
    !function(e2, t) {
      typeof exports2 == "object" && typeof module2 != "undefined" ? t(exports2) : typeof define == "function" && define.amd ? define(["exports"], t) : t((e2 = typeof globalThis != "undefined" ? globalThis : e2 || self).WebStreamsPolyfill = {});
    }(exports2, function(e2) {
      "use strict";
      const t = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol : (e3) => `Symbol(${e3})`;
      function r() {
      }
      function o(e3) {
        return typeof e3 == "object" && e3 !== null || typeof e3 == "function";
      }
      const n = r, a = Promise, i = Promise.prototype.then, l = Promise.resolve.bind(a), s = Promise.reject.bind(a);
      function u(e3) {
        return new a(e3);
      }
      function c(e3) {
        return l(e3);
      }
      function d2(e3) {
        return s(e3);
      }
      function f(e3, t2, r2) {
        return i.call(e3, t2, r2);
      }
      function b(e3, t2, r2) {
        f(f(e3, t2, r2), void 0, n);
      }
      function _(e3, t2) {
        b(e3, t2);
      }
      function h(e3, t2) {
        b(e3, void 0, t2);
      }
      function m(e3, t2, r2) {
        return f(e3, t2, r2);
      }
      function p(e3) {
        f(e3, void 0, n);
      }
      let y2 = (e3) => {
        if (typeof queueMicrotask == "function")
          y2 = queueMicrotask;
        else {
          const e4 = c(void 0);
          y2 = (t2) => f(e4, t2);
        }
        return y2(e3);
      };
      function g(e3, t2, r2) {
        if (typeof e3 != "function")
          throw new TypeError("Argument is not a function");
        return Function.prototype.apply.call(e3, t2, r2);
      }
      function S(e3, t2, r2) {
        try {
          return c(g(e3, t2, r2));
        } catch (e4) {
          return d2(e4);
        }
      }
      class v {
        constructor() {
          this._cursor = 0, this._size = 0, this._front = { _elements: [], _next: void 0 }, this._back = this._front, this._cursor = 0, this._size = 0;
        }
        get length() {
          return this._size;
        }
        push(e3) {
          const t2 = this._back;
          let r2 = t2;
          t2._elements.length === 16383 && (r2 = { _elements: [], _next: void 0 }), t2._elements.push(e3), r2 !== t2 && (this._back = r2, t2._next = r2), ++this._size;
        }
        shift() {
          const e3 = this._front;
          let t2 = e3;
          const r2 = this._cursor;
          let o2 = r2 + 1;
          const n2 = e3._elements, a2 = n2[r2];
          return o2 === 16384 && (t2 = e3._next, o2 = 0), --this._size, this._cursor = o2, e3 !== t2 && (this._front = t2), n2[r2] = void 0, a2;
        }
        forEach(e3) {
          let t2 = this._cursor, r2 = this._front, o2 = r2._elements;
          for (; !(t2 === o2.length && r2._next === void 0 || t2 === o2.length && (r2 = r2._next, o2 = r2._elements, t2 = 0, o2.length === 0)); )
            e3(o2[t2]), ++t2;
        }
        peek() {
          const e3 = this._front, t2 = this._cursor;
          return e3._elements[t2];
        }
      }
      function w(e3, t2) {
        e3._ownerReadableStream = t2, t2._reader = e3, t2._state === "readable" ? q(e3) : t2._state === "closed" ? function(e4) {
          q(e4), W(e4);
        }(e3) : P(e3, t2._storedError);
      }
      function R(e3, t2) {
        return dr2(e3._ownerReadableStream, t2);
      }
      function T(e3) {
        e3._ownerReadableStream._state === "readable" ? E(e3, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")) : function(e4, t2) {
          P(e4, t2);
        }(e3, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")), e3._ownerReadableStream._reader = void 0, e3._ownerReadableStream = void 0;
      }
      function C(e3) {
        return new TypeError("Cannot " + e3 + " a stream using a released reader");
      }
      function q(e3) {
        e3._closedPromise = u((t2, r2) => {
          e3._closedPromise_resolve = t2, e3._closedPromise_reject = r2;
        });
      }
      function P(e3, t2) {
        q(e3), E(e3, t2);
      }
      function E(e3, t2) {
        e3._closedPromise_reject !== void 0 && (p(e3._closedPromise), e3._closedPromise_reject(t2), e3._closedPromise_resolve = void 0, e3._closedPromise_reject = void 0);
      }
      function W(e3) {
        e3._closedPromise_resolve !== void 0 && (e3._closedPromise_resolve(void 0), e3._closedPromise_resolve = void 0, e3._closedPromise_reject = void 0);
      }
      const O = t("[[AbortSteps]]"), B = t("[[ErrorSteps]]"), k2 = t("[[CancelSteps]]"), j2 = t("[[PullSteps]]"), A = Number.isFinite || function(e3) {
        return typeof e3 == "number" && isFinite(e3);
      }, z = Math.trunc || function(e3) {
        return e3 < 0 ? Math.ceil(e3) : Math.floor(e3);
      };
      function F(e3, t2) {
        if (e3 !== void 0 && (typeof (r2 = e3) != "object" && typeof r2 != "function"))
          throw new TypeError(`${t2} is not an object.`);
        var r2;
      }
      function I2(e3, t2) {
        if (typeof e3 != "function")
          throw new TypeError(`${t2} is not a function.`);
      }
      function L(e3, t2) {
        if (!function(e4) {
          return typeof e4 == "object" && e4 !== null || typeof e4 == "function";
        }(e3))
          throw new TypeError(`${t2} is not an object.`);
      }
      function D2(e3, t2, r2) {
        if (e3 === void 0)
          throw new TypeError(`Parameter ${t2} is required in '${r2}'.`);
      }
      function $(e3, t2, r2) {
        if (e3 === void 0)
          throw new TypeError(`${t2} is required in '${r2}'.`);
      }
      function M(e3) {
        return Number(e3);
      }
      function Q(e3) {
        return e3 === 0 ? 0 : e3;
      }
      function Y(e3, t2) {
        const r2 = Number.MAX_SAFE_INTEGER;
        let o2 = Number(e3);
        if (o2 = Q(o2), !A(o2))
          throw new TypeError(`${t2} is not a finite number`);
        if (o2 = function(e4) {
          return Q(z(e4));
        }(o2), o2 < 0 || o2 > r2)
          throw new TypeError(`${t2} is outside the accepted range of 0 to ${r2}, inclusive`);
        return A(o2) && o2 !== 0 ? o2 : 0;
      }
      function x(e3, t2) {
        if (!ur(e3))
          throw new TypeError(`${t2} is not a ReadableStream.`);
      }
      function N2(e3) {
        return new ReadableStreamDefaultReader(e3);
      }
      function H(e3, t2) {
        e3._reader._readRequests.push(t2);
      }
      function V(e3, t2, r2) {
        const o2 = e3._reader._readRequests.shift();
        r2 ? o2._closeSteps() : o2._chunkSteps(t2);
      }
      function U(e3) {
        return e3._reader._readRequests.length;
      }
      function G(e3) {
        const t2 = e3._reader;
        return t2 !== void 0 && !!X(t2);
      }
      class ReadableStreamDefaultReader {
        constructor(e3) {
          if (D2(e3, 1, "ReadableStreamDefaultReader"), x(e3, "First parameter"), cr2(e3))
            throw new TypeError("This stream has already been locked for exclusive reading by another reader");
          w(this, e3), this._readRequests = new v();
        }
        get closed() {
          return X(this) ? this._closedPromise : d2(K2("closed"));
        }
        cancel(e3) {
          return X(this) ? this._ownerReadableStream === void 0 ? d2(C("cancel")) : R(this, e3) : d2(K2("cancel"));
        }
        read() {
          if (!X(this))
            return d2(K2("read"));
          if (this._ownerReadableStream === void 0)
            return d2(C("read from"));
          let e3, t2;
          const r2 = u((r3, o2) => {
            e3 = r3, t2 = o2;
          });
          return J(this, { _chunkSteps: (t3) => e3({ value: t3, done: false }), _closeSteps: () => e3({ value: void 0, done: true }), _errorSteps: (e4) => t2(e4) }), r2;
        }
        releaseLock() {
          if (!X(this))
            throw K2("releaseLock");
          if (this._ownerReadableStream !== void 0) {
            if (this._readRequests.length > 0)
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            T(this);
          }
        }
      }
      function X(e3) {
        return !!o(e3) && (!!Object.prototype.hasOwnProperty.call(e3, "_readRequests") && e3 instanceof ReadableStreamDefaultReader);
      }
      function J(e3, t2) {
        const r2 = e3._ownerReadableStream;
        r2._disturbed = true, r2._state === "closed" ? t2._closeSteps() : r2._state === "errored" ? t2._errorSteps(r2._storedError) : r2._readableStreamController[j2](t2);
      }
      function K2(e3) {
        return new TypeError(`ReadableStreamDefaultReader.prototype.${e3} can only be used on a ReadableStreamDefaultReader`);
      }
      Object.defineProperties(ReadableStreamDefaultReader.prototype, { cancel: { enumerable: true }, read: { enumerable: true }, releaseLock: { enumerable: true }, closed: { enumerable: true } }), typeof t.toStringTag == "symbol" && Object.defineProperty(ReadableStreamDefaultReader.prototype, t.toStringTag, { value: "ReadableStreamDefaultReader", configurable: true });
      class Z {
        constructor(e3, t2) {
          this._ongoingPromise = void 0, this._isFinished = false, this._reader = e3, this._preventCancel = t2;
        }
        next() {
          const e3 = () => this._nextSteps();
          return this._ongoingPromise = this._ongoingPromise ? m(this._ongoingPromise, e3, e3) : e3(), this._ongoingPromise;
        }
        return(e3) {
          const t2 = () => this._returnSteps(e3);
          return this._ongoingPromise ? m(this._ongoingPromise, t2, t2) : t2();
        }
        _nextSteps() {
          if (this._isFinished)
            return Promise.resolve({ value: void 0, done: true });
          const e3 = this._reader;
          if (e3._ownerReadableStream === void 0)
            return d2(C("iterate"));
          let t2, r2;
          const o2 = u((e4, o3) => {
            t2 = e4, r2 = o3;
          });
          return J(e3, { _chunkSteps: (e4) => {
            this._ongoingPromise = void 0, y2(() => t2({ value: e4, done: false }));
          }, _closeSteps: () => {
            this._ongoingPromise = void 0, this._isFinished = true, T(e3), t2({ value: void 0, done: true });
          }, _errorSteps: (t3) => {
            this._ongoingPromise = void 0, this._isFinished = true, T(e3), r2(t3);
          } }), o2;
        }
        _returnSteps(e3) {
          if (this._isFinished)
            return Promise.resolve({ value: e3, done: true });
          this._isFinished = true;
          const t2 = this._reader;
          if (t2._ownerReadableStream === void 0)
            return d2(C("finish iterating"));
          if (!this._preventCancel) {
            const r2 = R(t2, e3);
            return T(t2), m(r2, () => ({ value: e3, done: true }));
          }
          return T(t2), c({ value: e3, done: true });
        }
      }
      const ee = { next() {
        return te2(this) ? this._asyncIteratorImpl.next() : d2(re("next"));
      }, return(e3) {
        return te2(this) ? this._asyncIteratorImpl.return(e3) : d2(re("return"));
      } };
      function te2(e3) {
        if (!o(e3))
          return false;
        if (!Object.prototype.hasOwnProperty.call(e3, "_asyncIteratorImpl"))
          return false;
        try {
          return e3._asyncIteratorImpl instanceof Z;
        } catch (e4) {
          return false;
        }
      }
      function re(e3) {
        return new TypeError(`ReadableStreamAsyncIterator.${e3} can only be used on a ReadableSteamAsyncIterator`);
      }
      typeof t.asyncIterator == "symbol" && Object.defineProperty(ee, t.asyncIterator, { value() {
        return this;
      }, writable: true, configurable: true });
      const oe2 = Number.isNaN || function(e3) {
        return e3 != e3;
      };
      function ne(e3) {
        return e3.slice();
      }
      function ae2(e3, t2, r2, o2, n2) {
        new Uint8Array(e3).set(new Uint8Array(r2, o2, n2), t2);
      }
      function ie(e3, t2, r2) {
        if (e3.slice)
          return e3.slice(t2, r2);
        const o2 = r2 - t2, n2 = new ArrayBuffer(o2);
        return ae2(n2, 0, e3, t2, o2), n2;
      }
      function le(e3) {
        const t2 = ie(e3.buffer, e3.byteOffset, e3.byteOffset + e3.byteLength);
        return new Uint8Array(t2);
      }
      function se(e3) {
        const t2 = e3._queue.shift();
        return e3._queueTotalSize -= t2.size, e3._queueTotalSize < 0 && (e3._queueTotalSize = 0), t2.value;
      }
      function ue2(e3, t2, r2) {
        if (typeof (o2 = r2) != "number" || oe2(o2) || o2 < 0 || r2 === 1 / 0)
          throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
        var o2;
        e3._queue.push({ value: t2, size: r2 }), e3._queueTotalSize += r2;
      }
      function ce(e3) {
        e3._queue = new v(), e3._queueTotalSize = 0;
      }
      class ReadableStreamBYOBRequest {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        get view() {
          if (!fe2(this))
            throw Ae2("view");
          return this._view;
        }
        respond(e3) {
          if (!fe2(this))
            throw Ae2("respond");
          if (D2(e3, 1, "respond"), e3 = Y(e3, "First parameter"), this._associatedReadableByteStreamController === void 0)
            throw new TypeError("This BYOB request has been invalidated");
          this._view.buffer, Be(this._associatedReadableByteStreamController, e3);
        }
        respondWithNewView(e3) {
          if (!fe2(this))
            throw Ae2("respondWithNewView");
          if (D2(e3, 1, "respondWithNewView"), !ArrayBuffer.isView(e3))
            throw new TypeError("You can only respond with array buffer views");
          if (this._associatedReadableByteStreamController === void 0)
            throw new TypeError("This BYOB request has been invalidated");
          e3.buffer, ke(this._associatedReadableByteStreamController, e3);
        }
      }
      Object.defineProperties(ReadableStreamBYOBRequest.prototype, { respond: { enumerable: true }, respondWithNewView: { enumerable: true }, view: { enumerable: true } }), typeof t.toStringTag == "symbol" && Object.defineProperty(ReadableStreamBYOBRequest.prototype, t.toStringTag, { value: "ReadableStreamBYOBRequest", configurable: true });
      class ReadableByteStreamController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        get byobRequest() {
          if (!de(this))
            throw ze("byobRequest");
          return We(this);
        }
        get desiredSize() {
          if (!de(this))
            throw ze("desiredSize");
          return Oe(this);
        }
        close() {
          if (!de(this))
            throw ze("close");
          if (this._closeRequested)
            throw new TypeError("The stream has already been closed; do not close it again!");
          const e3 = this._controlledReadableByteStream._state;
          if (e3 !== "readable")
            throw new TypeError(`The stream (in ${e3} state) is not in the readable state and cannot be closed`);
          qe2(this);
        }
        enqueue(e3) {
          if (!de(this))
            throw ze("enqueue");
          if (D2(e3, 1, "enqueue"), !ArrayBuffer.isView(e3))
            throw new TypeError("chunk must be an array buffer view");
          if (e3.byteLength === 0)
            throw new TypeError("chunk must have non-zero byteLength");
          if (e3.buffer.byteLength === 0)
            throw new TypeError("chunk's buffer must have non-zero byteLength");
          if (this._closeRequested)
            throw new TypeError("stream is closed or draining");
          const t2 = this._controlledReadableByteStream._state;
          if (t2 !== "readable")
            throw new TypeError(`The stream (in ${t2} state) is not in the readable state and cannot be enqueued to`);
          Pe2(this, e3);
        }
        error(e3) {
          if (!de(this))
            throw ze("error");
          Ee2(this, e3);
        }
        [k2](e3) {
          _e(this), ce(this);
          const t2 = this._cancelAlgorithm(e3);
          return Ce2(this), t2;
        }
        [j2](e3) {
          const t2 = this._controlledReadableByteStream;
          if (this._queueTotalSize > 0) {
            const t3 = this._queue.shift();
            this._queueTotalSize -= t3.byteLength, Se(this);
            const r3 = new Uint8Array(t3.buffer, t3.byteOffset, t3.byteLength);
            return void e3._chunkSteps(r3);
          }
          const r2 = this._autoAllocateChunkSize;
          if (r2 !== void 0) {
            let t3;
            try {
              t3 = new ArrayBuffer(r2);
            } catch (t4) {
              return void e3._errorSteps(t4);
            }
            const o2 = { buffer: t3, bufferByteLength: r2, byteOffset: 0, byteLength: r2, bytesFilled: 0, elementSize: 1, viewConstructor: Uint8Array, readerType: "default" };
            this._pendingPullIntos.push(o2);
          }
          H(t2, e3), be(this);
        }
      }
      function de(e3) {
        return !!o(e3) && (!!Object.prototype.hasOwnProperty.call(e3, "_controlledReadableByteStream") && e3 instanceof ReadableByteStreamController);
      }
      function fe2(e3) {
        return !!o(e3) && (!!Object.prototype.hasOwnProperty.call(e3, "_associatedReadableByteStreamController") && e3 instanceof ReadableStreamBYOBRequest);
      }
      function be(e3) {
        if (!function(e4) {
          const t2 = e4._controlledReadableByteStream;
          if (t2._state !== "readable")
            return false;
          if (e4._closeRequested)
            return false;
          if (!e4._started)
            return false;
          if (G(t2) && U(t2) > 0)
            return true;
          if (De(t2) && Le2(t2) > 0)
            return true;
          if (Oe(e4) > 0)
            return true;
          return false;
        }(e3))
          return;
        if (e3._pulling)
          return void (e3._pullAgain = true);
        e3._pulling = true;
        b(e3._pullAlgorithm(), () => {
          e3._pulling = false, e3._pullAgain && (e3._pullAgain = false, be(e3));
        }, (t2) => {
          Ee2(e3, t2);
        });
      }
      function _e(e3) {
        ve2(e3), e3._pendingPullIntos = new v();
      }
      function he(e3, t2) {
        let r2 = false;
        e3._state === "closed" && (r2 = true);
        const o2 = me(t2);
        t2.readerType === "default" ? V(e3, o2, r2) : function(e4, t3, r3) {
          const o3 = e4._reader._readIntoRequests.shift();
          r3 ? o3._closeSteps(t3) : o3._chunkSteps(t3);
        }(e3, o2, r2);
      }
      function me(e3) {
        const t2 = e3.bytesFilled, r2 = e3.elementSize;
        return new e3.viewConstructor(e3.buffer, e3.byteOffset, t2 / r2);
      }
      function pe(e3, t2, r2, o2) {
        e3._queue.push({ buffer: t2, byteOffset: r2, byteLength: o2 }), e3._queueTotalSize += o2;
      }
      function ye(e3, t2) {
        const r2 = t2.elementSize, o2 = t2.bytesFilled - t2.bytesFilled % r2, n2 = Math.min(e3._queueTotalSize, t2.byteLength - t2.bytesFilled), a2 = t2.bytesFilled + n2, i2 = a2 - a2 % r2;
        let l2 = n2, s2 = false;
        i2 > o2 && (l2 = i2 - t2.bytesFilled, s2 = true);
        const u2 = e3._queue;
        for (; l2 > 0; ) {
          const r3 = u2.peek(), o3 = Math.min(l2, r3.byteLength), n3 = t2.byteOffset + t2.bytesFilled;
          ae2(t2.buffer, n3, r3.buffer, r3.byteOffset, o3), r3.byteLength === o3 ? u2.shift() : (r3.byteOffset += o3, r3.byteLength -= o3), e3._queueTotalSize -= o3, ge(e3, o3, t2), l2 -= o3;
        }
        return s2;
      }
      function ge(e3, t2, r2) {
        r2.bytesFilled += t2;
      }
      function Se(e3) {
        e3._queueTotalSize === 0 && e3._closeRequested ? (Ce2(e3), fr2(e3._controlledReadableByteStream)) : be(e3);
      }
      function ve2(e3) {
        e3._byobRequest !== null && (e3._byobRequest._associatedReadableByteStreamController = void 0, e3._byobRequest._view = null, e3._byobRequest = null);
      }
      function we2(e3) {
        for (; e3._pendingPullIntos.length > 0; ) {
          if (e3._queueTotalSize === 0)
            return;
          const t2 = e3._pendingPullIntos.peek();
          ye(e3, t2) && (Te(e3), he(e3._controlledReadableByteStream, t2));
        }
      }
      function Re(e3, t2) {
        const r2 = e3._pendingPullIntos.peek();
        ve2(e3);
        e3._controlledReadableByteStream._state === "closed" ? function(e4, t3) {
          const r3 = e4._controlledReadableByteStream;
          if (De(r3))
            for (; Le2(r3) > 0; )
              he(r3, Te(e4));
        }(e3) : function(e4, t3, r3) {
          if (ge(0, t3, r3), r3.bytesFilled < r3.elementSize)
            return;
          Te(e4);
          const o2 = r3.bytesFilled % r3.elementSize;
          if (o2 > 0) {
            const t4 = r3.byteOffset + r3.bytesFilled, n2 = ie(r3.buffer, t4 - o2, t4);
            pe(e4, n2, 0, n2.byteLength);
          }
          r3.bytesFilled -= o2, he(e4._controlledReadableByteStream, r3), we2(e4);
        }(e3, t2, r2), be(e3);
      }
      function Te(e3) {
        return e3._pendingPullIntos.shift();
      }
      function Ce2(e3) {
        e3._pullAlgorithm = void 0, e3._cancelAlgorithm = void 0;
      }
      function qe2(e3) {
        const t2 = e3._controlledReadableByteStream;
        if (!e3._closeRequested && t2._state === "readable")
          if (e3._queueTotalSize > 0)
            e3._closeRequested = true;
          else {
            if (e3._pendingPullIntos.length > 0) {
              if (e3._pendingPullIntos.peek().bytesFilled > 0) {
                const t3 = new TypeError("Insufficient bytes to fill elements in the given buffer");
                throw Ee2(e3, t3), t3;
              }
            }
            Ce2(e3), fr2(t2);
          }
      }
      function Pe2(e3, t2) {
        const r2 = e3._controlledReadableByteStream;
        if (e3._closeRequested || r2._state !== "readable")
          return;
        const o2 = t2.buffer, n2 = t2.byteOffset, a2 = t2.byteLength, i2 = o2;
        if (e3._pendingPullIntos.length > 0) {
          const t3 = e3._pendingPullIntos.peek();
          t3.buffer, 0, t3.buffer = t3.buffer;
        }
        if (ve2(e3), G(r2))
          if (U(r2) === 0)
            pe(e3, i2, n2, a2);
          else {
            V(r2, new Uint8Array(i2, n2, a2), false);
          }
        else
          De(r2) ? (pe(e3, i2, n2, a2), we2(e3)) : pe(e3, i2, n2, a2);
        be(e3);
      }
      function Ee2(e3, t2) {
        const r2 = e3._controlledReadableByteStream;
        r2._state === "readable" && (_e(e3), ce(e3), Ce2(e3), br2(r2, t2));
      }
      function We(e3) {
        if (e3._byobRequest === null && e3._pendingPullIntos.length > 0) {
          const t2 = e3._pendingPullIntos.peek(), r2 = new Uint8Array(t2.buffer, t2.byteOffset + t2.bytesFilled, t2.byteLength - t2.bytesFilled), o2 = Object.create(ReadableStreamBYOBRequest.prototype);
          !function(e4, t3, r3) {
            e4._associatedReadableByteStreamController = t3, e4._view = r3;
          }(o2, e3, r2), e3._byobRequest = o2;
        }
        return e3._byobRequest;
      }
      function Oe(e3) {
        const t2 = e3._controlledReadableByteStream._state;
        return t2 === "errored" ? null : t2 === "closed" ? 0 : e3._strategyHWM - e3._queueTotalSize;
      }
      function Be(e3, t2) {
        const r2 = e3._pendingPullIntos.peek();
        if (e3._controlledReadableByteStream._state === "closed") {
          if (t2 !== 0)
            throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
        } else {
          if (t2 === 0)
            throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
          if (r2.bytesFilled + t2 > r2.byteLength)
            throw new RangeError("bytesWritten out of range");
        }
        r2.buffer = r2.buffer, Re(e3, t2);
      }
      function ke(e3, t2) {
        const r2 = e3._pendingPullIntos.peek();
        if (e3._controlledReadableByteStream._state === "closed") {
          if (t2.byteLength !== 0)
            throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
        } else if (t2.byteLength === 0)
          throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
        if (r2.byteOffset + r2.bytesFilled !== t2.byteOffset)
          throw new RangeError("The region specified by view does not match byobRequest");
        if (r2.bufferByteLength !== t2.buffer.byteLength)
          throw new RangeError("The buffer of view has different capacity than byobRequest");
        if (r2.bytesFilled + t2.byteLength > r2.byteLength)
          throw new RangeError("The region specified by view is larger than byobRequest");
        r2.buffer = t2.buffer, Re(e3, t2.byteLength);
      }
      function je2(e3, t2, r2, o2, n2, a2, i2) {
        t2._controlledReadableByteStream = e3, t2._pullAgain = false, t2._pulling = false, t2._byobRequest = null, t2._queue = t2._queueTotalSize = void 0, ce(t2), t2._closeRequested = false, t2._started = false, t2._strategyHWM = a2, t2._pullAlgorithm = o2, t2._cancelAlgorithm = n2, t2._autoAllocateChunkSize = i2, t2._pendingPullIntos = new v(), e3._readableStreamController = t2;
        b(c(r2()), () => {
          t2._started = true, be(t2);
        }, (e4) => {
          Ee2(t2, e4);
        });
      }
      function Ae2(e3) {
        return new TypeError(`ReadableStreamBYOBRequest.prototype.${e3} can only be used on a ReadableStreamBYOBRequest`);
      }
      function ze(e3) {
        return new TypeError(`ReadableByteStreamController.prototype.${e3} can only be used on a ReadableByteStreamController`);
      }
      function Fe2(e3) {
        return new ReadableStreamBYOBReader(e3);
      }
      function Ie2(e3, t2) {
        e3._reader._readIntoRequests.push(t2);
      }
      function Le2(e3) {
        return e3._reader._readIntoRequests.length;
      }
      function De(e3) {
        const t2 = e3._reader;
        return t2 !== void 0 && !!$e(t2);
      }
      Object.defineProperties(ReadableByteStreamController.prototype, { close: { enumerable: true }, enqueue: { enumerable: true }, error: { enumerable: true }, byobRequest: { enumerable: true }, desiredSize: { enumerable: true } }), typeof t.toStringTag == "symbol" && Object.defineProperty(ReadableByteStreamController.prototype, t.toStringTag, { value: "ReadableByteStreamController", configurable: true });
      class ReadableStreamBYOBReader {
        constructor(e3) {
          if (D2(e3, 1, "ReadableStreamBYOBReader"), x(e3, "First parameter"), cr2(e3))
            throw new TypeError("This stream has already been locked for exclusive reading by another reader");
          if (!de(e3._readableStreamController))
            throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
          w(this, e3), this._readIntoRequests = new v();
        }
        get closed() {
          return $e(this) ? this._closedPromise : d2(Qe2("closed"));
        }
        cancel(e3) {
          return $e(this) ? this._ownerReadableStream === void 0 ? d2(C("cancel")) : R(this, e3) : d2(Qe2("cancel"));
        }
        read(e3) {
          if (!$e(this))
            return d2(Qe2("read"));
          if (!ArrayBuffer.isView(e3))
            return d2(new TypeError("view must be an array buffer view"));
          if (e3.byteLength === 0)
            return d2(new TypeError("view must have non-zero byteLength"));
          if (e3.buffer.byteLength === 0)
            return d2(new TypeError("view's buffer must have non-zero byteLength"));
          if (e3.buffer, this._ownerReadableStream === void 0)
            return d2(C("read from"));
          let t2, r2;
          const o2 = u((e4, o3) => {
            t2 = e4, r2 = o3;
          });
          return Me2(this, e3, { _chunkSteps: (e4) => t2({ value: e4, done: false }), _closeSteps: (e4) => t2({ value: e4, done: true }), _errorSteps: (e4) => r2(e4) }), o2;
        }
        releaseLock() {
          if (!$e(this))
            throw Qe2("releaseLock");
          if (this._ownerReadableStream !== void 0) {
            if (this._readIntoRequests.length > 0)
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            T(this);
          }
        }
      }
      function $e(e3) {
        return !!o(e3) && (!!Object.prototype.hasOwnProperty.call(e3, "_readIntoRequests") && e3 instanceof ReadableStreamBYOBReader);
      }
      function Me2(e3, t2, r2) {
        const o2 = e3._ownerReadableStream;
        o2._disturbed = true, o2._state === "errored" ? r2._errorSteps(o2._storedError) : function(e4, t3, r3) {
          const o3 = e4._controlledReadableByteStream;
          let n2 = 1;
          t3.constructor !== DataView && (n2 = t3.constructor.BYTES_PER_ELEMENT);
          const a2 = t3.constructor, i2 = t3.buffer, l2 = { buffer: i2, bufferByteLength: i2.byteLength, byteOffset: t3.byteOffset, byteLength: t3.byteLength, bytesFilled: 0, elementSize: n2, viewConstructor: a2, readerType: "byob" };
          if (e4._pendingPullIntos.length > 0)
            return e4._pendingPullIntos.push(l2), void Ie2(o3, r3);
          if (o3._state !== "closed") {
            if (e4._queueTotalSize > 0) {
              if (ye(e4, l2)) {
                const t4 = me(l2);
                return Se(e4), void r3._chunkSteps(t4);
              }
              if (e4._closeRequested) {
                const t4 = new TypeError("Insufficient bytes to fill elements in the given buffer");
                return Ee2(e4, t4), void r3._errorSteps(t4);
              }
            }
            e4._pendingPullIntos.push(l2), Ie2(o3, r3), be(e4);
          } else {
            const e5 = new a2(l2.buffer, l2.byteOffset, 0);
            r3._closeSteps(e5);
          }
        }(o2._readableStreamController, t2, r2);
      }
      function Qe2(e3) {
        return new TypeError(`ReadableStreamBYOBReader.prototype.${e3} can only be used on a ReadableStreamBYOBReader`);
      }
      function Ye2(e3, t2) {
        const { highWaterMark: r2 } = e3;
        if (r2 === void 0)
          return t2;
        if (oe2(r2) || r2 < 0)
          throw new RangeError("Invalid highWaterMark");
        return r2;
      }
      function xe(e3) {
        const { size: t2 } = e3;
        return t2 || (() => 1);
      }
      function Ne(e3, t2) {
        F(e3, t2);
        const r2 = e3 == null ? void 0 : e3.highWaterMark, o2 = e3 == null ? void 0 : e3.size;
        return { highWaterMark: r2 === void 0 ? void 0 : M(r2), size: o2 === void 0 ? void 0 : He2(o2, `${t2} has member 'size' that`) };
      }
      function He2(e3, t2) {
        return I2(e3, t2), (t3) => M(e3(t3));
      }
      function Ve(e3, t2, r2) {
        return I2(e3, r2), (r3) => S(e3, t2, [r3]);
      }
      function Ue2(e3, t2, r2) {
        return I2(e3, r2), () => S(e3, t2, []);
      }
      function Ge2(e3, t2, r2) {
        return I2(e3, r2), (r3) => g(e3, t2, [r3]);
      }
      function Xe2(e3, t2, r2) {
        return I2(e3, r2), (r3, o2) => S(e3, t2, [r3, o2]);
      }
      function Je2(e3, t2) {
        if (!tt(e3))
          throw new TypeError(`${t2} is not a WritableStream.`);
      }
      Object.defineProperties(ReadableStreamBYOBReader.prototype, { cancel: { enumerable: true }, read: { enumerable: true }, releaseLock: { enumerable: true }, closed: { enumerable: true } }), typeof t.toStringTag == "symbol" && Object.defineProperty(ReadableStreamBYOBReader.prototype, t.toStringTag, { value: "ReadableStreamBYOBReader", configurable: true });
      const Ke2 = typeof AbortController == "function";
      class WritableStream {
        constructor(e3 = {}, t2 = {}) {
          e3 === void 0 ? e3 = null : L(e3, "First parameter");
          const r2 = Ne(t2, "Second parameter"), o2 = function(e4, t3) {
            F(e4, t3);
            const r3 = e4 == null ? void 0 : e4.abort, o3 = e4 == null ? void 0 : e4.close, n3 = e4 == null ? void 0 : e4.start, a2 = e4 == null ? void 0 : e4.type, i2 = e4 == null ? void 0 : e4.write;
            return { abort: r3 === void 0 ? void 0 : Ve(r3, e4, `${t3} has member 'abort' that`), close: o3 === void 0 ? void 0 : Ue2(o3, e4, `${t3} has member 'close' that`), start: n3 === void 0 ? void 0 : Ge2(n3, e4, `${t3} has member 'start' that`), write: i2 === void 0 ? void 0 : Xe2(i2, e4, `${t3} has member 'write' that`), type: a2 };
          }(e3, "First parameter");
          et(this);
          if (o2.type !== void 0)
            throw new RangeError("Invalid type is specified");
          const n2 = xe(r2);
          !function(e4, t3, r3, o3) {
            const n3 = Object.create(WritableStreamDefaultController.prototype);
            let a2 = () => {
            }, i2 = () => c(void 0), l2 = () => c(void 0), s2 = () => c(void 0);
            t3.start !== void 0 && (a2 = () => t3.start(n3));
            t3.write !== void 0 && (i2 = (e5) => t3.write(e5, n3));
            t3.close !== void 0 && (l2 = () => t3.close());
            t3.abort !== void 0 && (s2 = (e5) => t3.abort(e5));
            gt(e4, n3, a2, i2, l2, s2, r3, o3);
          }(this, o2, Ye2(r2, 1), n2);
        }
        get locked() {
          if (!tt(this))
            throw qt2("locked");
          return rt2(this);
        }
        abort(e3) {
          return tt(this) ? rt2(this) ? d2(new TypeError("Cannot abort a stream that already has a writer")) : ot2(this, e3) : d2(qt2("abort"));
        }
        close() {
          return tt(this) ? rt2(this) ? d2(new TypeError("Cannot close a stream that already has a writer")) : st(this) ? d2(new TypeError("Cannot close an already-closing stream")) : nt2(this) : d2(qt2("close"));
        }
        getWriter() {
          if (!tt(this))
            throw qt2("getWriter");
          return Ze2(this);
        }
      }
      function Ze2(e3) {
        return new WritableStreamDefaultWriter(e3);
      }
      function et(e3) {
        e3._state = "writable", e3._storedError = void 0, e3._writer = void 0, e3._writableStreamController = void 0, e3._writeRequests = new v(), e3._inFlightWriteRequest = void 0, e3._closeRequest = void 0, e3._inFlightCloseRequest = void 0, e3._pendingAbortRequest = void 0, e3._backpressure = false;
      }
      function tt(e3) {
        return !!o(e3) && (!!Object.prototype.hasOwnProperty.call(e3, "_writableStreamController") && e3 instanceof WritableStream);
      }
      function rt2(e3) {
        return e3._writer !== void 0;
      }
      function ot2(e3, t2) {
        var r2;
        if (e3._state === "closed" || e3._state === "errored")
          return c(void 0);
        e3._writableStreamController._abortReason = t2, (r2 = e3._writableStreamController._abortController) === null || r2 === void 0 || r2.abort();
        const o2 = e3._state;
        if (o2 === "closed" || o2 === "errored")
          return c(void 0);
        if (e3._pendingAbortRequest !== void 0)
          return e3._pendingAbortRequest._promise;
        let n2 = false;
        o2 === "erroring" && (n2 = true, t2 = void 0);
        const a2 = u((r3, o3) => {
          e3._pendingAbortRequest = { _promise: void 0, _resolve: r3, _reject: o3, _reason: t2, _wasAlreadyErroring: n2 };
        });
        return e3._pendingAbortRequest._promise = a2, n2 || it2(e3, t2), a2;
      }
      function nt2(e3) {
        const t2 = e3._state;
        if (t2 === "closed" || t2 === "errored")
          return d2(new TypeError(`The stream (in ${t2} state) is not in the writable state and cannot be closed`));
        const r2 = u((t3, r3) => {
          const o3 = { _resolve: t3, _reject: r3 };
          e3._closeRequest = o3;
        }), o2 = e3._writer;
        var n2;
        return o2 !== void 0 && e3._backpressure && t2 === "writable" && Lt2(o2), ue2(n2 = e3._writableStreamController, pt, 0), wt2(n2), r2;
      }
      function at(e3, t2) {
        e3._state !== "writable" ? lt(e3) : it2(e3, t2);
      }
      function it2(e3, t2) {
        const r2 = e3._writableStreamController;
        e3._state = "erroring", e3._storedError = t2;
        const o2 = e3._writer;
        o2 !== void 0 && _t(o2, t2), !function(e4) {
          if (e4._inFlightWriteRequest === void 0 && e4._inFlightCloseRequest === void 0)
            return false;
          return true;
        }(e3) && r2._started && lt(e3);
      }
      function lt(e3) {
        e3._state = "errored", e3._writableStreamController[B]();
        const t2 = e3._storedError;
        if (e3._writeRequests.forEach((e4) => {
          e4._reject(t2);
        }), e3._writeRequests = new v(), e3._pendingAbortRequest === void 0)
          return void ut(e3);
        const r2 = e3._pendingAbortRequest;
        if (e3._pendingAbortRequest = void 0, r2._wasAlreadyErroring)
          return r2._reject(t2), void ut(e3);
        b(e3._writableStreamController[O](r2._reason), () => {
          r2._resolve(), ut(e3);
        }, (t3) => {
          r2._reject(t3), ut(e3);
        });
      }
      function st(e3) {
        return e3._closeRequest !== void 0 || e3._inFlightCloseRequest !== void 0;
      }
      function ut(e3) {
        e3._closeRequest !== void 0 && (e3._closeRequest._reject(e3._storedError), e3._closeRequest = void 0);
        const t2 = e3._writer;
        t2 !== void 0 && kt(t2, e3._storedError);
      }
      function ct2(e3, t2) {
        const r2 = e3._writer;
        r2 !== void 0 && t2 !== e3._backpressure && (t2 ? function(e4) {
          At(e4);
        }(r2) : Lt2(r2)), e3._backpressure = t2;
      }
      Object.defineProperties(WritableStream.prototype, { abort: { enumerable: true }, close: { enumerable: true }, getWriter: { enumerable: true }, locked: { enumerable: true } }), typeof t.toStringTag == "symbol" && Object.defineProperty(WritableStream.prototype, t.toStringTag, { value: "WritableStream", configurable: true });
      class WritableStreamDefaultWriter {
        constructor(e3) {
          if (D2(e3, 1, "WritableStreamDefaultWriter"), Je2(e3, "First parameter"), rt2(e3))
            throw new TypeError("This stream has already been locked for exclusive writing by another writer");
          this._ownerWritableStream = e3, e3._writer = this;
          const t2 = e3._state;
          if (t2 === "writable")
            !st(e3) && e3._backpressure ? At(this) : Ft2(this), Ot(this);
          else if (t2 === "erroring")
            zt2(this, e3._storedError), Ot(this);
          else if (t2 === "closed")
            Ft2(this), Ot(r2 = this), jt(r2);
          else {
            const t3 = e3._storedError;
            zt2(this, t3), Bt2(this, t3);
          }
          var r2;
        }
        get closed() {
          return dt(this) ? this._closedPromise : d2(Et("closed"));
        }
        get desiredSize() {
          if (!dt(this))
            throw Et("desiredSize");
          if (this._ownerWritableStream === void 0)
            throw Wt2("desiredSize");
          return function(e3) {
            const t2 = e3._ownerWritableStream, r2 = t2._state;
            if (r2 === "errored" || r2 === "erroring")
              return null;
            if (r2 === "closed")
              return 0;
            return vt2(t2._writableStreamController);
          }(this);
        }
        get ready() {
          return dt(this) ? this._readyPromise : d2(Et("ready"));
        }
        abort(e3) {
          return dt(this) ? this._ownerWritableStream === void 0 ? d2(Wt2("abort")) : function(e4, t2) {
            return ot2(e4._ownerWritableStream, t2);
          }(this, e3) : d2(Et("abort"));
        }
        close() {
          if (!dt(this))
            return d2(Et("close"));
          const e3 = this._ownerWritableStream;
          return e3 === void 0 ? d2(Wt2("close")) : st(e3) ? d2(new TypeError("Cannot close an already-closing stream")) : ft2(this);
        }
        releaseLock() {
          if (!dt(this))
            throw Et("releaseLock");
          this._ownerWritableStream !== void 0 && ht(this);
        }
        write(e3) {
          return dt(this) ? this._ownerWritableStream === void 0 ? d2(Wt2("write to")) : mt2(this, e3) : d2(Et("write"));
        }
      }
      function dt(e3) {
        return !!o(e3) && (!!Object.prototype.hasOwnProperty.call(e3, "_ownerWritableStream") && e3 instanceof WritableStreamDefaultWriter);
      }
      function ft2(e3) {
        return nt2(e3._ownerWritableStream);
      }
      function bt2(e3, t2) {
        e3._closedPromiseState === "pending" ? kt(e3, t2) : function(e4, t3) {
          Bt2(e4, t3);
        }(e3, t2);
      }
      function _t(e3, t2) {
        e3._readyPromiseState === "pending" ? It2(e3, t2) : function(e4, t3) {
          zt2(e4, t3);
        }(e3, t2);
      }
      function ht(e3) {
        const t2 = e3._ownerWritableStream, r2 = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
        _t(e3, r2), bt2(e3, r2), t2._writer = void 0, e3._ownerWritableStream = void 0;
      }
      function mt2(e3, t2) {
        const r2 = e3._ownerWritableStream, o2 = r2._writableStreamController, n2 = function(e4, t3) {
          try {
            return e4._strategySizeAlgorithm(t3);
          } catch (t4) {
            return Rt2(e4, t4), 1;
          }
        }(o2, t2);
        if (r2 !== e3._ownerWritableStream)
          return d2(Wt2("write to"));
        const a2 = r2._state;
        if (a2 === "errored")
          return d2(r2._storedError);
        if (st(r2) || a2 === "closed")
          return d2(new TypeError("The stream is closing or closed and cannot be written to"));
        if (a2 === "erroring")
          return d2(r2._storedError);
        const i2 = function(e4) {
          return u((t3, r3) => {
            const o3 = { _resolve: t3, _reject: r3 };
            e4._writeRequests.push(o3);
          });
        }(r2);
        return function(e4, t3, r3) {
          try {
            ue2(e4, t3, r3);
          } catch (t4) {
            return void Rt2(e4, t4);
          }
          const o3 = e4._controlledWritableStream;
          if (!st(o3) && o3._state === "writable") {
            ct2(o3, Tt2(e4));
          }
          wt2(e4);
        }(o2, t2, n2), i2;
      }
      Object.defineProperties(WritableStreamDefaultWriter.prototype, { abort: { enumerable: true }, close: { enumerable: true }, releaseLock: { enumerable: true }, write: { enumerable: true }, closed: { enumerable: true }, desiredSize: { enumerable: true }, ready: { enumerable: true } }), typeof t.toStringTag == "symbol" && Object.defineProperty(WritableStreamDefaultWriter.prototype, t.toStringTag, { value: "WritableStreamDefaultWriter", configurable: true });
      const pt = {};
      class WritableStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        get abortReason() {
          if (!yt(this))
            throw Pt("abortReason");
          return this._abortReason;
        }
        get signal() {
          if (!yt(this))
            throw Pt("signal");
          if (this._abortController === void 0)
            throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
          return this._abortController.signal;
        }
        error(e3) {
          if (!yt(this))
            throw Pt("error");
          this._controlledWritableStream._state === "writable" && Ct2(this, e3);
        }
        [O](e3) {
          const t2 = this._abortAlgorithm(e3);
          return St2(this), t2;
        }
        [B]() {
          ce(this);
        }
      }
      function yt(e3) {
        return !!o(e3) && (!!Object.prototype.hasOwnProperty.call(e3, "_controlledWritableStream") && e3 instanceof WritableStreamDefaultController);
      }
      function gt(e3, t2, r2, o2, n2, a2, i2, l2) {
        t2._controlledWritableStream = e3, e3._writableStreamController = t2, t2._queue = void 0, t2._queueTotalSize = void 0, ce(t2), t2._abortReason = void 0, t2._abortController = function() {
          if (Ke2)
            return new AbortController();
        }(), t2._started = false, t2._strategySizeAlgorithm = l2, t2._strategyHWM = i2, t2._writeAlgorithm = o2, t2._closeAlgorithm = n2, t2._abortAlgorithm = a2;
        const s2 = Tt2(t2);
        ct2(e3, s2);
        b(c(r2()), () => {
          t2._started = true, wt2(t2);
        }, (r3) => {
          t2._started = true, at(e3, r3);
        });
      }
      function St2(e3) {
        e3._writeAlgorithm = void 0, e3._closeAlgorithm = void 0, e3._abortAlgorithm = void 0, e3._strategySizeAlgorithm = void 0;
      }
      function vt2(e3) {
        return e3._strategyHWM - e3._queueTotalSize;
      }
      function wt2(e3) {
        const t2 = e3._controlledWritableStream;
        if (!e3._started)
          return;
        if (t2._inFlightWriteRequest !== void 0)
          return;
        if (t2._state === "erroring")
          return void lt(t2);
        if (e3._queue.length === 0)
          return;
        const r2 = e3._queue.peek().value;
        r2 === pt ? function(e4) {
          const t3 = e4._controlledWritableStream;
          (function(e5) {
            e5._inFlightCloseRequest = e5._closeRequest, e5._closeRequest = void 0;
          })(t3), se(e4);
          const r3 = e4._closeAlgorithm();
          St2(e4), b(r3, () => {
            !function(e5) {
              e5._inFlightCloseRequest._resolve(void 0), e5._inFlightCloseRequest = void 0, e5._state === "erroring" && (e5._storedError = void 0, e5._pendingAbortRequest !== void 0 && (e5._pendingAbortRequest._resolve(), e5._pendingAbortRequest = void 0)), e5._state = "closed";
              const t4 = e5._writer;
              t4 !== void 0 && jt(t4);
            }(t3);
          }, (e5) => {
            !function(e6, t4) {
              e6._inFlightCloseRequest._reject(t4), e6._inFlightCloseRequest = void 0, e6._pendingAbortRequest !== void 0 && (e6._pendingAbortRequest._reject(t4), e6._pendingAbortRequest = void 0), at(e6, t4);
            }(t3, e5);
          });
        }(e3) : function(e4, t3) {
          const r3 = e4._controlledWritableStream;
          !function(e5) {
            e5._inFlightWriteRequest = e5._writeRequests.shift();
          }(r3);
          b(e4._writeAlgorithm(t3), () => {
            !function(e5) {
              e5._inFlightWriteRequest._resolve(void 0), e5._inFlightWriteRequest = void 0;
            }(r3);
            const t4 = r3._state;
            if (se(e4), !st(r3) && t4 === "writable") {
              const t5 = Tt2(e4);
              ct2(r3, t5);
            }
            wt2(e4);
          }, (t4) => {
            r3._state === "writable" && St2(e4), function(e5, t5) {
              e5._inFlightWriteRequest._reject(t5), e5._inFlightWriteRequest = void 0, at(e5, t5);
            }(r3, t4);
          });
        }(e3, r2);
      }
      function Rt2(e3, t2) {
        e3._controlledWritableStream._state === "writable" && Ct2(e3, t2);
      }
      function Tt2(e3) {
        return vt2(e3) <= 0;
      }
      function Ct2(e3, t2) {
        const r2 = e3._controlledWritableStream;
        St2(e3), it2(r2, t2);
      }
      function qt2(e3) {
        return new TypeError(`WritableStream.prototype.${e3} can only be used on a WritableStream`);
      }
      function Pt(e3) {
        return new TypeError(`WritableStreamDefaultController.prototype.${e3} can only be used on a WritableStreamDefaultController`);
      }
      function Et(e3) {
        return new TypeError(`WritableStreamDefaultWriter.prototype.${e3} can only be used on a WritableStreamDefaultWriter`);
      }
      function Wt2(e3) {
        return new TypeError("Cannot " + e3 + " a stream using a released writer");
      }
      function Ot(e3) {
        e3._closedPromise = u((t2, r2) => {
          e3._closedPromise_resolve = t2, e3._closedPromise_reject = r2, e3._closedPromiseState = "pending";
        });
      }
      function Bt2(e3, t2) {
        Ot(e3), kt(e3, t2);
      }
      function kt(e3, t2) {
        e3._closedPromise_reject !== void 0 && (p(e3._closedPromise), e3._closedPromise_reject(t2), e3._closedPromise_resolve = void 0, e3._closedPromise_reject = void 0, e3._closedPromiseState = "rejected");
      }
      function jt(e3) {
        e3._closedPromise_resolve !== void 0 && (e3._closedPromise_resolve(void 0), e3._closedPromise_resolve = void 0, e3._closedPromise_reject = void 0, e3._closedPromiseState = "resolved");
      }
      function At(e3) {
        e3._readyPromise = u((t2, r2) => {
          e3._readyPromise_resolve = t2, e3._readyPromise_reject = r2;
        }), e3._readyPromiseState = "pending";
      }
      function zt2(e3, t2) {
        At(e3), It2(e3, t2);
      }
      function Ft2(e3) {
        At(e3), Lt2(e3);
      }
      function It2(e3, t2) {
        e3._readyPromise_reject !== void 0 && (p(e3._readyPromise), e3._readyPromise_reject(t2), e3._readyPromise_resolve = void 0, e3._readyPromise_reject = void 0, e3._readyPromiseState = "rejected");
      }
      function Lt2(e3) {
        e3._readyPromise_resolve !== void 0 && (e3._readyPromise_resolve(void 0), e3._readyPromise_resolve = void 0, e3._readyPromise_reject = void 0, e3._readyPromiseState = "fulfilled");
      }
      Object.defineProperties(WritableStreamDefaultController.prototype, { error: { enumerable: true } }), typeof t.toStringTag == "symbol" && Object.defineProperty(WritableStreamDefaultController.prototype, t.toStringTag, { value: "WritableStreamDefaultController", configurable: true });
      const Dt = typeof DOMException != "undefined" ? DOMException : void 0;
      const $t2 = function(e3) {
        if (typeof e3 != "function" && typeof e3 != "object")
          return false;
        try {
          return new e3(), true;
        } catch (e4) {
          return false;
        }
      }(Dt) ? Dt : function() {
        const e3 = function(e4, t2) {
          this.message = e4 || "", this.name = t2 || "Error", Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
        };
        return e3.prototype = Object.create(Error.prototype), Object.defineProperty(e3.prototype, "constructor", { value: e3, writable: true, configurable: true }), e3;
      }();
      function Mt2(e3, t2, o2, n2, a2, i2) {
        const l2 = N2(e3), s2 = Ze2(t2);
        e3._disturbed = true;
        let m2 = false, y3 = c(void 0);
        return u((g2, S2) => {
          let v2;
          if (i2 !== void 0) {
            if (v2 = () => {
              const r2 = new $t2("Aborted", "AbortError"), o3 = [];
              n2 || o3.push(() => t2._state === "writable" ? ot2(t2, r2) : c(void 0)), a2 || o3.push(() => e3._state === "readable" ? dr2(e3, r2) : c(void 0)), E2(() => Promise.all(o3.map((e4) => e4())), true, r2);
            }, i2.aborted)
              return void v2();
            i2.addEventListener("abort", v2);
          }
          var w2, R2, C2;
          if (P2(e3, l2._closedPromise, (e4) => {
            n2 ? W2(true, e4) : E2(() => ot2(t2, e4), true, e4);
          }), P2(t2, s2._closedPromise, (t3) => {
            a2 ? W2(true, t3) : E2(() => dr2(e3, t3), true, t3);
          }), w2 = e3, R2 = l2._closedPromise, C2 = () => {
            o2 ? W2() : E2(() => function(e4) {
              const t3 = e4._ownerWritableStream, r2 = t3._state;
              return st(t3) || r2 === "closed" ? c(void 0) : r2 === "errored" ? d2(t3._storedError) : ft2(e4);
            }(s2));
          }, w2._state === "closed" ? C2() : _(R2, C2), st(t2) || t2._state === "closed") {
            const t3 = new TypeError("the destination writable stream closed before all data could be piped to it");
            a2 ? W2(true, t3) : E2(() => dr2(e3, t3), true, t3);
          }
          function q2() {
            const e4 = y3;
            return f(y3, () => e4 !== y3 ? q2() : void 0);
          }
          function P2(e4, t3, r2) {
            e4._state === "errored" ? r2(e4._storedError) : h(t3, r2);
          }
          function E2(e4, r2, o3) {
            function n3() {
              b(e4(), () => O2(r2, o3), (e5) => O2(true, e5));
            }
            m2 || (m2 = true, t2._state !== "writable" || st(t2) ? n3() : _(q2(), n3));
          }
          function W2(e4, r2) {
            m2 || (m2 = true, t2._state !== "writable" || st(t2) ? O2(e4, r2) : _(q2(), () => O2(e4, r2)));
          }
          function O2(e4, t3) {
            ht(s2), T(l2), i2 !== void 0 && i2.removeEventListener("abort", v2), e4 ? S2(t3) : g2(void 0);
          }
          p(u((e4, t3) => {
            !function o3(n3) {
              n3 ? e4() : f(m2 ? c(true) : f(s2._readyPromise, () => u((e5, t4) => {
                J(l2, { _chunkSteps: (t5) => {
                  y3 = f(mt2(s2, t5), void 0, r), e5(false);
                }, _closeSteps: () => e5(true), _errorSteps: t4 });
              })), o3, t3);
            }(false);
          }));
        });
      }
      class ReadableStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        get desiredSize() {
          if (!Qt2(this))
            throw Kt2("desiredSize");
          return Gt(this);
        }
        close() {
          if (!Qt2(this))
            throw Kt2("close");
          if (!Xt2(this))
            throw new TypeError("The stream is not in a state that permits close");
          Ht2(this);
        }
        enqueue(e3) {
          if (!Qt2(this))
            throw Kt2("enqueue");
          if (!Xt2(this))
            throw new TypeError("The stream is not in a state that permits enqueue");
          return Vt(this, e3);
        }
        error(e3) {
          if (!Qt2(this))
            throw Kt2("error");
          Ut2(this, e3);
        }
        [k2](e3) {
          ce(this);
          const t2 = this._cancelAlgorithm(e3);
          return Nt(this), t2;
        }
        [j2](e3) {
          const t2 = this._controlledReadableStream;
          if (this._queue.length > 0) {
            const r2 = se(this);
            this._closeRequested && this._queue.length === 0 ? (Nt(this), fr2(t2)) : Yt2(this), e3._chunkSteps(r2);
          } else
            H(t2, e3), Yt2(this);
        }
      }
      function Qt2(e3) {
        return !!o(e3) && (!!Object.prototype.hasOwnProperty.call(e3, "_controlledReadableStream") && e3 instanceof ReadableStreamDefaultController);
      }
      function Yt2(e3) {
        if (!xt2(e3))
          return;
        if (e3._pulling)
          return void (e3._pullAgain = true);
        e3._pulling = true;
        b(e3._pullAlgorithm(), () => {
          e3._pulling = false, e3._pullAgain && (e3._pullAgain = false, Yt2(e3));
        }, (t2) => {
          Ut2(e3, t2);
        });
      }
      function xt2(e3) {
        const t2 = e3._controlledReadableStream;
        if (!Xt2(e3))
          return false;
        if (!e3._started)
          return false;
        if (cr2(t2) && U(t2) > 0)
          return true;
        return Gt(e3) > 0;
      }
      function Nt(e3) {
        e3._pullAlgorithm = void 0, e3._cancelAlgorithm = void 0, e3._strategySizeAlgorithm = void 0;
      }
      function Ht2(e3) {
        if (!Xt2(e3))
          return;
        const t2 = e3._controlledReadableStream;
        e3._closeRequested = true, e3._queue.length === 0 && (Nt(e3), fr2(t2));
      }
      function Vt(e3, t2) {
        if (!Xt2(e3))
          return;
        const r2 = e3._controlledReadableStream;
        if (cr2(r2) && U(r2) > 0)
          V(r2, t2, false);
        else {
          let r3;
          try {
            r3 = e3._strategySizeAlgorithm(t2);
          } catch (t3) {
            throw Ut2(e3, t3), t3;
          }
          try {
            ue2(e3, t2, r3);
          } catch (t3) {
            throw Ut2(e3, t3), t3;
          }
        }
        Yt2(e3);
      }
      function Ut2(e3, t2) {
        const r2 = e3._controlledReadableStream;
        r2._state === "readable" && (ce(e3), Nt(e3), br2(r2, t2));
      }
      function Gt(e3) {
        const t2 = e3._controlledReadableStream._state;
        return t2 === "errored" ? null : t2 === "closed" ? 0 : e3._strategyHWM - e3._queueTotalSize;
      }
      function Xt2(e3) {
        const t2 = e3._controlledReadableStream._state;
        return !e3._closeRequested && t2 === "readable";
      }
      function Jt(e3, t2, r2, o2, n2, a2, i2) {
        t2._controlledReadableStream = e3, t2._queue = void 0, t2._queueTotalSize = void 0, ce(t2), t2._started = false, t2._closeRequested = false, t2._pullAgain = false, t2._pulling = false, t2._strategySizeAlgorithm = i2, t2._strategyHWM = a2, t2._pullAlgorithm = o2, t2._cancelAlgorithm = n2, e3._readableStreamController = t2;
        b(c(r2()), () => {
          t2._started = true, Yt2(t2);
        }, (e4) => {
          Ut2(t2, e4);
        });
      }
      function Kt2(e3) {
        return new TypeError(`ReadableStreamDefaultController.prototype.${e3} can only be used on a ReadableStreamDefaultController`);
      }
      function Zt2(e3, t2) {
        return de(e3._readableStreamController) ? function(e4) {
          let t3, r2, o2, n2, a2, i2 = N2(e4), l2 = false, s2 = false, d3 = false;
          const f2 = u((e5) => {
            a2 = e5;
          });
          function b2(e5) {
            h(e5._closedPromise, (t4) => {
              e5 === i2 && (Ee2(o2._readableStreamController, t4), Ee2(n2._readableStreamController, t4), s2 && d3 || a2(void 0));
            });
          }
          function _2() {
            $e(i2) && (T(i2), i2 = N2(e4), b2(i2));
            J(i2, { _chunkSteps: (t4) => {
              y2(() => {
                l2 = false;
                const r3 = t4;
                let i3 = t4;
                if (!s2 && !d3)
                  try {
                    i3 = le(t4);
                  } catch (t5) {
                    return Ee2(o2._readableStreamController, t5), Ee2(n2._readableStreamController, t5), void a2(dr2(e4, t5));
                  }
                s2 || Pe2(o2._readableStreamController, r3), d3 || Pe2(n2._readableStreamController, i3);
              });
            }, _closeSteps: () => {
              l2 = false, s2 || qe2(o2._readableStreamController), d3 || qe2(n2._readableStreamController), o2._readableStreamController._pendingPullIntos.length > 0 && Be(o2._readableStreamController, 0), n2._readableStreamController._pendingPullIntos.length > 0 && Be(n2._readableStreamController, 0), s2 && d3 || a2(void 0);
            }, _errorSteps: () => {
              l2 = false;
            } });
          }
          function m2(t4, r3) {
            X(i2) && (T(i2), i2 = Fe2(e4), b2(i2));
            const u2 = r3 ? n2 : o2, c2 = r3 ? o2 : n2;
            Me2(i2, t4, { _chunkSteps: (t5) => {
              y2(() => {
                l2 = false;
                const o3 = r3 ? d3 : s2;
                if (r3 ? s2 : d3)
                  o3 || ke(u2._readableStreamController, t5);
                else {
                  let r4;
                  try {
                    r4 = le(t5);
                  } catch (t6) {
                    return Ee2(u2._readableStreamController, t6), Ee2(c2._readableStreamController, t6), void a2(dr2(e4, t6));
                  }
                  o3 || ke(u2._readableStreamController, t5), Pe2(c2._readableStreamController, r4);
                }
              });
            }, _closeSteps: (e5) => {
              l2 = false;
              const t5 = r3 ? d3 : s2, o3 = r3 ? s2 : d3;
              t5 || qe2(u2._readableStreamController), o3 || qe2(c2._readableStreamController), e5 !== void 0 && (t5 || ke(u2._readableStreamController, e5), !o3 && c2._readableStreamController._pendingPullIntos.length > 0 && Be(c2._readableStreamController, 0)), t5 && o3 || a2(void 0);
            }, _errorSteps: () => {
              l2 = false;
            } });
          }
          function p2() {
            if (l2)
              return c(void 0);
            l2 = true;
            const e5 = We(o2._readableStreamController);
            return e5 === null ? _2() : m2(e5._view, false), c(void 0);
          }
          function g2() {
            if (l2)
              return c(void 0);
            l2 = true;
            const e5 = We(n2._readableStreamController);
            return e5 === null ? _2() : m2(e5._view, true), c(void 0);
          }
          function S2(o3) {
            if (s2 = true, t3 = o3, d3) {
              const o4 = ne([t3, r2]), n3 = dr2(e4, o4);
              a2(n3);
            }
            return f2;
          }
          function v2(o3) {
            if (d3 = true, r2 = o3, s2) {
              const o4 = ne([t3, r2]), n3 = dr2(e4, o4);
              a2(n3);
            }
            return f2;
          }
          function w2() {
          }
          return o2 = lr(w2, p2, S2), n2 = lr(w2, g2, v2), b2(i2), [o2, n2];
        }(e3) : function(e4, t3) {
          const r2 = N2(e4);
          let o2, n2, a2, i2, l2, s2 = false, d3 = false, f2 = false;
          const b2 = u((e5) => {
            l2 = e5;
          });
          function _2() {
            if (s2)
              return c(void 0);
            s2 = true;
            return J(r2, { _chunkSteps: (e5) => {
              y2(() => {
                s2 = false;
                const t4 = e5, r3 = e5;
                d3 || Vt(a2._readableStreamController, t4), f2 || Vt(i2._readableStreamController, r3);
              });
            }, _closeSteps: () => {
              s2 = false, d3 || Ht2(a2._readableStreamController), f2 || Ht2(i2._readableStreamController), d3 && f2 || l2(void 0);
            }, _errorSteps: () => {
              s2 = false;
            } }), c(void 0);
          }
          function m2(t4) {
            if (d3 = true, o2 = t4, f2) {
              const t5 = ne([o2, n2]), r3 = dr2(e4, t5);
              l2(r3);
            }
            return b2;
          }
          function p2(t4) {
            if (f2 = true, n2 = t4, d3) {
              const t5 = ne([o2, n2]), r3 = dr2(e4, t5);
              l2(r3);
            }
            return b2;
          }
          function g2() {
          }
          return a2 = ir2(g2, _2, m2), i2 = ir2(g2, _2, p2), h(r2._closedPromise, (e5) => {
            Ut2(a2._readableStreamController, e5), Ut2(i2._readableStreamController, e5), d3 && f2 || l2(void 0);
          }), [a2, i2];
        }(e3);
      }
      function er2(e3, t2, r2) {
        return I2(e3, r2), (r3) => S(e3, t2, [r3]);
      }
      function tr2(e3, t2, r2) {
        return I2(e3, r2), (r3) => S(e3, t2, [r3]);
      }
      function rr2(e3, t2, r2) {
        return I2(e3, r2), (r3) => g(e3, t2, [r3]);
      }
      function or2(e3, t2) {
        if ((e3 = `${e3}`) !== "bytes")
          throw new TypeError(`${t2} '${e3}' is not a valid enumeration value for ReadableStreamType`);
        return e3;
      }
      function nr2(e3, t2) {
        if ((e3 = `${e3}`) !== "byob")
          throw new TypeError(`${t2} '${e3}' is not a valid enumeration value for ReadableStreamReaderMode`);
        return e3;
      }
      function ar(e3, t2) {
        F(e3, t2);
        const r2 = e3 == null ? void 0 : e3.preventAbort, o2 = e3 == null ? void 0 : e3.preventCancel, n2 = e3 == null ? void 0 : e3.preventClose, a2 = e3 == null ? void 0 : e3.signal;
        return a2 !== void 0 && function(e4, t3) {
          if (!function(e5) {
            if (typeof e5 != "object" || e5 === null)
              return false;
            try {
              return typeof e5.aborted == "boolean";
            } catch (e6) {
              return false;
            }
          }(e4))
            throw new TypeError(`${t3} is not an AbortSignal.`);
        }(a2, `${t2} has member 'signal' that`), { preventAbort: Boolean(r2), preventCancel: Boolean(o2), preventClose: Boolean(n2), signal: a2 };
      }
      Object.defineProperties(ReadableStreamDefaultController.prototype, { close: { enumerable: true }, enqueue: { enumerable: true }, error: { enumerable: true }, desiredSize: { enumerable: true } }), typeof t.toStringTag == "symbol" && Object.defineProperty(ReadableStreamDefaultController.prototype, t.toStringTag, { value: "ReadableStreamDefaultController", configurable: true });
      class ReadableStream2 {
        constructor(e3 = {}, t2 = {}) {
          e3 === void 0 ? e3 = null : L(e3, "First parameter");
          const r2 = Ne(t2, "Second parameter"), o2 = function(e4, t3) {
            F(e4, t3);
            const r3 = e4, o3 = r3 == null ? void 0 : r3.autoAllocateChunkSize, n2 = r3 == null ? void 0 : r3.cancel, a2 = r3 == null ? void 0 : r3.pull, i2 = r3 == null ? void 0 : r3.start, l2 = r3 == null ? void 0 : r3.type;
            return { autoAllocateChunkSize: o3 === void 0 ? void 0 : Y(o3, `${t3} has member 'autoAllocateChunkSize' that`), cancel: n2 === void 0 ? void 0 : er2(n2, r3, `${t3} has member 'cancel' that`), pull: a2 === void 0 ? void 0 : tr2(a2, r3, `${t3} has member 'pull' that`), start: i2 === void 0 ? void 0 : rr2(i2, r3, `${t3} has member 'start' that`), type: l2 === void 0 ? void 0 : or2(l2, `${t3} has member 'type' that`) };
          }(e3, "First parameter");
          if (sr(this), o2.type === "bytes") {
            if (r2.size !== void 0)
              throw new RangeError("The strategy for a byte stream cannot have a size function");
            !function(e4, t3, r3) {
              const o3 = Object.create(ReadableByteStreamController.prototype);
              let n2 = () => {
              }, a2 = () => c(void 0), i2 = () => c(void 0);
              t3.start !== void 0 && (n2 = () => t3.start(o3)), t3.pull !== void 0 && (a2 = () => t3.pull(o3)), t3.cancel !== void 0 && (i2 = (e5) => t3.cancel(e5));
              const l2 = t3.autoAllocateChunkSize;
              if (l2 === 0)
                throw new TypeError("autoAllocateChunkSize must be greater than 0");
              je2(e4, o3, n2, a2, i2, r3, l2);
            }(this, o2, Ye2(r2, 0));
          } else {
            const e4 = xe(r2);
            !function(e5, t3, r3, o3) {
              const n2 = Object.create(ReadableStreamDefaultController.prototype);
              let a2 = () => {
              }, i2 = () => c(void 0), l2 = () => c(void 0);
              t3.start !== void 0 && (a2 = () => t3.start(n2)), t3.pull !== void 0 && (i2 = () => t3.pull(n2)), t3.cancel !== void 0 && (l2 = (e6) => t3.cancel(e6)), Jt(e5, n2, a2, i2, l2, r3, o3);
            }(this, o2, Ye2(r2, 1), e4);
          }
        }
        get locked() {
          if (!ur(this))
            throw _r2("locked");
          return cr2(this);
        }
        cancel(e3) {
          return ur(this) ? cr2(this) ? d2(new TypeError("Cannot cancel a stream that already has a reader")) : dr2(this, e3) : d2(_r2("cancel"));
        }
        getReader(e3) {
          if (!ur(this))
            throw _r2("getReader");
          return function(e4, t2) {
            F(e4, t2);
            const r2 = e4 == null ? void 0 : e4.mode;
            return { mode: r2 === void 0 ? void 0 : nr2(r2, `${t2} has member 'mode' that`) };
          }(e3, "First parameter").mode === void 0 ? N2(this) : Fe2(this);
        }
        pipeThrough(e3, t2 = {}) {
          if (!ur(this))
            throw _r2("pipeThrough");
          D2(e3, 1, "pipeThrough");
          const r2 = function(e4, t3) {
            F(e4, t3);
            const r3 = e4 == null ? void 0 : e4.readable;
            $(r3, "readable", "ReadableWritablePair"), x(r3, `${t3} has member 'readable' that`);
            const o3 = e4 == null ? void 0 : e4.writable;
            return $(o3, "writable", "ReadableWritablePair"), Je2(o3, `${t3} has member 'writable' that`), { readable: r3, writable: o3 };
          }(e3, "First parameter"), o2 = ar(t2, "Second parameter");
          if (cr2(this))
            throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
          if (rt2(r2.writable))
            throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
          return p(Mt2(this, r2.writable, o2.preventClose, o2.preventAbort, o2.preventCancel, o2.signal)), r2.readable;
        }
        pipeTo(e3, t2 = {}) {
          if (!ur(this))
            return d2(_r2("pipeTo"));
          if (e3 === void 0)
            return d2("Parameter 1 is required in 'pipeTo'.");
          if (!tt(e3))
            return d2(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
          let r2;
          try {
            r2 = ar(t2, "Second parameter");
          } catch (e4) {
            return d2(e4);
          }
          return cr2(this) ? d2(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")) : rt2(e3) ? d2(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")) : Mt2(this, e3, r2.preventClose, r2.preventAbort, r2.preventCancel, r2.signal);
        }
        tee() {
          if (!ur(this))
            throw _r2("tee");
          return ne(Zt2(this));
        }
        values(e3) {
          if (!ur(this))
            throw _r2("values");
          return function(e4, t2) {
            const r2 = N2(e4), o2 = new Z(r2, t2), n2 = Object.create(ee);
            return n2._asyncIteratorImpl = o2, n2;
          }(this, function(e4, t2) {
            F(e4, t2);
            const r2 = e4 == null ? void 0 : e4.preventCancel;
            return { preventCancel: Boolean(r2) };
          }(e3, "First parameter").preventCancel);
        }
      }
      function ir2(e3, t2, r2, o2 = 1, n2 = () => 1) {
        const a2 = Object.create(ReadableStream2.prototype);
        sr(a2);
        return Jt(a2, Object.create(ReadableStreamDefaultController.prototype), e3, t2, r2, o2, n2), a2;
      }
      function lr(e3, t2, r2) {
        const o2 = Object.create(ReadableStream2.prototype);
        sr(o2);
        return je2(o2, Object.create(ReadableByteStreamController.prototype), e3, t2, r2, 0, void 0), o2;
      }
      function sr(e3) {
        e3._state = "readable", e3._reader = void 0, e3._storedError = void 0, e3._disturbed = false;
      }
      function ur(e3) {
        return !!o(e3) && (!!Object.prototype.hasOwnProperty.call(e3, "_readableStreamController") && e3 instanceof ReadableStream2);
      }
      function cr2(e3) {
        return e3._reader !== void 0;
      }
      function dr2(e3, t2) {
        if (e3._disturbed = true, e3._state === "closed")
          return c(void 0);
        if (e3._state === "errored")
          return d2(e3._storedError);
        fr2(e3);
        const o2 = e3._reader;
        o2 !== void 0 && $e(o2) && (o2._readIntoRequests.forEach((e4) => {
          e4._closeSteps(void 0);
        }), o2._readIntoRequests = new v());
        return m(e3._readableStreamController[k2](t2), r);
      }
      function fr2(e3) {
        e3._state = "closed";
        const t2 = e3._reader;
        t2 !== void 0 && (W(t2), X(t2) && (t2._readRequests.forEach((e4) => {
          e4._closeSteps();
        }), t2._readRequests = new v()));
      }
      function br2(e3, t2) {
        e3._state = "errored", e3._storedError = t2;
        const r2 = e3._reader;
        r2 !== void 0 && (E(r2, t2), X(r2) ? (r2._readRequests.forEach((e4) => {
          e4._errorSteps(t2);
        }), r2._readRequests = new v()) : (r2._readIntoRequests.forEach((e4) => {
          e4._errorSteps(t2);
        }), r2._readIntoRequests = new v()));
      }
      function _r2(e3) {
        return new TypeError(`ReadableStream.prototype.${e3} can only be used on a ReadableStream`);
      }
      function hr2(e3, t2) {
        F(e3, t2);
        const r2 = e3 == null ? void 0 : e3.highWaterMark;
        return $(r2, "highWaterMark", "QueuingStrategyInit"), { highWaterMark: M(r2) };
      }
      Object.defineProperties(ReadableStream2.prototype, { cancel: { enumerable: true }, getReader: { enumerable: true }, pipeThrough: { enumerable: true }, pipeTo: { enumerable: true }, tee: { enumerable: true }, values: { enumerable: true }, locked: { enumerable: true } }), typeof t.toStringTag == "symbol" && Object.defineProperty(ReadableStream2.prototype, t.toStringTag, { value: "ReadableStream", configurable: true }), typeof t.asyncIterator == "symbol" && Object.defineProperty(ReadableStream2.prototype, t.asyncIterator, { value: ReadableStream2.prototype.values, writable: true, configurable: true });
      const mr2 = (e3) => e3.byteLength;
      Object.defineProperty(mr2, "name", { value: "size", configurable: true });
      class ByteLengthQueuingStrategy {
        constructor(e3) {
          D2(e3, 1, "ByteLengthQueuingStrategy"), e3 = hr2(e3, "First parameter"), this._byteLengthQueuingStrategyHighWaterMark = e3.highWaterMark;
        }
        get highWaterMark() {
          if (!yr2(this))
            throw pr2("highWaterMark");
          return this._byteLengthQueuingStrategyHighWaterMark;
        }
        get size() {
          if (!yr2(this))
            throw pr2("size");
          return mr2;
        }
      }
      function pr2(e3) {
        return new TypeError(`ByteLengthQueuingStrategy.prototype.${e3} can only be used on a ByteLengthQueuingStrategy`);
      }
      function yr2(e3) {
        return !!o(e3) && (!!Object.prototype.hasOwnProperty.call(e3, "_byteLengthQueuingStrategyHighWaterMark") && e3 instanceof ByteLengthQueuingStrategy);
      }
      Object.defineProperties(ByteLengthQueuingStrategy.prototype, { highWaterMark: { enumerable: true }, size: { enumerable: true } }), typeof t.toStringTag == "symbol" && Object.defineProperty(ByteLengthQueuingStrategy.prototype, t.toStringTag, { value: "ByteLengthQueuingStrategy", configurable: true });
      const gr2 = () => 1;
      Object.defineProperty(gr2, "name", { value: "size", configurable: true });
      class CountQueuingStrategy {
        constructor(e3) {
          D2(e3, 1, "CountQueuingStrategy"), e3 = hr2(e3, "First parameter"), this._countQueuingStrategyHighWaterMark = e3.highWaterMark;
        }
        get highWaterMark() {
          if (!vr2(this))
            throw Sr2("highWaterMark");
          return this._countQueuingStrategyHighWaterMark;
        }
        get size() {
          if (!vr2(this))
            throw Sr2("size");
          return gr2;
        }
      }
      function Sr2(e3) {
        return new TypeError(`CountQueuingStrategy.prototype.${e3} can only be used on a CountQueuingStrategy`);
      }
      function vr2(e3) {
        return !!o(e3) && (!!Object.prototype.hasOwnProperty.call(e3, "_countQueuingStrategyHighWaterMark") && e3 instanceof CountQueuingStrategy);
      }
      function wr2(e3, t2, r2) {
        return I2(e3, r2), (r3) => S(e3, t2, [r3]);
      }
      function Rr2(e3, t2, r2) {
        return I2(e3, r2), (r3) => g(e3, t2, [r3]);
      }
      function Tr2(e3, t2, r2) {
        return I2(e3, r2), (r3, o2) => S(e3, t2, [r3, o2]);
      }
      Object.defineProperties(CountQueuingStrategy.prototype, { highWaterMark: { enumerable: true }, size: { enumerable: true } }), typeof t.toStringTag == "symbol" && Object.defineProperty(CountQueuingStrategy.prototype, t.toStringTag, { value: "CountQueuingStrategy", configurable: true });
      class TransformStream {
        constructor(e3 = {}, t2 = {}, r2 = {}) {
          e3 === void 0 && (e3 = null);
          const o2 = Ne(t2, "Second parameter"), n2 = Ne(r2, "Third parameter"), a2 = function(e4, t3) {
            F(e4, t3);
            const r3 = e4 == null ? void 0 : e4.flush, o3 = e4 == null ? void 0 : e4.readableType, n3 = e4 == null ? void 0 : e4.start, a3 = e4 == null ? void 0 : e4.transform, i3 = e4 == null ? void 0 : e4.writableType;
            return { flush: r3 === void 0 ? void 0 : wr2(r3, e4, `${t3} has member 'flush' that`), readableType: o3, start: n3 === void 0 ? void 0 : Rr2(n3, e4, `${t3} has member 'start' that`), transform: a3 === void 0 ? void 0 : Tr2(a3, e4, `${t3} has member 'transform' that`), writableType: i3 };
          }(e3, "First parameter");
          if (a2.readableType !== void 0)
            throw new RangeError("Invalid readableType specified");
          if (a2.writableType !== void 0)
            throw new RangeError("Invalid writableType specified");
          const i2 = Ye2(n2, 0), l2 = xe(n2), s2 = Ye2(o2, 1), f2 = xe(o2);
          let b2;
          !function(e4, t3, r3, o3, n3, a3) {
            function i3() {
              return t3;
            }
            function l3(t4) {
              return function(e5, t5) {
                const r4 = e5._transformStreamController;
                if (e5._backpressure) {
                  return m(e5._backpressureChangePromise, () => {
                    const o4 = e5._writable;
                    if (o4._state === "erroring")
                      throw o4._storedError;
                    return kr2(r4, t5);
                  });
                }
                return kr2(r4, t5);
              }(e4, t4);
            }
            function s3(t4) {
              return function(e5, t5) {
                return qr2(e5, t5), c(void 0);
              }(e4, t4);
            }
            function u2() {
              return function(e5) {
                const t4 = e5._readable, r4 = e5._transformStreamController, o4 = r4._flushAlgorithm();
                return Or2(r4), m(o4, () => {
                  if (t4._state === "errored")
                    throw t4._storedError;
                  Ht2(t4._readableStreamController);
                }, (r5) => {
                  throw qr2(e5, r5), t4._storedError;
                });
              }(e4);
            }
            function d3() {
              return function(e5) {
                return Er2(e5, false), e5._backpressureChangePromise;
              }(e4);
            }
            function f3(t4) {
              return Pr2(e4, t4), c(void 0);
            }
            e4._writable = function(e5, t4, r4, o4, n4 = 1, a4 = () => 1) {
              const i4 = Object.create(WritableStream.prototype);
              return et(i4), gt(i4, Object.create(WritableStreamDefaultController.prototype), e5, t4, r4, o4, n4, a4), i4;
            }(i3, l3, u2, s3, r3, o3), e4._readable = ir2(i3, d3, f3, n3, a3), e4._backpressure = void 0, e4._backpressureChangePromise = void 0, e4._backpressureChangePromise_resolve = void 0, Er2(e4, true), e4._transformStreamController = void 0;
          }(this, u((e4) => {
            b2 = e4;
          }), s2, f2, i2, l2), function(e4, t3) {
            const r3 = Object.create(TransformStreamDefaultController.prototype);
            let o3 = (e5) => {
              try {
                return Br2(r3, e5), c(void 0);
              } catch (e6) {
                return d2(e6);
              }
            }, n3 = () => c(void 0);
            t3.transform !== void 0 && (o3 = (e5) => t3.transform(e5, r3));
            t3.flush !== void 0 && (n3 = () => t3.flush(r3));
            !function(e5, t4, r4, o4) {
              t4._controlledTransformStream = e5, e5._transformStreamController = t4, t4._transformAlgorithm = r4, t4._flushAlgorithm = o4;
            }(e4, r3, o3, n3);
          }(this, a2), a2.start !== void 0 ? b2(a2.start(this._transformStreamController)) : b2(void 0);
        }
        get readable() {
          if (!Cr2(this))
            throw Ar2("readable");
          return this._readable;
        }
        get writable() {
          if (!Cr2(this))
            throw Ar2("writable");
          return this._writable;
        }
      }
      function Cr2(e3) {
        return !!o(e3) && (!!Object.prototype.hasOwnProperty.call(e3, "_transformStreamController") && e3 instanceof TransformStream);
      }
      function qr2(e3, t2) {
        Ut2(e3._readable._readableStreamController, t2), Pr2(e3, t2);
      }
      function Pr2(e3, t2) {
        Or2(e3._transformStreamController), Rt2(e3._writable._writableStreamController, t2), e3._backpressure && Er2(e3, false);
      }
      function Er2(e3, t2) {
        e3._backpressureChangePromise !== void 0 && e3._backpressureChangePromise_resolve(), e3._backpressureChangePromise = u((t3) => {
          e3._backpressureChangePromise_resolve = t3;
        }), e3._backpressure = t2;
      }
      Object.defineProperties(TransformStream.prototype, { readable: { enumerable: true }, writable: { enumerable: true } }), typeof t.toStringTag == "symbol" && Object.defineProperty(TransformStream.prototype, t.toStringTag, { value: "TransformStream", configurable: true });
      class TransformStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        get desiredSize() {
          if (!Wr2(this))
            throw jr2("desiredSize");
          return Gt(this._controlledTransformStream._readable._readableStreamController);
        }
        enqueue(e3) {
          if (!Wr2(this))
            throw jr2("enqueue");
          Br2(this, e3);
        }
        error(e3) {
          if (!Wr2(this))
            throw jr2("error");
          var t2;
          t2 = e3, qr2(this._controlledTransformStream, t2);
        }
        terminate() {
          if (!Wr2(this))
            throw jr2("terminate");
          !function(e3) {
            const t2 = e3._controlledTransformStream;
            Ht2(t2._readable._readableStreamController);
            const r2 = new TypeError("TransformStream terminated");
            Pr2(t2, r2);
          }(this);
        }
      }
      function Wr2(e3) {
        return !!o(e3) && (!!Object.prototype.hasOwnProperty.call(e3, "_controlledTransformStream") && e3 instanceof TransformStreamDefaultController);
      }
      function Or2(e3) {
        e3._transformAlgorithm = void 0, e3._flushAlgorithm = void 0;
      }
      function Br2(e3, t2) {
        const r2 = e3._controlledTransformStream, o2 = r2._readable._readableStreamController;
        if (!Xt2(o2))
          throw new TypeError("Readable side is not in a state that permits enqueue");
        try {
          Vt(o2, t2);
        } catch (e4) {
          throw Pr2(r2, e4), r2._readable._storedError;
        }
        (function(e4) {
          return !xt2(e4);
        })(o2) !== r2._backpressure && Er2(r2, true);
      }
      function kr2(e3, t2) {
        return m(e3._transformAlgorithm(t2), void 0, (t3) => {
          throw qr2(e3._controlledTransformStream, t3), t3;
        });
      }
      function jr2(e3) {
        return new TypeError(`TransformStreamDefaultController.prototype.${e3} can only be used on a TransformStreamDefaultController`);
      }
      function Ar2(e3) {
        return new TypeError(`TransformStream.prototype.${e3} can only be used on a TransformStream`);
      }
      Object.defineProperties(TransformStreamDefaultController.prototype, { enqueue: { enumerable: true }, error: { enumerable: true }, terminate: { enumerable: true }, desiredSize: { enumerable: true } }), typeof t.toStringTag == "symbol" && Object.defineProperty(TransformStreamDefaultController.prototype, t.toStringTag, { value: "TransformStreamDefaultController", configurable: true }), e2.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy, e2.CountQueuingStrategy = CountQueuingStrategy, e2.ReadableByteStreamController = ReadableByteStreamController, e2.ReadableStream = ReadableStream2, e2.ReadableStreamBYOBReader = ReadableStreamBYOBReader, e2.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest, e2.ReadableStreamDefaultController = ReadableStreamDefaultController, e2.ReadableStreamDefaultReader = ReadableStreamDefaultReader, e2.TransformStream = TransformStream, e2.TransformStreamDefaultController = TransformStreamDefaultController, e2.WritableStream = WritableStream, e2.WritableStreamDefaultController = WritableStreamDefaultController, e2.WritableStreamDefaultWriter = WritableStreamDefaultWriter, Object.defineProperty(e2, "__esModule", { value: true });
    });
  }
});

// node_modules/.pnpm/formdata-node@4.3.2/node_modules/formdata-node/lib/cjs/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/.pnpm/formdata-node@4.3.2/node_modules/formdata-node/lib/cjs/isFunction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isFunction = void 0;
    var isFunction3 = (value) => typeof value === "function";
    exports2.isFunction = isFunction3;
  }
});

// node_modules/.pnpm/formdata-node@4.3.2/node_modules/formdata-node/lib/cjs/blobHelpers.js
var require_blobHelpers = __commonJS({
  "node_modules/.pnpm/formdata-node@4.3.2/node_modules/formdata-node/lib/cjs/blobHelpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sliceBlob = exports2.consumeBlobParts = void 0;
    var isFunction_1 = require_isFunction();
    var CHUNK_SIZE = 65536;
    async function* clonePart(part) {
      const end = part.byteOffset + part.byteLength;
      let position = part.byteOffset;
      while (position !== end) {
        const size = Math.min(end - position, CHUNK_SIZE);
        const chunk = part.buffer.slice(position, position + size);
        position += chunk.byteLength;
        yield new Uint8Array(chunk);
      }
    }
    async function* consumeNodeBlob(blob) {
      let position = 0;
      while (position !== blob.size) {
        const chunk = blob.slice(position, Math.min(blob.size, position + CHUNK_SIZE));
        const buffer = await chunk.arrayBuffer();
        position += buffer.byteLength;
        yield new Uint8Array(buffer);
      }
    }
    async function* consumeBlobParts(parts, clone = false) {
      for (const part of parts) {
        if (ArrayBuffer.isView(part)) {
          if (clone) {
            yield* clonePart(part);
          } else {
            yield part;
          }
        } else if ((0, isFunction_1.isFunction)(part.stream)) {
          yield* part.stream();
        } else {
          yield* consumeNodeBlob(part);
        }
      }
    }
    exports2.consumeBlobParts = consumeBlobParts;
    function* sliceBlob(blobParts, blobSize, start = 0, end) {
      end !== null && end !== void 0 ? end : end = blobSize;
      let relativeStart = start < 0 ? Math.max(blobSize + start, 0) : Math.min(start, blobSize);
      let relativeEnd = end < 0 ? Math.max(blobSize + end, 0) : Math.min(end, blobSize);
      const span = Math.max(relativeEnd - relativeStart, 0);
      let added = 0;
      for (const part of blobParts) {
        if (added >= span) {
          break;
        }
        const partSize = ArrayBuffer.isView(part) ? part.byteLength : part.size;
        if (relativeStart && partSize <= relativeStart) {
          relativeStart -= partSize;
          relativeEnd -= partSize;
        } else {
          let chunk;
          if (ArrayBuffer.isView(part)) {
            chunk = part.subarray(relativeStart, Math.min(partSize, relativeEnd));
            added += chunk.byteLength;
          } else {
            chunk = part.slice(relativeStart, Math.min(partSize, relativeEnd));
            added += chunk.size;
          }
          relativeEnd -= partSize;
          relativeStart = 0;
          yield chunk;
        }
      }
    }
    exports2.sliceBlob = sliceBlob;
  }
});

// node_modules/.pnpm/formdata-node@4.3.2/node_modules/formdata-node/lib/cjs/Blob.js
var require_Blob = __commonJS({
  "node_modules/.pnpm/formdata-node@4.3.2/node_modules/formdata-node/lib/cjs/Blob.js"(exports2) {
    "use strict";
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var _Blob_parts;
    var _Blob_type;
    var _Blob_size;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Blob = void 0;
    var web_streams_polyfill_1 = require_ponyfill();
    var isFunction_1 = require_isFunction();
    var blobHelpers_1 = require_blobHelpers();
    var Blob = class {
      constructor(blobParts = [], options2 = {}) {
        _Blob_parts.set(this, []);
        _Blob_type.set(this, "");
        _Blob_size.set(this, 0);
        options2 !== null && options2 !== void 0 ? options2 : options2 = {};
        if (typeof blobParts !== "object" || blobParts === null) {
          throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
        }
        if (!(0, isFunction_1.isFunction)(blobParts[Symbol.iterator])) {
          throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
        }
        if (typeof options2 !== "object" && !(0, isFunction_1.isFunction)(options2)) {
          throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
        }
        const encoder = new TextEncoder();
        for (const raw2 of blobParts) {
          let part;
          if (ArrayBuffer.isView(raw2)) {
            part = new Uint8Array(raw2.buffer.slice(raw2.byteOffset, raw2.byteOffset + raw2.byteLength));
          } else if (raw2 instanceof ArrayBuffer) {
            part = new Uint8Array(raw2.slice(0));
          } else if (raw2 instanceof Blob) {
            part = raw2;
          } else {
            part = encoder.encode(String(raw2));
          }
          __classPrivateFieldSet(this, _Blob_size, __classPrivateFieldGet(this, _Blob_size, "f") + (ArrayBuffer.isView(part) ? part.byteLength : part.size), "f");
          __classPrivateFieldGet(this, _Blob_parts, "f").push(part);
        }
        const type = options2.type === void 0 ? "" : String(options2.type);
        __classPrivateFieldSet(this, _Blob_type, /^[\x20-\x7E]*$/.test(type) ? type : "", "f");
      }
      static [(_Blob_parts = /* @__PURE__ */ new WeakMap(), _Blob_type = /* @__PURE__ */ new WeakMap(), _Blob_size = /* @__PURE__ */ new WeakMap(), Symbol.hasInstance)](value) {
        return Boolean(value && typeof value === "object" && (0, isFunction_1.isFunction)(value.constructor) && ((0, isFunction_1.isFunction)(value.stream) || (0, isFunction_1.isFunction)(value.arrayBuffer)) && /^(Blob|File)$/.test(value[Symbol.toStringTag]));
      }
      get type() {
        return __classPrivateFieldGet(this, _Blob_type, "f");
      }
      get size() {
        return __classPrivateFieldGet(this, _Blob_size, "f");
      }
      slice(start, end, contentType) {
        return new Blob((0, blobHelpers_1.sliceBlob)(__classPrivateFieldGet(this, _Blob_parts, "f"), this.size, start, end), {
          type: contentType
        });
      }
      async text() {
        const decoder = new TextDecoder();
        let result = "";
        for await (const chunk of (0, blobHelpers_1.consumeBlobParts)(__classPrivateFieldGet(this, _Blob_parts, "f"))) {
          result += decoder.decode(chunk, { stream: true });
        }
        result += decoder.decode();
        return result;
      }
      async arrayBuffer() {
        const view = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of (0, blobHelpers_1.consumeBlobParts)(__classPrivateFieldGet(this, _Blob_parts, "f"))) {
          view.set(chunk, offset);
          offset += chunk.length;
        }
        return view.buffer;
      }
      stream() {
        const iterator = (0, blobHelpers_1.consumeBlobParts)(__classPrivateFieldGet(this, _Blob_parts, "f"), true);
        return new web_streams_polyfill_1.ReadableStream({
          async pull(controller) {
            const { value, done: done2 } = await iterator.next();
            if (done2) {
              return queueMicrotask(() => controller.close());
            }
            controller.enqueue(value);
          },
          async cancel() {
            await iterator.return();
          }
        });
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
    };
    exports2.Blob = Blob;
    Object.defineProperties(Blob.prototype, {
      type: { enumerable: true },
      size: { enumerable: true },
      slice: { enumerable: true },
      stream: { enumerable: true },
      text: { enumerable: true },
      arrayBuffer: { enumerable: true }
    });
  }
});

// node_modules/.pnpm/formdata-node@4.3.2/node_modules/formdata-node/lib/cjs/File.js
var require_File = __commonJS({
  "node_modules/.pnpm/formdata-node@4.3.2/node_modules/formdata-node/lib/cjs/File.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _File_name;
    var _File_lastModified;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.File = void 0;
    var Blob_1 = require_Blob();
    var File = class extends Blob_1.Blob {
      constructor(fileBits, name, options2 = {}) {
        super(fileBits, options2);
        _File_name.set(this, void 0);
        _File_lastModified.set(this, 0);
        if (arguments.length < 2) {
          throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
        }
        __classPrivateFieldSet(this, _File_name, String(name), "f");
        const lastModified = options2.lastModified === void 0 ? Date.now() : Number(options2.lastModified);
        if (!Number.isNaN(lastModified)) {
          __classPrivateFieldSet(this, _File_lastModified, lastModified, "f");
        }
      }
      get name() {
        return __classPrivateFieldGet(this, _File_name, "f");
      }
      get lastModified() {
        return __classPrivateFieldGet(this, _File_lastModified, "f");
      }
      get [(_File_name = /* @__PURE__ */ new WeakMap(), _File_lastModified = /* @__PURE__ */ new WeakMap(), Symbol.toStringTag)]() {
        return "File";
      }
    };
    exports2.File = File;
  }
});

// node_modules/.pnpm/formdata-node@4.3.2/node_modules/formdata-node/lib/cjs/isFile.js
var require_isFile = __commonJS({
  "node_modules/.pnpm/formdata-node@4.3.2/node_modules/formdata-node/lib/cjs/isFile.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isFile = void 0;
    var File_1 = require_File();
    var isFile = (value) => value instanceof File_1.File;
    exports2.isFile = isFile;
  }
});

// node_modules/.pnpm/formdata-node@4.3.2/node_modules/formdata-node/lib/cjs/deprecateConstructorEntries.js
var require_deprecateConstructorEntries = __commonJS({
  "node_modules/.pnpm/formdata-node@4.3.2/node_modules/formdata-node/lib/cjs/deprecateConstructorEntries.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.deprecateConstructorEntries = void 0;
    var util_1 = (init_util(), __toCommonJS(util_exports));
    exports2.deprecateConstructorEntries = (0, util_1.deprecate)(() => {
    }, 'Constructor "entries" argument is not spec-compliant and will be removed in next major release.');
  }
});

// node_modules/.pnpm/formdata-node@4.3.2/node_modules/formdata-node/lib/cjs/FormData.js
var require_FormData = __commonJS({
  "node_modules/.pnpm/formdata-node@4.3.2/node_modules/formdata-node/lib/cjs/FormData.js"(exports2) {
    "use strict";
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _FormData_instances;
    var _FormData_entries;
    var _FormData_setEntry;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FormData = void 0;
    var util_1 = (init_util(), __toCommonJS(util_exports));
    var File_1 = require_File();
    var isFile_1 = require_isFile();
    var isFunction_1 = require_isFunction();
    var deprecateConstructorEntries_1 = require_deprecateConstructorEntries();
    var FormData = class {
      constructor(entries) {
        _FormData_instances.add(this);
        _FormData_entries.set(this, /* @__PURE__ */ new Map());
        if (entries) {
          (0, deprecateConstructorEntries_1.deprecateConstructorEntries)();
          entries.forEach(({ name, value, fileName }) => this.append(name, value, fileName));
        }
      }
      static [(_FormData_entries = /* @__PURE__ */ new WeakMap(), _FormData_instances = /* @__PURE__ */ new WeakSet(), Symbol.hasInstance)](value) {
        return Boolean(value && (0, isFunction_1.isFunction)(value.constructor) && value[Symbol.toStringTag] === "FormData" && (0, isFunction_1.isFunction)(value.append) && (0, isFunction_1.isFunction)(value.set) && (0, isFunction_1.isFunction)(value.get) && (0, isFunction_1.isFunction)(value.getAll) && (0, isFunction_1.isFunction)(value.has) && (0, isFunction_1.isFunction)(value.delete) && (0, isFunction_1.isFunction)(value.entries) && (0, isFunction_1.isFunction)(value.values) && (0, isFunction_1.isFunction)(value.keys) && (0, isFunction_1.isFunction)(value[Symbol.iterator]) && (0, isFunction_1.isFunction)(value.forEach));
      }
      append(name, value, fileName) {
        __classPrivateFieldGet(this, _FormData_instances, "m", _FormData_setEntry).call(this, {
          name,
          fileName,
          append: true,
          rawValue: value,
          argsLength: arguments.length
        });
      }
      set(name, value, fileName) {
        __classPrivateFieldGet(this, _FormData_instances, "m", _FormData_setEntry).call(this, {
          name,
          fileName,
          append: false,
          rawValue: value,
          argsLength: arguments.length
        });
      }
      get(name) {
        const field = __classPrivateFieldGet(this, _FormData_entries, "f").get(String(name));
        if (!field) {
          return null;
        }
        return field[0];
      }
      getAll(name) {
        const field = __classPrivateFieldGet(this, _FormData_entries, "f").get(String(name));
        if (!field) {
          return [];
        }
        return field.slice();
      }
      has(name) {
        return __classPrivateFieldGet(this, _FormData_entries, "f").has(String(name));
      }
      delete(name) {
        __classPrivateFieldGet(this, _FormData_entries, "f").delete(String(name));
      }
      *keys() {
        for (const key of __classPrivateFieldGet(this, _FormData_entries, "f").keys()) {
          yield key;
        }
      }
      *entries() {
        for (const name of this.keys()) {
          const values = this.getAll(name);
          for (const value of values) {
            yield [name, value];
          }
        }
      }
      *values() {
        for (const [, value] of this) {
          yield value;
        }
      }
      [(_FormData_setEntry = function _FormData_setEntry2({ name, rawValue, append, fileName, argsLength }) {
        const methodName = append ? "append" : "set";
        if (argsLength < 2) {
          throw new TypeError(`Failed to execute '${methodName}' on 'FormData': 2 arguments required, but only ${argsLength} present.`);
        }
        name = String(name);
        let value;
        if ((0, isFile_1.isFile)(rawValue)) {
          if (fileName === void 0) {
            fileName = rawValue.name === void 0 ? "blob" : rawValue.name;
          }
          value = new File_1.File([rawValue], String(fileName), {
            type: rawValue.type,
            lastModified: rawValue.lastModified
          });
        } else if (fileName) {
          throw new TypeError(`Failed to execute '${methodName}' on 'FormData': parameter 2 is not of type 'Blob'.`);
        } else {
          value = String(rawValue);
        }
        const values = __classPrivateFieldGet(this, _FormData_entries, "f").get(name);
        if (!values) {
          return void __classPrivateFieldGet(this, _FormData_entries, "f").set(name, [value]);
        }
        if (!append) {
          return void __classPrivateFieldGet(this, _FormData_entries, "f").set(name, [value]);
        }
        values.push(value);
      }, Symbol.iterator)]() {
        return this.entries();
      }
      forEach(callback, thisArg) {
        for (const [name, value] of this) {
          callback.call(thisArg, value, name, this);
        }
      }
      get [Symbol.toStringTag]() {
        return "FormData";
      }
      [util_1.inspect.custom]() {
        return this[Symbol.toStringTag];
      }
    };
    exports2.FormData = FormData;
  }
});

// node_modules/.pnpm/formdata-node@4.3.2/node_modules/formdata-node/lib/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/.pnpm/formdata-node@4.3.2/node_modules/formdata-node/lib/cjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o, k22, { enumerable: true, get: function() {
        return m[k2];
      } });
    } : function(o, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m[k2];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_FormData(), exports2);
    __exportStar(require_Blob(), exports2);
    __exportStar(require_File(), exports2);
  }
});

// node_modules/.pnpm/web-streams-polyfill@3.2.1/node_modules/web-streams-polyfill/dist/ponyfill.js
var require_ponyfill2 = __commonJS({
  "node_modules/.pnpm/web-streams-polyfill@3.2.1/node_modules/web-streams-polyfill/dist/ponyfill.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.WebStreamsPolyfill = {}));
    })(exports2, function(exports3) {
      "use strict";
      var SymbolPolyfill = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol : function(description) {
        return "Symbol(" + description + ")";
      };
      function noop() {
        return void 0;
      }
      function getGlobals() {
        if (typeof self !== "undefined") {
          return self;
        } else if (typeof window !== "undefined") {
          return window;
        } else if (typeof global !== "undefined") {
          return global;
        }
        return void 0;
      }
      var globals = getGlobals();
      function typeIsObject(x) {
        return typeof x === "object" && x !== null || typeof x === "function";
      }
      var rethrowAssertionErrorRejection = noop;
      var originalPromise = Promise;
      var originalPromiseThen = Promise.prototype.then;
      var originalPromiseResolve = Promise.resolve.bind(originalPromise);
      var originalPromiseReject = Promise.reject.bind(originalPromise);
      function newPromise(executor) {
        return new originalPromise(executor);
      }
      function promiseResolvedWith(value) {
        return originalPromiseResolve(value);
      }
      function promiseRejectedWith(reason) {
        return originalPromiseReject(reason);
      }
      function PerformPromiseThen(promise, onFulfilled, onRejected) {
        return originalPromiseThen.call(promise, onFulfilled, onRejected);
      }
      function uponPromise(promise, onFulfilled, onRejected) {
        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
      }
      function uponFulfillment(promise, onFulfilled) {
        uponPromise(promise, onFulfilled);
      }
      function uponRejection(promise, onRejected) {
        uponPromise(promise, void 0, onRejected);
      }
      function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
      }
      function setPromiseIsHandledToTrue(promise) {
        PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
      }
      var queueMicrotask2 = function() {
        var globalQueueMicrotask = globals && globals.queueMicrotask;
        if (typeof globalQueueMicrotask === "function") {
          return globalQueueMicrotask;
        }
        var resolvedPromise = promiseResolvedWith(void 0);
        return function(fn2) {
          return PerformPromiseThen(resolvedPromise, fn2);
        };
      }();
      function reflectCall(F, V, args) {
        if (typeof F !== "function") {
          throw new TypeError("Argument is not a function");
        }
        return Function.prototype.apply.call(F, V, args);
      }
      function promiseCall(F, V, args) {
        try {
          return promiseResolvedWith(reflectCall(F, V, args));
        } catch (value) {
          return promiseRejectedWith(value);
        }
      }
      var QUEUE_MAX_ARRAY_SIZE = 16384;
      var SimpleQueue = function() {
        function SimpleQueue2() {
          this._cursor = 0;
          this._size = 0;
          this._front = {
            _elements: [],
            _next: void 0
          };
          this._back = this._front;
          this._cursor = 0;
          this._size = 0;
        }
        Object.defineProperty(SimpleQueue2.prototype, "length", {
          get: function() {
            return this._size;
          },
          enumerable: false,
          configurable: true
        });
        SimpleQueue2.prototype.push = function(element) {
          var oldBack = this._back;
          var newBack = oldBack;
          if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
            newBack = {
              _elements: [],
              _next: void 0
            };
          }
          oldBack._elements.push(element);
          if (newBack !== oldBack) {
            this._back = newBack;
            oldBack._next = newBack;
          }
          ++this._size;
        };
        SimpleQueue2.prototype.shift = function() {
          var oldFront = this._front;
          var newFront = oldFront;
          var oldCursor = this._cursor;
          var newCursor = oldCursor + 1;
          var elements = oldFront._elements;
          var element = elements[oldCursor];
          if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
            newFront = oldFront._next;
            newCursor = 0;
          }
          --this._size;
          this._cursor = newCursor;
          if (oldFront !== newFront) {
            this._front = newFront;
          }
          elements[oldCursor] = void 0;
          return element;
        };
        SimpleQueue2.prototype.forEach = function(callback) {
          var i = this._cursor;
          var node = this._front;
          var elements = node._elements;
          while (i !== elements.length || node._next !== void 0) {
            if (i === elements.length) {
              node = node._next;
              elements = node._elements;
              i = 0;
              if (elements.length === 0) {
                break;
              }
            }
            callback(elements[i]);
            ++i;
          }
        };
        SimpleQueue2.prototype.peek = function() {
          var front = this._front;
          var cursor = this._cursor;
          return front._elements[cursor];
        };
        return SimpleQueue2;
      }();
      function ReadableStreamReaderGenericInitialize(reader, stream) {
        reader._ownerReadableStream = stream;
        stream._reader = reader;
        if (stream._state === "readable") {
          defaultReaderClosedPromiseInitialize(reader);
        } else if (stream._state === "closed") {
          defaultReaderClosedPromiseInitializeAsResolved(reader);
        } else {
          defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
        }
      }
      function ReadableStreamReaderGenericCancel(reader, reason) {
        var stream = reader._ownerReadableStream;
        return ReadableStreamCancel(stream, reason);
      }
      function ReadableStreamReaderGenericRelease(reader) {
        if (reader._ownerReadableStream._state === "readable") {
          defaultReaderClosedPromiseReject(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
        } else {
          defaultReaderClosedPromiseResetToRejected(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
        }
        reader._ownerReadableStream._reader = void 0;
        reader._ownerReadableStream = void 0;
      }
      function readerLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released reader");
      }
      function defaultReaderClosedPromiseInitialize(reader) {
        reader._closedPromise = newPromise(function(resolve2, reject2) {
          reader._closedPromise_resolve = resolve2;
          reader._closedPromise_reject = reject2;
        });
      }
      function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseReject(reader, reason);
      }
      function defaultReaderClosedPromiseInitializeAsResolved(reader) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseResolve(reader);
      }
      function defaultReaderClosedPromiseReject(reader, reason) {
        if (reader._closedPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(reader._closedPromise);
        reader._closedPromise_reject(reason);
        reader._closedPromise_resolve = void 0;
        reader._closedPromise_reject = void 0;
      }
      function defaultReaderClosedPromiseResetToRejected(reader, reason) {
        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
      }
      function defaultReaderClosedPromiseResolve(reader) {
        if (reader._closedPromise_resolve === void 0) {
          return;
        }
        reader._closedPromise_resolve(void 0);
        reader._closedPromise_resolve = void 0;
        reader._closedPromise_reject = void 0;
      }
      var AbortSteps = SymbolPolyfill("[[AbortSteps]]");
      var ErrorSteps = SymbolPolyfill("[[ErrorSteps]]");
      var CancelSteps = SymbolPolyfill("[[CancelSteps]]");
      var PullSteps = SymbolPolyfill("[[PullSteps]]");
      var NumberIsFinite = Number.isFinite || function(x) {
        return typeof x === "number" && isFinite(x);
      };
      var MathTrunc = Math.trunc || function(v) {
        return v < 0 ? Math.ceil(v) : Math.floor(v);
      };
      function isDictionary(x) {
        return typeof x === "object" || typeof x === "function";
      }
      function assertDictionary(obj, context) {
        if (obj !== void 0 && !isDictionary(obj)) {
          throw new TypeError(context + " is not an object.");
        }
      }
      function assertFunction(x, context) {
        if (typeof x !== "function") {
          throw new TypeError(context + " is not a function.");
        }
      }
      function isObject3(x) {
        return typeof x === "object" && x !== null || typeof x === "function";
      }
      function assertObject(x, context) {
        if (!isObject3(x)) {
          throw new TypeError(context + " is not an object.");
        }
      }
      function assertRequiredArgument(x, position, context) {
        if (x === void 0) {
          throw new TypeError("Parameter " + position + " is required in '" + context + "'.");
        }
      }
      function assertRequiredField(x, field, context) {
        if (x === void 0) {
          throw new TypeError(field + " is required in '" + context + "'.");
        }
      }
      function convertUnrestrictedDouble(value) {
        return Number(value);
      }
      function censorNegativeZero(x) {
        return x === 0 ? 0 : x;
      }
      function integerPart(x) {
        return censorNegativeZero(MathTrunc(x));
      }
      function convertUnsignedLongLongWithEnforceRange(value, context) {
        var lowerBound = 0;
        var upperBound = Number.MAX_SAFE_INTEGER;
        var x = Number(value);
        x = censorNegativeZero(x);
        if (!NumberIsFinite(x)) {
          throw new TypeError(context + " is not a finite number");
        }
        x = integerPart(x);
        if (x < lowerBound || x > upperBound) {
          throw new TypeError(context + " is outside the accepted range of " + lowerBound + " to " + upperBound + ", inclusive");
        }
        if (!NumberIsFinite(x) || x === 0) {
          return 0;
        }
        return x;
      }
      function assertReadableStream(x, context) {
        if (!IsReadableStream(x)) {
          throw new TypeError(context + " is not a ReadableStream.");
        }
      }
      function AcquireReadableStreamDefaultReader(stream) {
        return new ReadableStreamDefaultReader(stream);
      }
      function ReadableStreamAddReadRequest(stream, readRequest) {
        stream._reader._readRequests.push(readRequest);
      }
      function ReadableStreamFulfillReadRequest(stream, chunk, done2) {
        var reader = stream._reader;
        var readRequest = reader._readRequests.shift();
        if (done2) {
          readRequest._closeSteps();
        } else {
          readRequest._chunkSteps(chunk);
        }
      }
      function ReadableStreamGetNumReadRequests(stream) {
        return stream._reader._readRequests.length;
      }
      function ReadableStreamHasDefaultReader(stream) {
        var reader = stream._reader;
        if (reader === void 0) {
          return false;
        }
        if (!IsReadableStreamDefaultReader(reader)) {
          return false;
        }
        return true;
      }
      var ReadableStreamDefaultReader = function() {
        function ReadableStreamDefaultReader2(stream) {
          assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
          assertReadableStream(stream, "First parameter");
          if (IsReadableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive reading by another reader");
          }
          ReadableStreamReaderGenericInitialize(this, stream);
          this._readRequests = new SimpleQueue();
        }
        Object.defineProperty(ReadableStreamDefaultReader2.prototype, "closed", {
          get: function() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
            }
            return this._closedPromise;
          },
          enumerable: false,
          configurable: true
        });
        ReadableStreamDefaultReader2.prototype.cancel = function(reason) {
          if (reason === void 0) {
            reason = void 0;
          }
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("cancel"));
          }
          return ReadableStreamReaderGenericCancel(this, reason);
        };
        ReadableStreamDefaultReader2.prototype.read = function() {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("read"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("read from"));
          }
          var resolvePromise;
          var rejectPromise;
          var promise = newPromise(function(resolve2, reject2) {
            resolvePromise = resolve2;
            rejectPromise = reject2;
          });
          var readRequest = {
            _chunkSteps: function(chunk) {
              return resolvePromise({ value: chunk, done: false });
            },
            _closeSteps: function() {
              return resolvePromise({ value: void 0, done: true });
            },
            _errorSteps: function(e2) {
              return rejectPromise(e2);
            }
          };
          ReadableStreamDefaultReaderRead(this, readRequest);
          return promise;
        };
        ReadableStreamDefaultReader2.prototype.releaseLock = function() {
          if (!IsReadableStreamDefaultReader(this)) {
            throw defaultReaderBrandCheckException("releaseLock");
          }
          if (this._ownerReadableStream === void 0) {
            return;
          }
          if (this._readRequests.length > 0) {
            throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
          }
          ReadableStreamReaderGenericRelease(this);
        };
        return ReadableStreamDefaultReader2;
      }();
      Object.defineProperties(ReadableStreamDefaultReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamDefaultReader",
          configurable: true
        });
      }
      function IsReadableStreamDefaultReader(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_readRequests")) {
          return false;
        }
        return x instanceof ReadableStreamDefaultReader;
      }
      function ReadableStreamDefaultReaderRead(reader, readRequest) {
        var stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === "closed") {
          readRequest._closeSteps();
        } else if (stream._state === "errored") {
          readRequest._errorSteps(stream._storedError);
        } else {
          stream._readableStreamController[PullSteps](readRequest);
        }
      }
      function defaultReaderBrandCheckException(name) {
        return new TypeError("ReadableStreamDefaultReader.prototype." + name + " can only be used on a ReadableStreamDefaultReader");
      }
      var _a3;
      var AsyncIteratorPrototype;
      if (typeof SymbolPolyfill.asyncIterator === "symbol") {
        AsyncIteratorPrototype = (_a3 = {}, _a3[SymbolPolyfill.asyncIterator] = function() {
          return this;
        }, _a3);
        Object.defineProperty(AsyncIteratorPrototype, SymbolPolyfill.asyncIterator, { enumerable: false });
      }
      var ReadableStreamAsyncIteratorImpl = function() {
        function ReadableStreamAsyncIteratorImpl2(reader, preventCancel) {
          this._ongoingPromise = void 0;
          this._isFinished = false;
          this._reader = reader;
          this._preventCancel = preventCancel;
        }
        ReadableStreamAsyncIteratorImpl2.prototype.next = function() {
          var _this = this;
          var nextSteps = function() {
            return _this._nextSteps();
          };
          this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
          return this._ongoingPromise;
        };
        ReadableStreamAsyncIteratorImpl2.prototype.return = function(value) {
          var _this = this;
          var returnSteps = function() {
            return _this._returnSteps(value);
          };
          return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
        };
        ReadableStreamAsyncIteratorImpl2.prototype._nextSteps = function() {
          var _this = this;
          if (this._isFinished) {
            return Promise.resolve({ value: void 0, done: true });
          }
          var reader = this._reader;
          if (reader._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("iterate"));
          }
          var resolvePromise;
          var rejectPromise;
          var promise = newPromise(function(resolve2, reject2) {
            resolvePromise = resolve2;
            rejectPromise = reject2;
          });
          var readRequest = {
            _chunkSteps: function(chunk) {
              _this._ongoingPromise = void 0;
              queueMicrotask2(function() {
                return resolvePromise({ value: chunk, done: false });
              });
            },
            _closeSteps: function() {
              _this._ongoingPromise = void 0;
              _this._isFinished = true;
              ReadableStreamReaderGenericRelease(reader);
              resolvePromise({ value: void 0, done: true });
            },
            _errorSteps: function(reason) {
              _this._ongoingPromise = void 0;
              _this._isFinished = true;
              ReadableStreamReaderGenericRelease(reader);
              rejectPromise(reason);
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
          return promise;
        };
        ReadableStreamAsyncIteratorImpl2.prototype._returnSteps = function(value) {
          if (this._isFinished) {
            return Promise.resolve({ value, done: true });
          }
          this._isFinished = true;
          var reader = this._reader;
          if (reader._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("finish iterating"));
          }
          if (!this._preventCancel) {
            var result = ReadableStreamReaderGenericCancel(reader, value);
            ReadableStreamReaderGenericRelease(reader);
            return transformPromiseWith(result, function() {
              return { value, done: true };
            });
          }
          ReadableStreamReaderGenericRelease(reader);
          return promiseResolvedWith({ value, done: true });
        };
        return ReadableStreamAsyncIteratorImpl2;
      }();
      var ReadableStreamAsyncIteratorPrototype = {
        next: function() {
          if (!IsReadableStreamAsyncIterator(this)) {
            return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
          }
          return this._asyncIteratorImpl.next();
        },
        return: function(value) {
          if (!IsReadableStreamAsyncIterator(this)) {
            return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
          }
          return this._asyncIteratorImpl.return(value);
        }
      };
      if (AsyncIteratorPrototype !== void 0) {
        Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
      }
      function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
        var reader = AcquireReadableStreamDefaultReader(stream);
        var impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
        iterator._asyncIteratorImpl = impl;
        return iterator;
      }
      function IsReadableStreamAsyncIterator(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_asyncIteratorImpl")) {
          return false;
        }
        try {
          return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
        } catch (_a4) {
          return false;
        }
      }
      function streamAsyncIteratorBrandCheckException(name) {
        return new TypeError("ReadableStreamAsyncIterator." + name + " can only be used on a ReadableSteamAsyncIterator");
      }
      var NumberIsNaN = Number.isNaN || function(x) {
        return x !== x;
      };
      function CreateArrayFromList(elements) {
        return elements.slice();
      }
      function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
      }
      function TransferArrayBuffer(O) {
        return O;
      }
      function IsDetachedBuffer(O) {
        return false;
      }
      function ArrayBufferSlice(buffer, begin, end) {
        if (buffer.slice) {
          return buffer.slice(begin, end);
        }
        var length = end - begin;
        var slice = new ArrayBuffer(length);
        CopyDataBlockBytes(slice, 0, buffer, begin, length);
        return slice;
      }
      function IsNonNegativeNumber(v) {
        if (typeof v !== "number") {
          return false;
        }
        if (NumberIsNaN(v)) {
          return false;
        }
        if (v < 0) {
          return false;
        }
        return true;
      }
      function CloneAsUint8Array(O) {
        var buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
        return new Uint8Array(buffer);
      }
      function DequeueValue(container) {
        var pair = container._queue.shift();
        container._queueTotalSize -= pair.size;
        if (container._queueTotalSize < 0) {
          container._queueTotalSize = 0;
        }
        return pair.value;
      }
      function EnqueueValueWithSize(container, value, size) {
        if (!IsNonNegativeNumber(size) || size === Infinity) {
          throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
        }
        container._queue.push({ value, size });
        container._queueTotalSize += size;
      }
      function PeekQueueValue(container) {
        var pair = container._queue.peek();
        return pair.value;
      }
      function ResetQueue(container) {
        container._queue = new SimpleQueue();
        container._queueTotalSize = 0;
      }
      var ReadableStreamBYOBRequest = function() {
        function ReadableStreamBYOBRequest2() {
          throw new TypeError("Illegal constructor");
        }
        Object.defineProperty(ReadableStreamBYOBRequest2.prototype, "view", {
          get: function() {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("view");
            }
            return this._view;
          },
          enumerable: false,
          configurable: true
        });
        ReadableStreamBYOBRequest2.prototype.respond = function(bytesWritten) {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("respond");
          }
          assertRequiredArgument(bytesWritten, 1, "respond");
          bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
          if (this._associatedReadableByteStreamController === void 0) {
            throw new TypeError("This BYOB request has been invalidated");
          }
          if (IsDetachedBuffer(this._view.buffer))
            ;
          ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
        };
        ReadableStreamBYOBRequest2.prototype.respondWithNewView = function(view) {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("respondWithNewView");
          }
          assertRequiredArgument(view, 1, "respondWithNewView");
          if (!ArrayBuffer.isView(view)) {
            throw new TypeError("You can only respond with array buffer views");
          }
          if (this._associatedReadableByteStreamController === void 0) {
            throw new TypeError("This BYOB request has been invalidated");
          }
          if (IsDetachedBuffer(view.buffer))
            ;
          ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
        };
        return ReadableStreamBYOBRequest2;
      }();
      Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
        respond: { enumerable: true },
        respondWithNewView: { enumerable: true },
        view: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamBYOBRequest",
          configurable: true
        });
      }
      var ReadableByteStreamController = function() {
        function ReadableByteStreamController2() {
          throw new TypeError("Illegal constructor");
        }
        Object.defineProperty(ReadableByteStreamController2.prototype, "byobRequest", {
          get: function() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("byobRequest");
            }
            return ReadableByteStreamControllerGetBYOBRequest(this);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(ReadableByteStreamController2.prototype, "desiredSize", {
          get: function() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("desiredSize");
            }
            return ReadableByteStreamControllerGetDesiredSize(this);
          },
          enumerable: false,
          configurable: true
        });
        ReadableByteStreamController2.prototype.close = function() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("close");
          }
          if (this._closeRequested) {
            throw new TypeError("The stream has already been closed; do not close it again!");
          }
          var state = this._controlledReadableByteStream._state;
          if (state !== "readable") {
            throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be closed");
          }
          ReadableByteStreamControllerClose(this);
        };
        ReadableByteStreamController2.prototype.enqueue = function(chunk) {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("enqueue");
          }
          assertRequiredArgument(chunk, 1, "enqueue");
          if (!ArrayBuffer.isView(chunk)) {
            throw new TypeError("chunk must be an array buffer view");
          }
          if (chunk.byteLength === 0) {
            throw new TypeError("chunk must have non-zero byteLength");
          }
          if (chunk.buffer.byteLength === 0) {
            throw new TypeError("chunk's buffer must have non-zero byteLength");
          }
          if (this._closeRequested) {
            throw new TypeError("stream is closed or draining");
          }
          var state = this._controlledReadableByteStream._state;
          if (state !== "readable") {
            throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be enqueued to");
          }
          ReadableByteStreamControllerEnqueue(this, chunk);
        };
        ReadableByteStreamController2.prototype.error = function(e2) {
          if (e2 === void 0) {
            e2 = void 0;
          }
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("error");
          }
          ReadableByteStreamControllerError(this, e2);
        };
        ReadableByteStreamController2.prototype[CancelSteps] = function(reason) {
          ReadableByteStreamControllerClearPendingPullIntos(this);
          ResetQueue(this);
          var result = this._cancelAlgorithm(reason);
          ReadableByteStreamControllerClearAlgorithms(this);
          return result;
        };
        ReadableByteStreamController2.prototype[PullSteps] = function(readRequest) {
          var stream = this._controlledReadableByteStream;
          if (this._queueTotalSize > 0) {
            var entry = this._queue.shift();
            this._queueTotalSize -= entry.byteLength;
            ReadableByteStreamControllerHandleQueueDrain(this);
            var view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
            readRequest._chunkSteps(view);
            return;
          }
          var autoAllocateChunkSize = this._autoAllocateChunkSize;
          if (autoAllocateChunkSize !== void 0) {
            var buffer = void 0;
            try {
              buffer = new ArrayBuffer(autoAllocateChunkSize);
            } catch (bufferE) {
              readRequest._errorSteps(bufferE);
              return;
            }
            var pullIntoDescriptor = {
              buffer,
              bufferByteLength: autoAllocateChunkSize,
              byteOffset: 0,
              byteLength: autoAllocateChunkSize,
              bytesFilled: 0,
              elementSize: 1,
              viewConstructor: Uint8Array,
              readerType: "default"
            };
            this._pendingPullIntos.push(pullIntoDescriptor);
          }
          ReadableStreamAddReadRequest(stream, readRequest);
          ReadableByteStreamControllerCallPullIfNeeded(this);
        };
        return ReadableByteStreamController2;
      }();
      Object.defineProperties(ReadableByteStreamController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        byobRequest: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableByteStreamController",
          configurable: true
        });
      }
      function IsReadableByteStreamController(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableByteStream")) {
          return false;
        }
        return x instanceof ReadableByteStreamController;
      }
      function IsReadableStreamBYOBRequest(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_associatedReadableByteStreamController")) {
          return false;
        }
        return x instanceof ReadableStreamBYOBRequest;
      }
      function ReadableByteStreamControllerCallPullIfNeeded(controller) {
        var shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
        if (!shouldPull) {
          return;
        }
        if (controller._pulling) {
          controller._pullAgain = true;
          return;
        }
        controller._pulling = true;
        var pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, function() {
          controller._pulling = false;
          if (controller._pullAgain) {
            controller._pullAgain = false;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
        }, function(e2) {
          ReadableByteStreamControllerError(controller, e2);
        });
      }
      function ReadableByteStreamControllerClearPendingPullIntos(controller) {
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        controller._pendingPullIntos = new SimpleQueue();
      }
      function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
        var done2 = false;
        if (stream._state === "closed") {
          done2 = true;
        }
        var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
        if (pullIntoDescriptor.readerType === "default") {
          ReadableStreamFulfillReadRequest(stream, filledView, done2);
        } else {
          ReadableStreamFulfillReadIntoRequest(stream, filledView, done2);
        }
      }
      function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
        var bytesFilled = pullIntoDescriptor.bytesFilled;
        var elementSize = pullIntoDescriptor.elementSize;
        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
      }
      function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
        controller._queue.push({ buffer, byteOffset, byteLength });
        controller._queueTotalSize += byteLength;
      }
      function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
        var elementSize = pullIntoDescriptor.elementSize;
        var currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
        var maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
        var maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
        var maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
        var totalBytesToCopyRemaining = maxBytesToCopy;
        var ready = false;
        if (maxAlignedBytes > currentAlignedBytes) {
          totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
          ready = true;
        }
        var queue = controller._queue;
        while (totalBytesToCopyRemaining > 0) {
          var headOfQueue = queue.peek();
          var bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
          var destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
          if (headOfQueue.byteLength === bytesToCopy) {
            queue.shift();
          } else {
            headOfQueue.byteOffset += bytesToCopy;
            headOfQueue.byteLength -= bytesToCopy;
          }
          controller._queueTotalSize -= bytesToCopy;
          ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
          totalBytesToCopyRemaining -= bytesToCopy;
        }
        return ready;
      }
      function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
        pullIntoDescriptor.bytesFilled += size;
      }
      function ReadableByteStreamControllerHandleQueueDrain(controller) {
        if (controller._queueTotalSize === 0 && controller._closeRequested) {
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamClose(controller._controlledReadableByteStream);
        } else {
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
      }
      function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
        if (controller._byobRequest === null) {
          return;
        }
        controller._byobRequest._associatedReadableByteStreamController = void 0;
        controller._byobRequest._view = null;
        controller._byobRequest = null;
      }
      function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
        while (controller._pendingPullIntos.length > 0) {
          if (controller._queueTotalSize === 0) {
            return;
          }
          var pullIntoDescriptor = controller._pendingPullIntos.peek();
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
          }
        }
      }
      function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
        var stream = controller._controlledReadableByteStream;
        var elementSize = 1;
        if (view.constructor !== DataView) {
          elementSize = view.constructor.BYTES_PER_ELEMENT;
        }
        var ctor = view.constructor;
        var buffer = TransferArrayBuffer(view.buffer);
        var pullIntoDescriptor = {
          buffer,
          bufferByteLength: buffer.byteLength,
          byteOffset: view.byteOffset,
          byteLength: view.byteLength,
          bytesFilled: 0,
          elementSize,
          viewConstructor: ctor,
          readerType: "byob"
        };
        if (controller._pendingPullIntos.length > 0) {
          controller._pendingPullIntos.push(pullIntoDescriptor);
          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          return;
        }
        if (stream._state === "closed") {
          var emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
          readIntoRequest._closeSteps(emptyView);
          return;
        }
        if (controller._queueTotalSize > 0) {
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
            ReadableByteStreamControllerHandleQueueDrain(controller);
            readIntoRequest._chunkSteps(filledView);
            return;
          }
          if (controller._closeRequested) {
            var e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e2);
            readIntoRequest._errorSteps(e2);
            return;
          }
        }
        controller._pendingPullIntos.push(pullIntoDescriptor);
        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
        var stream = controller._controlledReadableByteStream;
        if (ReadableStreamHasBYOBReader(stream)) {
          while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
          }
        }
      }
      function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
        if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
          return;
        }
        ReadableByteStreamControllerShiftPendingPullInto(controller);
        var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
        if (remainderSize > 0) {
          var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          var remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
        }
        pullIntoDescriptor.bytesFilled -= remainderSize;
        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
      }
      function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
        var firstDescriptor = controller._pendingPullIntos.peek();
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        var state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          ReadableByteStreamControllerRespondInClosedState(controller);
        } else {
          ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerShiftPendingPullInto(controller) {
        var descriptor = controller._pendingPullIntos.shift();
        return descriptor;
      }
      function ReadableByteStreamControllerShouldCallPull(controller) {
        var stream = controller._controlledReadableByteStream;
        if (stream._state !== "readable") {
          return false;
        }
        if (controller._closeRequested) {
          return false;
        }
        if (!controller._started) {
          return false;
        }
        if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          return true;
        }
        if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
          return true;
        }
        var desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
          return true;
        }
        return false;
      }
      function ReadableByteStreamControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
      }
      function ReadableByteStreamControllerClose(controller) {
        var stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== "readable") {
          return;
        }
        if (controller._queueTotalSize > 0) {
          controller._closeRequested = true;
          return;
        }
        if (controller._pendingPullIntos.length > 0) {
          var firstPendingPullInto = controller._pendingPullIntos.peek();
          if (firstPendingPullInto.bytesFilled > 0) {
            var e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e2);
            throw e2;
          }
        }
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamClose(stream);
      }
      function ReadableByteStreamControllerEnqueue(controller, chunk) {
        var stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== "readable") {
          return;
        }
        var buffer = chunk.buffer;
        var byteOffset = chunk.byteOffset;
        var byteLength = chunk.byteLength;
        var transferredBuffer = TransferArrayBuffer(buffer);
        if (controller._pendingPullIntos.length > 0) {
          var firstPendingPullInto = controller._pendingPullIntos.peek();
          if (IsDetachedBuffer(firstPendingPullInto.buffer))
            ;
          firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
        }
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        if (ReadableStreamHasDefaultReader(stream)) {
          if (ReadableStreamGetNumReadRequests(stream) === 0) {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          } else {
            if (controller._pendingPullIntos.length > 0) {
              ReadableByteStreamControllerShiftPendingPullInto(controller);
            }
            var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
            ReadableStreamFulfillReadRequest(stream, transferredView, false);
          }
        } else if (ReadableStreamHasBYOBReader(stream)) {
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        } else {
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerError(controller, e2) {
        var stream = controller._controlledReadableByteStream;
        if (stream._state !== "readable") {
          return;
        }
        ReadableByteStreamControllerClearPendingPullIntos(controller);
        ResetQueue(controller);
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e2);
      }
      function ReadableByteStreamControllerGetBYOBRequest(controller) {
        if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
          var firstDescriptor = controller._pendingPullIntos.peek();
          var view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
          var byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
          SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
          controller._byobRequest = byobRequest;
        }
        return controller._byobRequest;
      }
      function ReadableByteStreamControllerGetDesiredSize(controller) {
        var state = controller._controlledReadableByteStream._state;
        if (state === "errored") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableByteStreamControllerRespond(controller, bytesWritten) {
        var firstDescriptor = controller._pendingPullIntos.peek();
        var state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (bytesWritten !== 0) {
            throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
          }
        } else {
          if (bytesWritten === 0) {
            throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
          }
          if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
            throw new RangeError("bytesWritten out of range");
          }
        }
        firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
        ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
      }
      function ReadableByteStreamControllerRespondWithNewView(controller, view) {
        var firstDescriptor = controller._pendingPullIntos.peek();
        var state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (view.byteLength !== 0) {
            throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
          }
        } else {
          if (view.byteLength === 0) {
            throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
          }
        }
        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
          throw new RangeError("The region specified by view does not match byobRequest");
        }
        if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
          throw new RangeError("The buffer of view has different capacity than byobRequest");
        }
        if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
          throw new RangeError("The region specified by view is larger than byobRequest");
        }
        var viewByteLength = view.byteLength;
        firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
        ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
      }
      function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
        controller._controlledReadableByteStream = stream;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._byobRequest = null;
        controller._queue = controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._closeRequested = false;
        controller._started = false;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        controller._autoAllocateChunkSize = autoAllocateChunkSize;
        controller._pendingPullIntos = new SimpleQueue();
        stream._readableStreamController = controller;
        var startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), function() {
          controller._started = true;
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }, function(r) {
          ReadableByteStreamControllerError(controller, r);
        });
      }
      function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
        var controller = Object.create(ReadableByteStreamController.prototype);
        var startAlgorithm = function() {
          return void 0;
        };
        var pullAlgorithm = function() {
          return promiseResolvedWith(void 0);
        };
        var cancelAlgorithm = function() {
          return promiseResolvedWith(void 0);
        };
        if (underlyingByteSource.start !== void 0) {
          startAlgorithm = function() {
            return underlyingByteSource.start(controller);
          };
        }
        if (underlyingByteSource.pull !== void 0) {
          pullAlgorithm = function() {
            return underlyingByteSource.pull(controller);
          };
        }
        if (underlyingByteSource.cancel !== void 0) {
          cancelAlgorithm = function(reason) {
            return underlyingByteSource.cancel(reason);
          };
        }
        var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
        if (autoAllocateChunkSize === 0) {
          throw new TypeError("autoAllocateChunkSize must be greater than 0");
        }
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
      }
      function SetUpReadableStreamBYOBRequest(request3, controller, view) {
        request3._associatedReadableByteStreamController = controller;
        request3._view = view;
      }
      function byobRequestBrandCheckException(name) {
        return new TypeError("ReadableStreamBYOBRequest.prototype." + name + " can only be used on a ReadableStreamBYOBRequest");
      }
      function byteStreamControllerBrandCheckException(name) {
        return new TypeError("ReadableByteStreamController.prototype." + name + " can only be used on a ReadableByteStreamController");
      }
      function AcquireReadableStreamBYOBReader(stream) {
        return new ReadableStreamBYOBReader(stream);
      }
      function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
        stream._reader._readIntoRequests.push(readIntoRequest);
      }
      function ReadableStreamFulfillReadIntoRequest(stream, chunk, done2) {
        var reader = stream._reader;
        var readIntoRequest = reader._readIntoRequests.shift();
        if (done2) {
          readIntoRequest._closeSteps(chunk);
        } else {
          readIntoRequest._chunkSteps(chunk);
        }
      }
      function ReadableStreamGetNumReadIntoRequests(stream) {
        return stream._reader._readIntoRequests.length;
      }
      function ReadableStreamHasBYOBReader(stream) {
        var reader = stream._reader;
        if (reader === void 0) {
          return false;
        }
        if (!IsReadableStreamBYOBReader(reader)) {
          return false;
        }
        return true;
      }
      var ReadableStreamBYOBReader = function() {
        function ReadableStreamBYOBReader2(stream) {
          assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
          assertReadableStream(stream, "First parameter");
          if (IsReadableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive reading by another reader");
          }
          if (!IsReadableByteStreamController(stream._readableStreamController)) {
            throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
          }
          ReadableStreamReaderGenericInitialize(this, stream);
          this._readIntoRequests = new SimpleQueue();
        }
        Object.defineProperty(ReadableStreamBYOBReader2.prototype, "closed", {
          get: function() {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("closed"));
            }
            return this._closedPromise;
          },
          enumerable: false,
          configurable: true
        });
        ReadableStreamBYOBReader2.prototype.cancel = function(reason) {
          if (reason === void 0) {
            reason = void 0;
          }
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("cancel"));
          }
          return ReadableStreamReaderGenericCancel(this, reason);
        };
        ReadableStreamBYOBReader2.prototype.read = function(view) {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("read"));
          }
          if (!ArrayBuffer.isView(view)) {
            return promiseRejectedWith(new TypeError("view must be an array buffer view"));
          }
          if (view.byteLength === 0) {
            return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
          }
          if (view.buffer.byteLength === 0) {
            return promiseRejectedWith(new TypeError("view's buffer must have non-zero byteLength"));
          }
          if (IsDetachedBuffer(view.buffer))
            ;
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("read from"));
          }
          var resolvePromise;
          var rejectPromise;
          var promise = newPromise(function(resolve2, reject2) {
            resolvePromise = resolve2;
            rejectPromise = reject2;
          });
          var readIntoRequest = {
            _chunkSteps: function(chunk) {
              return resolvePromise({ value: chunk, done: false });
            },
            _closeSteps: function(chunk) {
              return resolvePromise({ value: chunk, done: true });
            },
            _errorSteps: function(e2) {
              return rejectPromise(e2);
            }
          };
          ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
          return promise;
        };
        ReadableStreamBYOBReader2.prototype.releaseLock = function() {
          if (!IsReadableStreamBYOBReader(this)) {
            throw byobReaderBrandCheckException("releaseLock");
          }
          if (this._ownerReadableStream === void 0) {
            return;
          }
          if (this._readIntoRequests.length > 0) {
            throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
          }
          ReadableStreamReaderGenericRelease(this);
        };
        return ReadableStreamBYOBReader2;
      }();
      Object.defineProperties(ReadableStreamBYOBReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamBYOBReader",
          configurable: true
        });
      }
      function IsReadableStreamBYOBReader(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_readIntoRequests")) {
          return false;
        }
        return x instanceof ReadableStreamBYOBReader;
      }
      function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
        var stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === "errored") {
          readIntoRequest._errorSteps(stream._storedError);
        } else {
          ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
        }
      }
      function byobReaderBrandCheckException(name) {
        return new TypeError("ReadableStreamBYOBReader.prototype." + name + " can only be used on a ReadableStreamBYOBReader");
      }
      function ExtractHighWaterMark(strategy, defaultHWM) {
        var highWaterMark = strategy.highWaterMark;
        if (highWaterMark === void 0) {
          return defaultHWM;
        }
        if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
          throw new RangeError("Invalid highWaterMark");
        }
        return highWaterMark;
      }
      function ExtractSizeAlgorithm(strategy) {
        var size = strategy.size;
        if (!size) {
          return function() {
            return 1;
          };
        }
        return size;
      }
      function convertQueuingStrategy(init, context) {
        assertDictionary(init, context);
        var highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
        var size = init === null || init === void 0 ? void 0 : init.size;
        return {
          highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
          size: size === void 0 ? void 0 : convertQueuingStrategySize(size, context + " has member 'size' that")
        };
      }
      function convertQueuingStrategySize(fn2, context) {
        assertFunction(fn2, context);
        return function(chunk) {
          return convertUnrestrictedDouble(fn2(chunk));
        };
      }
      function convertUnderlyingSink(original, context) {
        assertDictionary(original, context);
        var abort = original === null || original === void 0 ? void 0 : original.abort;
        var close = original === null || original === void 0 ? void 0 : original.close;
        var start = original === null || original === void 0 ? void 0 : original.start;
        var type = original === null || original === void 0 ? void 0 : original.type;
        var write = original === null || original === void 0 ? void 0 : original.write;
        return {
          abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, context + " has member 'abort' that"),
          close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, context + " has member 'close' that"),
          start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, context + " has member 'start' that"),
          write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, context + " has member 'write' that"),
          type
        };
      }
      function convertUnderlyingSinkAbortCallback(fn2, original, context) {
        assertFunction(fn2, context);
        return function(reason) {
          return promiseCall(fn2, original, [reason]);
        };
      }
      function convertUnderlyingSinkCloseCallback(fn2, original, context) {
        assertFunction(fn2, context);
        return function() {
          return promiseCall(fn2, original, []);
        };
      }
      function convertUnderlyingSinkStartCallback(fn2, original, context) {
        assertFunction(fn2, context);
        return function(controller) {
          return reflectCall(fn2, original, [controller]);
        };
      }
      function convertUnderlyingSinkWriteCallback(fn2, original, context) {
        assertFunction(fn2, context);
        return function(chunk, controller) {
          return promiseCall(fn2, original, [chunk, controller]);
        };
      }
      function assertWritableStream(x, context) {
        if (!IsWritableStream(x)) {
          throw new TypeError(context + " is not a WritableStream.");
        }
      }
      function isAbortSignal(value) {
        if (typeof value !== "object" || value === null) {
          return false;
        }
        try {
          return typeof value.aborted === "boolean";
        } catch (_a4) {
          return false;
        }
      }
      var supportsAbortController = typeof AbortController === "function";
      function createAbortController() {
        if (supportsAbortController) {
          return new AbortController();
        }
        return void 0;
      }
      var WritableStream = function() {
        function WritableStream2(rawUnderlyingSink, rawStrategy) {
          if (rawUnderlyingSink === void 0) {
            rawUnderlyingSink = {};
          }
          if (rawStrategy === void 0) {
            rawStrategy = {};
          }
          if (rawUnderlyingSink === void 0) {
            rawUnderlyingSink = null;
          } else {
            assertObject(rawUnderlyingSink, "First parameter");
          }
          var strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
          var underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
          InitializeWritableStream(this);
          var type = underlyingSink.type;
          if (type !== void 0) {
            throw new RangeError("Invalid type is specified");
          }
          var sizeAlgorithm = ExtractSizeAlgorithm(strategy);
          var highWaterMark = ExtractHighWaterMark(strategy, 1);
          SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
        }
        Object.defineProperty(WritableStream2.prototype, "locked", {
          get: function() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("locked");
            }
            return IsWritableStreamLocked(this);
          },
          enumerable: false,
          configurable: true
        });
        WritableStream2.prototype.abort = function(reason) {
          if (reason === void 0) {
            reason = void 0;
          }
          if (!IsWritableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$2("abort"));
          }
          if (IsWritableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
          }
          return WritableStreamAbort(this, reason);
        };
        WritableStream2.prototype.close = function() {
          if (!IsWritableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$2("close"));
          }
          if (IsWritableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
          }
          if (WritableStreamCloseQueuedOrInFlight(this)) {
            return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
          }
          return WritableStreamClose(this);
        };
        WritableStream2.prototype.getWriter = function() {
          if (!IsWritableStream(this)) {
            throw streamBrandCheckException$2("getWriter");
          }
          return AcquireWritableStreamDefaultWriter(this);
        };
        return WritableStream2;
      }();
      Object.defineProperties(WritableStream.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        getWriter: { enumerable: true },
        locked: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
          value: "WritableStream",
          configurable: true
        });
      }
      function AcquireWritableStreamDefaultWriter(stream) {
        return new WritableStreamDefaultWriter(stream);
      }
      function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        if (highWaterMark === void 0) {
          highWaterMark = 1;
        }
        if (sizeAlgorithm === void 0) {
          sizeAlgorithm = function() {
            return 1;
          };
        }
        var stream = Object.create(WritableStream.prototype);
        InitializeWritableStream(stream);
        var controller = Object.create(WritableStreamDefaultController.prototype);
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
      }
      function InitializeWritableStream(stream) {
        stream._state = "writable";
        stream._storedError = void 0;
        stream._writer = void 0;
        stream._writableStreamController = void 0;
        stream._writeRequests = new SimpleQueue();
        stream._inFlightWriteRequest = void 0;
        stream._closeRequest = void 0;
        stream._inFlightCloseRequest = void 0;
        stream._pendingAbortRequest = void 0;
        stream._backpressure = false;
      }
      function IsWritableStream(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_writableStreamController")) {
          return false;
        }
        return x instanceof WritableStream;
      }
      function IsWritableStreamLocked(stream) {
        if (stream._writer === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamAbort(stream, reason) {
        var _a4;
        if (stream._state === "closed" || stream._state === "errored") {
          return promiseResolvedWith(void 0);
        }
        stream._writableStreamController._abortReason = reason;
        (_a4 = stream._writableStreamController._abortController) === null || _a4 === void 0 ? void 0 : _a4.abort();
        var state = stream._state;
        if (state === "closed" || state === "errored") {
          return promiseResolvedWith(void 0);
        }
        if (stream._pendingAbortRequest !== void 0) {
          return stream._pendingAbortRequest._promise;
        }
        var wasAlreadyErroring = false;
        if (state === "erroring") {
          wasAlreadyErroring = true;
          reason = void 0;
        }
        var promise = newPromise(function(resolve2, reject2) {
          stream._pendingAbortRequest = {
            _promise: void 0,
            _resolve: resolve2,
            _reject: reject2,
            _reason: reason,
            _wasAlreadyErroring: wasAlreadyErroring
          };
        });
        stream._pendingAbortRequest._promise = promise;
        if (!wasAlreadyErroring) {
          WritableStreamStartErroring(stream, reason);
        }
        return promise;
      }
      function WritableStreamClose(stream) {
        var state = stream._state;
        if (state === "closed" || state === "errored") {
          return promiseRejectedWith(new TypeError("The stream (in " + state + " state) is not in the writable state and cannot be closed"));
        }
        var promise = newPromise(function(resolve2, reject2) {
          var closeRequest = {
            _resolve: resolve2,
            _reject: reject2
          };
          stream._closeRequest = closeRequest;
        });
        var writer = stream._writer;
        if (writer !== void 0 && stream._backpressure && state === "writable") {
          defaultWriterReadyPromiseResolve(writer);
        }
        WritableStreamDefaultControllerClose(stream._writableStreamController);
        return promise;
      }
      function WritableStreamAddWriteRequest(stream) {
        var promise = newPromise(function(resolve2, reject2) {
          var writeRequest = {
            _resolve: resolve2,
            _reject: reject2
          };
          stream._writeRequests.push(writeRequest);
        });
        return promise;
      }
      function WritableStreamDealWithRejection(stream, error2) {
        var state = stream._state;
        if (state === "writable") {
          WritableStreamStartErroring(stream, error2);
          return;
        }
        WritableStreamFinishErroring(stream);
      }
      function WritableStreamStartErroring(stream, reason) {
        var controller = stream._writableStreamController;
        stream._state = "erroring";
        stream._storedError = reason;
        var writer = stream._writer;
        if (writer !== void 0) {
          WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
        }
        if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
          WritableStreamFinishErroring(stream);
        }
      }
      function WritableStreamFinishErroring(stream) {
        stream._state = "errored";
        stream._writableStreamController[ErrorSteps]();
        var storedError = stream._storedError;
        stream._writeRequests.forEach(function(writeRequest) {
          writeRequest._reject(storedError);
        });
        stream._writeRequests = new SimpleQueue();
        if (stream._pendingAbortRequest === void 0) {
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        var abortRequest = stream._pendingAbortRequest;
        stream._pendingAbortRequest = void 0;
        if (abortRequest._wasAlreadyErroring) {
          abortRequest._reject(storedError);
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        var promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
        uponPromise(promise, function() {
          abortRequest._resolve();
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        }, function(reason) {
          abortRequest._reject(reason);
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        });
      }
      function WritableStreamFinishInFlightWrite(stream) {
        stream._inFlightWriteRequest._resolve(void 0);
        stream._inFlightWriteRequest = void 0;
      }
      function WritableStreamFinishInFlightWriteWithError(stream, error2) {
        stream._inFlightWriteRequest._reject(error2);
        stream._inFlightWriteRequest = void 0;
        WritableStreamDealWithRejection(stream, error2);
      }
      function WritableStreamFinishInFlightClose(stream) {
        stream._inFlightCloseRequest._resolve(void 0);
        stream._inFlightCloseRequest = void 0;
        var state = stream._state;
        if (state === "erroring") {
          stream._storedError = void 0;
          if (stream._pendingAbortRequest !== void 0) {
            stream._pendingAbortRequest._resolve();
            stream._pendingAbortRequest = void 0;
          }
        }
        stream._state = "closed";
        var writer = stream._writer;
        if (writer !== void 0) {
          defaultWriterClosedPromiseResolve(writer);
        }
      }
      function WritableStreamFinishInFlightCloseWithError(stream, error2) {
        stream._inFlightCloseRequest._reject(error2);
        stream._inFlightCloseRequest = void 0;
        if (stream._pendingAbortRequest !== void 0) {
          stream._pendingAbortRequest._reject(error2);
          stream._pendingAbortRequest = void 0;
        }
        WritableStreamDealWithRejection(stream, error2);
      }
      function WritableStreamCloseQueuedOrInFlight(stream) {
        if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamHasOperationMarkedInFlight(stream) {
        if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamMarkCloseRequestInFlight(stream) {
        stream._inFlightCloseRequest = stream._closeRequest;
        stream._closeRequest = void 0;
      }
      function WritableStreamMarkFirstWriteRequestInFlight(stream) {
        stream._inFlightWriteRequest = stream._writeRequests.shift();
      }
      function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
        if (stream._closeRequest !== void 0) {
          stream._closeRequest._reject(stream._storedError);
          stream._closeRequest = void 0;
        }
        var writer = stream._writer;
        if (writer !== void 0) {
          defaultWriterClosedPromiseReject(writer, stream._storedError);
        }
      }
      function WritableStreamUpdateBackpressure(stream, backpressure) {
        var writer = stream._writer;
        if (writer !== void 0 && backpressure !== stream._backpressure) {
          if (backpressure) {
            defaultWriterReadyPromiseReset(writer);
          } else {
            defaultWriterReadyPromiseResolve(writer);
          }
        }
        stream._backpressure = backpressure;
      }
      var WritableStreamDefaultWriter = function() {
        function WritableStreamDefaultWriter2(stream) {
          assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
          assertWritableStream(stream, "First parameter");
          if (IsWritableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive writing by another writer");
          }
          this._ownerWritableStream = stream;
          stream._writer = this;
          var state = stream._state;
          if (state === "writable") {
            if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
              defaultWriterReadyPromiseInitialize(this);
            } else {
              defaultWriterReadyPromiseInitializeAsResolved(this);
            }
            defaultWriterClosedPromiseInitialize(this);
          } else if (state === "erroring") {
            defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
            defaultWriterClosedPromiseInitialize(this);
          } else if (state === "closed") {
            defaultWriterReadyPromiseInitializeAsResolved(this);
            defaultWriterClosedPromiseInitializeAsResolved(this);
          } else {
            var storedError = stream._storedError;
            defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
            defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
          }
        }
        Object.defineProperty(WritableStreamDefaultWriter2.prototype, "closed", {
          get: function() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
            }
            return this._closedPromise;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(WritableStreamDefaultWriter2.prototype, "desiredSize", {
          get: function() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("desiredSize");
            }
            if (this._ownerWritableStream === void 0) {
              throw defaultWriterLockException("desiredSize");
            }
            return WritableStreamDefaultWriterGetDesiredSize(this);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(WritableStreamDefaultWriter2.prototype, "ready", {
          get: function() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
            }
            return this._readyPromise;
          },
          enumerable: false,
          configurable: true
        });
        WritableStreamDefaultWriter2.prototype.abort = function(reason) {
          if (reason === void 0) {
            reason = void 0;
          }
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
          }
          if (this._ownerWritableStream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("abort"));
          }
          return WritableStreamDefaultWriterAbort(this, reason);
        };
        WritableStreamDefaultWriter2.prototype.close = function() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("close"));
          }
          var stream = this._ownerWritableStream;
          if (stream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("close"));
          }
          if (WritableStreamCloseQueuedOrInFlight(stream)) {
            return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
          }
          return WritableStreamDefaultWriterClose(this);
        };
        WritableStreamDefaultWriter2.prototype.releaseLock = function() {
          if (!IsWritableStreamDefaultWriter(this)) {
            throw defaultWriterBrandCheckException("releaseLock");
          }
          var stream = this._ownerWritableStream;
          if (stream === void 0) {
            return;
          }
          WritableStreamDefaultWriterRelease(this);
        };
        WritableStreamDefaultWriter2.prototype.write = function(chunk) {
          if (chunk === void 0) {
            chunk = void 0;
          }
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("write"));
          }
          if (this._ownerWritableStream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("write to"));
          }
          return WritableStreamDefaultWriterWrite(this, chunk);
        };
        return WritableStreamDefaultWriter2;
      }();
      Object.defineProperties(WritableStreamDefaultWriter.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        releaseLock: { enumerable: true },
        write: { enumerable: true },
        closed: { enumerable: true },
        desiredSize: { enumerable: true },
        ready: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
          value: "WritableStreamDefaultWriter",
          configurable: true
        });
      }
      function IsWritableStreamDefaultWriter(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_ownerWritableStream")) {
          return false;
        }
        return x instanceof WritableStreamDefaultWriter;
      }
      function WritableStreamDefaultWriterAbort(writer, reason) {
        var stream = writer._ownerWritableStream;
        return WritableStreamAbort(stream, reason);
      }
      function WritableStreamDefaultWriterClose(writer) {
        var stream = writer._ownerWritableStream;
        return WritableStreamClose(stream);
      }
      function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
        var stream = writer._ownerWritableStream;
        var state = stream._state;
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
          return promiseResolvedWith(void 0);
        }
        if (state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        return WritableStreamDefaultWriterClose(writer);
      }
      function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error2) {
        if (writer._closedPromiseState === "pending") {
          defaultWriterClosedPromiseReject(writer, error2);
        } else {
          defaultWriterClosedPromiseResetToRejected(writer, error2);
        }
      }
      function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error2) {
        if (writer._readyPromiseState === "pending") {
          defaultWriterReadyPromiseReject(writer, error2);
        } else {
          defaultWriterReadyPromiseResetToRejected(writer, error2);
        }
      }
      function WritableStreamDefaultWriterGetDesiredSize(writer) {
        var stream = writer._ownerWritableStream;
        var state = stream._state;
        if (state === "errored" || state === "erroring") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
      }
      function WritableStreamDefaultWriterRelease(writer) {
        var stream = writer._ownerWritableStream;
        var releasedError = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
        WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
        stream._writer = void 0;
        writer._ownerWritableStream = void 0;
      }
      function WritableStreamDefaultWriterWrite(writer, chunk) {
        var stream = writer._ownerWritableStream;
        var controller = stream._writableStreamController;
        var chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
        if (stream !== writer._ownerWritableStream) {
          return promiseRejectedWith(defaultWriterLockException("write to"));
        }
        var state = stream._state;
        if (state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
          return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
        }
        if (state === "erroring") {
          return promiseRejectedWith(stream._storedError);
        }
        var promise = WritableStreamAddWriteRequest(stream);
        WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
        return promise;
      }
      var closeSentinel = {};
      var WritableStreamDefaultController = function() {
        function WritableStreamDefaultController2() {
          throw new TypeError("Illegal constructor");
        }
        Object.defineProperty(WritableStreamDefaultController2.prototype, "abortReason", {
          get: function() {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("abortReason");
            }
            return this._abortReason;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(WritableStreamDefaultController2.prototype, "signal", {
          get: function() {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("signal");
            }
            if (this._abortController === void 0) {
              throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
            }
            return this._abortController.signal;
          },
          enumerable: false,
          configurable: true
        });
        WritableStreamDefaultController2.prototype.error = function(e2) {
          if (e2 === void 0) {
            e2 = void 0;
          }
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("error");
          }
          var state = this._controlledWritableStream._state;
          if (state !== "writable") {
            return;
          }
          WritableStreamDefaultControllerError(this, e2);
        };
        WritableStreamDefaultController2.prototype[AbortSteps] = function(reason) {
          var result = this._abortAlgorithm(reason);
          WritableStreamDefaultControllerClearAlgorithms(this);
          return result;
        };
        WritableStreamDefaultController2.prototype[ErrorSteps] = function() {
          ResetQueue(this);
        };
        return WritableStreamDefaultController2;
      }();
      Object.defineProperties(WritableStreamDefaultController.prototype, {
        abortReason: { enumerable: true },
        signal: { enumerable: true },
        error: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
          value: "WritableStreamDefaultController",
          configurable: true
        });
      }
      function IsWritableStreamDefaultController(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_controlledWritableStream")) {
          return false;
        }
        return x instanceof WritableStreamDefaultController;
      }
      function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledWritableStream = stream;
        stream._writableStreamController = controller;
        controller._queue = void 0;
        controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._abortReason = void 0;
        controller._abortController = createAbortController();
        controller._started = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._writeAlgorithm = writeAlgorithm;
        controller._closeAlgorithm = closeAlgorithm;
        controller._abortAlgorithm = abortAlgorithm;
        var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream, backpressure);
        var startResult = startAlgorithm();
        var startPromise = promiseResolvedWith(startResult);
        uponPromise(startPromise, function() {
          controller._started = true;
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }, function(r) {
          controller._started = true;
          WritableStreamDealWithRejection(stream, r);
        });
      }
      function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
        var controller = Object.create(WritableStreamDefaultController.prototype);
        var startAlgorithm = function() {
          return void 0;
        };
        var writeAlgorithm = function() {
          return promiseResolvedWith(void 0);
        };
        var closeAlgorithm = function() {
          return promiseResolvedWith(void 0);
        };
        var abortAlgorithm = function() {
          return promiseResolvedWith(void 0);
        };
        if (underlyingSink.start !== void 0) {
          startAlgorithm = function() {
            return underlyingSink.start(controller);
          };
        }
        if (underlyingSink.write !== void 0) {
          writeAlgorithm = function(chunk) {
            return underlyingSink.write(chunk, controller);
          };
        }
        if (underlyingSink.close !== void 0) {
          closeAlgorithm = function() {
            return underlyingSink.close();
          };
        }
        if (underlyingSink.abort !== void 0) {
          abortAlgorithm = function(reason) {
            return underlyingSink.abort(reason);
          };
        }
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function WritableStreamDefaultControllerClearAlgorithms(controller) {
        controller._writeAlgorithm = void 0;
        controller._closeAlgorithm = void 0;
        controller._abortAlgorithm = void 0;
        controller._strategySizeAlgorithm = void 0;
      }
      function WritableStreamDefaultControllerClose(controller) {
        EnqueueValueWithSize(controller, closeSentinel, 0);
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
        try {
          return controller._strategySizeAlgorithm(chunk);
        } catch (chunkSizeE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
          return 1;
        }
      }
      function WritableStreamDefaultControllerGetDesiredSize(controller) {
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
        try {
          EnqueueValueWithSize(controller, chunk, chunkSize);
        } catch (enqueueE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
          return;
        }
        var stream = controller._controlledWritableStream;
        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
          var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
        }
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
        var stream = controller._controlledWritableStream;
        if (!controller._started) {
          return;
        }
        if (stream._inFlightWriteRequest !== void 0) {
          return;
        }
        var state = stream._state;
        if (state === "erroring") {
          WritableStreamFinishErroring(stream);
          return;
        }
        if (controller._queue.length === 0) {
          return;
        }
        var value = PeekQueueValue(controller);
        if (value === closeSentinel) {
          WritableStreamDefaultControllerProcessClose(controller);
        } else {
          WritableStreamDefaultControllerProcessWrite(controller, value);
        }
      }
      function WritableStreamDefaultControllerErrorIfNeeded(controller, error2) {
        if (controller._controlledWritableStream._state === "writable") {
          WritableStreamDefaultControllerError(controller, error2);
        }
      }
      function WritableStreamDefaultControllerProcessClose(controller) {
        var stream = controller._controlledWritableStream;
        WritableStreamMarkCloseRequestInFlight(stream);
        DequeueValue(controller);
        var sinkClosePromise = controller._closeAlgorithm();
        WritableStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(sinkClosePromise, function() {
          WritableStreamFinishInFlightClose(stream);
        }, function(reason) {
          WritableStreamFinishInFlightCloseWithError(stream, reason);
        });
      }
      function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
        var stream = controller._controlledWritableStream;
        WritableStreamMarkFirstWriteRequestInFlight(stream);
        var sinkWritePromise = controller._writeAlgorithm(chunk);
        uponPromise(sinkWritePromise, function() {
          WritableStreamFinishInFlightWrite(stream);
          var state = stream._state;
          DequeueValue(controller);
          if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
            var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }, function(reason) {
          if (stream._state === "writable") {
            WritableStreamDefaultControllerClearAlgorithms(controller);
          }
          WritableStreamFinishInFlightWriteWithError(stream, reason);
        });
      }
      function WritableStreamDefaultControllerGetBackpressure(controller) {
        var desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
        return desiredSize <= 0;
      }
      function WritableStreamDefaultControllerError(controller, error2) {
        var stream = controller._controlledWritableStream;
        WritableStreamDefaultControllerClearAlgorithms(controller);
        WritableStreamStartErroring(stream, error2);
      }
      function streamBrandCheckException$2(name) {
        return new TypeError("WritableStream.prototype." + name + " can only be used on a WritableStream");
      }
      function defaultControllerBrandCheckException$2(name) {
        return new TypeError("WritableStreamDefaultController.prototype." + name + " can only be used on a WritableStreamDefaultController");
      }
      function defaultWriterBrandCheckException(name) {
        return new TypeError("WritableStreamDefaultWriter.prototype." + name + " can only be used on a WritableStreamDefaultWriter");
      }
      function defaultWriterLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released writer");
      }
      function defaultWriterClosedPromiseInitialize(writer) {
        writer._closedPromise = newPromise(function(resolve2, reject2) {
          writer._closedPromise_resolve = resolve2;
          writer._closedPromise_reject = reject2;
          writer._closedPromiseState = "pending";
        });
      }
      function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseReject(writer, reason);
      }
      function defaultWriterClosedPromiseInitializeAsResolved(writer) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseResolve(writer);
      }
      function defaultWriterClosedPromiseReject(writer, reason) {
        if (writer._closedPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(writer._closedPromise);
        writer._closedPromise_reject(reason);
        writer._closedPromise_resolve = void 0;
        writer._closedPromise_reject = void 0;
        writer._closedPromiseState = "rejected";
      }
      function defaultWriterClosedPromiseResetToRejected(writer, reason) {
        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterClosedPromiseResolve(writer) {
        if (writer._closedPromise_resolve === void 0) {
          return;
        }
        writer._closedPromise_resolve(void 0);
        writer._closedPromise_resolve = void 0;
        writer._closedPromise_reject = void 0;
        writer._closedPromiseState = "resolved";
      }
      function defaultWriterReadyPromiseInitialize(writer) {
        writer._readyPromise = newPromise(function(resolve2, reject2) {
          writer._readyPromise_resolve = resolve2;
          writer._readyPromise_reject = reject2;
        });
        writer._readyPromiseState = "pending";
      }
      function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseReject(writer, reason);
      }
      function defaultWriterReadyPromiseInitializeAsResolved(writer) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseResolve(writer);
      }
      function defaultWriterReadyPromiseReject(writer, reason) {
        if (writer._readyPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(writer._readyPromise);
        writer._readyPromise_reject(reason);
        writer._readyPromise_resolve = void 0;
        writer._readyPromise_reject = void 0;
        writer._readyPromiseState = "rejected";
      }
      function defaultWriterReadyPromiseReset(writer) {
        defaultWriterReadyPromiseInitialize(writer);
      }
      function defaultWriterReadyPromiseResetToRejected(writer, reason) {
        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterReadyPromiseResolve(writer) {
        if (writer._readyPromise_resolve === void 0) {
          return;
        }
        writer._readyPromise_resolve(void 0);
        writer._readyPromise_resolve = void 0;
        writer._readyPromise_reject = void 0;
        writer._readyPromiseState = "fulfilled";
      }
      var NativeDOMException = typeof DOMException !== "undefined" ? DOMException : void 0;
      function isDOMExceptionConstructor(ctor) {
        if (!(typeof ctor === "function" || typeof ctor === "object")) {
          return false;
        }
        try {
          new ctor();
          return true;
        } catch (_a4) {
          return false;
        }
      }
      function createDOMExceptionPolyfill() {
        var ctor = function DOMException2(message, name) {
          this.message = message || "";
          this.name = name || "Error";
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          }
        };
        ctor.prototype = Object.create(Error.prototype);
        Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
        return ctor;
      }
      var DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
      function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
        var reader = AcquireReadableStreamDefaultReader(source);
        var writer = AcquireWritableStreamDefaultWriter(dest);
        source._disturbed = true;
        var shuttingDown = false;
        var currentWrite = promiseResolvedWith(void 0);
        return newPromise(function(resolve2, reject2) {
          var abortAlgorithm;
          if (signal !== void 0) {
            abortAlgorithm = function() {
              var error2 = new DOMException$1("Aborted", "AbortError");
              var actions = [];
              if (!preventAbort) {
                actions.push(function() {
                  if (dest._state === "writable") {
                    return WritableStreamAbort(dest, error2);
                  }
                  return promiseResolvedWith(void 0);
                });
              }
              if (!preventCancel) {
                actions.push(function() {
                  if (source._state === "readable") {
                    return ReadableStreamCancel(source, error2);
                  }
                  return promiseResolvedWith(void 0);
                });
              }
              shutdownWithAction(function() {
                return Promise.all(actions.map(function(action) {
                  return action();
                }));
              }, true, error2);
            };
            if (signal.aborted) {
              abortAlgorithm();
              return;
            }
            signal.addEventListener("abort", abortAlgorithm);
          }
          function pipeLoop() {
            return newPromise(function(resolveLoop, rejectLoop) {
              function next(done2) {
                if (done2) {
                  resolveLoop();
                } else {
                  PerformPromiseThen(pipeStep(), next, rejectLoop);
                }
              }
              next(false);
            });
          }
          function pipeStep() {
            if (shuttingDown) {
              return promiseResolvedWith(true);
            }
            return PerformPromiseThen(writer._readyPromise, function() {
              return newPromise(function(resolveRead, rejectRead) {
                ReadableStreamDefaultReaderRead(reader, {
                  _chunkSteps: function(chunk) {
                    currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop);
                    resolveRead(false);
                  },
                  _closeSteps: function() {
                    return resolveRead(true);
                  },
                  _errorSteps: rejectRead
                });
              });
            });
          }
          isOrBecomesErrored(source, reader._closedPromise, function(storedError) {
            if (!preventAbort) {
              shutdownWithAction(function() {
                return WritableStreamAbort(dest, storedError);
              }, true, storedError);
            } else {
              shutdown(true, storedError);
            }
          });
          isOrBecomesErrored(dest, writer._closedPromise, function(storedError) {
            if (!preventCancel) {
              shutdownWithAction(function() {
                return ReadableStreamCancel(source, storedError);
              }, true, storedError);
            } else {
              shutdown(true, storedError);
            }
          });
          isOrBecomesClosed(source, reader._closedPromise, function() {
            if (!preventClose) {
              shutdownWithAction(function() {
                return WritableStreamDefaultWriterCloseWithErrorPropagation(writer);
              });
            } else {
              shutdown();
            }
          });
          if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
            var destClosed_1 = new TypeError("the destination writable stream closed before all data could be piped to it");
            if (!preventCancel) {
              shutdownWithAction(function() {
                return ReadableStreamCancel(source, destClosed_1);
              }, true, destClosed_1);
            } else {
              shutdown(true, destClosed_1);
            }
          }
          setPromiseIsHandledToTrue(pipeLoop());
          function waitForWritesToFinish() {
            var oldCurrentWrite = currentWrite;
            return PerformPromiseThen(currentWrite, function() {
              return oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0;
            });
          }
          function isOrBecomesErrored(stream, promise, action) {
            if (stream._state === "errored") {
              action(stream._storedError);
            } else {
              uponRejection(promise, action);
            }
          }
          function isOrBecomesClosed(stream, promise, action) {
            if (stream._state === "closed") {
              action();
            } else {
              uponFulfillment(promise, action);
            }
          }
          function shutdownWithAction(action, originalIsError, originalError) {
            if (shuttingDown) {
              return;
            }
            shuttingDown = true;
            if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
              uponFulfillment(waitForWritesToFinish(), doTheRest);
            } else {
              doTheRest();
            }
            function doTheRest() {
              uponPromise(action(), function() {
                return finalize(originalIsError, originalError);
              }, function(newError) {
                return finalize(true, newError);
              });
            }
          }
          function shutdown(isError2, error2) {
            if (shuttingDown) {
              return;
            }
            shuttingDown = true;
            if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
              uponFulfillment(waitForWritesToFinish(), function() {
                return finalize(isError2, error2);
              });
            } else {
              finalize(isError2, error2);
            }
          }
          function finalize(isError2, error2) {
            WritableStreamDefaultWriterRelease(writer);
            ReadableStreamReaderGenericRelease(reader);
            if (signal !== void 0) {
              signal.removeEventListener("abort", abortAlgorithm);
            }
            if (isError2) {
              reject2(error2);
            } else {
              resolve2(void 0);
            }
          }
        });
      }
      var ReadableStreamDefaultController = function() {
        function ReadableStreamDefaultController2() {
          throw new TypeError("Illegal constructor");
        }
        Object.defineProperty(ReadableStreamDefaultController2.prototype, "desiredSize", {
          get: function() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("desiredSize");
            }
            return ReadableStreamDefaultControllerGetDesiredSize(this);
          },
          enumerable: false,
          configurable: true
        });
        ReadableStreamDefaultController2.prototype.close = function() {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("close");
          }
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
            throw new TypeError("The stream is not in a state that permits close");
          }
          ReadableStreamDefaultControllerClose(this);
        };
        ReadableStreamDefaultController2.prototype.enqueue = function(chunk) {
          if (chunk === void 0) {
            chunk = void 0;
          }
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("enqueue");
          }
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
            throw new TypeError("The stream is not in a state that permits enqueue");
          }
          return ReadableStreamDefaultControllerEnqueue(this, chunk);
        };
        ReadableStreamDefaultController2.prototype.error = function(e2) {
          if (e2 === void 0) {
            e2 = void 0;
          }
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("error");
          }
          ReadableStreamDefaultControllerError(this, e2);
        };
        ReadableStreamDefaultController2.prototype[CancelSteps] = function(reason) {
          ResetQueue(this);
          var result = this._cancelAlgorithm(reason);
          ReadableStreamDefaultControllerClearAlgorithms(this);
          return result;
        };
        ReadableStreamDefaultController2.prototype[PullSteps] = function(readRequest) {
          var stream = this._controlledReadableStream;
          if (this._queue.length > 0) {
            var chunk = DequeueValue(this);
            if (this._closeRequested && this._queue.length === 0) {
              ReadableStreamDefaultControllerClearAlgorithms(this);
              ReadableStreamClose(stream);
            } else {
              ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
            readRequest._chunkSteps(chunk);
          } else {
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableStreamDefaultControllerCallPullIfNeeded(this);
          }
        };
        return ReadableStreamDefaultController2;
      }();
      Object.defineProperties(ReadableStreamDefaultController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamDefaultController",
          configurable: true
        });
      }
      function IsReadableStreamDefaultController(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableStream")) {
          return false;
        }
        return x instanceof ReadableStreamDefaultController;
      }
      function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
        var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
        if (!shouldPull) {
          return;
        }
        if (controller._pulling) {
          controller._pullAgain = true;
          return;
        }
        controller._pulling = true;
        var pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, function() {
          controller._pulling = false;
          if (controller._pullAgain) {
            controller._pullAgain = false;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }
        }, function(e2) {
          ReadableStreamDefaultControllerError(controller, e2);
        });
      }
      function ReadableStreamDefaultControllerShouldCallPull(controller) {
        var stream = controller._controlledReadableStream;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return false;
        }
        if (!controller._started) {
          return false;
        }
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          return true;
        }
        var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
          return true;
        }
        return false;
      }
      function ReadableStreamDefaultControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
        controller._strategySizeAlgorithm = void 0;
      }
      function ReadableStreamDefaultControllerClose(controller) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return;
        }
        var stream = controller._controlledReadableStream;
        controller._closeRequested = true;
        if (controller._queue.length === 0) {
          ReadableStreamDefaultControllerClearAlgorithms(controller);
          ReadableStreamClose(stream);
        }
      }
      function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return;
        }
        var stream = controller._controlledReadableStream;
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          ReadableStreamFulfillReadRequest(stream, chunk, false);
        } else {
          var chunkSize = void 0;
          try {
            chunkSize = controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            ReadableStreamDefaultControllerError(controller, chunkSizeE);
            throw chunkSizeE;
          }
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
          } catch (enqueueE) {
            ReadableStreamDefaultControllerError(controller, enqueueE);
            throw enqueueE;
          }
        }
        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
      }
      function ReadableStreamDefaultControllerError(controller, e2) {
        var stream = controller._controlledReadableStream;
        if (stream._state !== "readable") {
          return;
        }
        ResetQueue(controller);
        ReadableStreamDefaultControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e2);
      }
      function ReadableStreamDefaultControllerGetDesiredSize(controller) {
        var state = controller._controlledReadableStream._state;
        if (state === "errored") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableStreamDefaultControllerHasBackpressure(controller) {
        if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
          return false;
        }
        return true;
      }
      function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
        var state = controller._controlledReadableStream._state;
        if (!controller._closeRequested && state === "readable") {
          return true;
        }
        return false;
      }
      function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledReadableStream = stream;
        controller._queue = void 0;
        controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._started = false;
        controller._closeRequested = false;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        stream._readableStreamController = controller;
        var startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), function() {
          controller._started = true;
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }, function(r) {
          ReadableStreamDefaultControllerError(controller, r);
        });
      }
      function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
        var controller = Object.create(ReadableStreamDefaultController.prototype);
        var startAlgorithm = function() {
          return void 0;
        };
        var pullAlgorithm = function() {
          return promiseResolvedWith(void 0);
        };
        var cancelAlgorithm = function() {
          return promiseResolvedWith(void 0);
        };
        if (underlyingSource.start !== void 0) {
          startAlgorithm = function() {
            return underlyingSource.start(controller);
          };
        }
        if (underlyingSource.pull !== void 0) {
          pullAlgorithm = function() {
            return underlyingSource.pull(controller);
          };
        }
        if (underlyingSource.cancel !== void 0) {
          cancelAlgorithm = function(reason) {
            return underlyingSource.cancel(reason);
          };
        }
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function defaultControllerBrandCheckException$1(name) {
        return new TypeError("ReadableStreamDefaultController.prototype." + name + " can only be used on a ReadableStreamDefaultController");
      }
      function ReadableStreamTee(stream, cloneForBranch2) {
        if (IsReadableByteStreamController(stream._readableStreamController)) {
          return ReadableByteStreamTee(stream);
        }
        return ReadableStreamDefaultTee(stream);
      }
      function ReadableStreamDefaultTee(stream, cloneForBranch2) {
        var reader = AcquireReadableStreamDefaultReader(stream);
        var reading = false;
        var readAgain = false;
        var canceled1 = false;
        var canceled2 = false;
        var reason1;
        var reason2;
        var branch1;
        var branch2;
        var resolveCancelPromise;
        var cancelPromise = newPromise(function(resolve2) {
          resolveCancelPromise = resolve2;
        });
        function pullAlgorithm() {
          if (reading) {
            readAgain = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          var readRequest = {
            _chunkSteps: function(chunk) {
              queueMicrotask2(function() {
                readAgain = false;
                var chunk1 = chunk;
                var chunk2 = chunk;
                if (!canceled1) {
                  ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                }
                if (!canceled2) {
                  ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                }
                reading = false;
                if (readAgain) {
                  pullAlgorithm();
                }
              });
            },
            _closeSteps: function() {
              reading = false;
              if (!canceled1) {
                ReadableStreamDefaultControllerClose(branch1._readableStreamController);
              }
              if (!canceled2) {
                ReadableStreamDefaultControllerClose(branch2._readableStreamController);
              }
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: function() {
              reading = false;
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
          return promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          canceled1 = true;
          reason1 = reason;
          if (canceled2) {
            var compositeReason = CreateArrayFromList([reason1, reason2]);
            var cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          canceled2 = true;
          reason2 = reason;
          if (canceled1) {
            var compositeReason = CreateArrayFromList([reason1, reason2]);
            var cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
        }
        branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
        branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
        uponRejection(reader._closedPromise, function(r) {
          ReadableStreamDefaultControllerError(branch1._readableStreamController, r);
          ReadableStreamDefaultControllerError(branch2._readableStreamController, r);
          if (!canceled1 || !canceled2) {
            resolveCancelPromise(void 0);
          }
        });
        return [branch1, branch2];
      }
      function ReadableByteStreamTee(stream) {
        var reader = AcquireReadableStreamDefaultReader(stream);
        var reading = false;
        var readAgainForBranch1 = false;
        var readAgainForBranch2 = false;
        var canceled1 = false;
        var canceled2 = false;
        var reason1;
        var reason2;
        var branch1;
        var branch2;
        var resolveCancelPromise;
        var cancelPromise = newPromise(function(resolve2) {
          resolveCancelPromise = resolve2;
        });
        function forwardReaderError(thisReader) {
          uponRejection(thisReader._closedPromise, function(r) {
            if (thisReader !== reader) {
              return;
            }
            ReadableByteStreamControllerError(branch1._readableStreamController, r);
            ReadableByteStreamControllerError(branch2._readableStreamController, r);
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(void 0);
            }
          });
        }
        function pullWithDefaultReader() {
          if (IsReadableStreamBYOBReader(reader)) {
            ReadableStreamReaderGenericRelease(reader);
            reader = AcquireReadableStreamDefaultReader(stream);
            forwardReaderError(reader);
          }
          var readRequest = {
            _chunkSteps: function(chunk) {
              queueMicrotask2(function() {
                readAgainForBranch1 = false;
                readAgainForBranch2 = false;
                var chunk1 = chunk;
                var chunk2 = chunk;
                if (!canceled1 && !canceled2) {
                  try {
                    chunk2 = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                    ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                    resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                }
                if (!canceled1) {
                  ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                }
                if (!canceled2) {
                  ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                }
                reading = false;
                if (readAgainForBranch1) {
                  pull1Algorithm();
                } else if (readAgainForBranch2) {
                  pull2Algorithm();
                }
              });
            },
            _closeSteps: function() {
              reading = false;
              if (!canceled1) {
                ReadableByteStreamControllerClose(branch1._readableStreamController);
              }
              if (!canceled2) {
                ReadableByteStreamControllerClose(branch2._readableStreamController);
              }
              if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
              }
              if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
              }
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: function() {
              reading = false;
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
        }
        function pullWithBYOBReader(view, forBranch2) {
          if (IsReadableStreamDefaultReader(reader)) {
            ReadableStreamReaderGenericRelease(reader);
            reader = AcquireReadableStreamBYOBReader(stream);
            forwardReaderError(reader);
          }
          var byobBranch = forBranch2 ? branch2 : branch1;
          var otherBranch = forBranch2 ? branch1 : branch2;
          var readIntoRequest = {
            _chunkSteps: function(chunk) {
              queueMicrotask2(function() {
                readAgainForBranch1 = false;
                readAgainForBranch2 = false;
                var byobCanceled = forBranch2 ? canceled2 : canceled1;
                var otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (!otherCanceled) {
                  var clonedChunk = void 0;
                  try {
                    clonedChunk = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                    ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                    resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                  if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                } else if (!byobCanceled) {
                  ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                }
                reading = false;
                if (readAgainForBranch1) {
                  pull1Algorithm();
                } else if (readAgainForBranch2) {
                  pull2Algorithm();
                }
              });
            },
            _closeSteps: function(chunk) {
              reading = false;
              var byobCanceled = forBranch2 ? canceled2 : canceled1;
              var otherCanceled = forBranch2 ? canceled1 : canceled2;
              if (!byobCanceled) {
                ReadableByteStreamControllerClose(byobBranch._readableStreamController);
              }
              if (!otherCanceled) {
                ReadableByteStreamControllerClose(otherBranch._readableStreamController);
              }
              if (chunk !== void 0) {
                if (!byobCanceled) {
                  ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                }
                if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                }
              }
              if (!byobCanceled || !otherCanceled) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: function() {
              reading = false;
            }
          };
          ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
        }
        function pull1Algorithm() {
          if (reading) {
            readAgainForBranch1 = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          var byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
          if (byobRequest === null) {
            pullWithDefaultReader();
          } else {
            pullWithBYOBReader(byobRequest._view, false);
          }
          return promiseResolvedWith(void 0);
        }
        function pull2Algorithm() {
          if (reading) {
            readAgainForBranch2 = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          var byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
          if (byobRequest === null) {
            pullWithDefaultReader();
          } else {
            pullWithBYOBReader(byobRequest._view, true);
          }
          return promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          canceled1 = true;
          reason1 = reason;
          if (canceled2) {
            var compositeReason = CreateArrayFromList([reason1, reason2]);
            var cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          canceled2 = true;
          reason2 = reason;
          if (canceled1) {
            var compositeReason = CreateArrayFromList([reason1, reason2]);
            var cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
          return;
        }
        branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
        branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
        forwardReaderError(reader);
        return [branch1, branch2];
      }
      function convertUnderlyingDefaultOrByteSource(source, context) {
        assertDictionary(source, context);
        var original = source;
        var autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
        var cancel = original === null || original === void 0 ? void 0 : original.cancel;
        var pull = original === null || original === void 0 ? void 0 : original.pull;
        var start = original === null || original === void 0 ? void 0 : original.start;
        var type = original === null || original === void 0 ? void 0 : original.type;
        return {
          autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, context + " has member 'autoAllocateChunkSize' that"),
          cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, context + " has member 'cancel' that"),
          pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, context + " has member 'pull' that"),
          start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, context + " has member 'start' that"),
          type: type === void 0 ? void 0 : convertReadableStreamType(type, context + " has member 'type' that")
        };
      }
      function convertUnderlyingSourceCancelCallback(fn2, original, context) {
        assertFunction(fn2, context);
        return function(reason) {
          return promiseCall(fn2, original, [reason]);
        };
      }
      function convertUnderlyingSourcePullCallback(fn2, original, context) {
        assertFunction(fn2, context);
        return function(controller) {
          return promiseCall(fn2, original, [controller]);
        };
      }
      function convertUnderlyingSourceStartCallback(fn2, original, context) {
        assertFunction(fn2, context);
        return function(controller) {
          return reflectCall(fn2, original, [controller]);
        };
      }
      function convertReadableStreamType(type, context) {
        type = "" + type;
        if (type !== "bytes") {
          throw new TypeError(context + " '" + type + "' is not a valid enumeration value for ReadableStreamType");
        }
        return type;
      }
      function convertReaderOptions(options2, context) {
        assertDictionary(options2, context);
        var mode = options2 === null || options2 === void 0 ? void 0 : options2.mode;
        return {
          mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, context + " has member 'mode' that")
        };
      }
      function convertReadableStreamReaderMode(mode, context) {
        mode = "" + mode;
        if (mode !== "byob") {
          throw new TypeError(context + " '" + mode + "' is not a valid enumeration value for ReadableStreamReaderMode");
        }
        return mode;
      }
      function convertIteratorOptions(options2, context) {
        assertDictionary(options2, context);
        var preventCancel = options2 === null || options2 === void 0 ? void 0 : options2.preventCancel;
        return { preventCancel: Boolean(preventCancel) };
      }
      function convertPipeOptions(options2, context) {
        assertDictionary(options2, context);
        var preventAbort = options2 === null || options2 === void 0 ? void 0 : options2.preventAbort;
        var preventCancel = options2 === null || options2 === void 0 ? void 0 : options2.preventCancel;
        var preventClose = options2 === null || options2 === void 0 ? void 0 : options2.preventClose;
        var signal = options2 === null || options2 === void 0 ? void 0 : options2.signal;
        if (signal !== void 0) {
          assertAbortSignal(signal, context + " has member 'signal' that");
        }
        return {
          preventAbort: Boolean(preventAbort),
          preventCancel: Boolean(preventCancel),
          preventClose: Boolean(preventClose),
          signal
        };
      }
      function assertAbortSignal(signal, context) {
        if (!isAbortSignal(signal)) {
          throw new TypeError(context + " is not an AbortSignal.");
        }
      }
      function convertReadableWritablePair(pair, context) {
        assertDictionary(pair, context);
        var readable = pair === null || pair === void 0 ? void 0 : pair.readable;
        assertRequiredField(readable, "readable", "ReadableWritablePair");
        assertReadableStream(readable, context + " has member 'readable' that");
        var writable = pair === null || pair === void 0 ? void 0 : pair.writable;
        assertRequiredField(writable, "writable", "ReadableWritablePair");
        assertWritableStream(writable, context + " has member 'writable' that");
        return { readable, writable };
      }
      var ReadableStream2 = function() {
        function ReadableStream3(rawUnderlyingSource, rawStrategy) {
          if (rawUnderlyingSource === void 0) {
            rawUnderlyingSource = {};
          }
          if (rawStrategy === void 0) {
            rawStrategy = {};
          }
          if (rawUnderlyingSource === void 0) {
            rawUnderlyingSource = null;
          } else {
            assertObject(rawUnderlyingSource, "First parameter");
          }
          var strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
          var underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
          InitializeReadableStream(this);
          if (underlyingSource.type === "bytes") {
            if (strategy.size !== void 0) {
              throw new RangeError("The strategy for a byte stream cannot have a size function");
            }
            var highWaterMark = ExtractHighWaterMark(strategy, 0);
            SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
          } else {
            var sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            var highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
          }
        }
        Object.defineProperty(ReadableStream3.prototype, "locked", {
          get: function() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("locked");
            }
            return IsReadableStreamLocked(this);
          },
          enumerable: false,
          configurable: true
        });
        ReadableStream3.prototype.cancel = function(reason) {
          if (reason === void 0) {
            reason = void 0;
          }
          if (!IsReadableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$1("cancel"));
          }
          if (IsReadableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
          }
          return ReadableStreamCancel(this, reason);
        };
        ReadableStream3.prototype.getReader = function(rawOptions) {
          if (rawOptions === void 0) {
            rawOptions = void 0;
          }
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("getReader");
          }
          var options2 = convertReaderOptions(rawOptions, "First parameter");
          if (options2.mode === void 0) {
            return AcquireReadableStreamDefaultReader(this);
          }
          return AcquireReadableStreamBYOBReader(this);
        };
        ReadableStream3.prototype.pipeThrough = function(rawTransform, rawOptions) {
          if (rawOptions === void 0) {
            rawOptions = {};
          }
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("pipeThrough");
          }
          assertRequiredArgument(rawTransform, 1, "pipeThrough");
          var transform = convertReadableWritablePair(rawTransform, "First parameter");
          var options2 = convertPipeOptions(rawOptions, "Second parameter");
          if (IsReadableStreamLocked(this)) {
            throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
          }
          if (IsWritableStreamLocked(transform.writable)) {
            throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
          }
          var promise = ReadableStreamPipeTo(this, transform.writable, options2.preventClose, options2.preventAbort, options2.preventCancel, options2.signal);
          setPromiseIsHandledToTrue(promise);
          return transform.readable;
        };
        ReadableStream3.prototype.pipeTo = function(destination, rawOptions) {
          if (rawOptions === void 0) {
            rawOptions = {};
          }
          if (!IsReadableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
          }
          if (destination === void 0) {
            return promiseRejectedWith("Parameter 1 is required in 'pipeTo'.");
          }
          if (!IsWritableStream(destination)) {
            return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
          }
          var options2;
          try {
            options2 = convertPipeOptions(rawOptions, "Second parameter");
          } catch (e2) {
            return promiseRejectedWith(e2);
          }
          if (IsReadableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
          }
          if (IsWritableStreamLocked(destination)) {
            return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
          }
          return ReadableStreamPipeTo(this, destination, options2.preventClose, options2.preventAbort, options2.preventCancel, options2.signal);
        };
        ReadableStream3.prototype.tee = function() {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("tee");
          }
          var branches = ReadableStreamTee(this);
          return CreateArrayFromList(branches);
        };
        ReadableStream3.prototype.values = function(rawOptions) {
          if (rawOptions === void 0) {
            rawOptions = void 0;
          }
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("values");
          }
          var options2 = convertIteratorOptions(rawOptions, "First parameter");
          return AcquireReadableStreamAsyncIterator(this, options2.preventCancel);
        };
        return ReadableStream3;
      }();
      Object.defineProperties(ReadableStream2.prototype, {
        cancel: { enumerable: true },
        getReader: { enumerable: true },
        pipeThrough: { enumerable: true },
        pipeTo: { enumerable: true },
        tee: { enumerable: true },
        values: { enumerable: true },
        locked: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStream",
          configurable: true
        });
      }
      if (typeof SymbolPolyfill.asyncIterator === "symbol") {
        Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.asyncIterator, {
          value: ReadableStream2.prototype.values,
          writable: true,
          configurable: true
        });
      }
      function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        if (highWaterMark === void 0) {
          highWaterMark = 1;
        }
        if (sizeAlgorithm === void 0) {
          sizeAlgorithm = function() {
            return 1;
          };
        }
        var stream = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream);
        var controller = Object.create(ReadableStreamDefaultController.prototype);
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
      }
      function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
        var stream = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream);
        var controller = Object.create(ReadableByteStreamController.prototype);
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
        return stream;
      }
      function InitializeReadableStream(stream) {
        stream._state = "readable";
        stream._reader = void 0;
        stream._storedError = void 0;
        stream._disturbed = false;
      }
      function IsReadableStream(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_readableStreamController")) {
          return false;
        }
        return x instanceof ReadableStream2;
      }
      function IsReadableStreamLocked(stream) {
        if (stream._reader === void 0) {
          return false;
        }
        return true;
      }
      function ReadableStreamCancel(stream, reason) {
        stream._disturbed = true;
        if (stream._state === "closed") {
          return promiseResolvedWith(void 0);
        }
        if (stream._state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        ReadableStreamClose(stream);
        var reader = stream._reader;
        if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
          reader._readIntoRequests.forEach(function(readIntoRequest) {
            readIntoRequest._closeSteps(void 0);
          });
          reader._readIntoRequests = new SimpleQueue();
        }
        var sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
        return transformPromiseWith(sourceCancelPromise, noop);
      }
      function ReadableStreamClose(stream) {
        stream._state = "closed";
        var reader = stream._reader;
        if (reader === void 0) {
          return;
        }
        defaultReaderClosedPromiseResolve(reader);
        if (IsReadableStreamDefaultReader(reader)) {
          reader._readRequests.forEach(function(readRequest) {
            readRequest._closeSteps();
          });
          reader._readRequests = new SimpleQueue();
        }
      }
      function ReadableStreamError(stream, e2) {
        stream._state = "errored";
        stream._storedError = e2;
        var reader = stream._reader;
        if (reader === void 0) {
          return;
        }
        defaultReaderClosedPromiseReject(reader, e2);
        if (IsReadableStreamDefaultReader(reader)) {
          reader._readRequests.forEach(function(readRequest) {
            readRequest._errorSteps(e2);
          });
          reader._readRequests = new SimpleQueue();
        } else {
          reader._readIntoRequests.forEach(function(readIntoRequest) {
            readIntoRequest._errorSteps(e2);
          });
          reader._readIntoRequests = new SimpleQueue();
        }
      }
      function streamBrandCheckException$1(name) {
        return new TypeError("ReadableStream.prototype." + name + " can only be used on a ReadableStream");
      }
      function convertQueuingStrategyInit(init, context) {
        assertDictionary(init, context);
        var highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
        assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
        return {
          highWaterMark: convertUnrestrictedDouble(highWaterMark)
        };
      }
      var byteLengthSizeFunction = function(chunk) {
        return chunk.byteLength;
      };
      try {
        Object.defineProperty(byteLengthSizeFunction, "name", {
          value: "size",
          configurable: true
        });
      } catch (_a4) {
      }
      var ByteLengthQueuingStrategy = function() {
        function ByteLengthQueuingStrategy2(options2) {
          assertRequiredArgument(options2, 1, "ByteLengthQueuingStrategy");
          options2 = convertQueuingStrategyInit(options2, "First parameter");
          this._byteLengthQueuingStrategyHighWaterMark = options2.highWaterMark;
        }
        Object.defineProperty(ByteLengthQueuingStrategy2.prototype, "highWaterMark", {
          get: function() {
            if (!IsByteLengthQueuingStrategy(this)) {
              throw byteLengthBrandCheckException("highWaterMark");
            }
            return this._byteLengthQueuingStrategyHighWaterMark;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(ByteLengthQueuingStrategy2.prototype, "size", {
          get: function() {
            if (!IsByteLengthQueuingStrategy(this)) {
              throw byteLengthBrandCheckException("size");
            }
            return byteLengthSizeFunction;
          },
          enumerable: false,
          configurable: true
        });
        return ByteLengthQueuingStrategy2;
      }();
      Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
          value: "ByteLengthQueuingStrategy",
          configurable: true
        });
      }
      function byteLengthBrandCheckException(name) {
        return new TypeError("ByteLengthQueuingStrategy.prototype." + name + " can only be used on a ByteLengthQueuingStrategy");
      }
      function IsByteLengthQueuingStrategy(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_byteLengthQueuingStrategyHighWaterMark")) {
          return false;
        }
        return x instanceof ByteLengthQueuingStrategy;
      }
      var countSizeFunction = function() {
        return 1;
      };
      try {
        Object.defineProperty(countSizeFunction, "name", {
          value: "size",
          configurable: true
        });
      } catch (_a4) {
      }
      var CountQueuingStrategy = function() {
        function CountQueuingStrategy2(options2) {
          assertRequiredArgument(options2, 1, "CountQueuingStrategy");
          options2 = convertQueuingStrategyInit(options2, "First parameter");
          this._countQueuingStrategyHighWaterMark = options2.highWaterMark;
        }
        Object.defineProperty(CountQueuingStrategy2.prototype, "highWaterMark", {
          get: function() {
            if (!IsCountQueuingStrategy(this)) {
              throw countBrandCheckException("highWaterMark");
            }
            return this._countQueuingStrategyHighWaterMark;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(CountQueuingStrategy2.prototype, "size", {
          get: function() {
            if (!IsCountQueuingStrategy(this)) {
              throw countBrandCheckException("size");
            }
            return countSizeFunction;
          },
          enumerable: false,
          configurable: true
        });
        return CountQueuingStrategy2;
      }();
      Object.defineProperties(CountQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
          value: "CountQueuingStrategy",
          configurable: true
        });
      }
      function countBrandCheckException(name) {
        return new TypeError("CountQueuingStrategy.prototype." + name + " can only be used on a CountQueuingStrategy");
      }
      function IsCountQueuingStrategy(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_countQueuingStrategyHighWaterMark")) {
          return false;
        }
        return x instanceof CountQueuingStrategy;
      }
      function convertTransformer(original, context) {
        assertDictionary(original, context);
        var flush = original === null || original === void 0 ? void 0 : original.flush;
        var readableType = original === null || original === void 0 ? void 0 : original.readableType;
        var start = original === null || original === void 0 ? void 0 : original.start;
        var transform = original === null || original === void 0 ? void 0 : original.transform;
        var writableType = original === null || original === void 0 ? void 0 : original.writableType;
        return {
          flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, context + " has member 'flush' that"),
          readableType,
          start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, context + " has member 'start' that"),
          transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, context + " has member 'transform' that"),
          writableType
        };
      }
      function convertTransformerFlushCallback(fn2, original, context) {
        assertFunction(fn2, context);
        return function(controller) {
          return promiseCall(fn2, original, [controller]);
        };
      }
      function convertTransformerStartCallback(fn2, original, context) {
        assertFunction(fn2, context);
        return function(controller) {
          return reflectCall(fn2, original, [controller]);
        };
      }
      function convertTransformerTransformCallback(fn2, original, context) {
        assertFunction(fn2, context);
        return function(chunk, controller) {
          return promiseCall(fn2, original, [chunk, controller]);
        };
      }
      var TransformStream = function() {
        function TransformStream2(rawTransformer, rawWritableStrategy, rawReadableStrategy) {
          if (rawTransformer === void 0) {
            rawTransformer = {};
          }
          if (rawWritableStrategy === void 0) {
            rawWritableStrategy = {};
          }
          if (rawReadableStrategy === void 0) {
            rawReadableStrategy = {};
          }
          if (rawTransformer === void 0) {
            rawTransformer = null;
          }
          var writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
          var readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
          var transformer = convertTransformer(rawTransformer, "First parameter");
          if (transformer.readableType !== void 0) {
            throw new RangeError("Invalid readableType specified");
          }
          if (transformer.writableType !== void 0) {
            throw new RangeError("Invalid writableType specified");
          }
          var readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
          var readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
          var writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
          var writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
          var startPromise_resolve;
          var startPromise = newPromise(function(resolve2) {
            startPromise_resolve = resolve2;
          });
          InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
          SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
          if (transformer.start !== void 0) {
            startPromise_resolve(transformer.start(this._transformStreamController));
          } else {
            startPromise_resolve(void 0);
          }
        }
        Object.defineProperty(TransformStream2.prototype, "readable", {
          get: function() {
            if (!IsTransformStream(this)) {
              throw streamBrandCheckException("readable");
            }
            return this._readable;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(TransformStream2.prototype, "writable", {
          get: function() {
            if (!IsTransformStream(this)) {
              throw streamBrandCheckException("writable");
            }
            return this._writable;
          },
          enumerable: false,
          configurable: true
        });
        return TransformStream2;
      }();
      Object.defineProperties(TransformStream.prototype, {
        readable: { enumerable: true },
        writable: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
          value: "TransformStream",
          configurable: true
        });
      }
      function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
        function startAlgorithm() {
          return startPromise;
        }
        function writeAlgorithm(chunk) {
          return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
        }
        function abortAlgorithm(reason) {
          return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
        }
        function closeAlgorithm() {
          return TransformStreamDefaultSinkCloseAlgorithm(stream);
        }
        stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
        function pullAlgorithm() {
          return TransformStreamDefaultSourcePullAlgorithm(stream);
        }
        function cancelAlgorithm(reason) {
          TransformStreamErrorWritableAndUnblockWrite(stream, reason);
          return promiseResolvedWith(void 0);
        }
        stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
        stream._backpressure = void 0;
        stream._backpressureChangePromise = void 0;
        stream._backpressureChangePromise_resolve = void 0;
        TransformStreamSetBackpressure(stream, true);
        stream._transformStreamController = void 0;
      }
      function IsTransformStream(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_transformStreamController")) {
          return false;
        }
        return x instanceof TransformStream;
      }
      function TransformStreamError(stream, e2) {
        ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e2);
        TransformStreamErrorWritableAndUnblockWrite(stream, e2);
      }
      function TransformStreamErrorWritableAndUnblockWrite(stream, e2) {
        TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
        WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e2);
        if (stream._backpressure) {
          TransformStreamSetBackpressure(stream, false);
        }
      }
      function TransformStreamSetBackpressure(stream, backpressure) {
        if (stream._backpressureChangePromise !== void 0) {
          stream._backpressureChangePromise_resolve();
        }
        stream._backpressureChangePromise = newPromise(function(resolve2) {
          stream._backpressureChangePromise_resolve = resolve2;
        });
        stream._backpressure = backpressure;
      }
      var TransformStreamDefaultController = function() {
        function TransformStreamDefaultController2() {
          throw new TypeError("Illegal constructor");
        }
        Object.defineProperty(TransformStreamDefaultController2.prototype, "desiredSize", {
          get: function() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("desiredSize");
            }
            var readableController = this._controlledTransformStream._readable._readableStreamController;
            return ReadableStreamDefaultControllerGetDesiredSize(readableController);
          },
          enumerable: false,
          configurable: true
        });
        TransformStreamDefaultController2.prototype.enqueue = function(chunk) {
          if (chunk === void 0) {
            chunk = void 0;
          }
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("enqueue");
          }
          TransformStreamDefaultControllerEnqueue(this, chunk);
        };
        TransformStreamDefaultController2.prototype.error = function(reason) {
          if (reason === void 0) {
            reason = void 0;
          }
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("error");
          }
          TransformStreamDefaultControllerError(this, reason);
        };
        TransformStreamDefaultController2.prototype.terminate = function() {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("terminate");
          }
          TransformStreamDefaultControllerTerminate(this);
        };
        return TransformStreamDefaultController2;
      }();
      Object.defineProperties(TransformStreamDefaultController.prototype, {
        enqueue: { enumerable: true },
        error: { enumerable: true },
        terminate: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
          value: "TransformStreamDefaultController",
          configurable: true
        });
      }
      function IsTransformStreamDefaultController(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_controlledTransformStream")) {
          return false;
        }
        return x instanceof TransformStreamDefaultController;
      }
      function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
        controller._controlledTransformStream = stream;
        stream._transformStreamController = controller;
        controller._transformAlgorithm = transformAlgorithm;
        controller._flushAlgorithm = flushAlgorithm;
      }
      function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
        var controller = Object.create(TransformStreamDefaultController.prototype);
        var transformAlgorithm = function(chunk) {
          try {
            TransformStreamDefaultControllerEnqueue(controller, chunk);
            return promiseResolvedWith(void 0);
          } catch (transformResultE) {
            return promiseRejectedWith(transformResultE);
          }
        };
        var flushAlgorithm = function() {
          return promiseResolvedWith(void 0);
        };
        if (transformer.transform !== void 0) {
          transformAlgorithm = function(chunk) {
            return transformer.transform(chunk, controller);
          };
        }
        if (transformer.flush !== void 0) {
          flushAlgorithm = function() {
            return transformer.flush(controller);
          };
        }
        SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
      }
      function TransformStreamDefaultControllerClearAlgorithms(controller) {
        controller._transformAlgorithm = void 0;
        controller._flushAlgorithm = void 0;
      }
      function TransformStreamDefaultControllerEnqueue(controller, chunk) {
        var stream = controller._controlledTransformStream;
        var readableController = stream._readable._readableStreamController;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
          throw new TypeError("Readable side is not in a state that permits enqueue");
        }
        try {
          ReadableStreamDefaultControllerEnqueue(readableController, chunk);
        } catch (e2) {
          TransformStreamErrorWritableAndUnblockWrite(stream, e2);
          throw stream._readable._storedError;
        }
        var backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
        if (backpressure !== stream._backpressure) {
          TransformStreamSetBackpressure(stream, true);
        }
      }
      function TransformStreamDefaultControllerError(controller, e2) {
        TransformStreamError(controller._controlledTransformStream, e2);
      }
      function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
        var transformPromise = controller._transformAlgorithm(chunk);
        return transformPromiseWith(transformPromise, void 0, function(r) {
          TransformStreamError(controller._controlledTransformStream, r);
          throw r;
        });
      }
      function TransformStreamDefaultControllerTerminate(controller) {
        var stream = controller._controlledTransformStream;
        var readableController = stream._readable._readableStreamController;
        ReadableStreamDefaultControllerClose(readableController);
        var error2 = new TypeError("TransformStream terminated");
        TransformStreamErrorWritableAndUnblockWrite(stream, error2);
      }
      function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
        var controller = stream._transformStreamController;
        if (stream._backpressure) {
          var backpressureChangePromise = stream._backpressureChangePromise;
          return transformPromiseWith(backpressureChangePromise, function() {
            var writable = stream._writable;
            var state = writable._state;
            if (state === "erroring") {
              throw writable._storedError;
            }
            return TransformStreamDefaultControllerPerformTransform(controller, chunk);
          });
        }
        return TransformStreamDefaultControllerPerformTransform(controller, chunk);
      }
      function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
        TransformStreamError(stream, reason);
        return promiseResolvedWith(void 0);
      }
      function TransformStreamDefaultSinkCloseAlgorithm(stream) {
        var readable = stream._readable;
        var controller = stream._transformStreamController;
        var flushPromise = controller._flushAlgorithm();
        TransformStreamDefaultControllerClearAlgorithms(controller);
        return transformPromiseWith(flushPromise, function() {
          if (readable._state === "errored") {
            throw readable._storedError;
          }
          ReadableStreamDefaultControllerClose(readable._readableStreamController);
        }, function(r) {
          TransformStreamError(stream, r);
          throw readable._storedError;
        });
      }
      function TransformStreamDefaultSourcePullAlgorithm(stream) {
        TransformStreamSetBackpressure(stream, false);
        return stream._backpressureChangePromise;
      }
      function defaultControllerBrandCheckException(name) {
        return new TypeError("TransformStreamDefaultController.prototype." + name + " can only be used on a TransformStreamDefaultController");
      }
      function streamBrandCheckException(name) {
        return new TypeError("TransformStream.prototype." + name + " can only be used on a TransformStream");
      }
      exports3.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
      exports3.CountQueuingStrategy = CountQueuingStrategy;
      exports3.ReadableByteStreamController = ReadableByteStreamController;
      exports3.ReadableStream = ReadableStream2;
      exports3.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
      exports3.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
      exports3.ReadableStreamDefaultController = ReadableStreamDefaultController;
      exports3.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
      exports3.TransformStream = TransformStream;
      exports3.TransformStreamDefaultController = TransformStreamDefaultController;
      exports3.WritableStream = WritableStream;
      exports3.WritableStreamDefaultController = WritableStreamDefaultController;
      exports3.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/.pnpm/cross-undici-fetch@0.2.5/node_modules/cross-undici-fetch/dist/multipart.js
var require_multipart = __commonJS({
  "node_modules/.pnpm/cross-undici-fetch@0.2.5/node_modules/cross-undici-fetch/dist/multipart.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function parse6(multipartBodyBuffer, boundary) {
      var lastline = "";
      var header = "";
      var info = "";
      var state = 0;
      var buffer = [];
      var allParts = [];
      for (var i = 0; i < multipartBodyBuffer.length; i++) {
        var oneByte = multipartBodyBuffer[i];
        var prevByte = i > 0 ? multipartBodyBuffer[i - 1] : null;
        var newLineDetected = oneByte === 10 && prevByte === 13 ? true : false;
        var newLineChar = oneByte === 10 || oneByte === 13 ? true : false;
        if (!newLineChar)
          lastline += String.fromCharCode(oneByte);
        if (state === 0 && newLineDetected) {
          if ("--" + boundary === lastline) {
            state = 1;
          }
          lastline = "";
        } else if (state === 1 && newLineDetected) {
          header = lastline;
          state = 2;
          if (header.indexOf("filename") === -1) {
            state = 3;
          }
          lastline = "";
        } else if (state === 2 && newLineDetected) {
          info = lastline;
          state = 3;
          lastline = "";
        } else if (state === 3 && newLineDetected) {
          state = 4;
          buffer = [];
          lastline = "";
        } else if (state === 4) {
          if (lastline.length > boundary.length + 4)
            lastline = "";
          if ("--" + boundary === lastline) {
            var j2 = buffer.length - lastline.length;
            var part = buffer.slice(0, j2 - 1);
            var p = { header, info, part };
            allParts.push(process2(p));
            buffer = [];
            lastline = "";
            state = 5;
            header = "";
            info = "";
          } else {
            buffer.push(oneByte);
          }
          if (newLineDetected)
            lastline = "";
        } else if (state === 5) {
          if (newLineDetected)
            state = 1;
        }
      }
      return allParts;
    }
    exports2.parse = parse6;
    function getBoundary(header) {
      var items = header.split(";");
      if (items) {
        for (var i = 0; i < items.length; i++) {
          var item = new String(items[i]).trim();
          if (item.indexOf("boundary") >= 0) {
            var k2 = item.split("=");
            return new String(k2[1]).trim();
          }
        }
      }
      return "";
    }
    exports2.getBoundary = getBoundary;
    function process2(part) {
      var [, nameData, filenameData] = part.header.split(";");
      var input = {};
      Object.defineProperty(input, "name", {
        value: nameData.split("=")[1].replace(/"/g, ""),
        writable: true,
        enumerable: true,
        configurable: true
      });
      if (filenameData) {
        Object.defineProperty(input, "filename", {
          value: filenameData.split("=")[1].replace(/"/g, ""),
          writable: true,
          enumerable: true,
          configurable: true
        });
        var contentType = part.info.split(":")[1].trim();
        Object.defineProperty(input, "type", {
          value: contentType,
          writable: true,
          enumerable: true,
          configurable: true
        });
      }
      Object.defineProperty(input, "data", {
        value: Buffer.from(part.part),
        writable: true,
        enumerable: true,
        configurable: true
      });
      return input;
    }
  }
});

// node_modules/.pnpm/cross-undici-fetch@0.2.5/node_modules/cross-undici-fetch/dist/add-formdata-to-request.js
var require_add_formdata_to_request = __commonJS({
  "node_modules/.pnpm/cross-undici-fetch@0.2.5/node_modules/cross-undici-fetch/dist/add-formdata-to-request.js"(exports2, module2) {
    module2.exports = function addFormDataToRequest(Request2, File, FormData) {
      if (Request2.FORMDATA_PATCHED) {
        return;
      }
      Request2.FORMDATA_PATCHED = true;
      const existingFormDataMethod = Request2.prototype.formData;
      Request2.prototype.formData = async function formData(...args) {
        try {
          const existingResult = await existingFormDataMethod.apply(this, args);
          if (!existingResult) {
            throw new Error("Existing formData method returned undefined");
          }
        } catch (e2) {
          const parseMultipartData = require_multipart();
          const contentType = this.headers.get("Content-Type");
          if (/multipart\/form-data/.test(contentType)) {
            const formData2 = new FormData();
            const boundary = parseMultipartData.getBoundary(contentType);
            if (this.body) {
              const arrayBuffer = await this.arrayBuffer();
              const allParts = parseMultipartData.parse(Buffer.from(arrayBuffer), boundary);
              for (const part of allParts) {
                if (part.type) {
                  if (File) {
                    const file = new File([part.data], part.filename, { type: part.type });
                    formData2.append(part.name, file);
                  } else {
                    formData2.append(part.name, part.data, part.filename);
                  }
                } else {
                  formData2.append(part.name, part.data.toString("utf8"));
                }
              }
              return formData2;
            }
          }
        }
      };
    };
  }
});

// node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/assert.js
var assert_exports = {};
__export(assert_exports, {
  AssertionError: () => AssertionError,
  assert: () => ok,
  deepEqual: () => deepEqual,
  deepStrictEqual: () => deepStrictEqual,
  default: () => assert_default,
  doesNotThrow: () => doesNotThrow,
  equal: () => equal,
  fail: () => fail,
  ifError: () => ifError,
  notDeepEqual: () => notDeepEqual,
  notDeepStrictEqual: () => notDeepStrictEqual,
  notEqual: () => notEqual,
  notStrictEqual: () => notStrictEqual,
  ok: () => ok,
  strictEqual: () => strictEqual,
  throws: () => throws
});
function compare(a, b) {
  if (a === b) {
    return 0;
  }
  var x = a.length;
  var y2 = b.length;
  for (var i = 0, len = Math.min(x, y2); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y2 = b[i];
      break;
    }
  }
  if (x < y2) {
    return -1;
  }
  if (y2 < x) {
    return 1;
  }
  return 0;
}
function functionsHaveNames() {
  if (typeof _functionsHaveNames !== "undefined") {
    return _functionsHaveNames;
  }
  return _functionsHaveNames = function() {
    return function foo() {
    }.name === "foo";
  }();
}
function pToString(obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== "function") {
    return false;
  }
  if (typeof ArrayBuffer.isView === "function") {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
function assert(value, message) {
  if (!value)
    fail(value, true, message, "==", ok);
}
function getName(func) {
  if (!isFunction(func)) {
    return;
  }
  if (functionsHaveNames()) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
function AssertionError(options2) {
  this.name = "AssertionError";
  this.actual = options2.actual;
  this.expected = options2.expected;
  this.operator = options2.operator;
  if (options2.message) {
    this.message = options2.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options2.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    var err2 = new Error();
    if (err2.stack) {
      var out = err2.stack;
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf("\n" + fn_name);
      if (idx >= 0) {
        var next_line = out.indexOf("\n", idx + 1);
        out = out.substring(next_line + 1);
      }
      this.stack = out;
    }
  }
}
function truncate(s, n) {
  if (typeof s === "string") {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect3(something) {
  if (functionsHaveNames() || !isFunction(something)) {
    return inspect2(something);
  }
  var rawname = getName(something);
  var name = rawname ? ": " + rawname : "";
  return "[Function" + name + "]";
}
function getMessage(self2) {
  return truncate(inspect3(self2.actual), 128) + " " + self2.operator + " " + truncate(inspect3(self2.expected), 128);
}
function fail(actual, expected, message, operator, stackStartFunction) {
  throw new AssertionError({
    message,
    actual,
    expected,
    operator,
    stackStartFunction
  });
}
function ok(value, message) {
  if (!value)
    fail(value, true, message, "==", ok);
}
function equal(actual, expected, message) {
  if (actual != expected)
    fail(actual, expected, message, "==", equal);
}
function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, "!=", notEqual);
  }
}
function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, "deepEqual", deepEqual);
  }
}
function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, "deepStrictEqual", deepStrictEqual);
  }
}
function _deepEqual(actual, expected, strict, memos) {
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;
  } else if (isDate(actual) && isDate(expected)) {
    return actual.getTime() === expected.getTime();
  } else if (isRegExp(actual) && isRegExp(expected)) {
    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
  } else if ((actual === null || typeof actual !== "object") && (expected === null || typeof expected !== "object")) {
    return strict ? actual === expected : actual == expected;
  } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0;
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || { actual: [], expected: [] };
    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }
    memos.actual.push(actual);
    memos.expected.push(expected);
    return objEquiv(actual, expected, strict, memos);
  }
}
function isArguments(object) {
  return Object.prototype.toString.call(object) == "[object Arguments]";
}
function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === void 0 || b === null || b === void 0)
    return false;
  if (isPrimitive(a) || isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka2 = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  if (ka2.length !== kb.length)
    return false;
  ka2.sort();
  kb.sort();
  for (i = ka2.length - 1; i >= 0; i--) {
    if (ka2[i] !== kb[i])
      return false;
  }
  for (i = ka2.length - 1; i >= 0; i--) {
    key = ka2[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}
function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, "notDeepEqual", notDeepEqual);
  }
}
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual);
  }
}
function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, "===", strictEqual);
  }
}
function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, "!==", notStrictEqual);
  }
}
function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }
  if (Object.prototype.toString.call(expected) == "[object RegExp]") {
    return expected.test(actual);
  }
  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e2) {
  }
  if (Error.isPrototypeOf(expected)) {
    return false;
  }
  return expected.call({}, actual) === true;
}
function _tryBlock(block2) {
  var error2;
  try {
    block2();
  } catch (e2) {
    error2 = e2;
  }
  return error2;
}
function _throws(shouldThrow, block2, expected, message) {
  var actual;
  if (typeof block2 !== "function") {
    throw new TypeError('"block" argument must be a function');
  }
  if (typeof expected === "string") {
    message = expected;
    expected = null;
  }
  actual = _tryBlock(block2);
  message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : ".");
  if (shouldThrow && !actual) {
    fail(actual, expected, "Missing expected exception" + message);
  }
  var userProvidedMessage = typeof message === "string";
  var isUnwantedException = !shouldThrow && isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;
  if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
    fail(actual, expected, "Got unwanted exception" + message);
  }
  if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
    throw actual;
  }
}
function throws(block2, error2, message) {
  _throws(true, block2, error2, message);
}
function doesNotThrow(block2, error2, message) {
  _throws(false, block2, error2, message);
}
function ifError(err2) {
  if (err2)
    throw err2;
}
var hasOwn, objectKeys, pSlice, _functionsHaveNames, assert_default, regex;
var init_assert = __esm({
  "node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/assert.js"() {
    init_buffer_es6();
    init_util();
    hasOwn = Object.prototype.hasOwnProperty;
    objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        if (hasOwn.call(obj, key))
          keys2.push(key);
      }
      return keys2;
    };
    pSlice = Array.prototype.slice;
    assert_default = assert;
    regex = /\s*function\s+([^\(\s]*)\s*/;
    assert.AssertionError = AssertionError;
    (0, import_inherits.default)(AssertionError, Error);
    assert.fail = fail;
    assert.ok = ok;
    assert.equal = equal;
    assert.notEqual = notEqual;
    assert.deepEqual = deepEqual;
    assert.deepStrictEqual = deepStrictEqual;
    assert.notDeepEqual = notDeepEqual;
    assert.notDeepStrictEqual = notDeepStrictEqual;
    assert.strictEqual = strictEqual;
    assert.notStrictEqual = notStrictEqual;
    assert.throws = throws;
    assert.doesNotThrow = doesNotThrow;
    assert.ifError = ifError;
  }
});

// node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/empty.js
var empty_exports = {};
__export(empty_exports, {
  default: () => empty_default
});
var empty_default;
var init_empty = __esm({
  "node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/empty.js"() {
    empty_default = {};
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/core/symbols.js
var require_symbols = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/core/symbols.js"(exports2, module2) {
    module2.exports = {
      kClose: Symbol("close"),
      kDestroy: Symbol("destroy"),
      kDispatch: Symbol("dispatch"),
      kUrl: Symbol("url"),
      kWriting: Symbol("writing"),
      kResuming: Symbol("resuming"),
      kQueue: Symbol("queue"),
      kConnect: Symbol("connect"),
      kConnecting: Symbol("connecting"),
      kHeadersList: Symbol("headers list"),
      kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
      kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
      kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
      kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
      kKeepAlive: Symbol("keep alive"),
      kHeadersTimeout: Symbol("headers timeout"),
      kBodyTimeout: Symbol("body timeout"),
      kServerName: Symbol("server name"),
      kHost: Symbol("host"),
      kNoRef: Symbol("no ref"),
      kBodyUsed: Symbol("used"),
      kRunning: Symbol("running"),
      kBlocking: Symbol("blocking"),
      kPending: Symbol("pending"),
      kSize: Symbol("size"),
      kBusy: Symbol("busy"),
      kQueued: Symbol("queued"),
      kFree: Symbol("free"),
      kConnected: Symbol("connected"),
      kClosed: Symbol("closed"),
      kNeedDrain: Symbol("need drain"),
      kReset: Symbol("reset"),
      kDestroyed: Symbol("destroyed"),
      kMaxHeadersSize: Symbol("max headers size"),
      kRunningIdx: Symbol("running index"),
      kPendingIdx: Symbol("pending index"),
      kError: Symbol("error"),
      kClients: Symbol("clients"),
      kClient: Symbol("client"),
      kParser: Symbol("parser"),
      kOnDestroyed: Symbol("destroy callbacks"),
      kPipelining: Symbol("pipelinig"),
      kSocket: Symbol("socket"),
      kHostHeader: Symbol("host header"),
      kConnector: Symbol("connector"),
      kStrictContentLength: Symbol("strict content length"),
      kMaxRedirections: Symbol("maxRedirections"),
      kMaxRequests: Symbol("maxRequestsPerClient"),
      kProxy: Symbol("proxy agent options"),
      kCounter: Symbol("socket request counter")
    };
  }
});

// node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/http-lib/capability.js
function blobConstructor() {
  if (typeof _blobConstructor !== "undefined") {
    return _blobConstructor;
  }
  try {
    new global.Blob([new ArrayBuffer(1)]);
    _blobConstructor = true;
  } catch (e2) {
    _blobConstructor = false;
  }
  return _blobConstructor;
}
function checkTypeSupport(type) {
  if (!xhr) {
    xhr = new global.XMLHttpRequest();
    xhr.open("GET", global.location.host ? "/" : "https://example.com");
  }
  try {
    xhr.responseType = type;
    return xhr.responseType === type;
  } catch (e2) {
    return false;
  }
}
function isFunction2(value) {
  return typeof value === "function";
}
var hasFetch, _blobConstructor, xhr, haveArrayBuffer, haveSlice, arraybuffer, msstream, mozchunkedarraybuffer, overrideMimeType, vbArray;
var init_capability = __esm({
  "node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/http-lib/capability.js"() {
    hasFetch = isFunction2(global.fetch) && isFunction2(global.ReadableStream);
    haveArrayBuffer = typeof global.ArrayBuffer !== "undefined";
    haveSlice = haveArrayBuffer && isFunction2(global.ArrayBuffer.prototype.slice);
    arraybuffer = haveArrayBuffer && checkTypeSupport("arraybuffer");
    msstream = !hasFetch && haveSlice && checkTypeSupport("ms-stream");
    mozchunkedarraybuffer = !hasFetch && haveArrayBuffer && checkTypeSupport("moz-chunked-arraybuffer");
    overrideMimeType = isFunction2(xhr.overrideMimeType);
    vbArray = isFunction2(global.VBArray);
    xhr = null;
  }
});

// node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/events.js
var events_exports = {};
__export(events_exports, {
  EventEmitter: () => EventEmitter,
  default: () => events_default
});
function EventHandlers() {
}
function EventEmitter() {
  EventEmitter.init.call(this);
}
function $getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
function emitNone(handler, isFn, self2) {
  if (isFn)
    handler.call(self2);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2);
  }
}
function emitOne(handler, isFn, self2, arg1) {
  if (isFn)
    handler.call(self2, arg1);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1);
  }
}
function emitTwo(handler, isFn, self2, arg1, arg2) {
  if (isFn)
    handler.call(self2, arg1, arg2);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1, arg2);
  }
}
function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self2, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1, arg2, arg3);
  }
}
function emitMany(handler, isFn, self2, args) {
  if (isFn)
    handler.apply(self2, args);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].apply(self2, args);
  }
}
function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    if (events.newListener) {
      target.emit("newListener", type, listener.listener ? listener.listener : listener);
      events = target._events;
    }
    existing = events[type];
  }
  if (!existing) {
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
    } else {
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }
  return target;
}
function emitWarning(e2) {
  typeof console.warn === "function" ? console.warn(e2) : console.log(e2);
}
function _onceWrap(target, type, listener) {
  var fired = false;
  function g() {
    target.removeListener(type, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}
function listenerCount(type) {
  var events = this._events;
  if (events) {
    var evlistener = events[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }
  return 0;
}
function spliceOne(list, index) {
  for (var i = index, k2 = i + 1, n = list.length; k2 < n; i += 1, k2 += 1)
    list[i] = list[k2];
  list.pop();
}
function arrayClone(arr, i) {
  var copy = new Array(i);
  while (i--)
    copy[i] = arr[i];
  return copy;
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
var domain, events_default;
var init_events = __esm({
  "node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/events.js"() {
    "use strict";
    EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
    events_default = EventEmitter;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.usingDomains = false;
    EventEmitter.prototype.domain = void 0;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._maxListeners = void 0;
    EventEmitter.defaultMaxListeners = 10;
    EventEmitter.init = function() {
      this.domain = null;
      if (EventEmitter.usingDomains) {
        if (domain.active && !(this instanceof domain.Domain)) {
          this.domain = domain.active;
        }
      }
      if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || isNaN(n))
        throw new TypeError('"n" argument must be a positive number');
      this._maxListeners = n;
      return this;
    };
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return $getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit2(type) {
      var er2, handler, len, args, i, events, domain2;
      var needDomainExit = false;
      var doError = type === "error";
      events = this._events;
      if (events)
        doError = doError && events.error == null;
      else if (!doError)
        return false;
      domain2 = this.domain;
      if (doError) {
        er2 = arguments[1];
        if (domain2) {
          if (!er2)
            er2 = new Error('Uncaught, unspecified "error" event');
          er2.domainEmitter = this;
          er2.domain = domain2;
          er2.domainThrown = false;
          domain2.emit("error", er2);
        } else if (er2 instanceof Error) {
          throw er2;
        } else {
          var err2 = new Error('Uncaught, unspecified "error" event. (' + er2 + ")");
          err2.context = er2;
          throw err2;
        }
        return false;
      }
      handler = events[type];
      if (!handler)
        return false;
      var isFn = typeof handler === "function";
      len = arguments.length;
      switch (len) {
        case 1:
          emitNone(handler, isFn, this);
          break;
        case 2:
          emitOne(handler, isFn, this, arguments[1]);
          break;
        case 3:
          emitTwo(handler, isFn, this, arguments[1], arguments[2]);
          break;
        case 4:
          emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
          break;
        default:
          args = new Array(len - 1);
          for (i = 1; i < len; i++)
            args[i - 1] = arguments[i];
          emitMany(handler, isFn, this, args);
      }
      if (needDomainExit)
        domain2.exit();
      return true;
    };
    EventEmitter.prototype.addListener = function addListener2(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    EventEmitter.prototype.once = function once2(type, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener2(type, listener) {
      var list, events, position, i, originalListener;
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      events = this._events;
      if (!events)
        return this;
      list = events[type];
      if (!list)
        return this;
      if (list === listener || list.listener && list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length; i-- > 0; ) {
          if (list[i] === listener || list[i].listener && list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (list.length === 1) {
          list[0] = void 0;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list, position);
        }
        if (events.removeListener)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners2(type) {
      var listeners2, events;
      events = this._events;
      if (!events)
        return this;
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys2 = Object.keys(events);
        for (var i = 0, key; i < keys2.length; ++i) {
          key = keys2[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }
      listeners2 = events[type];
      if (typeof listeners2 === "function") {
        this.removeListener(type, listeners2);
      } else if (listeners2) {
        do {
          this.removeListener(type, listeners2[listeners2.length - 1]);
        } while (listeners2[0]);
      }
      return this;
    };
    EventEmitter.prototype.listeners = function listeners(type) {
      var evlistener;
      var ret;
      var events = this._events;
      if (!events)
        ret = [];
      else {
        evlistener = events[type];
        if (!evlistener)
          ret = [];
        else if (typeof evlistener === "function")
          ret = [evlistener.listener || evlistener];
        else
          ret = unwrapListeners(evlistener);
      }
      return ret;
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    };
  }
});

// node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/readable-stream/buffer-list.js
function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}
var buffer_list_default;
var init_buffer_list = __esm({
  "node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/readable-stream/buffer-list.js"() {
    init_buffer_es6();
    buffer_list_default = BufferList;
    BufferList.prototype.push = function(v) {
      var entry = { data: v, next: null };
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry;
      ++this.length;
    };
    BufferList.prototype.unshift = function(v) {
      var entry = { data: v, next: this.head };
      if (this.length === 0)
        this.tail = entry;
      this.head = entry;
      ++this.length;
    };
    BufferList.prototype.shift = function() {
      if (this.length === 0)
        return;
      var ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    };
    BufferList.prototype.clear = function() {
      this.head = this.tail = null;
      this.length = 0;
    };
    BufferList.prototype.join = function(s) {
      if (this.length === 0)
        return "";
      var p = this.head;
      var ret = "" + p.data;
      while (p = p.next) {
        ret += s + p.data;
      }
      return ret;
    };
    BufferList.prototype.concat = function(n) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      if (this.length === 1)
        return this.head.data;
      var ret = Buffer2.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        p.data.copy(ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    };
  }
});

// node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/string-decoder.js
function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error("Unknown encoding: " + encoding);
  }
}
function StringDecoder(encoding) {
  this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
  assertEncoding(encoding);
  switch (this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case "base64":
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }
  this.charBuffer = new Buffer2(6);
  this.charReceived = 0;
  this.charLength = 0;
}
function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}
function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}
function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}
var isBufferEncoding;
var init_string_decoder = __esm({
  "node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/string-decoder.js"() {
    init_buffer_es6();
    isBufferEncoding = Buffer2.isEncoding || function(encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    StringDecoder.prototype.write = function(buffer) {
      var charStr = "";
      while (this.charLength) {
        var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
          return "";
        }
        buffer = buffer.slice(available, buffer.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 55296 && charCode <= 56319) {
          this.charLength += this.surrogateSize;
          charStr = "";
          continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
      this.detectIncompleteChar(buffer);
      var end = buffer.length;
      if (this.charLength) {
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
      charStr += buffer.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      if (charCode >= 55296 && charCode <= 56319) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      var i = buffer.length >= 3 ? 3 : buffer.length;
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];
        if (i == 1 && c >> 5 == 6) {
          this.charLength = 2;
          break;
        }
        if (i <= 2 && c >> 4 == 14) {
          this.charLength = 3;
          break;
        }
        if (i <= 3 && c >> 3 == 30) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };
    StringDecoder.prototype.end = function(buffer) {
      var res = "";
      if (buffer && buffer.length)
        res = this.write(buffer);
      if (this.charReceived) {
        var cr2 = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr2).toString(enc);
      }
      return res;
    };
  }
});

// node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/readable-stream/readable.js
function prependListener2(emitter, event, fn2) {
  if (typeof emitter.prependListener === "function") {
    return emitter.prependListener(event, fn2);
  } else {
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn2);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn2);
    else
      emitter._events[event] = [fn2, emitter._events[event]];
  }
}
function listenerCount2(emitter, type) {
  return emitter.listeners(type).length;
}
function ReadableState(options2, stream) {
  options2 = options2 || {};
  this.objectMode = !!options2.objectMode;
  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options2.readableObjectMode;
  var hwm = options2.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.buffer = new buffer_list_default();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.defaultEncoding = options2.defaultEncoding || "utf8";
  this.ranOut = false;
  this.awaitDrain = 0;
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options2.encoding) {
    this.decoder = new StringDecoder(options2.encoding);
    this.encoding = options2.encoding;
  }
}
function Readable(options2) {
  if (!(this instanceof Readable))
    return new Readable(options2);
  this._readableState = new ReadableState(options2, this);
  this.readable = true;
  if (options2 && typeof options2.read === "function")
    this._read = options2.read;
  events_default.call(this);
}
function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er2 = chunkInvalid(state, chunk);
  if (er2) {
    stream.emit("error", er2);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e2 = new Error("stream.push() after EOF");
      stream.emit("error", e2);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error("stream.unshift() after end event");
      stream.emit("error", _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }
      if (!addToFront)
        state.reading = false;
      if (!skipAdd) {
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit("data", chunk);
          stream.read(0);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream);
        }
      }
      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }
  return needMoreData(state);
}
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended)
    return 0;
  if (state.objectMode)
    return 1;
  if (n !== n) {
    if (state.flowing && state.length)
      return state.buffer.head.data.length;
    else
      return state.length;
  }
  if (n > state.highWaterMark)
    state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length)
    return n;
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}
function chunkInvalid(state, chunk) {
  var er2 = null;
  if (!Buffer.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state.objectMode) {
    er2 = new TypeError("Invalid non-string/buffer chunk");
  }
  return er2;
}
function onEofChunk(stream, state) {
  if (state.ended)
    return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  emitReadable(stream);
}
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug("emitReadable", state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      nextTick(emitReadable_, stream);
    else
      emitReadable_(stream);
  }
}
function emitReadable_(stream) {
  debug("emit readable");
  stream.emit("readable");
  flow(stream);
}
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    nextTick(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug("maybeReadMore read 0");
    stream.read(0);
    if (len === state.length)
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}
function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug("pipeOnDrain", state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && src.listeners("data").length) {
      state.flowing = true;
      flow(src);
    }
  };
}
function nReadingNextTick(self2) {
  debug("readable nexttick read 0");
  self2.read(0);
}
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    nextTick(resume_, stream, state);
  }
}
function resume_(stream, state) {
  if (!state.reading) {
    debug("resume read 0");
    stream.read(0);
  }
  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit("resume");
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}
function flow(stream) {
  var state = stream._readableState;
  debug("flow", state.flowing);
  while (state.flowing && stream.read() !== null) {
  }
}
function fromList(n, state) {
  if (state.length === 0)
    return null;
  var ret;
  if (state.objectMode)
    ret = state.buffer.shift();
  else if (!n || n >= state.length) {
    if (state.decoder)
      ret = state.buffer.join("");
    else if (state.buffer.length === 1)
      ret = state.buffer.head.data;
    else
      ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    ret = fromListPartial(n, state.buffer, state.decoder);
  }
  return ret;
}
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    ret = list.shift();
  } else {
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length)
      ret += str;
    else
      ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next)
          list.head = p.next;
        else
          list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next)
          list.head = p.next;
        else
          list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}
function endReadable(stream) {
  var state = stream._readableState;
  if (state.length > 0)
    throw new Error('"endReadable()" called on non-empty stream');
  if (!state.endEmitted) {
    state.ended = true;
    nextTick(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit("end");
  }
}
function forEach(xs2, f) {
  for (var i = 0, l = xs2.length; i < l; i++) {
    f(xs2[i], i);
  }
}
function indexOf(xs2, x) {
  for (var i = 0, l = xs2.length; i < l; i++) {
    if (xs2[i] === x)
      return i;
  }
  return -1;
}
var debug, MAX_HWM;
var init_readable = __esm({
  "node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/readable-stream/readable.js"() {
    "use strict";
    init_events();
    init_util();
    init_buffer_list();
    init_string_decoder();
    init_duplex();
    init_browser();
    Readable.ReadableState = ReadableState;
    debug = debuglog("stream");
    (0, import_inherits.default)(Readable, events_default);
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      if (!state.objectMode && typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer.from(chunk, encoding);
          encoding = "";
        }
      }
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, "", true);
    };
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    MAX_HWM = 8388608;
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = !pipeOpts || pipeOpts.end !== false;
      var endFn = doEnd ? onend2 : cleanup;
      if (state.endEmitted)
        nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable) {
        debug("onunpipe");
        if (readable === src) {
          cleanup();
        }
      }
      function onend2() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend2);
        src.removeListener("end", cleanup);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (ret === false && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er2) {
        debug("onerror", er2);
        unpipe();
        dest.removeListener("error", onerror);
        if (listenerCount2(dest, "error") === 0)
          dest.emit("error", er2);
      }
      prependListener2(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var _i2 = 0; _i2 < len; _i2++) {
          dests[_i2].emit("unpipe", this);
        }
        return this;
      }
      var i = indexOf(state.pipes, dest);
      if (i === -1)
        return this;
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this);
      return this;
    };
    Readable.prototype.on = function(ev, fn2) {
      var res = events_default.prototype.on.call(this, ev, fn2);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
      var self2 = this;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self2.push(chunk);
        }
        self2.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = self2.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      var events = ["error", "close", "destroy", "pause", "resume"];
      forEach(events, function(ev) {
        stream.on(ev, self2.emit.bind(self2, ev));
      });
      self2._read = function(n) {
        debug("wrapped _read", n);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return self2;
    };
    Readable._fromList = fromList;
  }
});

// node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/readable-stream/writable.js
function nop() {
}
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}
function WritableState(options2, stream) {
  Object.defineProperty(this, "buffer", {
    get: deprecate(function() {
      return this.getBuffer();
    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
  });
  options2 = options2 || {};
  this.objectMode = !!options2.objectMode;
  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options2.writableObjectMode;
  var hwm = options2.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  var noDecode = options2.decodeStrings === false;
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options2.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = function(er2) {
    onwrite(stream, er2);
  };
  this.writecb = null;
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  this.pendingcb = 0;
  this.prefinished = false;
  this.errorEmitted = false;
  this.bufferedRequestCount = 0;
  this.corkedRequestsFree = new CorkedRequest(this);
}
function Writable(options2) {
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options2);
  this._writableState = new WritableState(options2, this);
  this.writable = true;
  if (options2) {
    if (typeof options2.write === "function")
      this._write = options2.write;
    if (typeof options2.writev === "function")
      this._writev = options2.writev;
  }
  EventEmitter.call(this);
}
function writeAfterEnd(stream, cb) {
  var er2 = new Error("write after end");
  stream.emit("error", er2);
  nextTick(cb, er2);
}
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er2 = false;
  if (chunk === null) {
    er2 = new TypeError("May not write null values to stream");
  } else if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
    er2 = new TypeError("Invalid non-string/buffer chunk");
  }
  if (er2) {
    stream.emit("error", er2);
    nextTick(cb, er2);
    valid = false;
  }
  return valid;
}
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
    chunk = Buffer2.from(chunk, encoding);
  }
  return chunk;
}
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer2.isBuffer(chunk))
    encoding = "buffer";
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  if (!ret)
    state.needDrain = true;
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync, er2, cb) {
  --state.pendingcb;
  if (sync)
    nextTick(cb, er2);
  else
    cb(er2);
  stream._writableState.errorEmitted = true;
  stream.emit("error", er2);
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er2) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er2)
    onwriteError(stream, state, sync, er2, cb);
  else {
    var finished = needFinish(state);
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}
function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit("drain");
  }
}
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;
  if (stream._writev && entry && entry.next) {
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    while (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }
    doWrite(stream, state, true, state.length, buffer, "", holder.finish);
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      if (state.writing) {
        break;
      }
    }
    if (entry === null)
      state.lastBufferedRequest = null;
  }
  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit("prefinish");
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit("finish");
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}
function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      nextTick(cb);
    else
      stream.once("finish", cb);
  }
  state.ended = true;
  stream.writable = false;
}
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function(err2) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err2);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
var init_writable = __esm({
  "node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/readable-stream/writable.js"() {
    init_util();
    init_buffer_es6();
    init_events();
    init_duplex();
    init_browser();
    Writable.WritableState = WritableState;
    (0, import_inherits.default)(Writable, EventEmitter);
    WritableState.prototype.getBuffer = function writableStateGetBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (Buffer2.isBuffer(chunk))
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
  }
});

// node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/readable-stream/duplex.js
function Duplex(options2) {
  if (!(this instanceof Duplex))
    return new Duplex(options2);
  Readable.call(this, options2);
  Writable.call(this, options2);
  if (options2 && options2.readable === false)
    this.readable = false;
  if (options2 && options2.writable === false)
    this.writable = false;
  this.allowHalfOpen = true;
  if (options2 && options2.allowHalfOpen === false)
    this.allowHalfOpen = false;
  this.once("end", onend);
}
function onend() {
  if (this.allowHalfOpen || this._writableState.ended)
    return;
  nextTick(onEndNT, this);
}
function onEndNT(self2) {
  self2.end();
}
var keys, method, v;
var init_duplex = __esm({
  "node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/readable-stream/duplex.js"() {
    init_util();
    init_browser();
    init_readable();
    init_writable();
    (0, import_inherits.default)(Duplex, Readable);
    keys = Object.keys(Writable.prototype);
    for (v = 0; v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
});

// node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/readable-stream/transform.js
function TransformState(stream) {
  this.afterTransform = function(er2, data) {
    return afterTransform(stream, er2, data);
  };
  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}
function afterTransform(stream, er2, data) {
  var ts2 = stream._transformState;
  ts2.transforming = false;
  var cb = ts2.writecb;
  if (!cb)
    return stream.emit("error", new Error("no writecb in Transform class"));
  ts2.writechunk = null;
  ts2.writecb = null;
  if (data !== null && data !== void 0)
    stream.push(data);
  cb(er2);
  var rs2 = stream._readableState;
  rs2.reading = false;
  if (rs2.needReadable || rs2.length < rs2.highWaterMark) {
    stream._read(rs2.highWaterMark);
  }
}
function Transform(options2) {
  if (!(this instanceof Transform))
    return new Transform(options2);
  Duplex.call(this, options2);
  this._transformState = new TransformState(this);
  var stream = this;
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options2) {
    if (typeof options2.transform === "function")
      this._transform = options2.transform;
    if (typeof options2.flush === "function")
      this._flush = options2.flush;
  }
  this.once("prefinish", function() {
    if (typeof this._flush === "function")
      this._flush(function(er2) {
        done(stream, er2);
      });
    else
      done(stream);
  });
}
function done(stream, er2) {
  if (er2)
    return stream.emit("error", er2);
  var ws2 = stream._writableState;
  var ts2 = stream._transformState;
  if (ws2.length)
    throw new Error("Calling transform done when ws.length != 0");
  if (ts2.transforming)
    throw new Error("Calling transform done when still transforming");
  return stream.push(null);
}
var init_transform = __esm({
  "node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/readable-stream/transform.js"() {
    init_duplex();
    init_util();
    (0, import_inherits.default)(Transform, Duplex);
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("Not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts2 = this._transformState;
      ts2.writecb = cb;
      ts2.writechunk = chunk;
      ts2.writeencoding = encoding;
      if (!ts2.transforming) {
        var rs2 = this._readableState;
        if (ts2.needTransform || rs2.needReadable || rs2.length < rs2.highWaterMark)
          this._read(rs2.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts2 = this._transformState;
      if (ts2.writechunk !== null && ts2.writecb && !ts2.transforming) {
        ts2.transforming = true;
        this._transform(ts2.writechunk, ts2.writeencoding, ts2.afterTransform);
      } else {
        ts2.needTransform = true;
      }
    };
  }
});

// node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/readable-stream/passthrough.js
function PassThrough(options2) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options2);
  Transform.call(this, options2);
}
var init_passthrough = __esm({
  "node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/readable-stream/passthrough.js"() {
    init_transform();
    init_util();
    (0, import_inherits.default)(PassThrough, Transform);
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/stream.js
var stream_exports = {};
__export(stream_exports, {
  Duplex: () => Duplex,
  PassThrough: () => PassThrough,
  Readable: () => Readable,
  Stream: () => Stream,
  Transform: () => Transform,
  Writable: () => Writable,
  default: () => stream_default
});
function Stream() {
  events_default.call(this);
}
var stream_default;
var init_stream = __esm({
  "node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/stream.js"() {
    init_events();
    init_util();
    init_duplex();
    init_readable();
    init_writable();
    init_transform();
    init_passthrough();
    (0, import_inherits.default)(Stream, events_default);
    Stream.Readable = Readable;
    Stream.Writable = Writable;
    Stream.Duplex = Duplex;
    Stream.Transform = Transform;
    Stream.PassThrough = PassThrough;
    Stream.Stream = Stream;
    stream_default = Stream;
    Stream.prototype.pipe = function(dest, options2) {
      var source = this;
      function ondata(chunk) {
        if (dest.writable) {
          if (dest.write(chunk) === false && source.pause) {
            source.pause();
          }
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options2 || options2.end !== false)) {
        source.on("end", onend2);
        source.on("close", onclose);
      }
      var didOnEnd = false;
      function onend2() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er2) {
        cleanup();
        if (events_default.listenerCount(this, "error") === 0) {
          throw er2;
        }
      }
      source.on("error", onerror);
      dest.on("error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend2);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
  }
});

// node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/http-lib/response.js
function IncomingMessage(xhr2, response, mode) {
  var self2 = this;
  Readable.call(self2);
  self2._mode = mode;
  self2.headers = {};
  self2.rawHeaders = [];
  self2.trailers = {};
  self2.rawTrailers = [];
  self2.on("end", function() {
    process.nextTick(function() {
      self2.emit("close");
    });
  });
  var read;
  if (mode === "fetch") {
    self2._fetchResponse = response;
    self2.url = response.url;
    self2.statusCode = response.status;
    self2.statusMessage = response.statusText;
    for (var header, _i2, _it = response.headers[Symbol.iterator](); header = (_i2 = _it.next()).value, !_i2.done; ) {
      self2.headers[header[0].toLowerCase()] = header[1];
      self2.rawHeaders.push(header[0], header[1]);
    }
    var reader = response.body.getReader();
    read = function() {
      reader.read().then(function(result) {
        if (self2._destroyed)
          return;
        if (result.done) {
          self2.push(null);
          return;
        }
        self2.push(new Buffer(result.value));
        read();
      });
    };
    read();
  } else {
    self2._xhr = xhr2;
    self2._pos = 0;
    self2.url = xhr2.responseURL;
    self2.statusCode = xhr2.status;
    self2.statusMessage = xhr2.statusText;
    var headers = xhr2.getAllResponseHeaders().split(/\r?\n/);
    headers.forEach(function(header2) {
      var matches = header2.match(/^([^:]+):\s*(.*)/);
      if (matches) {
        var key = matches[1].toLowerCase();
        if (key === "set-cookie") {
          if (self2.headers[key] === void 0) {
            self2.headers[key] = [];
          }
          self2.headers[key].push(matches[2]);
        } else if (self2.headers[key] !== void 0) {
          self2.headers[key] += ", " + matches[2];
        } else {
          self2.headers[key] = matches[2];
        }
        self2.rawHeaders.push(matches[1], matches[2]);
      }
    });
    self2._charset = "x-user-defined";
    if (!overrideMimeType) {
      var mimeType = self2.rawHeaders["mime-type"];
      if (mimeType) {
        var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
        if (charsetMatch) {
          self2._charset = charsetMatch[1].toLowerCase();
        }
      }
      if (!self2._charset)
        self2._charset = "utf-8";
    }
  }
}
var rStates;
var init_response = __esm({
  "node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/http-lib/response.js"() {
    init_capability();
    init_util();
    init_stream();
    rStates = {
      UNSENT: 0,
      OPENED: 1,
      HEADERS_RECEIVED: 2,
      LOADING: 3,
      DONE: 4
    };
    (0, import_inherits.default)(IncomingMessage, Readable);
    IncomingMessage.prototype._read = function() {
    };
    IncomingMessage.prototype._onXHRProgress = function() {
      var self2 = this;
      var xhr2 = self2._xhr;
      var response = null;
      switch (self2._mode) {
        case "text:vbarray":
          if (xhr2.readyState !== rStates.DONE)
            break;
          try {
            response = new global.VBArray(xhr2.responseBody).toArray();
          } catch (e2) {
          }
          if (response !== null) {
            self2.push(new Buffer(response));
            break;
          }
        case "text":
          try {
            response = xhr2.responseText;
          } catch (e2) {
            self2._mode = "text:vbarray";
            break;
          }
          if (response.length > self2._pos) {
            var newData = response.substr(self2._pos);
            if (self2._charset === "x-user-defined") {
              var buffer = new Buffer(newData.length);
              for (var i = 0; i < newData.length; i++)
                buffer[i] = newData.charCodeAt(i) & 255;
              self2.push(buffer);
            } else {
              self2.push(newData, self2._charset);
            }
            self2._pos = response.length;
          }
          break;
        case "arraybuffer":
          if (xhr2.readyState !== rStates.DONE || !xhr2.response)
            break;
          response = xhr2.response;
          self2.push(new Buffer(new Uint8Array(response)));
          break;
        case "moz-chunked-arraybuffer":
          response = xhr2.response;
          if (xhr2.readyState !== rStates.LOADING || !response)
            break;
          self2.push(new Buffer(new Uint8Array(response)));
          break;
        case "ms-stream":
          response = xhr2.response;
          if (xhr2.readyState !== rStates.LOADING)
            break;
          var reader = new global.MSStreamReader();
          reader.onprogress = function() {
            if (reader.result.byteLength > self2._pos) {
              self2.push(new Buffer(new Uint8Array(reader.result.slice(self2._pos))));
              self2._pos = reader.result.byteLength;
            }
          };
          reader.onload = function() {
            self2.push(null);
          };
          reader.readAsArrayBuffer(response);
          break;
      }
      if (self2._xhr.readyState === rStates.DONE && self2._mode !== "ms-stream") {
        self2.push(null);
      }
    };
  }
});

// node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/http-lib/to-arraybuffer.js
function to_arraybuffer_default(buf) {
  if (buf instanceof Uint8Array) {
    if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
      return buf.buffer;
    } else if (typeof buf.buffer.slice === "function") {
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
  }
  if (isBuffer(buf)) {
    var arrayCopy = new Uint8Array(buf.length);
    var len = buf.length;
    for (var i = 0; i < len; i++) {
      arrayCopy[i] = buf[i];
    }
    return arrayCopy.buffer;
  } else {
    throw new Error("Argument must be a Buffer");
  }
}
var init_to_arraybuffer = __esm({
  "node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/http-lib/to-arraybuffer.js"() {
    init_buffer_es6();
  }
});

// node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/http-lib/request.js
function decideMode(preferBinary, useFetch) {
  if (hasFetch && useFetch) {
    return "fetch";
  } else if (mozchunkedarraybuffer) {
    return "moz-chunked-arraybuffer";
  } else if (msstream) {
    return "ms-stream";
  } else if (arraybuffer && preferBinary) {
    return "arraybuffer";
  } else if (vbArray && preferBinary) {
    return "text:vbarray";
  } else {
    return "text";
  }
}
function ClientRequest(opts) {
  var self2 = this;
  Writable.call(self2);
  self2._opts = opts;
  self2._body = [];
  self2._headers = {};
  if (opts.auth)
    self2.setHeader("Authorization", "Basic " + new Buffer(opts.auth).toString("base64"));
  Object.keys(opts.headers).forEach(function(name) {
    self2.setHeader(name, opts.headers[name]);
  });
  var preferBinary;
  var useFetch = true;
  if (opts.mode === "disable-fetch") {
    useFetch = false;
    preferBinary = true;
  } else if (opts.mode === "prefer-streaming") {
    preferBinary = false;
  } else if (opts.mode === "allow-wrong-content-type") {
    preferBinary = !overrideMimeType;
  } else if (!opts.mode || opts.mode === "default" || opts.mode === "prefer-fast") {
    preferBinary = true;
  } else {
    throw new Error("Invalid value for opts.mode");
  }
  self2._mode = decideMode(preferBinary, useFetch);
  self2.on("finish", function() {
    self2._onFinish();
  });
}
function statusValid(xhr2) {
  try {
    var status2 = xhr2.status;
    return status2 !== null && status2 !== 0;
  } catch (e2) {
    return false;
  }
}
var request_default, unsafeHeaders;
var init_request = __esm({
  "node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/http-lib/request.js"() {
    init_capability();
    init_util();
    init_response();
    init_stream();
    init_to_arraybuffer();
    request_default = ClientRequest;
    (0, import_inherits.default)(ClientRequest, Writable);
    unsafeHeaders = [
      "accept-charset",
      "accept-encoding",
      "access-control-request-headers",
      "access-control-request-method",
      "connection",
      "content-length",
      "cookie",
      "cookie2",
      "date",
      "dnt",
      "expect",
      "host",
      "keep-alive",
      "origin",
      "referer",
      "te",
      "trailer",
      "transfer-encoding",
      "upgrade",
      "user-agent",
      "via"
    ];
    ClientRequest.prototype.setHeader = function(name, value) {
      var self2 = this;
      var lowerName = name.toLowerCase();
      if (unsafeHeaders.indexOf(lowerName) !== -1)
        return;
      self2._headers[lowerName] = {
        name,
        value
      };
    };
    ClientRequest.prototype.getHeader = function(name) {
      var self2 = this;
      return self2._headers[name.toLowerCase()].value;
    };
    ClientRequest.prototype.removeHeader = function(name) {
      var self2 = this;
      delete self2._headers[name.toLowerCase()];
    };
    ClientRequest.prototype._onFinish = function() {
      var self2 = this;
      if (self2._destroyed)
        return;
      var opts = self2._opts;
      var headersObj = self2._headers;
      var body;
      if (opts.method === "POST" || opts.method === "PUT" || opts.method === "PATCH") {
        if (blobConstructor()) {
          body = new global.Blob(self2._body.map(function(buffer) {
            return to_arraybuffer_default(buffer);
          }), {
            type: (headersObj["content-type"] || {}).value || ""
          });
        } else {
          body = Buffer.concat(self2._body).toString();
        }
      }
      if (self2._mode === "fetch") {
        var headers = Object.keys(headersObj).map(function(name) {
          return [headersObj[name].name, headersObj[name].value];
        });
        global.fetch(self2._opts.url, {
          method: self2._opts.method,
          headers,
          body,
          mode: "cors",
          credentials: opts.withCredentials ? "include" : "same-origin"
        }).then(function(response) {
          self2._fetchResponse = response;
          self2._connect();
        }, function(reason) {
          self2.emit("error", reason);
        });
      } else {
        var xhr2 = self2._xhr = new global.XMLHttpRequest();
        try {
          xhr2.open(self2._opts.method, self2._opts.url, true);
        } catch (err2) {
          process.nextTick(function() {
            self2.emit("error", err2);
          });
          return;
        }
        if ("responseType" in xhr2)
          xhr2.responseType = self2._mode.split(":")[0];
        if ("withCredentials" in xhr2)
          xhr2.withCredentials = !!opts.withCredentials;
        if (self2._mode === "text" && "overrideMimeType" in xhr2)
          xhr2.overrideMimeType("text/plain; charset=x-user-defined");
        Object.keys(headersObj).forEach(function(name) {
          xhr2.setRequestHeader(headersObj[name].name, headersObj[name].value);
        });
        self2._response = null;
        xhr2.onreadystatechange = function() {
          switch (xhr2.readyState) {
            case rStates.LOADING:
            case rStates.DONE:
              self2._onXHRProgress();
              break;
          }
        };
        if (self2._mode === "moz-chunked-arraybuffer") {
          xhr2.onprogress = function() {
            self2._onXHRProgress();
          };
        }
        xhr2.onerror = function() {
          if (self2._destroyed)
            return;
          self2.emit("error", new Error("XHR error"));
        };
        try {
          xhr2.send(body);
        } catch (err2) {
          process.nextTick(function() {
            self2.emit("error", err2);
          });
          return;
        }
      }
    };
    ClientRequest.prototype._onXHRProgress = function() {
      var self2 = this;
      if (!statusValid(self2._xhr) || self2._destroyed)
        return;
      if (!self2._response)
        self2._connect();
      self2._response._onXHRProgress();
    };
    ClientRequest.prototype._connect = function() {
      var self2 = this;
      if (self2._destroyed)
        return;
      self2._response = new IncomingMessage(self2._xhr, self2._fetchResponse, self2._mode);
      self2.emit("response", self2._response);
    };
    ClientRequest.prototype._write = function(chunk, encoding, cb) {
      var self2 = this;
      self2._body.push(chunk);
      cb();
    };
    ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function() {
      var self2 = this;
      self2._destroyed = true;
      if (self2._response)
        self2._response._destroyed = true;
      if (self2._xhr)
        self2._xhr.abort();
    };
    ClientRequest.prototype.end = function(data, encoding, cb) {
      var self2 = this;
      if (typeof data === "function") {
        cb = data;
        data = void 0;
      }
      Writable.prototype.end.call(self2, data, encoding, cb);
    };
    ClientRequest.prototype.flushHeaders = function() {
    };
    ClientRequest.prototype.setTimeout = function() {
    };
    ClientRequest.prototype.setNoDelay = function() {
    };
    ClientRequest.prototype.setSocketKeepAlive = function() {
    };
  }
});

// node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/punycode.js
var punycode_exports = {};
__export(punycode_exports, {
  decode: () => decode,
  default: () => punycode_default,
  encode: () => encode,
  toASCII: () => toASCII,
  toUnicode: () => toUnicode,
  ucs2: () => ucs2,
  version: () => version2
});
function error(type) {
  throw new RangeError(errors[type]);
}
function map(array, fn2) {
  var length = array.length;
  var result = [];
  while (length--) {
    result[length] = fn2(array[length]);
  }
  return result;
}
function mapDomain(string, fn2) {
  var parts = string.split("@");
  var result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    string = parts[1];
  }
  string = string.replace(regexSeparators, ".");
  var labels = string.split(".");
  var encoded = map(labels, fn2).join(".");
  return result + encoded;
}
function ucs2decode(string) {
  var output = [], counter = 0, length = string.length, value, extra;
  while (counter < length) {
    value = string.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
function ucs2encode(array) {
  return map(array, function(value) {
    var output = "";
    if (value > 65535) {
      value -= 65536;
      output += stringFromCharCode(value >>> 10 & 1023 | 55296);
      value = 56320 | value & 1023;
    }
    output += stringFromCharCode(value);
    return output;
  }).join("");
}
function basicToDigit(codePoint) {
  if (codePoint - 48 < 10) {
    return codePoint - 22;
  }
  if (codePoint - 65 < 26) {
    return codePoint - 65;
  }
  if (codePoint - 97 < 26) {
    return codePoint - 97;
  }
  return base;
}
function digitToBasic(digit, flag) {
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
}
function adapt(delta, numPoints, firstTime) {
  var k2 = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  for (; delta > baseMinusTMin * tMax >> 1; k2 += base) {
    delta = floor(delta / baseMinusTMin);
  }
  return floor(k2 + (baseMinusTMin + 1) * delta / (delta + skew));
}
function decode(input) {
  var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j2, index, oldi, w, k2, digit, t, baseMinusT;
  basic = input.lastIndexOf(delimiter);
  if (basic < 0) {
    basic = 0;
  }
  for (j2 = 0; j2 < basic; ++j2) {
    if (input.charCodeAt(j2) >= 128) {
      error("not-basic");
    }
    output.push(input.charCodeAt(j2));
  }
  for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
    for (oldi = i, w = 1, k2 = base; ; k2 += base) {
      if (index >= inputLength) {
        error("invalid-input");
      }
      digit = basicToDigit(input.charCodeAt(index++));
      if (digit >= base || digit > floor((maxInt - i) / w)) {
        error("overflow");
      }
      i += digit * w;
      t = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
      if (digit < t) {
        break;
      }
      baseMinusT = base - t;
      if (w > floor(maxInt / baseMinusT)) {
        error("overflow");
      }
      w *= baseMinusT;
    }
    out = output.length + 1;
    bias = adapt(i - oldi, out, oldi == 0);
    if (floor(i / out) > maxInt - n) {
      error("overflow");
    }
    n += floor(i / out);
    i %= out;
    output.splice(i++, 0, n);
  }
  return ucs2encode(output);
}
function encode(input) {
  var n, delta, handledCPCount, basicLength, bias, j2, m, q, k2, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
  input = ucs2decode(input);
  inputLength = input.length;
  n = initialN;
  delta = 0;
  bias = initialBias;
  for (j2 = 0; j2 < inputLength; ++j2) {
    currentValue = input[j2];
    if (currentValue < 128) {
      output.push(stringFromCharCode(currentValue));
    }
  }
  handledCPCount = basicLength = output.length;
  if (basicLength) {
    output.push(delimiter);
  }
  while (handledCPCount < inputLength) {
    for (m = maxInt, j2 = 0; j2 < inputLength; ++j2) {
      currentValue = input[j2];
      if (currentValue >= n && currentValue < m) {
        m = currentValue;
      }
    }
    handledCPCountPlusOne = handledCPCount + 1;
    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
      error("overflow");
    }
    delta += (m - n) * handledCPCountPlusOne;
    n = m;
    for (j2 = 0; j2 < inputLength; ++j2) {
      currentValue = input[j2];
      if (currentValue < n && ++delta > maxInt) {
        error("overflow");
      }
      if (currentValue == n) {
        for (q = delta, k2 = base; ; k2 += base) {
          t = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
          if (q < t) {
            break;
          }
          qMinusT = q - t;
          baseMinusT = base - t;
          output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
          q = floor(qMinusT / baseMinusT);
        }
        output.push(stringFromCharCode(digitToBasic(q, 0)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }
    ++delta;
    ++n;
  }
  return output.join("");
}
function toUnicode(input) {
  return mapDomain(input, function(string) {
    return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
  });
}
function toASCII(input) {
  return mapDomain(input, function(string) {
    return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
  });
}
var maxInt, base, tMin, tMax, skew, damp, initialBias, initialN, delimiter, regexPunycode, regexNonASCII, regexSeparators, errors, baseMinusTMin, floor, stringFromCharCode, version2, ucs2, punycode_default;
var init_punycode = __esm({
  "node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/punycode.js"() {
    maxInt = 2147483647;
    base = 36;
    tMin = 1;
    tMax = 26;
    skew = 38;
    damp = 700;
    initialBias = 72;
    initialN = 128;
    delimiter = "-";
    regexPunycode = /^xn--/;
    regexNonASCII = /[^\x20-\x7E]/;
    regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    baseMinusTMin = base - tMin;
    floor = Math.floor;
    stringFromCharCode = String.fromCharCode;
    version2 = "1.4.1";
    ucs2 = {
      decode: ucs2decode,
      encode: ucs2encode
    };
    punycode_default = {
      version: version2,
      ucs2,
      toASCII,
      toUnicode,
      encode,
      decode
    };
  }
});

// node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/qs.js
function hasOwnProperty2(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function stringifyPrimitive(v) {
  switch (typeof v) {
    case "string":
      return v;
    case "boolean":
      return v ? "true" : "false";
    case "number":
      return isFinite(v) ? v : "";
    default:
      return "";
  }
}
function stringify(obj, sep, eq, name) {
  sep = sep || "&";
  eq = eq || "=";
  if (obj === null) {
    obj = void 0;
  }
  if (typeof obj === "object") {
    return map2(objectKeys2(obj), function(k2) {
      var ks2 = encodeURIComponent(stringifyPrimitive(k2)) + eq;
      if (isArray2(obj[k2])) {
        return map2(obj[k2], function(v) {
          return ks2 + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks2 + encodeURIComponent(stringifyPrimitive(obj[k2]));
      }
    }).join(sep);
  }
  if (!name)
    return "";
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
}
function map2(xs2, f) {
  if (xs2.map)
    return xs2.map(f);
  var res = [];
  for (var i = 0; i < xs2.length; i++) {
    res.push(f(xs2[i], i));
  }
  return res;
}
function parse4(qs2, sep, eq, options2) {
  sep = sep || "&";
  eq = eq || "=";
  var obj = {};
  if (typeof qs2 !== "string" || qs2.length === 0) {
    return obj;
  }
  var regexp = /\+/g;
  qs2 = qs2.split(sep);
  var maxKeys = 1e3;
  if (options2 && typeof options2.maxKeys === "number") {
    maxKeys = options2.maxKeys;
  }
  var len = qs2.length;
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }
  for (var i = 0; i < len; ++i) {
    var x = qs2[i].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k2, v;
    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = "";
    }
    k2 = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);
    if (!hasOwnProperty2(obj, k2)) {
      obj[k2] = v;
    } else if (isArray2(obj[k2])) {
      obj[k2].push(v);
    } else {
      obj[k2] = [obj[k2], v];
    }
  }
  return obj;
}
var isArray2, objectKeys2;
var init_qs = __esm({
  "node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/qs.js"() {
    isArray2 = Array.isArray || function(xs2) {
      return Object.prototype.toString.call(xs2) === "[object Array]";
    };
    objectKeys2 = Object.keys || function(obj) {
      var res = [];
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key))
          res.push(key);
      }
      return res;
    };
  }
});

// node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/url.js
var url_exports = {};
__export(url_exports, {
  Url: () => Url,
  default: () => url_default,
  format: () => urlFormat,
  parse: () => urlParse,
  resolve: () => urlResolve,
  resolveObject: () => urlResolveObject
});
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}
function urlParse(url2, parseQueryString, slashesDenoteHost) {
  if (url2 && isObject2(url2) && url2 instanceof Url)
    return url2;
  var u = new Url();
  u.parse(url2, parseQueryString, slashesDenoteHost);
  return u;
}
function parse5(self2, url2, parseQueryString, slashesDenoteHost) {
  if (!isString(url2)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url2);
  }
  var queryIndex = url2.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url2.indexOf("#") ? "?" : "#", uSplit = url2.split(splitter), slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, "/");
  url2 = uSplit.join(splitter);
  var rest = url2;
  rest = rest.trim();
  if (!slashesDenoteHost && url2.split("#").length === 1) {
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      self2.path = rest;
      self2.href = rest;
      self2.pathname = simplePath[1];
      if (simplePath[2]) {
        self2.search = simplePath[2];
        if (parseQueryString) {
          self2.query = parse4(self2.search.substr(1));
        } else {
          self2.query = self2.search.substr(1);
        }
      } else if (parseQueryString) {
        self2.search = "";
        self2.query = {};
      }
      return self2;
    }
  }
  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    self2.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      self2.slashes = true;
    }
  }
  var i, hec, l, p;
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    var hostEnd = -1;
    for (i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    var auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      self2.auth = decodeURIComponent(auth);
    }
    hostEnd = -1;
    for (i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    if (hostEnd === -1)
      hostEnd = rest.length;
    self2.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    parseHost(self2);
    self2.hostname = self2.hostname || "";
    var ipv6Hostname = self2.hostname[0] === "[" && self2.hostname[self2.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      var hostparts = self2.hostname.split(/\./);
      for (i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part)
          continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = "";
          for (var j2 = 0, k2 = part.length; j2 < k2; j2++) {
            if (part.charCodeAt(j2) > 127) {
              newpart += "x";
            } else {
              newpart += part[j2];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = "/" + notHost.join(".") + rest;
            }
            self2.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (self2.hostname.length > hostnameMaxLen) {
      self2.hostname = "";
    } else {
      self2.hostname = self2.hostname.toLowerCase();
    }
    if (!ipv6Hostname) {
      self2.hostname = toASCII(self2.hostname);
    }
    p = self2.port ? ":" + self2.port : "";
    var h = self2.hostname || "";
    self2.host = h + p;
    self2.href += self2.host;
    if (ipv6Hostname) {
      self2.hostname = self2.hostname.substr(1, self2.hostname.length - 2);
      if (rest[0] !== "/") {
        rest = "/" + rest;
      }
    }
  }
  if (!unsafeProtocol[lowerProto]) {
    for (i = 0, l = autoEscape.length; i < l; i++) {
      var ae2 = autoEscape[i];
      if (rest.indexOf(ae2) === -1)
        continue;
      var esc = encodeURIComponent(ae2);
      if (esc === ae2) {
        esc = escape(ae2);
      }
      rest = rest.split(ae2).join(esc);
    }
  }
  var hash = rest.indexOf("#");
  if (hash !== -1) {
    self2.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf("?");
  if (qm !== -1) {
    self2.search = rest.substr(qm);
    self2.query = rest.substr(qm + 1);
    if (parseQueryString) {
      self2.query = parse4(self2.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    self2.search = "";
    self2.query = {};
  }
  if (rest)
    self2.pathname = rest;
  if (slashedProtocol[lowerProto] && self2.hostname && !self2.pathname) {
    self2.pathname = "/";
  }
  if (self2.pathname || self2.search) {
    p = self2.pathname || "";
    var s = self2.search || "";
    self2.path = p + s;
  }
  self2.href = format2(self2);
  return self2;
}
function urlFormat(obj) {
  if (isString(obj))
    obj = parse5({}, obj);
  return format2(obj);
}
function format2(self2) {
  var auth = self2.auth || "";
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ":");
    auth += "@";
  }
  var protocol = self2.protocol || "", pathname = self2.pathname || "", hash = self2.hash || "", host = false, query = "";
  if (self2.host) {
    host = auth + self2.host;
  } else if (self2.hostname) {
    host = auth + (self2.hostname.indexOf(":") === -1 ? self2.hostname : "[" + this.hostname + "]");
    if (self2.port) {
      host += ":" + self2.port;
    }
  }
  if (self2.query && isObject2(self2.query) && Object.keys(self2.query).length) {
    query = stringify(self2.query);
  }
  var search = self2.search || query && "?" + query || "";
  if (protocol && protocol.substr(-1) !== ":")
    protocol += ":";
  if (self2.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = "//" + (host || "");
    if (pathname && pathname.charAt(0) !== "/")
      pathname = "/" + pathname;
  } else if (!host) {
    host = "";
  }
  if (hash && hash.charAt(0) !== "#")
    hash = "#" + hash;
  if (search && search.charAt(0) !== "?")
    search = "?" + search;
  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace("#", "%23");
  return protocol + host + pathname + search + hash;
}
function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}
function urlResolveObject(source, relative) {
  if (!source)
    return relative;
  return urlParse(source, false, true).resolveObject(relative);
}
function parseHost(self2) {
  var host = self2.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ":") {
      self2.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host)
    self2.hostname = host;
}
var url_default, protocolPattern, portPattern, simplePathPattern, delims, unwise, autoEscape, nonHostChars, hostEndingChars, hostnameMaxLen, hostnamePartPattern, hostnamePartStart, unsafeProtocol, hostlessProtocol, slashedProtocol;
var init_url = __esm({
  "node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/url.js"() {
    init_punycode();
    init_util();
    init_qs();
    url_default = {
      parse: urlParse,
      resolve: urlResolve,
      resolveObject: urlResolveObject,
      format: urlFormat,
      Url
    };
    protocolPattern = /^([a-z0-9.+-]+:)/i;
    portPattern = /:[0-9]*$/;
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
    delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
    unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
    autoEscape = ["'"].concat(unwise);
    nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
    hostEndingChars = ["/", "?", "#"];
    hostnameMaxLen = 255;
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    unsafeProtocol = {
      "javascript": true,
      "javascript:": true
    };
    hostlessProtocol = {
      "javascript": true,
      "javascript:": true
    };
    slashedProtocol = {
      "http": true,
      "https": true,
      "ftp": true,
      "gopher": true,
      "file": true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    Url.prototype.parse = function(url2, parseQueryString, slashesDenoteHost) {
      return parse5(this, url2, parseQueryString, slashesDenoteHost);
    };
    Url.prototype.format = function() {
      return format2(this);
    };
    Url.prototype.resolve = function(relative) {
      return this.resolveObject(urlParse(relative, false, true)).format();
    };
    Url.prototype.resolveObject = function(relative) {
      if (isString(relative)) {
        var rel = new Url();
        rel.parse(relative, false, true);
        relative = rel;
      }
      var result = new Url();
      var tkeys = Object.keys(this);
      for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
      }
      result.hash = relative.hash;
      if (relative.href === "") {
        result.href = result.format();
        return result;
      }
      if (relative.slashes && !relative.protocol) {
        var rkeys = Object.keys(relative);
        for (var rk = 0; rk < rkeys.length; rk++) {
          var rkey = rkeys[rk];
          if (rkey !== "protocol")
            result[rkey] = relative[rkey];
        }
        if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
          result.path = result.pathname = "/";
        }
        result.href = result.format();
        return result;
      }
      var relPath;
      if (relative.protocol && relative.protocol !== result.protocol) {
        if (!slashedProtocol[relative.protocol]) {
          var keys2 = Object.keys(relative);
          for (var v = 0; v < keys2.length; v++) {
            var k2 = keys2[v];
            result[k2] = relative[k2];
          }
          result.href = result.format();
          return result;
        }
        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
          relPath = (relative.pathname || "").split("/");
          while (relPath.length && !(relative.host = relPath.shift()))
            ;
          if (!relative.host)
            relative.host = "";
          if (!relative.hostname)
            relative.hostname = "";
          if (relPath[0] !== "")
            relPath.unshift("");
          if (relPath.length < 2)
            relPath.unshift("");
          result.pathname = relPath.join("/");
        } else {
          result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || "";
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        if (result.pathname || result.search) {
          var p = result.pathname || "";
          var s = result.search || "";
          result.path = p + s;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      }
      var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
      relPath = relative.pathname && relative.pathname.split("/") || [];
      if (psychotic) {
        result.hostname = "";
        result.port = null;
        if (result.host) {
          if (srcPath[0] === "")
            srcPath[0] = result.host;
          else
            srcPath.unshift(result.host);
        }
        result.host = "";
        if (relative.protocol) {
          relative.hostname = null;
          relative.port = null;
          if (relative.host) {
            if (relPath[0] === "")
              relPath[0] = relative.host;
            else
              relPath.unshift(relative.host);
          }
          relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
      }
      var authInHost;
      if (isRelAbs) {
        result.host = relative.host || relative.host === "" ? relative.host : result.host;
        result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
      } else if (relPath.length) {
        if (!srcPath)
          srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
      } else if (!isNullOrUndefined(relative.search)) {
        if (psychotic) {
          result.hostname = result.host = srcPath.shift();
          authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
          }
        }
        result.search = relative.search;
        result.query = relative.query;
        if (!isNull(result.pathname) || !isNull(result.search)) {
          result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.href = result.format();
        return result;
      }
      if (!srcPath.length) {
        result.pathname = null;
        if (result.search) {
          result.path = "/" + result.search;
        } else {
          result.path = null;
        }
        result.href = result.format();
        return result;
      }
      var last = srcPath.slice(-1)[0];
      var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
      var up = 0;
      for (var i = srcPath.length; i >= 0; i--) {
        last = srcPath[i];
        if (last === ".") {
          srcPath.splice(i, 1);
        } else if (last === "..") {
          srcPath.splice(i, 1);
          up++;
        } else if (up) {
          srcPath.splice(i, 1);
          up--;
        }
      }
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift("..");
        }
      }
      if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
        srcPath.unshift("");
      }
      if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
        srcPath.push("");
      }
      var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
      if (psychotic) {
        result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
        authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }
      mustEndAbs = mustEndAbs || result.host && srcPath.length;
      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift("");
      }
      if (!srcPath.length) {
        result.pathname = null;
        result.path = null;
      } else {
        result.pathname = srcPath.join("/");
      }
      if (!isNull(result.pathname) || !isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
      }
      result.auth = relative.auth || result.auth;
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    };
    Url.prototype.parseHost = function() {
      return parseHost(this);
    };
  }
});

// node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/http.js
var http_exports = {};
__export(http_exports, {
  Agent: () => Agent,
  METHODS: () => METHODS,
  STATUS_CODES: () => STATUS_CODES,
  default: () => http_default,
  get: () => get,
  request: () => request2
});
function request2(opts, cb) {
  if (typeof opts === "string")
    opts = urlParse(opts);
  var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? "http:" : "";
  var protocol = opts.protocol || defaultProtocol;
  var host = opts.hostname || opts.host;
  var port = opts.port;
  var path = opts.path || "/";
  if (host && host.indexOf(":") !== -1)
    host = "[" + host + "]";
  opts.url = (host ? protocol + "//" + host : "") + (port ? ":" + port : "") + path;
  opts.method = (opts.method || "GET").toUpperCase();
  opts.headers = opts.headers || {};
  var req = new request_default(opts);
  if (cb)
    req.on("response", cb);
  return req;
}
function get(opts, cb) {
  var req = request2(opts, cb);
  req.end();
  return req;
}
function Agent() {
}
var METHODS, STATUS_CODES, http_default;
var init_http = __esm({
  "node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/http.js"() {
    init_request();
    init_url();
    Agent.defaultMaxSockets = 4;
    METHODS = [
      "CHECKOUT",
      "CONNECT",
      "COPY",
      "DELETE",
      "GET",
      "HEAD",
      "LOCK",
      "M-SEARCH",
      "MERGE",
      "MKACTIVITY",
      "MKCOL",
      "MOVE",
      "NOTIFY",
      "OPTIONS",
      "PATCH",
      "POST",
      "PROPFIND",
      "PROPPATCH",
      "PURGE",
      "PUT",
      "REPORT",
      "SEARCH",
      "SUBSCRIBE",
      "TRACE",
      "UNLOCK",
      "UNSUBSCRIBE"
    ];
    STATUS_CODES = {
      100: "Continue",
      101: "Switching Protocols",
      102: "Processing",
      200: "OK",
      201: "Created",
      202: "Accepted",
      203: "Non-Authoritative Information",
      204: "No Content",
      205: "Reset Content",
      206: "Partial Content",
      207: "Multi-Status",
      300: "Multiple Choices",
      301: "Moved Permanently",
      302: "Moved Temporarily",
      303: "See Other",
      304: "Not Modified",
      305: "Use Proxy",
      307: "Temporary Redirect",
      400: "Bad Request",
      401: "Unauthorized",
      402: "Payment Required",
      403: "Forbidden",
      404: "Not Found",
      405: "Method Not Allowed",
      406: "Not Acceptable",
      407: "Proxy Authentication Required",
      408: "Request Time-out",
      409: "Conflict",
      410: "Gone",
      411: "Length Required",
      412: "Precondition Failed",
      413: "Request Entity Too Large",
      414: "Request-URI Too Large",
      415: "Unsupported Media Type",
      416: "Requested Range Not Satisfiable",
      417: "Expectation Failed",
      418: "I'm a teapot",
      422: "Unprocessable Entity",
      423: "Locked",
      424: "Failed Dependency",
      425: "Unordered Collection",
      426: "Upgrade Required",
      428: "Precondition Required",
      429: "Too Many Requests",
      431: "Request Header Fields Too Large",
      500: "Internal Server Error",
      501: "Not Implemented",
      502: "Bad Gateway",
      503: "Service Unavailable",
      504: "Gateway Time-out",
      505: "HTTP Version Not Supported",
      506: "Variant Also Negotiates",
      507: "Insufficient Storage",
      509: "Bandwidth Limit Exceeded",
      510: "Not Extended",
      511: "Network Authentication Required"
    };
    http_default = {
      request: request2,
      get,
      Agent,
      METHODS,
      STATUS_CODES
    };
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/core/errors.js
var require_errors = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/core/errors.js"(exports2, module2) {
    "use strict";
    var AbortError = class extends Error {
      constructor() {
        super("The operation was aborted");
        this.code = "ABORT_ERR";
        this.name = "AbortError";
      }
    };
    var UndiciError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "UndiciError";
        this.code = "UND_ERR";
      }
    };
    var ConnectTimeoutError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, ConnectTimeoutError);
        this.name = "ConnectTimeoutError";
        this.message = message || "Connect Timeout Error";
        this.code = "UND_ERR_CONNECT_TIMEOUT";
      }
    };
    var HeadersTimeoutError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, HeadersTimeoutError);
        this.name = "HeadersTimeoutError";
        this.message = message || "Headers Timeout Error";
        this.code = "UND_ERR_HEADERS_TIMEOUT";
      }
    };
    var HeadersOverflowError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, HeadersOverflowError);
        this.name = "HeadersOverflowError";
        this.message = message || "Headers Overflow Error";
        this.code = "UND_ERR_HEADERS_OVERFLOW";
      }
    };
    var BodyTimeoutError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, BodyTimeoutError);
        this.name = "BodyTimeoutError";
        this.message = message || "Body Timeout Error";
        this.code = "UND_ERR_BODY_TIMEOUT";
      }
    };
    var InvalidArgumentError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, InvalidArgumentError);
        this.name = "InvalidArgumentError";
        this.message = message || "Invalid Argument Error";
        this.code = "UND_ERR_INVALID_ARG";
      }
    };
    var InvalidReturnValueError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, InvalidReturnValueError);
        this.name = "InvalidReturnValueError";
        this.message = message || "Invalid Return Value Error";
        this.code = "UND_ERR_INVALID_RETURN_VALUE";
      }
    };
    var RequestAbortedError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, RequestAbortedError);
        this.name = "AbortError";
        this.message = message || "Request aborted";
        this.code = "UND_ERR_ABORTED";
      }
    };
    var InformationalError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, InformationalError);
        this.name = "InformationalError";
        this.message = message || "Request information";
        this.code = "UND_ERR_INFO";
      }
    };
    var RequestContentLengthMismatchError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, RequestContentLengthMismatchError);
        this.name = "RequestContentLengthMismatchError";
        this.message = message || "Request body length does not match content-length header";
        this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
      }
    };
    var ResponseContentLengthMismatchError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, ResponseContentLengthMismatchError);
        this.name = "ResponseContentLengthMismatchError";
        this.message = message || "Response body length does not match content-length header";
        this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
      }
    };
    var TrailerMismatchError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, TrailerMismatchError);
        this.name = "TrailerMismatchError";
        this.message = message || "Trailers does not match trailer header";
        this.code = "UND_ERR_TRAILER_MISMATCH";
      }
    };
    var ClientDestroyedError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, ClientDestroyedError);
        this.name = "ClientDestroyedError";
        this.message = message || "The client is destroyed";
        this.code = "UND_ERR_DESTROYED";
      }
    };
    var ClientClosedError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, ClientClosedError);
        this.name = "ClientClosedError";
        this.message = message || "The client is closed";
        this.code = "UND_ERR_CLOSED";
      }
    };
    var SocketError = class extends UndiciError {
      constructor(message, socket) {
        super(message);
        Error.captureStackTrace(this, SocketError);
        this.name = "SocketError";
        this.message = message || "Socket error";
        this.code = "UND_ERR_SOCKET";
        this.socket = socket;
      }
    };
    var NotSupportedError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, NotSupportedError);
        this.name = "NotSupportedError";
        this.message = message || "Not supported error";
        this.code = "UND_ERR_NOT_SUPPORTED";
      }
    };
    var BalancedPoolMissingUpstreamError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, NotSupportedError);
        this.name = "MissingUpstreamError";
        this.message = message || "No upstream has been added to the BalancedPool";
        this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
      }
    };
    var HTTPParserError = class extends Error {
      constructor(message, code, data) {
        super(message);
        Error.captureStackTrace(this, HTTPParserError);
        this.name = "HTTPParserError";
        this.code = code ? `HPE_${code}` : void 0;
        this.data = data ? data.toString() : void 0;
      }
    };
    module2.exports = {
      AbortError,
      HTTPParserError,
      UndiciError,
      HeadersTimeoutError,
      HeadersOverflowError,
      BodyTimeoutError,
      RequestContentLengthMismatchError,
      ConnectTimeoutError,
      TrailerMismatchError,
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError,
      ClientDestroyedError,
      ClientClosedError,
      InformationalError,
      SocketError,
      NotSupportedError,
      ResponseContentLengthMismatchError,
      BalancedPoolMissingUpstreamError
    };
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/core/util.js
var require_util = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/core/util.js"(exports2, module2) {
    "use strict";
    var assert3 = (init_assert(), __toCommonJS(assert_exports));
    var { kDestroyed, kBodyUsed } = require_symbols();
    var { IncomingMessage: IncomingMessage2 } = (init_http(), __toCommonJS(http_exports));
    var stream = (init_stream(), __toCommonJS(stream_exports));
    var net = (init_empty(), __toCommonJS(empty_exports));
    var { InvalidArgumentError } = require_errors();
    var { Blob } = (init_buffer_es6(), __toCommonJS(buffer_es6_exports));
    var nodeUtil = (init_util(), __toCommonJS(util_exports));
    function nop2() {
    }
    function isStream(obj) {
      return obj && typeof obj.pipe === "function";
    }
    function isBlobLike(object) {
      return Blob && object instanceof Blob || object && typeof object === "object" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
    }
    function parseURL(url2) {
      if (typeof url2 === "string") {
        url2 = new URL(url2);
      }
      if (!url2 || typeof url2 !== "object") {
        throw new InvalidArgumentError("invalid url");
      }
      if (url2.port != null && url2.port !== "" && !Number.isFinite(parseInt(url2.port))) {
        throw new InvalidArgumentError("invalid port");
      }
      if (url2.path != null && typeof url2.path !== "string") {
        throw new InvalidArgumentError("invalid path");
      }
      if (url2.pathname != null && typeof url2.pathname !== "string") {
        throw new InvalidArgumentError("invalid pathname");
      }
      if (url2.hostname != null && typeof url2.hostname !== "string") {
        throw new InvalidArgumentError("invalid hostname");
      }
      if (url2.origin != null && typeof url2.origin !== "string") {
        throw new InvalidArgumentError("invalid origin");
      }
      if (!/^https?:/.test(url2.origin || url2.protocol)) {
        throw new InvalidArgumentError("invalid protocol");
      }
      if (!(url2 instanceof URL)) {
        const port = url2.port != null ? url2.port : url2.protocol === "https:" ? 443 : 80;
        const origin = url2.origin != null ? url2.origin : `${url2.protocol}//${url2.hostname}:${port}`;
        const path = url2.path != null ? url2.path : `${url2.pathname || ""}${url2.search || ""}`;
        url2 = new URL(path, origin);
      }
      return url2;
    }
    function parseOrigin(url2) {
      url2 = parseURL(url2);
      if (url2.pathname !== "/" || url2.search || url2.hash) {
        throw new InvalidArgumentError("invalid url");
      }
      return url2;
    }
    function getHostname(host) {
      if (host[0] === "[") {
        const idx2 = host.indexOf("]");
        assert3(idx2 !== -1);
        return host.substr(1, idx2 - 1);
      }
      const idx = host.indexOf(":");
      if (idx === -1)
        return host;
      return host.substr(0, idx);
    }
    function getServerName(host) {
      if (!host) {
        return null;
      }
      assert3.strictEqual(typeof host, "string");
      const servername = getHostname(host);
      if (net.isIP(servername)) {
        return "";
      }
      return servername;
    }
    function deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    function isAsyncIterable3(obj) {
      return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
    }
    function isIterable(obj) {
      return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
    }
    function bodyLength(body) {
      if (body == null) {
        return 0;
      } else if (isStream(body)) {
        const state = body._readableState;
        return state && state.ended === true && Number.isFinite(state.length) ? state.length : null;
      } else if (isBlobLike(body)) {
        return body.size != null ? body.size : null;
      } else if (isBuffer3(body)) {
        return body.byteLength;
      }
      return null;
    }
    function isDestroyed(stream2) {
      return !stream2 || !!(stream2.destroyed || stream2[kDestroyed]);
    }
    function isReadableAborted(stream2) {
      const state = stream2 && stream2._readableState;
      return isDestroyed(stream2) && state && !state.endEmitted;
    }
    function destroy(stream2, err2) {
      if (!isStream(stream2) || isDestroyed(stream2)) {
        return;
      }
      if (typeof stream2.destroy === "function") {
        if (Object.getPrototypeOf(stream2).constructor === IncomingMessage2) {
          stream2.socket = null;
        }
        stream2.destroy(err2);
      } else if (err2) {
        process.nextTick((stream3, err3) => {
          stream3.emit("error", err3);
        }, stream2, err2);
      }
      if (stream2.destroyed !== true) {
        stream2[kDestroyed] = true;
      }
    }
    var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
    function parseKeepAliveTimeout(val) {
      const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
      return m ? parseInt(m[1], 10) * 1e3 : null;
    }
    function parseHeaders(headers, obj = {}) {
      for (let i = 0; i < headers.length; i += 2) {
        const key = headers[i].toString().toLowerCase();
        let val = obj[key];
        if (!val) {
          obj[key] = headers[i + 1].toString();
        } else {
          if (!Array.isArray(val)) {
            val = [val];
            obj[key] = val;
          }
          val.push(headers[i + 1].toString());
        }
      }
      return obj;
    }
    function parseRawHeaders(headers) {
      return headers.map((header) => header.toString());
    }
    function isBuffer3(buffer) {
      return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
    }
    function validateHandler(handler, method, upgrade) {
      if (!handler || typeof handler !== "object") {
        throw new InvalidArgumentError("handler must be an object");
      }
      if (typeof handler.onConnect !== "function") {
        throw new InvalidArgumentError("invalid onConnect method");
      }
      if (typeof handler.onError !== "function") {
        throw new InvalidArgumentError("invalid onError method");
      }
      if (typeof handler.onBodySent !== "function" && handler.onBodySent !== void 0) {
        throw new InvalidArgumentError("invalid onBodySent method");
      }
      if (upgrade || method === "CONNECT") {
        if (typeof handler.onUpgrade !== "function") {
          throw new InvalidArgumentError("invalid onUpgrade method");
        }
      } else {
        if (typeof handler.onHeaders !== "function") {
          throw new InvalidArgumentError("invalid onHeaders method");
        }
        if (typeof handler.onData !== "function") {
          throw new InvalidArgumentError("invalid onData method");
        }
        if (typeof handler.onComplete !== "function") {
          throw new InvalidArgumentError("invalid onComplete method");
        }
      }
    }
    function isDisturbed(body) {
      return !!(body && (stream.isDisturbed ? stream.isDisturbed(body) || body[kBodyUsed] : body[kBodyUsed] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));
    }
    function isErrored(body) {
      return !!(body && (stream.isErrored ? stream.isErrored(body) : /state: 'errored'/.test(nodeUtil.inspect(body))));
    }
    function isReadable(body) {
      return !!(body && (stream.isReadable ? stream.isReadable(body) : /state: 'readable'/.test(nodeUtil.inspect(body))));
    }
    function getSocketInfo(socket) {
      return {
        localAddress: socket.localAddress,
        localPort: socket.localPort,
        remoteAddress: socket.remoteAddress,
        remotePort: socket.remotePort,
        remoteFamily: socket.remoteFamily,
        timeout: socket.timeout,
        bytesWritten: socket.bytesWritten,
        bytesRead: socket.bytesRead
      };
    }
    var ReadableStream2;
    function ReadableStreamFrom(iterable) {
      if (!ReadableStream2) {
        ReadableStream2 = __require("stream/web").ReadableStream;
      }
      if (ReadableStream2.from) {
        return ReadableStream2.from(iterable);
      }
      let iterator;
      return new ReadableStream2({
        async start() {
          iterator = iterable[Symbol.asyncIterator]();
        },
        async pull(controller) {
          const { done: done2, value } = await iterator.next();
          if (done2) {
            queueMicrotask(() => {
              controller.close();
            });
          } else {
            const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
            controller.enqueue(new Uint8Array(buf));
          }
          return controller.desiredSize > 0;
        },
        async cancel(reason) {
          await iterator.return();
        }
      }, 0);
    }
    var kEnumerableProperty = /* @__PURE__ */ Object.create(null);
    kEnumerableProperty.enumerable = true;
    module2.exports = {
      kEnumerableProperty,
      nop: nop2,
      isDisturbed,
      isErrored,
      isReadable,
      toUSVString: nodeUtil.toUSVString || ((val) => `${val}`),
      isReadableAborted,
      isBlobLike,
      parseOrigin,
      parseURL,
      getServerName,
      isStream,
      isIterable,
      isAsyncIterable: isAsyncIterable3,
      isDestroyed,
      parseRawHeaders,
      parseHeaders,
      parseKeepAliveTimeout,
      destroy,
      bodyLength,
      deepClone,
      ReadableStreamFrom,
      isBuffer: isBuffer3,
      validateHandler,
      getSocketInfo
    };
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/core/request.js
var require_request = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/core/request.js"(exports2, module2) {
    "use strict";
    var {
      InvalidArgumentError,
      NotSupportedError
    } = require_errors();
    var util = require_util();
    var assert3 = (init_assert(), __toCommonJS(assert_exports));
    var kHandler = Symbol("handler");
    var channels = {};
    try {
      const diagnosticsChannel = __require("diagnostics_channel");
      channels.create = diagnosticsChannel.channel("undici:request:create");
      channels.bodySent = diagnosticsChannel.channel("undici:request:bodySent");
      channels.headers = diagnosticsChannel.channel("undici:request:headers");
      channels.trailers = diagnosticsChannel.channel("undici:request:trailers");
      channels.error = diagnosticsChannel.channel("undici:request:error");
    } catch {
      channels.create = { hasSubscribers: false };
      channels.bodySent = { hasSubscribers: false };
      channels.headers = { hasSubscribers: false };
      channels.trailers = { hasSubscribers: false };
      channels.error = { hasSubscribers: false };
    }
    var Request2 = class {
      constructor(origin, {
        path,
        method,
        body,
        headers,
        idempotent,
        blocking,
        upgrade,
        headersTimeout,
        bodyTimeout
      }, handler) {
        if (typeof path !== "string") {
          throw new InvalidArgumentError("path must be a string");
        } else if (path[0] !== "/" && !(path.startsWith("http://") || path.startsWith("https://"))) {
          throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
        }
        if (typeof method !== "string") {
          throw new InvalidArgumentError("method must be a string");
        }
        if (upgrade && typeof upgrade !== "string") {
          throw new InvalidArgumentError("upgrade must be a string");
        }
        if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("invalid headersTimeout");
        }
        if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("invalid bodyTimeout");
        }
        this.headersTimeout = headersTimeout;
        this.bodyTimeout = bodyTimeout;
        this.method = method;
        if (body == null) {
          this.body = null;
        } else if (util.isStream(body)) {
          this.body = body;
        } else if (body instanceof DataView) {
          this.body = body.buffer.byteLength ? Buffer.from(body.buffer) : null;
        } else if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
          this.body = body.byteLength ? Buffer.from(body) : null;
        } else if (util.isBuffer(body)) {
          this.body = body.byteLength ? body : null;
        } else if (typeof body === "string") {
          this.body = body.length ? Buffer.from(body) : null;
        } else if (util.isIterable(body) || util.isBlobLike(body)) {
          this.body = body;
        } else {
          throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
        }
        this.completed = false;
        this.aborted = false;
        this.upgrade = upgrade || null;
        this.path = path;
        this.origin = origin;
        this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
        this.blocking = blocking == null ? false : blocking;
        this.host = null;
        this.contentLength = null;
        this.contentType = null;
        this.headers = "";
        if (Array.isArray(headers)) {
          if (headers.length % 2 !== 0) {
            throw new InvalidArgumentError("headers array must be even");
          }
          for (let i = 0; i < headers.length; i += 2) {
            processHeader(this, headers[i], headers[i + 1]);
          }
        } else if (headers && typeof headers === "object") {
          const keys2 = Object.keys(headers);
          for (let i = 0; i < keys2.length; i++) {
            const key = keys2[i];
            processHeader(this, key, headers[key]);
          }
        } else if (headers != null) {
          throw new InvalidArgumentError("headers must be an object or an array");
        }
        if (util.isBlobLike(body) && this.contentType == null && body.type) {
          this.contentType = body.type;
          this.headers += `content-type: ${body.type}\r
`;
        }
        util.validateHandler(handler, method, upgrade);
        this.servername = util.getServerName(this.host);
        this[kHandler] = handler;
        if (channels.create.hasSubscribers) {
          channels.create.publish({ request: this });
        }
      }
      onBodySent(chunk) {
        if (this[kHandler].onBodySent) {
          try {
            this[kHandler].onBodySent(chunk);
          } catch (err2) {
            this.onError(err2);
          }
        }
      }
      onRequestSent() {
        if (channels.bodySent.hasSubscribers) {
          channels.bodySent.publish({ request: this });
        }
      }
      onConnect(abort) {
        assert3(!this.aborted);
        assert3(!this.completed);
        return this[kHandler].onConnect(abort);
      }
      onHeaders(statusCode, headers, resume2, statusText) {
        assert3(!this.aborted);
        assert3(!this.completed);
        if (channels.headers.hasSubscribers) {
          channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });
        }
        return this[kHandler].onHeaders(statusCode, headers, resume2, statusText);
      }
      onData(chunk) {
        assert3(!this.aborted);
        assert3(!this.completed);
        return this[kHandler].onData(chunk);
      }
      onUpgrade(statusCode, headers, socket) {
        assert3(!this.aborted);
        assert3(!this.completed);
        return this[kHandler].onUpgrade(statusCode, headers, socket);
      }
      onComplete(trailers) {
        assert3(!this.aborted);
        this.completed = true;
        if (channels.trailers.hasSubscribers) {
          channels.trailers.publish({ request: this, trailers });
        }
        return this[kHandler].onComplete(trailers);
      }
      onError(error2) {
        if (channels.error.hasSubscribers) {
          channels.error.publish({ request: this, error: error2 });
        }
        if (this.aborted) {
          return;
        }
        this.aborted = true;
        return this[kHandler].onError(error2);
      }
      addHeader(key, value) {
        processHeader(this, key, value);
        return this;
      }
    };
    function processHeader(request3, key, val) {
      if (val && typeof val === "object") {
        throw new InvalidArgumentError(`invalid ${key} header`);
      } else if (val === void 0) {
        return;
      }
      if (request3.host === null && key.length === 4 && key.toLowerCase() === "host") {
        request3.host = val;
      } else if (request3.contentLength === null && key.length === 14 && key.toLowerCase() === "content-length") {
        request3.contentLength = parseInt(val, 10);
        if (!Number.isFinite(request3.contentLength)) {
          throw new InvalidArgumentError("invalid content-length header");
        }
      } else if (request3.contentType === null && key.length === 12 && key.toLowerCase() === "content-type") {
        request3.contentType = val;
        request3.headers += `${key}: ${val}\r
`;
      } else if (key.length === 17 && key.toLowerCase() === "transfer-encoding") {
        throw new InvalidArgumentError("invalid transfer-encoding header");
      } else if (key.length === 10 && key.toLowerCase() === "connection") {
        throw new InvalidArgumentError("invalid connection header");
      } else if (key.length === 10 && key.toLowerCase() === "keep-alive") {
        throw new InvalidArgumentError("invalid keep-alive header");
      } else if (key.length === 7 && key.toLowerCase() === "upgrade") {
        throw new InvalidArgumentError("invalid upgrade header");
      } else if (key.length === 6 && key.toLowerCase() === "expect") {
        throw new NotSupportedError("expect header not supported");
      } else {
        request3.headers += `${key}: ${val}\r
`;
      }
    }
    module2.exports = Request2;
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/dispatcher.js
var require_dispatcher = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/dispatcher.js"(exports2, module2) {
    "use strict";
    var EventEmitter2 = (init_events(), __toCommonJS(events_exports));
    var Dispatcher = class extends EventEmitter2 {
      dispatch() {
        throw new Error("not implemented");
      }
      close() {
        throw new Error("not implemented");
      }
      destroy() {
        throw new Error("not implemented");
      }
    };
    module2.exports = Dispatcher;
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/dispatcher-base.js
var require_dispatcher_base = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/dispatcher-base.js"(exports2, module2) {
    "use strict";
    var Dispatcher = require_dispatcher();
    var {
      ClientDestroyedError,
      ClientClosedError,
      InvalidArgumentError
    } = require_errors();
    var { kDestroy, kClose, kDispatch } = require_symbols();
    var kDestroyed = Symbol("destroyed");
    var kClosed = Symbol("closed");
    var kOnDestroyed = Symbol("onDestroyed");
    var kOnClosed = Symbol("onClosed");
    var DispatcherBase = class extends Dispatcher {
      constructor() {
        super();
        this[kDestroyed] = false;
        this[kOnDestroyed] = [];
        this[kClosed] = false;
        this[kOnClosed] = [];
      }
      get destroyed() {
        return this[kDestroyed];
      }
      get closed() {
        return this[kClosed];
      }
      close(callback) {
        if (callback === void 0) {
          return new Promise((resolve2, reject2) => {
            this.close((err2, data) => {
              return err2 ? reject2(err2) : resolve2(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          queueMicrotask(() => callback(new ClientDestroyedError(), null));
          return;
        }
        if (this[kClosed]) {
          if (this[kOnClosed]) {
            this[kOnClosed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        this[kClosed] = true;
        this[kOnClosed].push(callback);
        const onClosed = () => {
          const callbacks = this[kOnClosed];
          this[kOnClosed] = null;
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](null, null);
          }
        };
        this[kClose]().then(() => this.destroy()).then(() => {
          queueMicrotask(onClosed);
        });
      }
      destroy(err2, callback) {
        if (typeof err2 === "function") {
          callback = err2;
          err2 = null;
        }
        if (callback === void 0) {
          return new Promise((resolve2, reject2) => {
            this.destroy(err2, (err3, data) => {
              return err3 ? reject2(err3) : resolve2(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          if (this[kOnDestroyed]) {
            this[kOnDestroyed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        if (!err2) {
          err2 = new ClientDestroyedError();
        }
        this[kDestroyed] = true;
        this[kOnDestroyed].push(callback);
        const onDestroyed = () => {
          const callbacks = this[kOnDestroyed];
          this[kOnDestroyed] = null;
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](null, null);
          }
        };
        this[kDestroy](err2).then(() => {
          queueMicrotask(onDestroyed);
        });
      }
      dispatch(opts, handler) {
        if (!handler || typeof handler !== "object") {
          throw new InvalidArgumentError("handler must be an object");
        }
        try {
          if (!opts || typeof opts !== "object") {
            throw new InvalidArgumentError("opts must be an object.");
          }
          if (this[kDestroyed]) {
            throw new ClientDestroyedError();
          }
          if (this[kClosed]) {
            throw new ClientClosedError();
          }
          return this[kDispatch](opts, handler);
        } catch (err2) {
          if (typeof handler.onError !== "function") {
            throw new InvalidArgumentError("invalid onError method");
          }
          handler.onError(err2);
          return false;
        }
      }
    };
    module2.exports = DispatcherBase;
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/handler/redirect.js
var require_redirect = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/handler/redirect.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    var { kBodyUsed } = require_symbols();
    var assert3 = (init_assert(), __toCommonJS(assert_exports));
    var { InvalidArgumentError } = require_errors();
    var EE = (init_events(), __toCommonJS(events_exports));
    var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
    var kBody = Symbol("body");
    var BodyAsyncIterable = class {
      constructor(body) {
        this[kBody] = body;
        this[kBodyUsed] = false;
      }
      async *[Symbol.asyncIterator]() {
        assert3(!this[kBodyUsed], "disturbed");
        this[kBodyUsed] = true;
        yield* this[kBody];
      }
    };
    var RedirectHandler = class {
      constructor(dispatcher, maxRedirections, opts, handler) {
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        util.validateHandler(handler, opts.method, opts.upgrade);
        this.dispatcher = dispatcher;
        this.location = null;
        this.abort = null;
        this.opts = { ...opts, maxRedirections: 0 };
        this.maxRedirections = maxRedirections;
        this.handler = handler;
        this.history = [];
        if (util.isStream(this.opts.body)) {
          if (util.bodyLength(this.opts.body) === 0) {
            this.opts.body.on("data", function() {
              assert3(false);
            });
          }
          if (typeof this.opts.body.readableDidRead !== "boolean") {
            this.opts.body[kBodyUsed] = false;
            EE.prototype.on.call(this.opts.body, "data", function() {
              this[kBodyUsed] = true;
            });
          }
        } else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        } else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body)) {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        }
      }
      onConnect(abort) {
        this.abort = abort;
        this.handler.onConnect(abort, { history: this.history });
      }
      onUpgrade(statusCode, headers, socket) {
        this.handler.onUpgrade(statusCode, headers, socket);
      }
      onError(error2) {
        this.handler.onError(error2);
      }
      onHeaders(statusCode, headers, resume2, statusText) {
        this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);
        if (this.opts.origin) {
          this.history.push(new URL(this.opts.path, this.opts.origin));
        }
        if (!this.location) {
          return this.handler.onHeaders(statusCode, headers, resume2, statusText);
        }
        const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin));
        const path = search ? `${pathname}${search}` : pathname;
        this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
        this.opts.path = path;
        this.opts.origin = origin;
        this.opts.maxRedirections = 0;
        if (statusCode === 303 && this.opts.method !== "HEAD") {
          this.opts.method = "GET";
          this.opts.body = null;
        }
      }
      onData(chunk) {
        if (this.location) {
        } else {
          return this.handler.onData(chunk);
        }
      }
      onComplete(trailers) {
        if (this.location) {
          this.location = null;
          this.abort = null;
          this.dispatcher.dispatch(this.opts, this);
        } else {
          this.handler.onComplete(trailers);
        }
      }
      onBodySent(chunk) {
        if (this.handler.onBodySent) {
          this.handler.onBodySent(chunk);
        }
      }
    };
    function parseLocation(statusCode, headers) {
      if (redirectableStatusCodes.indexOf(statusCode) === -1) {
        return null;
      }
      for (let i = 0; i < headers.length; i += 2) {
        if (headers[i].toString().toLowerCase() === "location") {
          return headers[i + 1];
        }
      }
    }
    function shouldRemoveHeader(header, removeContent, unknownOrigin) {
      return header.length === 4 && header.toString().toLowerCase() === "host" || removeContent && header.toString().toLowerCase().indexOf("content-") === 0 || unknownOrigin && header.length === 13 && header.toString().toLowerCase() === "authorization";
    }
    function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
      const ret = [];
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2) {
          if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {
            ret.push(headers[i], headers[i + 1]);
          }
        }
      } else if (headers && typeof headers === "object") {
        for (const key of Object.keys(headers)) {
          if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
            ret.push(key, headers[key]);
          }
        }
      } else {
        assert3(headers == null, "headers must be an object or an array");
      }
      return ret;
    }
    module2.exports = RedirectHandler;
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/core/connect.js
var require_connect = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/core/connect.js"(exports2, module2) {
    "use strict";
    var net = (init_empty(), __toCommonJS(empty_exports));
    var assert3 = (init_assert(), __toCommonJS(assert_exports));
    var util = require_util();
    var { InvalidArgumentError, ConnectTimeoutError } = require_errors();
    var tls;
    function buildConnector({ maxCachedSessions, socketPath, timeout, ...opts }) {
      if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
        throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
      }
      const options2 = { path: socketPath, ...opts };
      const sessionCache = /* @__PURE__ */ new Map();
      timeout = timeout == null ? 1e4 : timeout;
      maxCachedSessions = maxCachedSessions == null ? 100 : maxCachedSessions;
      return function connect({ hostname, host, protocol, port, servername }, callback) {
        let socket;
        if (protocol === "https:") {
          if (!tls) {
            tls = (init_empty(), __toCommonJS(empty_exports));
          }
          servername = servername || options2.servername || util.getServerName(host) || null;
          const sessionKey = servername || hostname;
          const session = sessionCache.get(sessionKey) || null;
          assert3(sessionKey);
          socket = tls.connect({
            highWaterMark: 16384,
            ...options2,
            servername,
            session,
            port: port || 443,
            host: hostname
          });
          socket.on("session", function(session2) {
            if (maxCachedSessions === 0) {
              return;
            }
            if (sessionCache.size >= maxCachedSessions) {
              const { value: oldestKey } = sessionCache.keys().next();
              sessionCache.delete(oldestKey);
            }
            sessionCache.set(sessionKey, session2);
          }).on("error", function(err2) {
            if (sessionKey && err2.code !== "UND_ERR_INFO") {
              sessionCache.delete(sessionKey);
            }
          });
        } else {
          socket = net.connect({
            highWaterMark: 64 * 1024,
            ...options2,
            port: port || 80,
            host: hostname
          });
        }
        const timeoutId = timeout ? setTimeout(onConnectTimeout, timeout, socket) : null;
        socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
          clearTimeout(timeoutId);
          if (callback) {
            const cb = callback;
            callback = null;
            cb(null, this);
          }
        }).on("error", function(err2) {
          clearTimeout(timeoutId);
          if (callback) {
            const cb = callback;
            callback = null;
            cb(err2);
          }
        });
        return socket;
      };
    }
    function onConnectTimeout(socket) {
      util.destroy(socket, new ConnectTimeoutError());
    }
    module2.exports = buildConnector;
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/llhttp/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/llhttp/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enumToMap = void 0;
    function enumToMap(obj) {
      const res = {};
      Object.keys(obj).forEach((key) => {
        const value = obj[key];
        if (typeof value === "number") {
          res[key] = value;
        }
      });
      return res;
    }
    exports2.enumToMap = enumToMap;
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/llhttp/constants.js
var require_constants = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/llhttp/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SPECIAL_HEADERS = exports2.HEADER_STATE = exports2.MINOR = exports2.MAJOR = exports2.CONNECTION_TOKEN_CHARS = exports2.HEADER_CHARS = exports2.TOKEN = exports2.STRICT_TOKEN = exports2.HEX = exports2.URL_CHAR = exports2.STRICT_URL_CHAR = exports2.USERINFO_CHARS = exports2.MARK = exports2.ALPHANUM = exports2.NUM = exports2.HEX_MAP = exports2.NUM_MAP = exports2.ALPHA = exports2.FINISH = exports2.H_METHOD_MAP = exports2.METHOD_MAP = exports2.METHODS_RTSP = exports2.METHODS_ICE = exports2.METHODS_HTTP = exports2.METHODS = exports2.LENIENT_FLAGS = exports2.FLAGS = exports2.TYPE = exports2.ERROR = void 0;
    var utils_1 = require_utils();
    var ERROR;
    (function(ERROR2) {
      ERROR2[ERROR2["OK"] = 0] = "OK";
      ERROR2[ERROR2["INTERNAL"] = 1] = "INTERNAL";
      ERROR2[ERROR2["STRICT"] = 2] = "STRICT";
      ERROR2[ERROR2["LF_EXPECTED"] = 3] = "LF_EXPECTED";
      ERROR2[ERROR2["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
      ERROR2[ERROR2["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
      ERROR2[ERROR2["INVALID_METHOD"] = 6] = "INVALID_METHOD";
      ERROR2[ERROR2["INVALID_URL"] = 7] = "INVALID_URL";
      ERROR2[ERROR2["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
      ERROR2[ERROR2["INVALID_VERSION"] = 9] = "INVALID_VERSION";
      ERROR2[ERROR2["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
      ERROR2[ERROR2["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
      ERROR2[ERROR2["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
      ERROR2[ERROR2["INVALID_STATUS"] = 13] = "INVALID_STATUS";
      ERROR2[ERROR2["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
      ERROR2[ERROR2["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
      ERROR2[ERROR2["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
      ERROR2[ERROR2["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
      ERROR2[ERROR2["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
      ERROR2[ERROR2["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
      ERROR2[ERROR2["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
      ERROR2[ERROR2["PAUSED"] = 21] = "PAUSED";
      ERROR2[ERROR2["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
      ERROR2[ERROR2["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
      ERROR2[ERROR2["USER"] = 24] = "USER";
    })(ERROR = exports2.ERROR || (exports2.ERROR = {}));
    var TYPE3;
    (function(TYPE4) {
      TYPE4[TYPE4["BOTH"] = 0] = "BOTH";
      TYPE4[TYPE4["REQUEST"] = 1] = "REQUEST";
      TYPE4[TYPE4["RESPONSE"] = 2] = "RESPONSE";
    })(TYPE3 = exports2.TYPE || (exports2.TYPE = {}));
    var FLAGS2;
    (function(FLAGS3) {
      FLAGS3[FLAGS3["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
      FLAGS3[FLAGS3["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
      FLAGS3[FLAGS3["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
      FLAGS3[FLAGS3["CHUNKED"] = 8] = "CHUNKED";
      FLAGS3[FLAGS3["UPGRADE"] = 16] = "UPGRADE";
      FLAGS3[FLAGS3["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
      FLAGS3[FLAGS3["SKIPBODY"] = 64] = "SKIPBODY";
      FLAGS3[FLAGS3["TRAILING"] = 128] = "TRAILING";
      FLAGS3[FLAGS3["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
    })(FLAGS2 = exports2.FLAGS || (exports2.FLAGS = {}));
    var LENIENT_FLAGS;
    (function(LENIENT_FLAGS2) {
      LENIENT_FLAGS2[LENIENT_FLAGS2["HEADERS"] = 1] = "HEADERS";
      LENIENT_FLAGS2[LENIENT_FLAGS2["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
      LENIENT_FLAGS2[LENIENT_FLAGS2["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
    })(LENIENT_FLAGS = exports2.LENIENT_FLAGS || (exports2.LENIENT_FLAGS = {}));
    var METHODS2;
    (function(METHODS3) {
      METHODS3[METHODS3["DELETE"] = 0] = "DELETE";
      METHODS3[METHODS3["GET"] = 1] = "GET";
      METHODS3[METHODS3["HEAD"] = 2] = "HEAD";
      METHODS3[METHODS3["POST"] = 3] = "POST";
      METHODS3[METHODS3["PUT"] = 4] = "PUT";
      METHODS3[METHODS3["CONNECT"] = 5] = "CONNECT";
      METHODS3[METHODS3["OPTIONS"] = 6] = "OPTIONS";
      METHODS3[METHODS3["TRACE"] = 7] = "TRACE";
      METHODS3[METHODS3["COPY"] = 8] = "COPY";
      METHODS3[METHODS3["LOCK"] = 9] = "LOCK";
      METHODS3[METHODS3["MKCOL"] = 10] = "MKCOL";
      METHODS3[METHODS3["MOVE"] = 11] = "MOVE";
      METHODS3[METHODS3["PROPFIND"] = 12] = "PROPFIND";
      METHODS3[METHODS3["PROPPATCH"] = 13] = "PROPPATCH";
      METHODS3[METHODS3["SEARCH"] = 14] = "SEARCH";
      METHODS3[METHODS3["UNLOCK"] = 15] = "UNLOCK";
      METHODS3[METHODS3["BIND"] = 16] = "BIND";
      METHODS3[METHODS3["REBIND"] = 17] = "REBIND";
      METHODS3[METHODS3["UNBIND"] = 18] = "UNBIND";
      METHODS3[METHODS3["ACL"] = 19] = "ACL";
      METHODS3[METHODS3["REPORT"] = 20] = "REPORT";
      METHODS3[METHODS3["MKACTIVITY"] = 21] = "MKACTIVITY";
      METHODS3[METHODS3["CHECKOUT"] = 22] = "CHECKOUT";
      METHODS3[METHODS3["MERGE"] = 23] = "MERGE";
      METHODS3[METHODS3["M-SEARCH"] = 24] = "M-SEARCH";
      METHODS3[METHODS3["NOTIFY"] = 25] = "NOTIFY";
      METHODS3[METHODS3["SUBSCRIBE"] = 26] = "SUBSCRIBE";
      METHODS3[METHODS3["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
      METHODS3[METHODS3["PATCH"] = 28] = "PATCH";
      METHODS3[METHODS3["PURGE"] = 29] = "PURGE";
      METHODS3[METHODS3["MKCALENDAR"] = 30] = "MKCALENDAR";
      METHODS3[METHODS3["LINK"] = 31] = "LINK";
      METHODS3[METHODS3["UNLINK"] = 32] = "UNLINK";
      METHODS3[METHODS3["SOURCE"] = 33] = "SOURCE";
      METHODS3[METHODS3["PRI"] = 34] = "PRI";
      METHODS3[METHODS3["DESCRIBE"] = 35] = "DESCRIBE";
      METHODS3[METHODS3["ANNOUNCE"] = 36] = "ANNOUNCE";
      METHODS3[METHODS3["SETUP"] = 37] = "SETUP";
      METHODS3[METHODS3["PLAY"] = 38] = "PLAY";
      METHODS3[METHODS3["PAUSE"] = 39] = "PAUSE";
      METHODS3[METHODS3["TEARDOWN"] = 40] = "TEARDOWN";
      METHODS3[METHODS3["GET_PARAMETER"] = 41] = "GET_PARAMETER";
      METHODS3[METHODS3["SET_PARAMETER"] = 42] = "SET_PARAMETER";
      METHODS3[METHODS3["REDIRECT"] = 43] = "REDIRECT";
      METHODS3[METHODS3["RECORD"] = 44] = "RECORD";
      METHODS3[METHODS3["FLUSH"] = 45] = "FLUSH";
    })(METHODS2 = exports2.METHODS || (exports2.METHODS = {}));
    exports2.METHODS_HTTP = [
      METHODS2.DELETE,
      METHODS2.GET,
      METHODS2.HEAD,
      METHODS2.POST,
      METHODS2.PUT,
      METHODS2.CONNECT,
      METHODS2.OPTIONS,
      METHODS2.TRACE,
      METHODS2.COPY,
      METHODS2.LOCK,
      METHODS2.MKCOL,
      METHODS2.MOVE,
      METHODS2.PROPFIND,
      METHODS2.PROPPATCH,
      METHODS2.SEARCH,
      METHODS2.UNLOCK,
      METHODS2.BIND,
      METHODS2.REBIND,
      METHODS2.UNBIND,
      METHODS2.ACL,
      METHODS2.REPORT,
      METHODS2.MKACTIVITY,
      METHODS2.CHECKOUT,
      METHODS2.MERGE,
      METHODS2["M-SEARCH"],
      METHODS2.NOTIFY,
      METHODS2.SUBSCRIBE,
      METHODS2.UNSUBSCRIBE,
      METHODS2.PATCH,
      METHODS2.PURGE,
      METHODS2.MKCALENDAR,
      METHODS2.LINK,
      METHODS2.UNLINK,
      METHODS2.PRI,
      METHODS2.SOURCE
    ];
    exports2.METHODS_ICE = [
      METHODS2.SOURCE
    ];
    exports2.METHODS_RTSP = [
      METHODS2.OPTIONS,
      METHODS2.DESCRIBE,
      METHODS2.ANNOUNCE,
      METHODS2.SETUP,
      METHODS2.PLAY,
      METHODS2.PAUSE,
      METHODS2.TEARDOWN,
      METHODS2.GET_PARAMETER,
      METHODS2.SET_PARAMETER,
      METHODS2.REDIRECT,
      METHODS2.RECORD,
      METHODS2.FLUSH,
      METHODS2.GET,
      METHODS2.POST
    ];
    exports2.METHOD_MAP = utils_1.enumToMap(METHODS2);
    exports2.H_METHOD_MAP = {};
    Object.keys(exports2.METHOD_MAP).forEach((key) => {
      if (/^H/.test(key)) {
        exports2.H_METHOD_MAP[key] = exports2.METHOD_MAP[key];
      }
    });
    var FINISH;
    (function(FINISH2) {
      FINISH2[FINISH2["SAFE"] = 0] = "SAFE";
      FINISH2[FINISH2["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
      FINISH2[FINISH2["UNSAFE"] = 2] = "UNSAFE";
    })(FINISH = exports2.FINISH || (exports2.FINISH = {}));
    exports2.ALPHA = [];
    for (let i = "A".charCodeAt(0); i <= "Z".charCodeAt(0); i++) {
      exports2.ALPHA.push(String.fromCharCode(i));
      exports2.ALPHA.push(String.fromCharCode(i + 32));
    }
    exports2.NUM_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9
    };
    exports2.HEX_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      A: 10,
      B: 11,
      C: 12,
      D: 13,
      E: 14,
      F: 15,
      a: 10,
      b: 11,
      c: 12,
      d: 13,
      e: 14,
      f: 15
    };
    exports2.NUM = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9"
    ];
    exports2.ALPHANUM = exports2.ALPHA.concat(exports2.NUM);
    exports2.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
    exports2.USERINFO_CHARS = exports2.ALPHANUM.concat(exports2.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
    exports2.STRICT_URL_CHAR = [
      "!",
      '"',
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      ":",
      ";",
      "<",
      "=",
      ">",
      "@",
      "[",
      "\\",
      "]",
      "^",
      "_",
      "`",
      "{",
      "|",
      "}",
      "~"
    ].concat(exports2.ALPHANUM);
    exports2.URL_CHAR = exports2.STRICT_URL_CHAR.concat(["	", "\f"]);
    for (let i = 128; i <= 255; i++) {
      exports2.URL_CHAR.push(i);
    }
    exports2.HEX = exports2.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
    exports2.STRICT_TOKEN = [
      "!",
      "#",
      "$",
      "%",
      "&",
      "'",
      "*",
      "+",
      "-",
      ".",
      "^",
      "_",
      "`",
      "|",
      "~"
    ].concat(exports2.ALPHANUM);
    exports2.TOKEN = exports2.STRICT_TOKEN.concat([" "]);
    exports2.HEADER_CHARS = ["	"];
    for (let i = 32; i <= 255; i++) {
      if (i !== 127) {
        exports2.HEADER_CHARS.push(i);
      }
    }
    exports2.CONNECTION_TOKEN_CHARS = exports2.HEADER_CHARS.filter((c) => c !== 44);
    exports2.MAJOR = exports2.NUM_MAP;
    exports2.MINOR = exports2.MAJOR;
    var HEADER_STATE;
    (function(HEADER_STATE2) {
      HEADER_STATE2[HEADER_STATE2["GENERAL"] = 0] = "GENERAL";
      HEADER_STATE2[HEADER_STATE2["CONNECTION"] = 1] = "CONNECTION";
      HEADER_STATE2[HEADER_STATE2["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
      HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
      HEADER_STATE2[HEADER_STATE2["UPGRADE"] = 4] = "UPGRADE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
      HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
    })(HEADER_STATE = exports2.HEADER_STATE || (exports2.HEADER_STATE = {}));
    exports2.SPECIAL_HEADERS = {
      "connection": HEADER_STATE.CONNECTION,
      "content-length": HEADER_STATE.CONTENT_LENGTH,
      "proxy-connection": HEADER_STATE.CONNECTION,
      "transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
      "upgrade": HEADER_STATE.UPGRADE
    };
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/llhttp/llhttp.wasm.js
var require_llhttp_wasm = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/llhttp/llhttp.wasm.js"(exports2, module2) {
    module2.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzk4AwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAYGAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAAMEBQFwAQ4OBQMBAAIGCAF/AUGgtwQLB/UEHwZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAJGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAKGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQA1DGxsaHR0cF9hbGxvYwAMBm1hbGxvYwA6C2xsaHR0cF9mcmVlAA0EZnJlZQA8D2xsaHR0cF9nZXRfdHlwZQAOFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAPFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAQEWxsaHR0cF9nZXRfbWV0aG9kABEWbGxodHRwX2dldF9zdGF0dXNfY29kZQASEmxsaHR0cF9nZXRfdXBncmFkZQATDGxsaHR0cF9yZXNldAAUDmxsaHR0cF9leGVjdXRlABUUbGxodHRwX3NldHRpbmdzX2luaXQAFg1sbGh0dHBfZmluaXNoABcMbGxodHRwX3BhdXNlABgNbGxodHRwX3Jlc3VtZQAZG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAaEGxsaHR0cF9nZXRfZXJybm8AGxdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAcF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uAB0UbGxodHRwX2dldF9lcnJvcl9wb3MAHhFsbGh0dHBfZXJybm9fbmFtZQAfEmxsaHR0cF9tZXRob2RfbmFtZQAgGmxsaHR0cF9zZXRfbGVu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QZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQBBBCEFIARBiARxQYAERg0CIARBKHFFDQILQQAPC0EAQQMgACkDIFAbIQULIAULXQECf0EAIQECQCAALQAoQQFGDQAgAC8BMiICQZx/akHkAEkNACACQcwBRg0AIAJBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhASAAQYgEcUGABEYNACAAQShxRSEBCyABC6IBAQN/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQMgAC8BMCIEQQJxRQ0BDAILQQAhAyAALwEwIgRBAXFFDQELQQEhAyAALQAoQQFGDQAgAC8BMiIFQZx/akHkAEkNACAFQcwBRg0AIAVBsAJGDQAgBEHAAHENAEEAIQMgBEGIBHFBgARGDQAgBEEocUEARyEDCyAAQQA7ATAgAEEAOgAvIAMLlAEBAn8CQAJAAkAgAC0AKkUNACAALQArRQ0AQQAhASAALwEwIgJBAnFFDQEMAgtBACEBIAAvATAiAkEBcUUNAQtBASEBIAAtAChBAUYNACAALwEyIgBBnH9qQeQASQ0AIABBzAFGDQAgAEGwAkYNACACQcAAcQ0AQQAhASACQYgEcUGABEYNACACQShxQQBHIQELIAELTwAgAEEYakIANwMAIABCADcDACAAQTBqQgA3AwAgAEEoakIANwMAIABBIGpCADcDACAAQRBqQgA3AwAgAEEIakIANwMAIABBuAE2AhxBAAt7AQF/AkAgACgCDCIDDQACQCAAKAIERQ0AIAAgATYCBAsCQCAAIAEgAhC4gICAACIDDQAgACgCDA8LIAAgAzYCHEEAIQMgACgCBCIBRQ0AIAAgASACIAAoAggRgYCAgAAAIgFFDQAgACACNgIUIAAgATYCDCABIQMLIAML8soBAxl/A34FfyOAgICAAEEQayIDJICAgIAAIAEhBCABIQUgASEGIAEhByABIQggASEJIAEhCiABIQsgASEMIAEhDSABIQ4gASEPIAEhECABIREgASESIAEhEyABIRQgASEVIAEhFiABIRcgASEYIAEhGSABIRoCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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QQEhGwwPC0GbASEbDA4LQZwBIRsMDQtBngEhGwwMC0GgASEbDAsLQZ8BIRsMCgtBoQEhGwwJC0GiASEbDAgLQaMBIRsMBwtBpAEhGwwGC0GlASEbDAULQaYBIRsMBAtBpwEhGwwDC0GoASEbDAILQakBIRsMAQtBrwEhGwsDQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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IAAgIDYCAAybAgsgAEEANgIAIB8gI2tBBWohAUEjIRsMswELAkAgASIEIAJHDQBB6wAhGwyaAgsCQAJAIAQtAABBtH9qDggAtgG2AbYBtgG2AbYBAbYBCyAEQQFqIQFB3QAhGwyPAgsgBEEBaiEBQd4AIRsMjgILAkAgASIEIAJHDQBB7AAhGwyZAgsgBC0AAEHFAEcNswEgBEEBaiEBDOQBC0HtACEbIAEiHyACRg2XAiACIB9rIAAoAgAiI2ohICAfIQQgIyEBAkADQCAELQAAIAFBqLKAgABqLQAARw2zASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAICA2AgAMmAILIABBADYCACAfICNrQQRqIQFBLSEbDLABC0HuACEbIAEiHyACRg2WAiACIB9rIAAoAgAiI2ohICAfIQQgIyEBAkADQCAELQAAIAFB8LKAgABqLQAARw2yASABQQhGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAICA2AgAMlwILIABBADYCACAfICNrQQlqIQFBKSEbDK8BCwJAIAEiASACRw0AQe8AIRsMlgILQQEhGyABLQAAQd8ARw2uASABQQFqIQEM4gELQfAAIRsgASIfIAJGDZQCIAIgH2sgACgCACIjaiEgIB8hBCAjIQEDQCAELQAAIAFBrLKAgABqLQAARw2vASABQQFGDfoBIAFBAWohASAEQQFqIgQgAkcNAAsgACAgNgIADJQCC0HxACEbIAEiHyACRg2TAiACIB9rIAAoAgAiI2ohICAfIQQgIyEBAkADQCAELQAAIAFBrrKAgABqLQAARw2vASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAICA2AgAMlAILIABBADYCACAfICNrQQNqIQFBAiEbDKwBC0HyACEbIAEiHyACRg2SAiACIB9rIAAoAgAiI2ohICAfIQQgIyEBAkADQCAELQAAIAFBkLOAgABqLQAARw2uASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAICA2AgAMkwILIABBADYCACAfICNrQQJqIQFBHyEbDKsBC0HzACEbIAEiHyACRg2RAiACIB9rIAAoAgAiI2ohICAfIQQgIyEBAkADQCAELQAAIAFBkrOAgABqLQAARw2tASABQQFGDQEgAUEBaiEBIARBAWoiBCAC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c3QASW52YWxpZCBtZXRob2QgZm9yIFJUU1AveC54IHJlcXVlc3QARXhwZWN0ZWQgU09VUkNFIG1ldGhvZCBmb3IgSUNFL3gueCByZXF1ZXN0AEludmFsaWQgY2hhciBpbiB1cmwgZnJhZ21lbnQgc3RhcnQARXhwZWN0ZWQgZG90AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fc3RhdHVzAEludmFsaWQgcmVzcG9uc2Ugc3RhdHVzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHBhcmFtZXRlcnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAE1LQUNUSVZJVFkAQ09QWQBOT1RJRlkAUExBWQBQVVQAQ0hFQ0tPVVQAUE9TVABSRVBPUlQASFBFX0lOVkFMSURfQ09OU1RBTlQAR0VUAEhQRV9TVFJJQ1QAUkVESVJFQ1QAQ09OTkVDVABIUEVfSU5WQUxJRF9TVEFUVVMAT1BUSU9OUwBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIASFBFX0NCX0NIVU5LX0hFQURFUgBNS0NBTEVOREFSAFNFVFVQAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIUEVfSU5WQUxJRF9WRVJTSU9OAEhQRV9DQl9NRVNTQUdFX0JFR0lOAEhQRV9JTlZBTElEX0hFQURFUl9UT0tFTgBIUEVfSU5WQUxJRF9VUkwATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAFBBVVNFAFBVUkdFAE1FUkdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QAUFJPUEZJTkQAVU5CSU5EAFJFQklORABIUEVfTEZfRVhQRUNURUQASFBFX1BBVVNFRABIRUFEAEV4cGVjdGVkIEhUVFAvAIwLAAB/CwAAgwoAADkNAADACwAADQsAAA8NAABlCwAAagoAACMLAABMCwAApQsAACMMAACfCgAAjAwAAPcLAAA3CwAAPwwAAG0MAADfCgAAVwwAAEkNAAC0DAAAxwwAANYKAACFDAAAfwoAAFQNAABeCgAAUQoAAJcKAACyCgAA7QwAAEAKAACcCwAAdQsAADoMAAAiDQAA5AsAAPALAACaCwAANA0AADINAAArDQAAewsAAGMKAAA1CgAAVQoAAK4MAADuCwAARQoAAP4MAAD8DAAA6AsAAKgMAADzCgAAlQsAAJMLAADdDAAAoQsAAPMMAADkDAAA/goAAEwKAACiDAAABAsAAMgKAAC6CgAAjgoAAAgNAADeCwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAIAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAWxvc2VlZXAtYWxpdmUAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAWNodW5rZWQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAAABAQABAQABAQEBAQEBAQEBAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZWN0aW9uZW50LWxlbmd0aG9ucm94eS1jb25uZWN0aW9uAAAAAAAAAAAAAAAAAAAAcmFuc2Zlci1lbmNvZGluZ3BncmFkZQ0KDQoNClNNDQoNClRUUC9DRS9UU1AvAAAAAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBBQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAEAAAIAAAAAAAAAAAAAAAAAAAAAAAADBAAABAQEBAQEBAQEBAQFBAQEBAQEBAQEBAQEAAQABgcEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAACAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRU9SRElSRUNUT1JUUkNIUEFSQU1FVEVSVVJDRUJTQ1JJQkVBUkRPV05BQ0VJTkROS0NLVUJTQ1JJQkVIVFRQL0FEVFAv";
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/llhttp/llhttp_simd.wasm.js
var require_llhttp_simd_wasm = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/llhttp/llhttp_simd.wasm.js"(exports2, module2) {
    module2.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzk4AwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAYGAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAAMEBQFwAQ4OBQMBAAIGCAF/AUGgtwQLB/UEHwZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAJGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAKGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQA1DGxsaHR0cF9hbGxvYwAMBm1hbGxvYwA6C2xsaHR0cF9mcmVlAA0EZnJlZQA8D2xsaHR0cF9nZXRfdHlwZQAOFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAPFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAQEWxsaHR0cF9nZXRfbWV0aG9kABEWbGxodHRwX2dldF9zdGF0dXNfY29kZQASEmxsaHR0cF9nZXRfdXBncmFkZQATDGxsaHR0cF9yZXNldAAUDmxsaHR0cF9leGVjdXRlABUUbGxodHRwX3NldHRpbmdzX2luaXQAFg1sbGh0dHBfZmluaXNoABcMbGxodHRwX3BhdXNlABgNbGxodHRwX3Jlc3VtZQAZG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAaEGxsaHR0cF9nZXRfZXJybm8AGxdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAcF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uAB0UbGxodHRwX2dldF9lcnJvcl9wb3MAHhFsbGh0dHBfZXJybm9fbmFtZQAfEmxsaHR0cF9tZXRob2RfbmFtZQAgGmxsaHR0cF9zZXRfbGVu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C0GcASEbDA0LQZ4BIRsMDAtBoAEhGwwLC0GfASEbDAoLQaEBIRsMCQtBogEhGwwIC0GjASEbDAcLQaQBIRsMBgtBpQEhGwwFC0GmASEbDAQLQacBIRsMAwtBqAEhGwwCC0GpASEbDAELQa8BIRsLA0ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBsO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aG9kIGZvciBSVFNQL3gueCByZXF1ZXN0AEV4cGVjdGVkIFNPVVJDRSBtZXRob2QgZm9yIElDRS94LnggcmVxdWVzdABJbnZhbGlkIGNoYXIgaW4gdXJsIGZyYWdtZW50IHN0YXJ0AEV4cGVjdGVkIGRvdABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3N0YXR1cwBJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBwYXJhbWV0ZXJzAFVzZXIgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2hlYWRlcmAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfYmVnaW5gIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBJbnZhbGlkIG1pbm9yIHZlcnNpb24ASW52YWxpZCBtYWpvciB2ZXJzaW9uAEV4cGVjdGVkIHNwYWNlIGFmdGVyIHZlcnNpb24ARXhwZWN0ZWQgQ1JMRiBhZnRlciB2ZXJzaW9uAEludmFsaWQgaGVhZGVyIHRva2VuAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdXJsAEludmFsaWQgY2hhcmFjdGVycyBpbiB1cmwAVW5leHBlY3RlZCBzdGFydCBjaGFyIGluIHVybABEb3VibGUgQCBpbiB1cmwARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgARHVwbGljYXRlIENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhciBpbiB1cmwgcGF0aABDb250ZW50LUxlbmd0aCBjYW4ndCBiZSBwcmVzZW50IHdpdGggVHJhbnNmZXItRW5jb2RpbmcASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgc2l6ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl92YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAFBhdXNlIG9uIENPTk5FQ1QvVXBncmFkZQBQYXVzZSBvbiBQUkkvVXBncmFkZQBFeHBlY3RlZCBIVFRQLzIgQ29ubmVjdGlvbiBQcmVmYWNlAEV4cGVjdGVkIHNwYWNlIGFmdGVyIG1ldGhvZABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl9maWVsZABQYXVzZWQASW52YWxpZCB3b3JkIGVuY291bnRlcmVkAEludmFsaWQgbWV0aG9kIGVuY291bnRlcmVkAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2NoZW1hAFJlcXVlc3QgaGFzIGludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYABNS0FDVElWSVRZAENPUFkATk9USUZZAFBMQVkAUFVUAENIRUNLT1VUAFBPU1QAUkVQT1JUAEhQRV9JTlZBTElEX0NPTlNUQU5UAEdFVABIUEVfU1RSSUNUAFJFRElSRUNUAENPTk5FQ1QASFBFX0lOVkFMSURfU1RBVFVTAE9QVElPTlMAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASFBFX0lOVkFMSURfVVJMAE1LQ09MAEFDTABIUEVfSU5URVJOQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBS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bmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==";
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/client.js
var require_client = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/client.js"(exports2, module2) {
    "use strict";
    var assert3 = (init_assert(), __toCommonJS(assert_exports));
    var net = (init_empty(), __toCommonJS(empty_exports));
    var util = require_util();
    var Request2 = require_request();
    var DispatcherBase = require_dispatcher_base();
    var RedirectHandler = require_redirect();
    var {
      RequestContentLengthMismatchError,
      ResponseContentLengthMismatchError,
      TrailerMismatchError,
      InvalidArgumentError,
      RequestAbortedError,
      HeadersTimeoutError,
      HeadersOverflowError,
      SocketError,
      InformationalError,
      BodyTimeoutError,
      HTTPParserError
    } = require_errors();
    var buildConnector = require_connect();
    var {
      kUrl,
      kReset,
      kServerName,
      kClient,
      kBusy,
      kParser,
      kConnect,
      kBlocking,
      kResuming,
      kRunning,
      kPending,
      kSize,
      kWriting,
      kQueue,
      kConnected,
      kConnecting,
      kNeedDrain,
      kNoRef,
      kKeepAliveDefaultTimeout,
      kHostHeader,
      kPendingIdx,
      kRunningIdx,
      kError,
      kPipelining,
      kSocket,
      kKeepAliveTimeoutValue,
      kMaxHeadersSize,
      kKeepAliveMaxTimeout,
      kKeepAliveTimeoutThreshold,
      kHeadersTimeout,
      kBodyTimeout,
      kStrictContentLength,
      kConnector,
      kMaxRedirections,
      kMaxRequests,
      kCounter,
      kClose,
      kDestroy,
      kDispatch
    } = require_symbols();
    var kClosedResolve = Symbol("kClosedResolve");
    var channels = {};
    try {
      const diagnosticsChannel = __require("diagnostics_channel");
      channels.sendHeaders = diagnosticsChannel.channel("undici:client:sendHeaders");
      channels.beforeConnect = diagnosticsChannel.channel("undici:client:beforeConnect");
      channels.connectError = diagnosticsChannel.channel("undici:client:connectError");
      channels.connected = diagnosticsChannel.channel("undici:client:connected");
    } catch {
      channels.sendHeaders = { hasSubscribers: false };
      channels.beforeConnect = { hasSubscribers: false };
      channels.connectError = { hasSubscribers: false };
      channels.connected = { hasSubscribers: false };
    }
    var Client = class extends DispatcherBase {
      constructor(url2, {
        maxHeaderSize,
        headersTimeout,
        socketTimeout,
        requestTimeout,
        connectTimeout,
        bodyTimeout,
        idleTimeout,
        keepAlive,
        keepAliveTimeout,
        maxKeepAliveTimeout,
        keepAliveMaxTimeout,
        keepAliveTimeoutThreshold,
        socketPath,
        pipelining,
        tls,
        strictContentLength,
        maxCachedSessions,
        maxRedirections,
        connect: connect2,
        maxRequestsPerClient
      } = {}) {
        super();
        if (keepAlive !== void 0) {
          throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
        }
        if (socketTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (requestTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (idleTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
        }
        if (maxKeepAliveTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
        }
        if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
          throw new InvalidArgumentError("invalid maxHeaderSize");
        }
        if (socketPath != null && typeof socketPath !== "string") {
          throw new InvalidArgumentError("invalid socketPath");
        }
        if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
          throw new InvalidArgumentError("invalid connectTimeout");
        }
        if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveTimeout");
        }
        if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
        }
        if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
          throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
        }
        if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
        }
        if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
        }
        if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
          throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
        }
        if (typeof connect2 !== "function") {
          connect2 = buildConnector({
            ...tls,
            maxCachedSessions,
            socketPath,
            timeout: connectTimeout,
            ...connect2
          });
        }
        this[kUrl] = util.parseOrigin(url2);
        this[kConnector] = connect2;
        this[kSocket] = null;
        this[kPipelining] = pipelining != null ? pipelining : 1;
        this[kMaxHeadersSize] = maxHeaderSize || 16384;
        this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
        this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
        this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;
        this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
        this[kServerName] = null;
        this[kResuming] = 0;
        this[kNeedDrain] = 0;
        this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`;
        this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e4;
        this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e4;
        this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
        this[kMaxRedirections] = maxRedirections;
        this[kMaxRequests] = maxRequestsPerClient;
        this[kClosedResolve] = null;
        this[kQueue] = [];
        this[kRunningIdx] = 0;
        this[kPendingIdx] = 0;
      }
      get pipelining() {
        return this[kPipelining];
      }
      set pipelining(value) {
        this[kPipelining] = value;
        resume2(this, true);
      }
      get [kPending]() {
        return this[kQueue].length - this[kPendingIdx];
      }
      get [kRunning]() {
        return this[kPendingIdx] - this[kRunningIdx];
      }
      get [kSize]() {
        return this[kQueue].length - this[kRunningIdx];
      }
      get [kConnected]() {
        return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;
      }
      get [kBusy]() {
        const socket = this[kSocket];
        return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;
      }
      [kConnect](cb) {
        connect(this);
        this.once("connect", cb);
      }
      [kDispatch](opts, handler) {
        const { maxRedirections = this[kMaxRedirections] } = opts;
        if (maxRedirections) {
          handler = new RedirectHandler(this, maxRedirections, opts, handler);
        }
        const origin = opts.origin || this[kUrl].origin;
        const request3 = new Request2(origin, opts, handler);
        this[kQueue].push(request3);
        if (this[kResuming]) {
        } else if (util.bodyLength(request3.body) == null && util.isIterable(request3.body)) {
          this[kResuming] = 1;
          process.nextTick(resume2, this);
        } else {
          resume2(this, true);
        }
        if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
          this[kNeedDrain] = 2;
        }
        return this[kNeedDrain] < 2;
      }
      async [kClose]() {
        return new Promise((resolve2) => {
          if (!this[kSize]) {
            this.destroy(resolve2);
          } else {
            this[kClosedResolve] = resolve2;
          }
        });
      }
      async [kDestroy](err2) {
        return new Promise((resolve2) => {
          const requests = this[kQueue].splice(this[kPendingIdx]);
          for (let i = 0; i < requests.length; i++) {
            const request3 = requests[i];
            errorRequest(this, request3, err2);
          }
          const callback = () => {
            if (this[kClosedResolve]) {
              this[kClosedResolve]();
              this[kClosedResolve] = null;
            }
            resolve2();
          };
          if (!this[kSocket]) {
            queueMicrotask(callback);
          } else {
            util.destroy(this[kSocket].on("close", callback), err2);
          }
          resume2(this);
        });
      }
    };
    var constants = require_constants();
    var EMPTY_BUF = Buffer.alloc(0);
    async function lazyllhttp() {
      const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : void 0;
      let mod;
      try {
        mod = await WebAssembly.compile(Buffer.from(require_llhttp_simd_wasm(), "base64"));
      } catch (e2) {
        mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require_llhttp_wasm(), "base64"));
      }
      return await WebAssembly.instantiate(mod, {
        env: {
          wasm_on_url: (p, at, len) => {
            return 0;
          },
          wasm_on_status: (p, at, len) => {
            assert3.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr;
            const end = start + len;
            return currentParser.onStatus(currentBufferRef.slice(start, end)) || 0;
          },
          wasm_on_message_begin: (p) => {
            assert3.strictEqual(currentParser.ptr, p);
            return currentParser.onMessageBegin() || 0;
          },
          wasm_on_header_field: (p, at, len) => {
            assert3.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr;
            const end = start + len;
            return currentParser.onHeaderField(currentBufferRef.slice(start, end)) || 0;
          },
          wasm_on_header_value: (p, at, len) => {
            assert3.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr;
            const end = start + len;
            return currentParser.onHeaderValue(currentBufferRef.slice(start, end)) || 0;
          },
          wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
            assert3.strictEqual(currentParser.ptr, p);
            return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;
          },
          wasm_on_body: (p, at, len) => {
            assert3.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr;
            const end = start + len;
            return currentParser.onBody(currentBufferRef.slice(start, end)) || 0;
          },
          wasm_on_message_complete: (p) => {
            assert3.strictEqual(currentParser.ptr, p);
            return currentParser.onMessageComplete() || 0;
          }
        }
      });
    }
    var llhttpInstance = null;
    var llhttpPromise = lazyllhttp().catch(() => {
    });
    var currentParser = null;
    var currentBufferRef = null;
    var currentBufferSize = 0;
    var currentBufferPtr = null;
    var TIMEOUT_HEADERS = 1;
    var TIMEOUT_BODY = 2;
    var TIMEOUT_IDLE = 3;
    var Parser = class {
      constructor(client, socket, { exports: exports3 }) {
        assert3(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);
        this.llhttp = exports3;
        this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
        this.client = client;
        this.socket = socket;
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.statusCode = null;
        this.statusText = "";
        this.upgrade = false;
        this.headers = [];
        this.headersSize = 0;
        this.headersMaxSize = client[kMaxHeadersSize];
        this.shouldKeepAlive = false;
        this.paused = false;
        this.resume = this.resume.bind(this);
        this.bytesRead = 0;
        this.trailer = "";
        this.keepAlive = "";
        this.contentLength = "";
      }
      setTimeout(value, type) {
        this.timeoutType = type;
        if (value !== this.timeoutValue) {
          clearTimeout(this.timeout);
          if (value) {
            this.timeout = setTimeout(onParserTimeout, value, this);
            if (this.timeout.unref) {
              this.timeout.unref();
            }
          } else {
            this.timeout = null;
          }
          this.timeoutValue = value;
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
      }
      resume() {
        if (this.socket.destroyed || !this.paused) {
          return;
        }
        assert3(this.ptr != null);
        assert3(currentParser == null);
        this.llhttp.llhttp_resume(this.ptr);
        assert3(this.timeoutType === TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        this.paused = false;
        this.execute(this.socket.read() || EMPTY_BUF);
        this.readMore();
      }
      readMore() {
        while (!this.paused && this.ptr) {
          const chunk = this.socket.read();
          if (chunk === null) {
            break;
          }
          this.execute(chunk);
        }
      }
      execute(data) {
        assert3(this.ptr != null);
        assert3(currentParser == null);
        assert3(!this.paused);
        const { socket, llhttp } = this;
        if (data.length > currentBufferSize) {
          if (currentBufferPtr) {
            llhttp.free(currentBufferPtr);
          }
          currentBufferSize = Math.ceil(data.length / 4096) * 4096;
          currentBufferPtr = llhttp.malloc(currentBufferSize);
        }
        new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
        try {
          let ret;
          try {
            currentBufferRef = data;
            currentParser = this;
            ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
          } catch (err2) {
            throw err2;
          } finally {
            currentParser = null;
            currentBufferRef = null;
          }
          const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
          if (ret === constants.ERROR.PAUSED_UPGRADE) {
            this.onUpgrade(data.slice(offset));
          } else if (ret === constants.ERROR.PAUSED) {
            this.paused = true;
            socket.unshift(data.slice(offset));
          } else if (ret !== constants.ERROR.OK) {
            const ptr = llhttp.llhttp_get_error_reason(this.ptr);
            let message = "";
            if (ptr) {
              const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
              message = Buffer.from(llhttp.memory.buffer, ptr, len).toString();
            }
            throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));
          }
        } catch (err2) {
          util.destroy(socket, err2);
        }
      }
      finish() {
        try {
          try {
            currentParser = this;
          } finally {
            currentParser = null;
          }
        } catch (err2) {
          util.destroy(this.socket, err2);
        }
      }
      destroy() {
        assert3(this.ptr != null);
        assert3(currentParser == null);
        this.llhttp.llhttp_free(this.ptr);
        this.ptr = null;
        clearTimeout(this.timeout);
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.paused = false;
      }
      onStatus(buf) {
        this.statusText = buf.toString();
      }
      onMessageBegin() {
        const { socket, client } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request3 = client[kQueue][client[kRunningIdx]];
        if (!request3) {
          return -1;
        }
      }
      onHeaderField(buf) {
        const len = this.headers.length;
        if ((len & 1) === 0) {
          this.headers.push(buf);
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        this.trackHeader(buf.length);
      }
      onHeaderValue(buf) {
        let len = this.headers.length;
        if ((len & 1) === 1) {
          this.headers.push(buf);
          len += 1;
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        const key = this.headers[len - 2];
        if (key.length === 10 && key.toString().toLowerCase() === "keep-alive") {
          this.keepAlive += buf.toString();
        } else if (key.length === 7 && key.toString().toLowerCase() === "trailer") {
          this.trailer += buf.toString();
        } else if (key.length === 14 && key.toString().toLowerCase() === "content-length") {
          this.contentLength += buf.toString();
        }
        this.trackHeader(buf.length);
      }
      trackHeader(len) {
        this.headersSize += len;
        if (this.headersSize >= this.headersMaxSize) {
          util.destroy(this.socket, new HeadersOverflowError());
        }
      }
      onUpgrade(head) {
        const { upgrade, client, socket, headers, statusCode } = this;
        assert3(upgrade);
        const request3 = client[kQueue][client[kRunningIdx]];
        assert3(request3);
        assert3(!socket.destroyed);
        assert3(socket === client[kSocket]);
        assert3(!this.paused);
        assert3(request3.upgrade || request3.method === "CONNECT");
        this.statusCode = null;
        this.statusText = "";
        this.shouldKeepAlive = null;
        assert3(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        socket.unshift(head);
        socket[kParser].destroy();
        socket[kParser] = null;
        socket[kClient] = null;
        socket[kError] = null;
        socket.removeListener("error", onSocketError).removeListener("readable", onSocketReadable).removeListener("end", onSocketEnd).removeListener("close", onSocketClose);
        client[kSocket] = null;
        client[kQueue][client[kRunningIdx]++] = null;
        client.emit("disconnect", client[kUrl], [client], new InformationalError("upgrade"));
        try {
          request3.onUpgrade(statusCode, headers, socket);
        } catch (err2) {
          util.destroy(socket, err2);
        }
        resume2(client);
      }
      onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
        const { client, socket, headers, statusText } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request3 = client[kQueue][client[kRunningIdx]];
        if (!request3) {
          return -1;
        }
        assert3(!this.upgrade);
        assert3(this.statusCode < 200);
        if (statusCode === 100) {
          util.destroy(socket, new SocketError("bad response", util.getSocketInfo(socket)));
          return -1;
        }
        if (upgrade && !request3.upgrade) {
          util.destroy(socket, new SocketError("bad upgrade", util.getSocketInfo(socket)));
          return -1;
        }
        assert3.strictEqual(this.timeoutType, TIMEOUT_HEADERS);
        this.statusCode = statusCode;
        this.shouldKeepAlive = shouldKeepAlive;
        if (this.statusCode >= 200) {
          const bodyTimeout = request3.bodyTimeout != null ? request3.bodyTimeout : client[kBodyTimeout];
          this.setTimeout(bodyTimeout, TIMEOUT_BODY);
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        if (request3.method === "CONNECT" && statusCode >= 200 && statusCode < 300) {
          assert3(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        if (upgrade) {
          assert3(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        assert3(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        if (shouldKeepAlive && client[kPipelining]) {
          const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;
          if (keepAliveTimeout != null) {
            const timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);
            if (timeout <= 0) {
              socket[kReset] = true;
            } else {
              client[kKeepAliveTimeoutValue] = timeout;
            }
          } else {
            client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
          }
        } else {
          socket[kReset] = true;
        }
        let pause;
        try {
          pause = request3.onHeaders(statusCode, headers, this.resume, statusText) === false;
        } catch (err2) {
          util.destroy(socket, err2);
          return -1;
        }
        if (request3.method === "HEAD") {
          assert3(socket[kReset]);
          return 1;
        }
        if (statusCode < 200) {
          return 1;
        }
        if (socket[kBlocking]) {
          socket[kBlocking] = false;
          resume2(client);
        }
        return pause ? constants.ERROR.PAUSED : 0;
      }
      onBody(buf) {
        const { client, socket, statusCode } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request3 = client[kQueue][client[kRunningIdx]];
        assert3(request3);
        assert3.strictEqual(this.timeoutType, TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        assert3(statusCode >= 200);
        this.bytesRead += buf.length;
        try {
          if (request3.onData(buf) === false) {
            return constants.ERROR.PAUSED;
          }
        } catch (err2) {
          util.destroy(socket, err2);
          return -1;
        }
      }
      onMessageComplete() {
        const { client, socket, statusCode, upgrade, trailer, headers, contentLength, bytesRead, shouldKeepAlive } = this;
        if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
          return -1;
        }
        if (upgrade) {
          return;
        }
        const request3 = client[kQueue][client[kRunningIdx]];
        assert3(request3);
        assert3(statusCode >= 100);
        this.statusCode = null;
        this.statusText = "";
        this.bytesRead = 0;
        this.contentLength = "";
        this.trailer = "";
        this.keepAlive = "";
        assert3(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        if (statusCode < 200) {
          return;
        }
        const trailers = trailer ? trailer.split(/,\s*/) : [];
        for (let i = 0; i < trailers.length; i++) {
          const trailer2 = trailers[i];
          let found = false;
          for (let n = 0; n < headers.length; n += 2) {
            const key = headers[n];
            if (key.length === trailer2.length && key.toString().toLowerCase() === trailer2.toLowerCase()) {
              found = true;
              break;
            }
          }
          if (!found) {
            util.destroy(socket, new TrailerMismatchError());
            return -1;
          }
        }
        if (request3.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
          util.destroy(socket, new ResponseContentLengthMismatchError());
          return -1;
        }
        try {
          request3.onComplete(headers);
        } catch (err2) {
          errorRequest(client, request3, err2);
        }
        client[kQueue][client[kRunningIdx]++] = null;
        if (socket[kWriting]) {
          assert3.strictEqual(client[kRunning], 0);
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (!shouldKeepAlive) {
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (socket[kReset] && client[kRunning] === 0) {
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else {
          resume2(client);
        }
      }
    };
    function onParserTimeout(parser) {
      const { socket, timeoutType, client } = parser;
      if (timeoutType === TIMEOUT_HEADERS) {
        if (!socket[kWriting]) {
          assert3(!parser.paused, "cannot be paused while waiting for headers");
          util.destroy(socket, new HeadersTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_BODY) {
        if (!parser.paused) {
          util.destroy(socket, new BodyTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_IDLE) {
        assert3(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);
        util.destroy(socket, new InformationalError("socket idle timeout"));
      }
    }
    function onSocketReadable() {
      const { [kParser]: parser } = this;
      parser.readMore();
    }
    function onSocketError(err2) {
      const { [kParser]: parser } = this;
      assert3(err2.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      if (err2.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
        parser.finish();
        return;
      }
      this[kError] = err2;
      onError(this[kClient], err2);
    }
    function onError(client, err2) {
      if (client[kRunning] === 0 && err2.code !== "UND_ERR_INFO" && err2.code !== "UND_ERR_SOCKET") {
        assert3(client[kPendingIdx] === client[kRunningIdx]);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request3 = requests[i];
          errorRequest(client, request3, err2);
        }
        assert3(client[kSize] === 0);
      }
    }
    function onSocketEnd() {
      const { [kParser]: parser } = this;
      if (parser.statusCode && !parser.shouldKeepAlive) {
        parser.finish();
        return;
      }
      util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
    }
    function onSocketClose() {
      const { [kClient]: client } = this;
      this[kParser].destroy();
      this[kParser] = null;
      const err2 = this[kError] || new SocketError("closed", util.getSocketInfo(this));
      client[kSocket] = null;
      if (client.destroyed) {
        assert3(client[kPending] === 0);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request3 = requests[i];
          errorRequest(client, request3, err2);
        }
      } else if (client[kRunning] > 0 && err2.code !== "UND_ERR_INFO") {
        const request3 = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null;
        errorRequest(client, request3, err2);
      }
      client[kPendingIdx] = client[kRunningIdx];
      assert3(client[kRunning] === 0);
      client.emit("disconnect", client[kUrl], [client], err2);
      resume2(client);
    }
    async function connect(client) {
      assert3(!client[kConnecting]);
      assert3(!client[kSocket]);
      let { host, hostname, protocol, port } = client[kUrl];
      if (hostname[0] === "[") {
        const idx = hostname.indexOf("]");
        assert3(idx !== -1);
        const ip = hostname.substr(1, idx - 1);
        assert3(net.isIP(ip));
        hostname = ip;
      }
      client[kConnecting] = true;
      if (channels.beforeConnect.hasSubscribers) {
        channels.beforeConnect.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName]
          },
          connector: client[kConnector]
        });
      }
      try {
        const socket = await new Promise((resolve2, reject2) => {
          client[kConnector]({
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName]
          }, (err2, socket2) => {
            if (err2) {
              reject2(err2);
            } else {
              resolve2(socket2);
            }
          });
        });
        if (!llhttpInstance) {
          llhttpInstance = await llhttpPromise;
          llhttpPromise = null;
        }
        client[kConnecting] = false;
        assert3(socket);
        client[kSocket] = socket;
        socket[kNoRef] = false;
        socket[kWriting] = false;
        socket[kReset] = false;
        socket[kBlocking] = false;
        socket[kError] = null;
        socket[kParser] = new Parser(client, socket, llhttpInstance);
        socket[kClient] = client;
        socket[kCounter] = 0;
        socket[kMaxRequests] = client[kMaxRequests];
        socket.on("error", onSocketError).on("readable", onSocketReadable).on("end", onSocketEnd).on("close", onSocketClose);
        if (channels.connected.hasSubscribers) {
          channels.connected.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              servername: client[kServerName]
            },
            connector: client[kConnector],
            socket
          });
        }
        client.emit("connect", client[kUrl], [client]);
      } catch (err2) {
        client[kConnecting] = false;
        if (channels.connectError.hasSubscribers) {
          channels.connectError.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              servername: client[kServerName]
            },
            connector: client[kConnector],
            error: err2
          });
        }
        if (err2.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
          assert3(client[kRunning] === 0);
          while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
            const request3 = client[kQueue][client[kPendingIdx]++];
            errorRequest(client, request3, err2);
          }
        } else {
          onError(client, err2);
        }
        client.emit("connectionError", client[kUrl], [client], err2);
      }
      resume2(client);
    }
    function emitDrain(client) {
      client[kNeedDrain] = 0;
      client.emit("drain", client[kUrl], [client]);
    }
    function resume2(client, sync) {
      if (client[kResuming] === 2) {
        return;
      }
      client[kResuming] = 2;
      _resume(client, sync);
      client[kResuming] = 0;
      if (client[kRunningIdx] > 256) {
        client[kQueue].splice(0, client[kRunningIdx]);
        client[kPendingIdx] -= client[kRunningIdx];
        client[kRunningIdx] = 0;
      }
    }
    function _resume(client, sync) {
      while (true) {
        if (client.destroyed) {
          assert3(client[kPending] === 0);
          return;
        }
        if (client.closed && !client[kSize]) {
          client.destroy();
          return;
        }
        const socket = client[kSocket];
        if (socket) {
          if (client[kSize] === 0) {
            if (!socket[kNoRef] && socket.unref) {
              socket.unref();
              socket[kNoRef] = true;
            }
          } else if (socket[kNoRef] && socket.ref) {
            socket.ref();
            socket[kNoRef] = false;
          }
          if (client[kSize] === 0) {
            if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {
              socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
            }
          } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
            if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
              const request4 = client[kQueue][client[kRunningIdx]];
              const headersTimeout = request4.headersTimeout != null ? request4.headersTimeout : client[kHeadersTimeout];
              socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
            }
          }
        }
        if (client[kBusy]) {
          client[kNeedDrain] = 2;
        } else if (client[kNeedDrain] === 2) {
          if (sync) {
            client[kNeedDrain] = 1;
            process.nextTick(emitDrain, client);
          } else {
            emitDrain(client);
          }
          continue;
        }
        if (client[kPending] === 0) {
          return;
        }
        if (client[kRunning] >= (client[kPipelining] || 1)) {
          return;
        }
        const request3 = client[kQueue][client[kPendingIdx]];
        if (client[kUrl].protocol === "https:" && client[kServerName] !== request3.servername) {
          if (client[kRunning] > 0) {
            return;
          }
          client[kServerName] = request3.servername;
          if (socket && socket.servername !== request3.servername) {
            util.destroy(socket, new InformationalError("servername changed"));
            return;
          }
        }
        if (client[kConnecting]) {
          return;
        }
        if (!socket) {
          connect(client);
          continue;
        }
        if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {
          return;
        }
        if (client[kRunning] > 0 && !request3.idempotent) {
          return;
        }
        if (client[kRunning] > 0 && (request3.upgrade || request3.method === "CONNECT")) {
          return;
        }
        if (util.isStream(request3.body) && util.bodyLength(request3.body) === 0) {
          request3.body.on("data", function() {
            assert3(false);
          }).on("error", function(err2) {
            errorRequest(client, request3, err2);
          }).on("end", function() {
            util.destroy(this);
          });
          request3.body = null;
        }
        if (client[kRunning] > 0 && (util.isStream(request3.body) || util.isAsyncIterable(request3.body))) {
          return;
        }
        if (!request3.aborted && write(client, request3)) {
          client[kPendingIdx]++;
        } else {
          client[kQueue].splice(client[kPendingIdx], 1);
        }
      }
    }
    function write(client, request3) {
      const { body, method, path, host, upgrade, headers, blocking } = request3;
      const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
      if (body && typeof body.read === "function") {
        body.read(0);
      }
      let contentLength = util.bodyLength(body);
      if (contentLength === null) {
        contentLength = request3.contentLength;
      }
      if (contentLength === 0 && !expectsPayload) {
        contentLength = null;
      }
      if (request3.contentLength !== null && request3.contentLength !== contentLength) {
        if (client[kStrictContentLength]) {
          errorRequest(client, request3, new RequestContentLengthMismatchError());
          return false;
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      const socket = client[kSocket];
      try {
        request3.onConnect((err2) => {
          if (request3.aborted || request3.completed) {
            return;
          }
          errorRequest(client, request3, err2 || new RequestAbortedError());
          util.destroy(socket, new InformationalError("aborted"));
        });
      } catch (err2) {
        errorRequest(client, request3, err2);
      }
      if (request3.aborted) {
        return false;
      }
      if (method === "HEAD") {
        socket[kReset] = true;
      }
      if (upgrade || method === "CONNECT") {
        socket[kReset] = true;
      }
      if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
        socket[kReset] = true;
      }
      if (blocking) {
        socket[kBlocking] = true;
      }
      let header = `${method} ${path} HTTP/1.1\r
`;
      if (typeof host === "string") {
        header += `host: ${host}\r
`;
      } else {
        header += client[kHostHeader];
      }
      if (upgrade) {
        header += `connection: upgrade\r
upgrade: ${upgrade}\r
`;
      } else if (client[kPipelining]) {
        header += "connection: keep-alive\r\n";
      } else {
        header += "connection: close\r\n";
      }
      if (headers) {
        header += headers;
      }
      if (channels.sendHeaders.hasSubscribers) {
        channels.sendHeaders.publish({ request: request3, headers: header, socket });
      }
      if (!body) {
        if (contentLength === 0) {
          socket.write(`${header}content-length: 0\r
\r
`, "ascii");
        } else {
          assert3(contentLength === null, "no body must not have content length");
          socket.write(`${header}\r
`, "ascii");
        }
        request3.onRequestSent();
      } else if (util.isBuffer(body)) {
        assert3(contentLength === body.byteLength, "buffer body must have content length");
        socket.cork();
        socket.write(`${header}content-length: ${contentLength}\r
\r
`, "ascii");
        socket.write(body);
        socket.uncork();
        request3.onBodySent(body);
        request3.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
      } else if (util.isBlobLike(body)) {
        if (typeof body.stream === "function") {
          writeIterable({ body: body.stream(), client, request: request3, socket, contentLength, header, expectsPayload });
        } else {
          writeBlob({ body, client, request: request3, socket, contentLength, header, expectsPayload });
        }
      } else if (util.isStream(body)) {
        writeStream({ body, client, request: request3, socket, contentLength, header, expectsPayload });
      } else if (util.isIterable(body)) {
        writeIterable({ body, client, request: request3, socket, contentLength, header, expectsPayload });
      } else {
        assert3(false);
      }
      return true;
    }
    function writeStream({ body, client, request: request3, socket, contentLength, header, expectsPayload }) {
      assert3(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
      let finished = false;
      const writer = new AsyncWriter({ socket, request: request3, contentLength, client, expectsPayload, header });
      const onData = function(chunk) {
        try {
          assert3(!finished);
          if (!writer.write(chunk) && this.pause) {
            this.pause();
          }
        } catch (err2) {
          util.destroy(this, err2);
        }
      };
      const onDrain = function() {
        assert3(!finished);
        if (body.resume) {
          body.resume();
        }
      };
      const onAbort = function() {
        onFinished(new RequestAbortedError());
      };
      const onFinished = function(err2) {
        if (finished) {
          return;
        }
        finished = true;
        assert3(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);
        socket.off("drain", onDrain).off("error", onFinished);
        body.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort);
        if (!err2) {
          try {
            writer.end();
          } catch (er2) {
            err2 = er2;
          }
        }
        writer.destroy(err2);
        if (err2 && (err2.code !== "UND_ERR_INFO" || err2.message !== "reset")) {
          util.destroy(body, err2);
        } else {
          util.destroy(body);
        }
      };
      body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort);
      if (body.resume) {
        body.resume();
      }
      socket.on("drain", onDrain).on("error", onFinished);
    }
    async function writeBlob({ body, client, request: request3, socket, contentLength, header, expectsPayload }) {
      assert3(contentLength === body.size, "blob body must have content length");
      try {
        if (contentLength != null && contentLength !== body.size) {
          throw new RequestContentLengthMismatchError();
        }
        const buffer = Buffer.from(await body.arrayBuffer());
        socket.cork();
        socket.write(`${header}content-length: ${contentLength}\r
\r
`, "ascii");
        socket.write(buffer);
        socket.uncork();
        request3.onBodySent(buffer);
        request3.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        resume2(client);
      } catch (err2) {
        util.destroy(socket, err2);
      }
    }
    async function writeIterable({ body, client, request: request3, socket, contentLength, header, expectsPayload }) {
      assert3(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
      let callback = null;
      function onDrain() {
        if (callback) {
          const cb = callback;
          callback = null;
          cb();
        }
      }
      const waitForDrain = () => new Promise((resolve2, reject2) => {
        assert3(callback === null);
        if (socket[kError]) {
          reject2(socket[kError]);
        } else {
          callback = resolve2;
        }
      });
      socket.on("close", onDrain).on("drain", onDrain);
      const writer = new AsyncWriter({ socket, request: request3, contentLength, client, expectsPayload, header });
      try {
        for await (const chunk of body) {
          if (socket[kError]) {
            throw socket[kError];
          }
          if (!writer.write(chunk)) {
            await waitForDrain();
          }
        }
        writer.end();
      } catch (err2) {
        writer.destroy(err2);
      } finally {
        socket.off("close", onDrain).off("drain", onDrain);
      }
    }
    var AsyncWriter = class {
      constructor({ socket, request: request3, contentLength, client, expectsPayload, header }) {
        this.socket = socket;
        this.request = request3;
        this.contentLength = contentLength;
        this.client = client;
        this.bytesWritten = 0;
        this.expectsPayload = expectsPayload;
        this.header = header;
        socket[kWriting] = true;
      }
      write(chunk) {
        const { socket, request: request3, contentLength, client, bytesWritten, expectsPayload, header } = this;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return false;
        }
        const len = Buffer.byteLength(chunk);
        if (!len) {
          return true;
        }
        if (contentLength !== null && bytesWritten + len > contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          }
          process.emitWarning(new RequestContentLengthMismatchError());
        }
        if (bytesWritten === 0) {
          if (!expectsPayload) {
            socket[kReset] = true;
          }
          if (contentLength === null) {
            socket.write(`${header}transfer-encoding: chunked\r
`, "ascii");
          } else {
            socket.write(`${header}content-length: ${contentLength}\r
\r
`, "ascii");
          }
        }
        if (contentLength === null) {
          socket.write(`\r
${len.toString(16)}\r
`, "ascii");
        }
        this.bytesWritten += len;
        const ret = socket.write(chunk);
        request3.onBodySent(chunk);
        return ret;
      }
      end() {
        const { socket, contentLength, client, bytesWritten, expectsPayload, header, request: request3 } = this;
        request3.onRequestSent();
        socket[kWriting] = false;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return;
        }
        if (bytesWritten === 0) {
          if (expectsPayload) {
            socket.write(`${header}content-length: 0\r
\r
`, "ascii");
          } else {
            socket.write(`${header}\r
`, "ascii");
          }
        } else if (contentLength === null) {
          socket.write("\r\n0\r\n\r\n", "ascii");
        }
        if (contentLength !== null && bytesWritten !== contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          } else {
            process.emitWarning(new RequestContentLengthMismatchError());
          }
        }
        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
          if (socket[kParser].timeout.refresh) {
            socket[kParser].timeout.refresh();
          }
        }
        resume2(client);
      }
      destroy(err2) {
        const { socket, client } = this;
        socket[kWriting] = false;
        if (err2) {
          assert3(client[kRunning] <= 1, "pipeline should only contain this request");
          util.destroy(socket, err2);
        }
      }
    };
    function errorRequest(client, request3, err2) {
      try {
        request3.onError(err2);
        assert3(request3.aborted);
      } catch (err3) {
        client.emit("error", err3);
      }
    }
    module2.exports = Client;
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/node/fixed-queue.js
var require_fixed_queue = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/node/fixed-queue.js"(exports2, module2) {
    "use strict";
    var kSize = 2048;
    var kMask = kSize - 1;
    var FixedCircularBuffer = class {
      constructor() {
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize);
        this.next = null;
      }
      isEmpty() {
        return this.top === this.bottom;
      }
      isFull() {
        return (this.top + 1 & kMask) === this.bottom;
      }
      push(data) {
        this.list[this.top] = data;
        this.top = this.top + 1 & kMask;
      }
      shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === void 0)
          return null;
        this.list[this.bottom] = void 0;
        this.bottom = this.bottom + 1 & kMask;
        return nextItem;
      }
    };
    module2.exports = class FixedQueue {
      constructor() {
        this.head = this.tail = new FixedCircularBuffer();
      }
      isEmpty() {
        return this.head.isEmpty();
      }
      push(data) {
        if (this.head.isFull()) {
          this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data);
      }
      shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
          this.tail = tail.next;
        }
        return next;
      }
    };
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/pool-stats.js
var require_pool_stats = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/pool-stats.js"(exports2, module2) {
    var { kFree, kConnected, kPending, kQueued, kRunning, kSize } = require_symbols();
    var kPool = Symbol("pool");
    var PoolStats = class {
      constructor(pool) {
        this[kPool] = pool;
      }
      get connected() {
        return this[kPool][kConnected];
      }
      get free() {
        return this[kPool][kFree];
      }
      get pending() {
        return this[kPool][kPending];
      }
      get queued() {
        return this[kPool][kQueued];
      }
      get running() {
        return this[kPool][kRunning];
      }
      get size() {
        return this[kPool][kSize];
      }
    };
    module2.exports = PoolStats;
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/pool-base.js
var require_pool_base = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/pool-base.js"(exports2, module2) {
    "use strict";
    var DispatcherBase = require_dispatcher_base();
    var FixedQueue = require_fixed_queue();
    var { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require_symbols();
    var PoolStats = require_pool_stats();
    var kClients = Symbol("clients");
    var kNeedDrain = Symbol("needDrain");
    var kQueue = Symbol("queue");
    var kClosedResolve = Symbol("closed resolve");
    var kOnDrain = Symbol("onDrain");
    var kOnConnect = Symbol("onConnect");
    var kOnDisconnect = Symbol("onDisconnect");
    var kOnConnectionError = Symbol("onConnectionError");
    var kGetDispatcher = Symbol("get dispatcher");
    var kAddClient = Symbol("add client");
    var kRemoveClient = Symbol("remove client");
    var kStats = Symbol("stats");
    var PoolBase = class extends DispatcherBase {
      constructor() {
        super();
        this[kQueue] = new FixedQueue();
        this[kClients] = [];
        this[kQueued] = 0;
        const pool = this;
        this[kOnDrain] = function onDrain(origin, targets) {
          const queue = pool[kQueue];
          let needDrain = false;
          while (!needDrain) {
            const item = queue.shift();
            if (!item) {
              break;
            }
            pool[kQueued]--;
            needDrain = !this.dispatch(item.opts, item.handler);
          }
          this[kNeedDrain] = needDrain;
          if (!this[kNeedDrain] && pool[kNeedDrain]) {
            pool[kNeedDrain] = false;
            pool.emit("drain", origin, [pool, ...targets]);
          }
          if (pool[kClosedResolve] && queue.isEmpty()) {
            Promise.all(pool[kClients].map((c) => c.close())).then(pool[kClosedResolve]);
          }
        };
        this[kOnConnect] = (origin, targets) => {
          pool.emit("connect", origin, [pool, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err2) => {
          pool.emit("disconnect", origin, [pool, ...targets], err2);
        };
        this[kOnConnectionError] = (origin, targets, err2) => {
          pool.emit("connectionError", origin, [pool, ...targets], err2);
        };
        this[kStats] = new PoolStats(this);
      }
      get [kBusy]() {
        return this[kNeedDrain];
      }
      get [kConnected]() {
        return this[kClients].filter((client) => client[kConnected]).length;
      }
      get [kFree]() {
        return this[kClients].filter((client) => client[kConnected] && !client[kNeedDrain]).length;
      }
      get [kPending]() {
        let ret = this[kQueued];
        for (const { [kPending]: pending } of this[kClients]) {
          ret += pending;
        }
        return ret;
      }
      get [kRunning]() {
        let ret = 0;
        for (const { [kRunning]: running } of this[kClients]) {
          ret += running;
        }
        return ret;
      }
      get [kSize]() {
        let ret = this[kQueued];
        for (const { [kSize]: size } of this[kClients]) {
          ret += size;
        }
        return ret;
      }
      get stats() {
        return this[kStats];
      }
      async [kClose]() {
        if (this[kQueue].isEmpty()) {
          return Promise.all(this[kClients].map((c) => c.close()));
        } else {
          return new Promise((resolve2) => {
            this[kClosedResolve] = resolve2;
          });
        }
      }
      async [kDestroy](err2) {
        while (true) {
          const item = this[kQueue].shift();
          if (!item) {
            break;
          }
          item.handler.onError(err2);
        }
        return Promise.all(this[kClients].map((c) => c.destroy(err2)));
      }
      [kDispatch](opts, handler) {
        const dispatcher = this[kGetDispatcher]();
        if (!dispatcher) {
          this[kNeedDrain] = true;
          this[kQueue].push({ opts, handler });
          this[kQueued]++;
        } else if (!dispatcher.dispatch(opts, handler)) {
          dispatcher[kNeedDrain] = true;
          this[kNeedDrain] = !this[kGetDispatcher]();
        }
        return !this[kNeedDrain];
      }
      [kAddClient](client) {
        client.on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
        this[kClients].push(client);
        if (this[kNeedDrain]) {
          process.nextTick(() => {
            if (this[kNeedDrain]) {
              this[kOnDrain](client[kUrl], [this, client]);
            }
          });
        }
        return this;
      }
      [kRemoveClient](client) {
        client.close(() => {
          const idx = this[kClients].indexOf(client);
          if (idx !== -1) {
            this[kClients].splice(idx, 1);
          }
        });
        this[kNeedDrain] = this[kClients].some((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);
      }
    };
    module2.exports = {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    };
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/pool.js
var require_pool = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/pool.js"(exports2, module2) {
    "use strict";
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kGetDispatcher
    } = require_pool_base();
    var Client = require_client();
    var {
      InvalidArgumentError
    } = require_errors();
    var util = require_util();
    var { kUrl } = require_symbols();
    var buildConnector = require_connect();
    var kOptions = Symbol("options");
    var kConnections = Symbol("connections");
    var kFactory = Symbol("factory");
    function defaultFactory(origin, opts) {
      return new Client(origin, opts);
    }
    var Pool = class extends PoolBase {
      constructor(origin, {
        connections,
        factory = defaultFactory,
        connect,
        connectTimeout,
        tls,
        maxCachedSessions,
        socketPath,
        ...options2
      } = {}) {
        super();
        if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
          throw new InvalidArgumentError("invalid connections");
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (typeof connect !== "function") {
          connect = buildConnector({
            ...tls,
            maxCachedSessions,
            socketPath,
            timeout: connectTimeout == null ? 1e4 : connectTimeout,
            ...connect
          });
        }
        this[kConnections] = connections || null;
        this[kUrl] = util.parseOrigin(origin);
        this[kOptions] = { ...util.deepClone(options2), connect };
        this[kFactory] = factory;
      }
      [kGetDispatcher]() {
        let dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain]);
        if (dispatcher) {
          return dispatcher;
        }
        if (!this[kConnections] || this[kClients].length < this[kConnections]) {
          dispatcher = this[kFactory](this[kUrl], this[kOptions]);
          this[kAddClient](dispatcher);
        }
        return dispatcher;
      }
    };
    module2.exports = Pool;
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/balanced-pool.js
var require_balanced_pool = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/balanced-pool.js"(exports2, module2) {
    "use strict";
    var {
      BalancedPoolMissingUpstreamError,
      InvalidArgumentError
    } = require_errors();
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    } = require_pool_base();
    var Pool = require_pool();
    var { kUrl } = require_symbols();
    var { parseOrigin } = require_util();
    var kFactory = Symbol("factory");
    var kOptions = Symbol("options");
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var BalancedPool = class extends PoolBase {
      constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
        super();
        this[kOptions] = opts;
        if (!Array.isArray(upstreams)) {
          upstreams = [upstreams];
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        this[kFactory] = factory;
        for (const upstream of upstreams) {
          this.addUpstream(upstream);
        }
      }
      addUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        if (this[kClients].find((pool) => pool[kUrl].origin === upstreamOrigin && pool.closed !== true && pool.destroyed !== true)) {
          return this;
        }
        this[kAddClient](this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions])));
        return this;
      }
      removeUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        const pool = this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true);
        if (pool) {
          this[kRemoveClient](pool);
        }
        return this;
      }
      get upstreams() {
        return this[kClients].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p) => p[kUrl].origin);
      }
      [kGetDispatcher]() {
        if (this[kClients].length === 0) {
          throw new BalancedPoolMissingUpstreamError();
        }
        const dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);
        if (!dispatcher) {
          return;
        }
        this[kClients].splice(this[kClients].indexOf(dispatcher), 1);
        this[kClients].push(dispatcher);
        return dispatcher;
      }
    };
    module2.exports = BalancedPool;
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/compat/dispatcher-weakref.js
var require_dispatcher_weakref = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/compat/dispatcher-weakref.js"(exports2, module2) {
    "use strict";
    var { kConnected, kSize } = require_symbols();
    var CompatWeakRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value[kConnected] === 0 && this.value[kSize] === 0 ? void 0 : this.value;
      }
    };
    var CompatFinalizer = class {
      constructor(finalizer) {
        this.finalizer = finalizer;
      }
      register(dispatcher, key) {
        dispatcher.on("disconnect", () => {
          if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
            this.finalizer(key);
          }
        });
      }
    };
    module2.exports = function() {
      return {
        WeakRef: global.WeakRef || CompatWeakRef,
        FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer
      };
    };
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/agent.js
var require_agent = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/agent.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError } = require_errors();
    var { kClients, kRunning, kClose, kDestroy, kDispatch } = require_symbols();
    var DispatcherBase = require_dispatcher_base();
    var Pool = require_pool();
    var Client = require_client();
    var util = require_util();
    var RedirectHandler = require_redirect();
    var { WeakRef: WeakRef2, FinalizationRegistry: FinalizationRegistry2 } = require_dispatcher_weakref()();
    var kOnConnect = Symbol("onConnect");
    var kOnDisconnect = Symbol("onDisconnect");
    var kOnConnectionError = Symbol("onConnectionError");
    var kMaxRedirections = Symbol("maxRedirections");
    var kOnDrain = Symbol("onDrain");
    var kFactory = Symbol("factory");
    var kFinalizer = Symbol("finalizer");
    var kOptions = Symbol("options");
    function defaultFactory(origin, opts) {
      return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);
    }
    var Agent2 = class extends DispatcherBase {
      constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options2 } = {}) {
        super();
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        if (connect && typeof connect !== "function") {
          connect = { ...connect };
        }
        this[kOptions] = { ...util.deepClone(options2), connect };
        this[kMaxRedirections] = maxRedirections;
        this[kFactory] = factory;
        this[kClients] = /* @__PURE__ */ new Map();
        this[kFinalizer] = new FinalizationRegistry2((key) => {
          const ref = this[kClients].get(key);
          if (ref !== void 0 && ref.deref() === void 0) {
            this[kClients].delete(key);
          }
        });
        const agent = this;
        this[kOnDrain] = (origin, targets) => {
          agent.emit("drain", origin, [agent, ...targets]);
        };
        this[kOnConnect] = (origin, targets) => {
          agent.emit("connect", origin, [agent, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err2) => {
          agent.emit("disconnect", origin, [agent, ...targets], err2);
        };
        this[kOnConnectionError] = (origin, targets, err2) => {
          agent.emit("connectionError", origin, [agent, ...targets], err2);
        };
      }
      get [kRunning]() {
        let ret = 0;
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            ret += client[kRunning];
          }
        }
        return ret;
      }
      [kDispatch](opts, handler) {
        let key;
        if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) {
          key = String(opts.origin);
        } else {
          throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
        }
        const ref = this[kClients].get(key);
        let dispatcher = ref ? ref.deref() : null;
        if (!dispatcher) {
          dispatcher = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
          this[kClients].set(key, new WeakRef2(dispatcher));
          this[kFinalizer].register(dispatcher, key);
        }
        const { maxRedirections = this[kMaxRedirections] } = opts;
        if (maxRedirections != null && maxRedirections !== 0) {
          opts = { ...opts, maxRedirections: 0 };
          handler = new RedirectHandler(this, maxRedirections, opts, handler);
        }
        return dispatcher.dispatch(opts, handler);
      }
      async [kClose]() {
        const closePromises = [];
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            closePromises.push(client.close());
          }
        }
        await Promise.all(closePromises);
      }
      async [kDestroy](err2) {
        const destroyPromises = [];
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            destroyPromises.push(client.destroy(err2));
          }
        }
        await Promise.all(destroyPromises);
      }
    };
    module2.exports = Agent2;
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/api/readable.js
var require_readable = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/api/readable.js"(exports2, module2) {
    "use strict";
    var assert3 = (init_assert(), __toCommonJS(assert_exports));
    var { Readable: Readable2 } = (init_stream(), __toCommonJS(stream_exports));
    var { RequestAbortedError, NotSupportedError } = require_errors();
    var util = require_util();
    var { ReadableStreamFrom, toUSVString } = require_util();
    var Blob;
    var kConsume = Symbol("kConsume");
    var kReading = Symbol("kReading");
    var kBody = Symbol("kBody");
    var kAbort = Symbol("abort");
    var kContentType = Symbol("kContentType");
    module2.exports = class BodyReadable extends Readable2 {
      constructor(resume2, abort, contentType = "") {
        super({
          autoDestroy: true,
          read: resume2,
          highWaterMark: 64 * 1024
        });
        this._readableState.dataEmitted = false;
        this[kAbort] = abort;
        this[kConsume] = null;
        this[kBody] = null;
        this[kContentType] = contentType;
        this[kReading] = false;
      }
      destroy(err2) {
        if (this.destroyed) {
          return this;
        }
        if (!err2 && !this._readableState.endEmitted) {
          err2 = new RequestAbortedError();
        }
        if (err2) {
          this[kAbort]();
        }
        return super.destroy(err2);
      }
      emit(ev, ...args) {
        if (ev === "data") {
          this._readableState.dataEmitted = true;
        } else if (ev === "error") {
          this._readableState.errorEmitted = true;
        }
        return super.emit(ev, ...args);
      }
      on(ev, ...args) {
        if (ev === "data" || ev === "readable") {
          this[kReading] = true;
        }
        return super.on(ev, ...args);
      }
      addListener(ev, ...args) {
        return this.on(ev, ...args);
      }
      off(ev, ...args) {
        const ret = super.off(ev, ...args);
        if (ev === "data" || ev === "readable") {
          this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
        }
        return ret;
      }
      removeListener(ev, ...args) {
        return this.off(ev, ...args);
      }
      push(chunk) {
        if (this[kConsume] && chunk !== null) {
          consumePush(this[kConsume], chunk);
          return this[kReading] ? super.push(chunk) : true;
        }
        return super.push(chunk);
      }
      async text() {
        return consume(this, "text");
      }
      async json() {
        return consume(this, "json");
      }
      async blob() {
        return consume(this, "blob");
      }
      async arrayBuffer() {
        return consume(this, "arrayBuffer");
      }
      async formData() {
        throw new NotSupportedError();
      }
      get bodyUsed() {
        return util.isDisturbed(this);
      }
      get body() {
        if (!this[kBody]) {
          this[kBody] = ReadableStreamFrom(this);
          if (this[kConsume]) {
            this[kBody].getReader();
            assert3(this[kBody].locked);
          }
        }
        return this[kBody];
      }
      async dump(opts) {
        let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
        try {
          for await (const chunk of this) {
            limit -= Buffer.byteLength(chunk);
            if (limit < 0) {
              return;
            }
          }
        } catch {
        }
      }
    };
    function isLocked(self2) {
      return self2[kBody] && self2[kBody].locked === true || self2[kConsume];
    }
    function isUnusable(self2) {
      return util.isDisturbed(self2) || isLocked(self2);
    }
    async function consume(stream, type) {
      if (isUnusable(stream)) {
        throw new TypeError("unusable");
      }
      assert3(!stream[kConsume]);
      return new Promise((resolve2, reject2) => {
        stream[kConsume] = {
          type,
          stream,
          resolve: resolve2,
          reject: reject2,
          length: 0,
          body: []
        };
        stream.on("error", function(err2) {
          consumeFinish(this[kConsume], err2);
        }).on("close", function() {
          if (this[kConsume].body !== null) {
            consumeFinish(this[kConsume], new RequestAbortedError());
          }
        });
        process.nextTick(consumeStart, stream[kConsume]);
      });
    }
    function consumeStart(consume2) {
      if (consume2.body === null) {
        return;
      }
      const { _readableState: state } = consume2.stream;
      for (const chunk of state.buffer) {
        consumePush(consume2, chunk);
      }
      if (state.endEmitted) {
        consumeEnd(this[kConsume]);
      } else {
        consume2.stream.on("end", function() {
          consumeEnd(this[kConsume]);
        });
      }
      consume2.stream.resume();
      while (consume2.stream.read() != null) {
      }
    }
    function consumeEnd(consume2) {
      const { type, body, resolve: resolve2, stream, length } = consume2;
      try {
        if (type === "text") {
          resolve2(toUSVString(Buffer.concat(body)));
        } else if (type === "json") {
          resolve2(JSON.parse(Buffer.concat(body)));
        } else if (type === "arrayBuffer") {
          const dst = new Uint8Array(length);
          let pos = 0;
          for (const buf of body) {
            dst.set(buf, pos);
            pos += buf.byteLength;
          }
          resolve2(dst);
        } else if (type === "blob") {
          if (!Blob) {
            Blob = (init_buffer_es6(), __toCommonJS(buffer_es6_exports)).Blob;
          }
          resolve2(new Blob(body, { type: stream[kContentType] }));
        }
        consumeFinish(consume2);
      } catch (err2) {
        stream.destroy(err2);
      }
    }
    function consumePush(consume2, chunk) {
      consume2.length += chunk.length;
      consume2.body.push(chunk);
    }
    function consumeFinish(consume2, err2) {
      if (consume2.body === null) {
        return;
      }
      if (err2) {
        consume2.reject(err2);
      } else {
        consume2.resolve();
      }
      consume2.type = null;
      consume2.stream = null;
      consume2.resolve = null;
      consume2.reject = null;
      consume2.length = 0;
      consume2.body = null;
    }
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/api/abort-signal.js
var require_abort_signal = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/api/abort-signal.js"(exports2, module2) {
    var { RequestAbortedError } = require_errors();
    var kListener = Symbol("kListener");
    var kSignal = Symbol("kSignal");
    function abort(self2) {
      if (self2.abort) {
        self2.abort();
      } else {
        self2.onError(new RequestAbortedError());
      }
    }
    function addSignal(self2, signal) {
      self2[kSignal] = null;
      self2[kListener] = null;
      if (!signal) {
        return;
      }
      if (signal.aborted) {
        abort(self2);
        return;
      }
      self2[kSignal] = signal;
      self2[kListener] = () => {
        abort(self2);
      };
      if ("addEventListener" in self2[kSignal]) {
        self2[kSignal].addEventListener("abort", self2[kListener]);
      } else {
        self2[kSignal].addListener("abort", self2[kListener]);
      }
    }
    function removeSignal(self2) {
      if (!self2[kSignal]) {
        return;
      }
      if ("removeEventListener" in self2[kSignal]) {
        self2[kSignal].removeEventListener("abort", self2[kListener]);
      } else {
        self2[kSignal].removeListener("abort", self2[kListener]);
      }
      self2[kSignal] = null;
      self2[kListener] = null;
    }
    module2.exports = {
      addSignal,
      removeSignal
    };
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/api/api-request.js
var require_api_request = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/api/api-request.js"(exports2, module2) {
    "use strict";
    var Readable2 = require_readable();
    var {
      InvalidArgumentError,
      RequestAbortedError
    } = require_errors();
    var util = require_util();
    var { AsyncResource } = __require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var RequestHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body, onInfo, responseHeaders } = opts;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_REQUEST");
        } catch (err2) {
          if (util.isStream(body)) {
            util.destroy(body.on("error", util.nop), err2);
          }
          throw err2;
        }
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.body = body;
        this.trailers = {};
        this.context = null;
        this.onInfo = onInfo || null;
        if (util.isStream(body)) {
          body.on("error", (err2) => {
            this.onError(err2);
          });
        }
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume2) {
        const { callback, opaque, abort, context } = this;
        if (statusCode < 200) {
          if (this.onInfo) {
            const headers2 = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
            this.onInfo({ statusCode, headers: headers2 });
          }
          return;
        }
        const parsedHeaders = util.parseHeaders(rawHeaders);
        const body = new Readable2(resume2, abort, parsedHeaders["content-type"]);
        this.callback = null;
        this.res = body;
        const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        this.runInAsyncScope(callback, null, null, {
          statusCode,
          headers,
          trailers: this.trailers,
          opaque,
          body,
          context
        });
      }
      onData(chunk) {
        const { res } = this;
        return res.push(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        removeSignal(this);
        util.parseHeaders(trailers, this.trailers);
        res.push(null);
      }
      onError(err2) {
        const { res, callback, body, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err2, { opaque });
          });
        }
        if (res) {
          this.res = null;
          queueMicrotask(() => {
            util.destroy(res, err2);
          });
        }
        if (body) {
          this.body = null;
          util.destroy(body, err2);
        }
      }
    };
    function request3(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve2, reject2) => {
          request3.call(this, opts, (err2, data) => {
            return err2 ? reject2(err2) : resolve2(data);
          });
        });
      }
      try {
        this.dispatch(opts, new RequestHandler(opts, callback));
      } catch (err2) {
        if (typeof callback !== "function") {
          throw err2;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err2, { opaque }));
      }
    }
    module2.exports = request3;
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/api/api-stream.js
var require_api_stream = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/api/api-stream.js"(exports2, module2) {
    "use strict";
    var { finished } = (init_stream(), __toCommonJS(stream_exports));
    var {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError
    } = require_errors();
    var util = require_util();
    var { AsyncResource } = __require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var StreamHandler = class extends AsyncResource {
      constructor(opts, factory, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body, onInfo, responseHeaders } = opts;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (typeof factory !== "function") {
            throw new InvalidArgumentError("invalid factory");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_STREAM");
        } catch (err2) {
          if (util.isStream(body)) {
            util.destroy(body.on("error", util.nop), err2);
          }
          throw err2;
        }
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.factory = factory;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.context = null;
        this.trailers = null;
        this.body = body;
        this.onInfo = onInfo || null;
        if (util.isStream(body)) {
          body.on("error", (err2) => {
            this.onError(err2);
          });
        }
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume2) {
        const { factory, opaque, context } = this;
        if (statusCode < 200) {
          if (this.onInfo) {
            const headers2 = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
            this.onInfo({ statusCode, headers: headers2 });
          }
          return;
        }
        this.factory = null;
        const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        const res = this.runInAsyncScope(factory, null, {
          statusCode,
          headers,
          opaque,
          context
        });
        if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
          throw new InvalidReturnValueError("expected Writable");
        }
        res.on("drain", resume2);
        finished(res, { readable: false }, (err2) => {
          const { callback, res: res2, opaque: opaque2, trailers, abort } = this;
          this.res = null;
          if (err2 || !res2.readable) {
            util.destroy(res2, err2);
          }
          this.callback = null;
          this.runInAsyncScope(callback, null, err2 || null, { opaque: opaque2, trailers });
          if (err2) {
            abort();
          }
        });
        this.res = res;
        const needDrain = res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;
        return needDrain !== true;
      }
      onData(chunk) {
        const { res } = this;
        return res.write(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        removeSignal(this);
        this.trailers = util.parseHeaders(trailers);
        res.end();
      }
      onError(err2) {
        const { res, callback, opaque, body } = this;
        removeSignal(this);
        this.factory = null;
        if (res) {
          this.res = null;
          util.destroy(res, err2);
        } else if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err2, { opaque });
          });
        }
        if (body) {
          this.body = null;
          util.destroy(body, err2);
        }
      }
    };
    function stream(opts, factory, callback) {
      if (callback === void 0) {
        return new Promise((resolve2, reject2) => {
          stream.call(this, opts, factory, (err2, data) => {
            return err2 ? reject2(err2) : resolve2(data);
          });
        });
      }
      try {
        this.dispatch(opts, new StreamHandler(opts, factory, callback));
      } catch (err2) {
        if (typeof callback !== "function") {
          throw err2;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err2, { opaque }));
      }
    }
    module2.exports = stream;
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/api/api-pipeline.js
var require_api_pipeline = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/api/api-pipeline.js"(exports2, module2) {
    "use strict";
    var {
      Readable: Readable2,
      Duplex: Duplex2,
      PassThrough: PassThrough2
    } = (init_stream(), __toCommonJS(stream_exports));
    var {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError
    } = require_errors();
    var util = require_util();
    var { AsyncResource } = __require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var assert3 = (init_assert(), __toCommonJS(assert_exports));
    var kResume = Symbol("resume");
    var PipelineRequest = class extends Readable2 {
      constructor() {
        super({ autoDestroy: true });
        this[kResume] = null;
      }
      _read() {
        const { [kResume]: resume2 } = this;
        if (resume2) {
          this[kResume] = null;
          resume2();
        }
      }
      _destroy(err2, callback) {
        this._read();
        callback(err2);
      }
    };
    var PipelineResponse = class extends Readable2 {
      constructor(resume2) {
        super({ autoDestroy: true });
        this[kResume] = resume2;
      }
      _read() {
        this[kResume]();
      }
      _destroy(err2, callback) {
        if (!err2 && !this._readableState.endEmitted) {
          err2 = new RequestAbortedError();
        }
        callback(err2);
      }
    };
    var PipelineHandler = class extends AsyncResource {
      constructor(opts, handler) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof handler !== "function") {
          throw new InvalidArgumentError("invalid handler");
        }
        const { signal, method, opaque, onInfo, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_PIPELINE");
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.handler = handler;
        this.abort = null;
        this.context = null;
        this.onInfo = onInfo || null;
        this.req = new PipelineRequest().on("error", util.nop);
        this.ret = new Duplex2({
          readableObjectMode: opts.objectMode,
          autoDestroy: true,
          read: () => {
            const { body } = this;
            if (body && body.resume) {
              body.resume();
            }
          },
          write: (chunk, encoding, callback) => {
            const { req } = this;
            if (req.push(chunk, encoding) || req._readableState.destroyed) {
              callback();
            } else {
              req[kResume] = callback;
            }
          },
          destroy: (err2, callback) => {
            const { body, req, res, ret, abort } = this;
            if (!err2 && !ret._readableState.endEmitted) {
              err2 = new RequestAbortedError();
            }
            if (abort && err2) {
              abort();
            }
            util.destroy(body, err2);
            util.destroy(req, err2);
            util.destroy(res, err2);
            removeSignal(this);
            callback(err2);
          }
        }).on("prefinish", () => {
          const { req } = this;
          req.push(null);
        });
        this.res = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        const { ret, res } = this;
        assert3(!res, "pipeline cannot be retried");
        if (ret.destroyed) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume2) {
        const { opaque, handler, context } = this;
        if (statusCode < 200) {
          if (this.onInfo) {
            const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        this.res = new PipelineResponse(resume2);
        let body;
        try {
          this.handler = null;
          const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
          body = this.runInAsyncScope(handler, null, {
            statusCode,
            headers,
            opaque,
            body: this.res,
            context
          });
        } catch (err2) {
          this.res.on("error", util.nop);
          throw err2;
        }
        if (!body || typeof body.on !== "function") {
          throw new InvalidReturnValueError("expected Readable");
        }
        body.on("data", (chunk) => {
          const { ret, body: body2 } = this;
          if (!ret.push(chunk) && body2.pause) {
            body2.pause();
          }
        }).on("error", (err2) => {
          const { ret } = this;
          util.destroy(ret, err2);
        }).on("end", () => {
          const { ret } = this;
          ret.push(null);
        }).on("close", () => {
          const { ret } = this;
          if (!ret._readableState.ended) {
            util.destroy(ret, new RequestAbortedError());
          }
        });
        this.body = body;
      }
      onData(chunk) {
        const { res } = this;
        return res.push(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        res.push(null);
      }
      onError(err2) {
        const { ret } = this;
        this.handler = null;
        util.destroy(ret, err2);
      }
    };
    function pipeline(opts, handler) {
      try {
        const pipelineHandler = new PipelineHandler(opts, handler);
        this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
        return pipelineHandler.ret;
      } catch (err2) {
        return new PassThrough2().destroy(err2);
      }
    }
    module2.exports = pipeline;
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/api/api-upgrade.js
var require_api_upgrade = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/api/api-upgrade.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
    var { AsyncResource } = __require("async_hooks");
    var util = require_util();
    var { addSignal, removeSignal } = require_abort_signal();
    var assert3 = (init_assert(), __toCommonJS(assert_exports));
    var UpgradeHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_UPGRADE");
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.abort = null;
        this.context = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = null;
      }
      onHeaders() {
        throw new SocketError("bad upgrade", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        const { callback, opaque, context } = this;
        assert3.strictEqual(statusCode, 101);
        removeSignal(this);
        this.callback = null;
        const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        this.runInAsyncScope(callback, null, null, {
          headers,
          socket,
          opaque,
          context
        });
      }
      onError(err2) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err2, { opaque });
          });
        }
      }
    };
    function upgrade(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve2, reject2) => {
          upgrade.call(this, opts, (err2, data) => {
            return err2 ? reject2(err2) : resolve2(data);
          });
        });
      }
      try {
        const upgradeHandler = new UpgradeHandler(opts, callback);
        this.dispatch({
          ...opts,
          method: opts.method || "GET",
          upgrade: opts.protocol || "Websocket"
        }, upgradeHandler);
      } catch (err2) {
        if (typeof callback !== "function") {
          throw err2;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err2, { opaque }));
      }
    }
    module2.exports = upgrade;
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/api/api-connect.js
var require_api_connect = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/api/api-connect.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
    var { AsyncResource } = __require("async_hooks");
    var util = require_util();
    var { addSignal, removeSignal } = require_abort_signal();
    var ConnectHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_CONNECT");
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.callback = callback;
        this.abort = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders() {
        throw new SocketError("bad connect", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        const { callback, opaque, context } = this;
        removeSignal(this);
        this.callback = null;
        const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        this.runInAsyncScope(callback, null, null, {
          statusCode,
          headers,
          socket,
          opaque,
          context
        });
      }
      onError(err2) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err2, { opaque });
          });
        }
      }
    };
    function connect(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve2, reject2) => {
          connect.call(this, opts, (err2, data) => {
            return err2 ? reject2(err2) : resolve2(data);
          });
        });
      }
      try {
        const connectHandler = new ConnectHandler(opts, callback);
        this.dispatch({ ...opts, method: "CONNECT" }, connectHandler);
      } catch (err2) {
        if (typeof callback !== "function") {
          throw err2;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err2, { opaque }));
      }
    }
    module2.exports = connect;
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/api/index.js
var require_api = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/api/index.js"(exports2, module2) {
    "use strict";
    module2.exports.request = require_api_request();
    module2.exports.stream = require_api_stream();
    module2.exports.pipeline = require_api_pipeline();
    module2.exports.upgrade = require_api_upgrade();
    module2.exports.connect = require_api_connect();
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/mock/mock-errors.js
var require_mock_errors = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/mock/mock-errors.js"(exports2, module2) {
    "use strict";
    var { UndiciError } = require_errors();
    var MockNotMatchedError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, MockNotMatchedError);
        this.name = "MockNotMatchedError";
        this.message = message || "The request does not match any registered mock dispatches";
        this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
      }
    };
    module2.exports = {
      MockNotMatchedError
    };
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/mock/mock-symbols.js
var require_mock_symbols = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/mock/mock-symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kAgent: Symbol("agent"),
      kOptions: Symbol("options"),
      kFactory: Symbol("factory"),
      kDispatches: Symbol("dispatches"),
      kDispatchKey: Symbol("dispatch key"),
      kDefaultHeaders: Symbol("default headers"),
      kDefaultTrailers: Symbol("default trailers"),
      kContentLength: Symbol("content length"),
      kMockAgent: Symbol("mock agent"),
      kMockAgentSet: Symbol("mock agent set"),
      kMockAgentGet: Symbol("mock agent get"),
      kMockDispatch: Symbol("mock dispatch"),
      kClose: Symbol("close"),
      kOriginalClose: Symbol("original agent close"),
      kOrigin: Symbol("origin"),
      kIsMockActive: Symbol("is mock active"),
      kNetConnect: Symbol("net connect"),
      kGetNetConnect: Symbol("get net connect"),
      kConnected: Symbol("connected")
    };
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/mock/mock-utils.js
var require_mock_utils = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/mock/mock-utils.js"(exports2, module2) {
    "use strict";
    var { MockNotMatchedError } = require_mock_errors();
    var {
      kDispatches,
      kMockAgent,
      kOriginalDispatch,
      kOrigin,
      kIsMockActive,
      kGetNetConnect
    } = require_mock_symbols();
    function matchValue(match, value) {
      if (typeof match === "string") {
        return match === value;
      }
      if (match instanceof RegExp) {
        return match.test(value);
      }
      if (typeof match === "function") {
        return match(value) === true;
      }
      return false;
    }
    function lowerCaseEntries(headers) {
      return Object.fromEntries(Object.entries(headers).map(([headerName, headerValue]) => {
        return [headerName.toLocaleLowerCase(), headerValue];
      }));
    }
    function matchHeaders(mockDispatch2, headers) {
      if (typeof mockDispatch2.headers === "function") {
        if (Array.isArray(headers)) {
          const clone = headers.slice();
          const entries = [];
          for (let index = 0; index < clone.length; index += 2) {
            entries.push([clone[index], clone[index + 1]]);
          }
          headers = Object.fromEntries(entries);
        }
        return mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});
      }
      if (typeof mockDispatch2.headers === "undefined") {
        return true;
      }
      if (typeof headers !== "object" || typeof mockDispatch2.headers !== "object") {
        return false;
      }
      for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
        const header = typeof headers.get === "function" ? headers.get(matchHeaderName) : headers[matchHeaderName];
        if (!matchValue(matchHeaderValue, header)) {
          return false;
        }
      }
      return true;
    }
    function matchKey(mockDispatch2, { path, method, body, headers }) {
      const pathMatch = matchValue(mockDispatch2.path, path);
      const methodMatch = matchValue(mockDispatch2.method, method);
      const bodyMatch = typeof mockDispatch2.body !== "undefined" ? matchValue(mockDispatch2.body, body) : true;
      const headersMatch = matchHeaders(mockDispatch2, headers);
      return pathMatch && methodMatch && bodyMatch && headersMatch;
    }
    function getResponseData(data) {
      if (Buffer.isBuffer(data)) {
        return data;
      } else if (typeof data === "object") {
        return JSON.stringify(data);
      } else {
        return data.toString();
      }
    }
    function getMockDispatch(mockDispatches, key) {
      let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path }) => matchValue(path, key.path));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for path '${key.path}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== "undefined" ? matchValue(body, key.body) : true);
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers}'`);
      }
      return matchedMockDispatches[0];
    }
    function addMockDispatch(mockDispatches, key, data) {
      const baseData = { times: null, persist: false, consumed: false };
      const replyData = typeof data === "function" ? { callback: data } : { ...data };
      const newMockDispatch = { ...baseData, ...key, data: { error: null, ...replyData } };
      mockDispatches.push(newMockDispatch);
      return newMockDispatch;
    }
    function deleteMockDispatch(mockDispatches, key) {
      const index = mockDispatches.findIndex((dispatch) => {
        if (!dispatch.consumed) {
          return false;
        }
        return matchKey(dispatch, key);
      });
      if (index !== -1) {
        mockDispatches.splice(index, 1);
      }
    }
    function buildKey(opts) {
      const { path, method, body, headers } = opts;
      return {
        path,
        method,
        body,
        headers
      };
    }
    function generateKeyValues(data) {
      return Object.entries(data).reduce((keyValuePairs, [key, value]) => [...keyValuePairs, key, value], []);
    }
    async function getResponse(body) {
      const buffers = [];
      for await (const data of body) {
        buffers.push(data);
      }
      return Buffer.concat(buffers).toString("utf8");
    }
    function mockDispatch(opts, handler) {
      const key = buildKey(opts);
      const mockDispatch2 = getMockDispatch(this[kDispatches], key);
      if (mockDispatch2.data.callback) {
        mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
      }
      const { data: { statusCode, data, headers, trailers, error: error2 }, delay, persist } = mockDispatch2;
      let { times } = mockDispatch2;
      if (typeof times === "number" && times > 0) {
        times = --mockDispatch2.times;
      }
      if (!(persist === true || typeof times === "number" && times > 0)) {
        mockDispatch2.consumed = true;
      }
      if (error2 !== null) {
        deleteMockDispatch(this[kDispatches], key);
        handler.onError(error2);
        return true;
      }
      if (typeof delay === "number" && delay > 0) {
        setTimeout(() => {
          handleReply(this[kDispatches]);
        }, delay);
      } else {
        handleReply(this[kDispatches]);
      }
      function handleReply(mockDispatches) {
        const responseData = getResponseData(typeof data === "function" ? data(opts) : data);
        const responseHeaders = generateKeyValues(headers);
        const responseTrailers = generateKeyValues(trailers);
        handler.onHeaders(statusCode, responseHeaders, resume2);
        handler.onData(Buffer.from(responseData));
        handler.onComplete(responseTrailers);
        deleteMockDispatch(mockDispatches, key);
      }
      function resume2() {
      }
      return true;
    }
    function buildMockDispatch() {
      const agent = this[kMockAgent];
      const origin = this[kOrigin];
      const originalDispatch = this[kOriginalDispatch];
      return function dispatch(opts, handler) {
        if (agent[kIsMockActive]) {
          try {
            mockDispatch.call(this, opts, handler);
          } catch (error2) {
            if (error2 instanceof MockNotMatchedError) {
              const netConnect = agent[kGetNetConnect]();
              if (netConnect === false) {
                throw new MockNotMatchedError(`${error2.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
              }
              if (checkNetConnect(netConnect, origin)) {
                originalDispatch.call(this, opts, handler);
              } else {
                throw new MockNotMatchedError(`${error2.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
              }
            } else {
              throw error2;
            }
          }
        } else {
          originalDispatch.call(this, opts, handler);
        }
      };
    }
    function checkNetConnect(netConnect, origin) {
      const url2 = new URL(origin);
      if (netConnect === true) {
        return true;
      } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url2.host))) {
        return true;
      }
      return false;
    }
    function buildMockOptions(opts) {
      if (opts) {
        const { agent, ...mockOptions } = opts;
        return mockOptions;
      }
    }
    module2.exports = {
      getResponseData,
      getMockDispatch,
      addMockDispatch,
      deleteMockDispatch,
      buildKey,
      generateKeyValues,
      matchValue,
      getResponse,
      mockDispatch,
      buildMockDispatch,
      checkNetConnect,
      buildMockOptions
    };
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/mock/mock-interceptor.js
var require_mock_interceptor = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/mock/mock-interceptor.js"(exports2, module2) {
    "use strict";
    var { getResponseData, buildKey, addMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kDispatchKey,
      kDefaultHeaders,
      kDefaultTrailers,
      kContentLength,
      kMockDispatch
    } = require_mock_symbols();
    var { InvalidArgumentError } = require_errors();
    var MockScope = class {
      constructor(mockDispatch) {
        this[kMockDispatch] = mockDispatch;
      }
      delay(waitInMs) {
        if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) {
          throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
        }
        this[kMockDispatch].delay = waitInMs;
        return this;
      }
      persist() {
        this[kMockDispatch].persist = true;
        return this;
      }
      times(repeatTimes) {
        if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
          throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
        }
        this[kMockDispatch].times = repeatTimes;
        return this;
      }
    };
    var MockInterceptor = class {
      constructor(opts, mockDispatches) {
        if (typeof opts !== "object") {
          throw new InvalidArgumentError("opts must be an object");
        }
        if (typeof opts.path === "undefined") {
          throw new InvalidArgumentError("opts.path must be defined");
        }
        if (typeof opts.method === "undefined") {
          opts.method = "GET";
        }
        if (typeof opts.path === "string") {
          const parsedURL = new URL(opts.path, "data://");
          opts.path = parsedURL.pathname + parsedURL.search;
        }
        this[kDispatchKey] = buildKey(opts);
        this[kDispatches] = mockDispatches;
        this[kDefaultHeaders] = {};
        this[kDefaultTrailers] = {};
        this[kContentLength] = false;
      }
      createMockScopeDispatchData(statusCode, data, responseOptions = {}) {
        const responseData = getResponseData(data);
        const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
        const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
        const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
        return { statusCode, data, headers, trailers };
      }
      validateReplyParameters(statusCode, data, responseOptions) {
        if (typeof statusCode === "undefined") {
          throw new InvalidArgumentError("statusCode must be defined");
        }
        if (typeof data === "undefined") {
          throw new InvalidArgumentError("data must be defined");
        }
        if (typeof responseOptions !== "object") {
          throw new InvalidArgumentError("responseOptions must be an object");
        }
      }
      reply(replyData) {
        if (typeof replyData === "function") {
          const wrappedDefaultsCallback = (opts) => {
            const resolvedData = replyData(opts);
            if (typeof resolvedData !== "object") {
              throw new InvalidArgumentError("reply options callback must return an object");
            }
            const { statusCode: statusCode2, data: data2, responseOptions: responseOptions2 = {} } = resolvedData;
            this.validateReplyParameters(statusCode2, data2, responseOptions2);
            return {
              ...this.createMockScopeDispatchData(statusCode2, data2, responseOptions2)
            };
          };
          const newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
          return new MockScope(newMockDispatch2);
        }
        const [statusCode, data, responseOptions = {}] = [...arguments];
        this.validateReplyParameters(statusCode, data, responseOptions);
        const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
        return new MockScope(newMockDispatch);
      }
      replyWithError(error2) {
        if (typeof error2 === "undefined") {
          throw new InvalidArgumentError("error must be defined");
        }
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error: error2 });
        return new MockScope(newMockDispatch);
      }
      defaultReplyHeaders(headers) {
        if (typeof headers === "undefined") {
          throw new InvalidArgumentError("headers must be defined");
        }
        this[kDefaultHeaders] = headers;
        return this;
      }
      defaultReplyTrailers(trailers) {
        if (typeof trailers === "undefined") {
          throw new InvalidArgumentError("trailers must be defined");
        }
        this[kDefaultTrailers] = trailers;
        return this;
      }
      replyContentLength() {
        this[kContentLength] = true;
        return this;
      }
    };
    module2.exports.MockInterceptor = MockInterceptor;
    module2.exports.MockScope = MockScope;
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/mock/mock-client.js
var require_mock_client = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/mock/mock-client.js"(exports2, module2) {
    "use strict";
    var { promisify } = (init_util(), __toCommonJS(util_exports));
    var Client = require_client();
    var { buildMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected
    } = require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols();
    var { InvalidArgumentError } = require_errors();
    var MockClient = class extends Client {
      constructor(origin, opts) {
        super(origin, opts);
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      intercept(opts) {
        return new MockInterceptor(opts, this[kDispatches]);
      }
      async [kClose]() {
        await promisify(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module2.exports = MockClient;
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/mock/mock-pool.js
var require_mock_pool = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/mock/mock-pool.js"(exports2, module2) {
    "use strict";
    var { promisify } = (init_util(), __toCommonJS(util_exports));
    var Pool = require_pool();
    var { buildMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected
    } = require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols();
    var { InvalidArgumentError } = require_errors();
    var MockPool = class extends Pool {
      constructor(origin, opts) {
        super(origin, opts);
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      intercept(opts) {
        return new MockInterceptor(opts, this[kDispatches]);
      }
      async [kClose]() {
        await promisify(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module2.exports = MockPool;
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/mock/mock-agent.js
var require_mock_agent = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/mock/mock-agent.js"(exports2, module2) {
    "use strict";
    var { kClients } = require_symbols();
    var Agent2 = require_agent();
    var {
      kAgent,
      kMockAgentSet,
      kMockAgentGet,
      kDispatches,
      kIsMockActive,
      kNetConnect,
      kGetNetConnect,
      kOptions,
      kFactory
    } = require_mock_symbols();
    var MockClient = require_mock_client();
    var MockPool = require_mock_pool();
    var { matchValue, buildMockOptions } = require_mock_utils();
    var { InvalidArgumentError } = require_errors();
    var Dispatcher = require_dispatcher();
    var FakeWeakRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value;
      }
    };
    var MockAgent = class extends Dispatcher {
      constructor(opts) {
        super(opts);
        this[kNetConnect] = true;
        this[kIsMockActive] = true;
        if (opts && opts.agent && typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        const agent = opts && opts.agent ? opts.agent : new Agent2(opts);
        this[kAgent] = agent;
        this[kClients] = agent[kClients];
        this[kOptions] = buildMockOptions(opts);
      }
      get(origin) {
        let dispatcher = this[kMockAgentGet](origin);
        if (!dispatcher) {
          dispatcher = this[kFactory](origin);
          this[kMockAgentSet](origin, dispatcher);
        }
        return dispatcher;
      }
      dispatch(opts, handler) {
        this.get(opts.origin);
        return this[kAgent].dispatch(opts, handler);
      }
      async close() {
        await this[kAgent].close();
        this[kClients].clear();
      }
      deactivate() {
        this[kIsMockActive] = false;
      }
      activate() {
        this[kIsMockActive] = true;
      }
      enableNetConnect(matcher) {
        if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) {
          if (Array.isArray(this[kNetConnect])) {
            this[kNetConnect].push(matcher);
          } else {
            this[kNetConnect] = [matcher];
          }
        } else if (typeof matcher === "undefined") {
          this[kNetConnect] = true;
        } else {
          throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
        }
      }
      disableNetConnect() {
        this[kNetConnect] = false;
      }
      [kMockAgentSet](origin, dispatcher) {
        this[kClients].set(origin, new FakeWeakRef(dispatcher));
      }
      [kFactory](origin) {
        const mockOptions = Object.assign({ agent: this }, this[kOptions]);
        return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
      }
      [kMockAgentGet](origin) {
        const ref = this[kClients].get(origin);
        if (ref) {
          return ref.deref();
        }
        if (typeof origin !== "string") {
          const dispatcher = this[kFactory]("http://localhost:9999");
          this[kMockAgentSet](origin, dispatcher);
          return dispatcher;
        }
        for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
          const nonExplicitDispatcher = nonExplicitRef.deref();
          if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
            const dispatcher = this[kFactory](origin);
            this[kMockAgentSet](origin, dispatcher);
            dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
            return dispatcher;
          }
        }
      }
      [kGetNetConnect]() {
        return this[kNetConnect];
      }
    };
    module2.exports = MockAgent;
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/proxy-agent.js
var require_proxy_agent = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/proxy-agent.js"(exports2, module2) {
    "use strict";
    var { kProxy, kClose, kDestroy } = require_symbols();
    var { URL: URL2 } = (init_url(), __toCommonJS(url_exports));
    var Agent2 = require_agent();
    var DispatcherBase = require_dispatcher_base();
    var { InvalidArgumentError } = require_errors();
    var kAgent = Symbol("proxy agent");
    var ProxyAgent = class extends DispatcherBase {
      constructor(opts) {
        super(opts);
        this[kProxy] = buildProxyOptions(opts);
        this[kAgent] = new Agent2(opts);
      }
      dispatch(opts, handler) {
        const { host } = new URL2(opts.origin);
        return this[kAgent].dispatch({
          ...opts,
          origin: this[kProxy].uri,
          path: opts.origin + opts.path,
          headers: {
            ...opts.headers,
            host
          }
        }, handler);
      }
      async [kClose]() {
        await this[kAgent].close();
      }
      async [kDestroy]() {
        await this[kAgent].destroy();
      }
    };
    function buildProxyOptions(opts) {
      if (typeof opts === "string") {
        opts = { uri: opts };
      }
      if (!opts || !opts.uri) {
        throw new InvalidArgumentError("Proxy opts.uri is mandatory");
      }
      return {
        uri: opts.uri,
        protocol: opts.protocol || "https"
      };
    }
    module2.exports = ProxyAgent;
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/fetch/symbols.js
var require_symbols2 = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/fetch/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kUrl: Symbol("url"),
      kHeaders: Symbol("headers"),
      kSignal: Symbol("signal"),
      kState: Symbol("state"),
      kGuard: Symbol("guard"),
      kRealm: Symbol("realm")
    };
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/fetch/constants.js
var require_constants2 = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/fetch/constants.js"(exports2, module2) {
    "use strict";
    var forbiddenHeaderNames = [
      "accept-charset",
      "accept-encoding",
      "access-control-request-headers",
      "access-control-request-method",
      "connection",
      "content-length",
      "cookie",
      "cookie2",
      "date",
      "dnt",
      "expect",
      "host",
      "keep-alive",
      "origin",
      "referer",
      "te",
      "trailer",
      "transfer-encoding",
      "upgrade",
      "via"
    ];
    var corsSafeListedMethods = ["GET", "HEAD", "POST"];
    var nullBodyStatus = [101, 204, 205, 304];
    var redirectStatus = [301, 302, 303, 307, 308];
    var referrerPolicy = [
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url"
    ];
    var requestRedirect = ["follow", "manual", "error"];
    var safeMethods = ["GET", "HEAD", "OPTIONS", "TRACE"];
    var requestMode = ["navigate", "same-origin", "no-cors", "cors"];
    var requestCredentials = ["omit", "same-origin", "include"];
    var requestCache = [
      "default",
      "no-store",
      "reload",
      "no-cache",
      "force-cache",
      "only-if-cached"
    ];
    var forbiddenResponseHeaderNames = ["set-cookie", "set-cookie2"];
    var requestBodyHeader = [
      "content-encoding",
      "content-language",
      "content-location",
      "content-type"
    ];
    var forbiddenMethods = ["CONNECT", "TRACE", "TRACK"];
    var subresource = [
      "audio",
      "audioworklet",
      "font",
      "image",
      "manifest",
      "paintworklet",
      "script",
      "style",
      "track",
      "video",
      "xslt",
      ""
    ];
    var corsSafeListedResponseHeaderNames = [];
    module2.exports = {
      subresource,
      forbiddenResponseHeaderNames,
      corsSafeListedResponseHeaderNames,
      forbiddenMethods,
      requestBodyHeader,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      forbiddenHeaderNames,
      redirectStatus,
      corsSafeListedMethods,
      nullBodyStatus,
      safeMethods
    };
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/fetch/headers.js
var require_headers = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/fetch/headers.js"(exports2, module2) {
    "use strict";
    var { validateHeaderName, validateHeaderValue } = (init_http(), __toCommonJS(http_exports));
    var { kHeadersList } = require_symbols();
    var { kGuard } = require_symbols2();
    var { kEnumerableProperty } = require_util();
    var {
      forbiddenHeaderNames,
      forbiddenResponseHeaderNames
    } = require_constants2();
    function binarySearch(arr, val) {
      let low = 0;
      let high = Math.floor(arr.length / 2);
      while (high > low) {
        const mid = high + low >>> 1;
        if (val.localeCompare(arr[mid * 2]) > 0) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return low * 2;
    }
    function normalizeAndValidateHeaderName(name) {
      if (name === void 0) {
        throw new TypeError(`Header name ${name}`);
      }
      const normalizedHeaderName = name.toLocaleLowerCase();
      validateHeaderName(normalizedHeaderName);
      return normalizedHeaderName;
    }
    function normalizeAndValidateHeaderValue(name, value) {
      if (value === void 0) {
        throw new TypeError(value, name);
      }
      const normalizedHeaderValue = `${value}`.replace(/^[\n\t\r\x20]+|[\n\t\r\x20]+$/g, "");
      validateHeaderValue(name, normalizedHeaderValue);
      return normalizedHeaderValue;
    }
    function fill(headers, object) {
      if (object[Symbol.iterator]) {
        for (let header of object) {
          if (!header[Symbol.iterator]) {
            throw new TypeError();
          }
          if (typeof header === "string") {
            throw new TypeError();
          }
          if (!Array.isArray(header)) {
            header = [...header];
          }
          if (header.length !== 2) {
            throw new TypeError();
          }
          headers.append(header[0], header[1]);
        }
      } else if (object && typeof object === "object") {
        for (const header of Object.entries(object)) {
          headers.append(header[0], header[1]);
        }
      } else {
        throw TypeError();
      }
    }
    var HeadersList = class extends Array {
      append(name, value) {
        const normalizedName = normalizeAndValidateHeaderName(name);
        const normalizedValue = normalizeAndValidateHeaderValue(name, value);
        const index = binarySearch(this, normalizedName);
        if (this[index] === normalizedName) {
          this[index + 1] += `, ${normalizedValue}`;
        } else {
          this.splice(index, 0, normalizedName, normalizedValue);
        }
      }
      delete(name) {
        const normalizedName = normalizeAndValidateHeaderName(name);
        const index = binarySearch(this, normalizedName);
        if (this[index] === normalizedName) {
          this.splice(index, 2);
        }
      }
      get(name) {
        const normalizedName = normalizeAndValidateHeaderName(name);
        const index = binarySearch(this, normalizedName);
        if (this[index] === normalizedName) {
          return this[index + 1];
        }
        return null;
      }
      has(name) {
        const normalizedName = normalizeAndValidateHeaderName(name);
        const index = binarySearch(this, normalizedName);
        return this[index] === normalizedName;
      }
      set(name, value) {
        const normalizedName = normalizeAndValidateHeaderName(name);
        const normalizedValue = normalizeAndValidateHeaderValue(name, value);
        const index = binarySearch(this, normalizedName);
        if (this[index] === normalizedName) {
          this[index + 1] = normalizedValue;
        } else {
          this.splice(index, 0, normalizedName, normalizedValue);
        }
      }
    };
    var Headers = class {
      constructor(...args) {
        if (args[0] !== void 0 && !(typeof args[0] === "object" && args[0] != null) && !Array.isArray(args[0])) {
          throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(record<ByteString, ByteString> or sequence<sequence<ByteString>>");
        }
        const init = args.length >= 1 ? args[0] ?? {} : {};
        this[kHeadersList] = new HeadersList();
        this[kGuard] = "none";
        fill(this, init);
      }
      get [Symbol.toStringTag]() {
        if (!(this instanceof Headers)) {
          throw new TypeError("Illegal invocation");
        }
        return this.constructor.name;
      }
      toString() {
        if (!(this instanceof Headers)) {
          throw new TypeError("Illegal invocation");
        }
        return Object.prototype.toString.call(this);
      }
      append(...args) {
        if (!(this instanceof Headers)) {
          throw new TypeError("Illegal invocation");
        }
        if (args.length < 2) {
          throw new TypeError(`Failed to execute 'append' on 'Headers': 2 arguments required, but only ${args.length} present.`);
        }
        const normalizedName = normalizeAndValidateHeaderName(String(args[0]));
        if (this[kGuard] === "immutable") {
          throw new TypeError("immutable");
        } else if (this[kGuard] === "request" && forbiddenHeaderNames.includes(normalizedName)) {
          return;
        } else if (this[kGuard] === "request-no-cors") {
        } else if (this[kGuard] === "response" && forbiddenResponseHeaderNames.includes(normalizedName)) {
          return;
        }
        return this[kHeadersList].append(String(args[0]), String(args[1]));
      }
      delete(...args) {
        if (!(this instanceof Headers)) {
          throw new TypeError("Illegal invocation");
        }
        if (args.length < 1) {
          throw new TypeError(`Failed to execute 'delete' on 'Headers': 1 argument required, but only ${args.length} present.`);
        }
        const normalizedName = normalizeAndValidateHeaderName(String(args[0]));
        if (this[kGuard] === "immutable") {
          throw new TypeError("immutable");
        } else if (this[kGuard] === "request" && forbiddenHeaderNames.includes(normalizedName)) {
          return;
        } else if (this[kGuard] === "request-no-cors") {
        } else if (this[kGuard] === "response" && forbiddenResponseHeaderNames.includes(normalizedName)) {
          return;
        }
        return this[kHeadersList].delete(String(args[0]));
      }
      get(...args) {
        if (!(this instanceof Headers)) {
          throw new TypeError("Illegal invocation");
        }
        if (args.length < 1) {
          throw new TypeError(`Failed to execute 'get' on 'Headers': 1 argument required, but only ${args.length} present.`);
        }
        return this[kHeadersList].get(String(args[0]));
      }
      has(...args) {
        if (!(this instanceof Headers)) {
          throw new TypeError("Illegal invocation");
        }
        if (args.length < 1) {
          throw new TypeError(`Failed to execute 'has' on 'Headers': 1 argument required, but only ${args.length} present.`);
        }
        return this[kHeadersList].has(String(args[0]));
      }
      set(...args) {
        if (!(this instanceof Headers)) {
          throw new TypeError("Illegal invocation");
        }
        if (args.length < 2) {
          throw new TypeError(`Failed to execute 'set' on 'Headers': 2 arguments required, but only ${args.length} present.`);
        }
        const normalizedName = normalizeAndValidateHeaderName(String(args[0]));
        if (this[kGuard] === "immutable") {
          throw new TypeError("immutable");
        } else if (this[kGuard] === "request" && forbiddenHeaderNames.includes(normalizedName)) {
          return;
        } else if (this[kGuard] === "request-no-cors") {
        } else if (this[kGuard] === "response" && forbiddenResponseHeaderNames.includes(normalizedName)) {
          return;
        }
        return this[kHeadersList].set(String(args[0]), String(args[1]));
      }
      *keys() {
        const clone = this[kHeadersList].slice();
        for (let index = 0; index < clone.length; index += 2) {
          yield clone[index];
        }
      }
      *values() {
        const clone = this[kHeadersList].slice();
        for (let index = 1; index < clone.length; index += 2) {
          yield clone[index];
        }
      }
      *entries() {
        const clone = this[kHeadersList].slice();
        for (let index = 0; index < clone.length; index += 2) {
          yield [clone[index], clone[index + 1]];
        }
      }
      forEach(...args) {
        if (!(this instanceof Headers)) {
          throw new TypeError("Illegal invocation");
        }
        if (args.length < 1) {
          throw new TypeError(`Failed to execute 'forEach' on 'Headers': 1 argument required, but only ${args.length} present.`);
        }
        if (typeof args[0] !== "function") {
          throw new TypeError("Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.");
        }
        const callback = args[0];
        const thisArg = args[1];
        const clone = this[kHeadersList].slice();
        for (let index = 0; index < clone.length; index += 2) {
          callback.call(thisArg, clone[index + 1], clone[index], this);
        }
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        if (!(this instanceof Headers)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kHeadersList];
      }
    };
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
    Object.defineProperties(Headers.prototype, {
      append: kEnumerableProperty,
      delete: kEnumerableProperty,
      get: kEnumerableProperty,
      has: kEnumerableProperty,
      set: kEnumerableProperty,
      keys: kEnumerableProperty,
      values: kEnumerableProperty,
      entries: kEnumerableProperty,
      forEach: kEnumerableProperty
    });
    module2.exports = {
      fill,
      Headers,
      HeadersList,
      binarySearch,
      normalizeAndValidateHeaderName,
      normalizeAndValidateHeaderValue
    };
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/fetch/file.js
var require_file = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/fetch/file.js"(exports2, module2) {
    "use strict";
    var { Blob } = (init_buffer_es6(), __toCommonJS(buffer_es6_exports));
    var { kState } = require_symbols2();
    var File = class extends Blob {
      constructor(fileBits, fileName, options2 = {}) {
        const n = fileName;
        const t = options2.type;
        const d2 = options2.lastModified ?? Date.now();
        super(fileBits, { type: t });
        this[kState] = {
          name: n,
          lastModified: d2
        };
      }
      get name() {
        if (!(this instanceof File)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].name;
      }
      get lastModified() {
        if (!(this instanceof File)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].lastModified;
      }
      get [Symbol.toStringTag]() {
        if (!(this instanceof File)) {
          throw new TypeError("Illegal invocation");
        }
        return this.constructor.name;
      }
    };
    var FileLike = class {
      constructor(blobLike, fileName, options2 = {}) {
        const n = fileName;
        const t = options2.type;
        const d2 = options2.lastModified ?? Date.now();
        this[kState] = {
          blobLike,
          name: n,
          type: t,
          lastModified: d2
        };
      }
      stream(...args) {
        if (!(this instanceof FileLike)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].blobLike.stream(...args);
      }
      arrayBuffer(...args) {
        if (!(this instanceof FileLike)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].blobLike.arrayBuffer(...args);
      }
      slice(...args) {
        if (!(this instanceof FileLike)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].blobLike.slice(...args);
      }
      text(...args) {
        if (!(this instanceof FileLike)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].blobLike.text(...args);
      }
      get size() {
        if (!(this instanceof FileLike)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].blobLike.size;
      }
      get type() {
        if (!(this instanceof FileLike)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].blobLike.type;
      }
      get name() {
        if (!(this instanceof FileLike)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].name;
      }
      get lastModified() {
        if (!(this instanceof FileLike)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].lastModified;
      }
      get [Symbol.toStringTag]() {
        if (!(this instanceof FileLike)) {
          throw new TypeError("Illegal invocation");
        }
        return "File";
      }
    };
    module2.exports = { File: globalThis.File ?? File, FileLike };
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/fetch/util.js
var require_util2 = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/fetch/util.js"(exports2, module2) {
    "use strict";
    var { redirectStatus } = require_constants2();
    var { performance: performance2 } = __require("perf_hooks");
    var { isBlobLike, toUSVString, ReadableStreamFrom } = require_util();
    var File;
    var badPorts = [
      "1",
      "7",
      "9",
      "11",
      "13",
      "15",
      "17",
      "19",
      "20",
      "21",
      "22",
      "23",
      "25",
      "37",
      "42",
      "43",
      "53",
      "69",
      "77",
      "79",
      "87",
      "95",
      "101",
      "102",
      "103",
      "104",
      "109",
      "110",
      "111",
      "113",
      "115",
      "117",
      "119",
      "123",
      "135",
      "137",
      "139",
      "143",
      "161",
      "179",
      "389",
      "427",
      "465",
      "512",
      "513",
      "514",
      "515",
      "526",
      "530",
      "531",
      "532",
      "540",
      "548",
      "554",
      "556",
      "563",
      "587",
      "601",
      "636",
      "989",
      "990",
      "993",
      "995",
      "1719",
      "1720",
      "1723",
      "2049",
      "3659",
      "4045",
      "5060",
      "5061",
      "6000",
      "6566",
      "6665",
      "6666",
      "6667",
      "6668",
      "6669",
      "6697",
      "10080"
    ];
    function responseURL(response) {
      const urlList = response.urlList;
      const length = urlList.length;
      return length === 0 ? null : urlList[length - 1].toString();
    }
    function responseLocationURL(response, requestFragment) {
      if (!redirectStatus.includes(response.status)) {
        return null;
      }
      let location = response.headersList.get("location");
      location = location ? new URL(location, responseURL(response)) : null;
      if (location && !location.hash) {
        location.hash = requestFragment;
      }
      return location;
    }
    function requestCurrentURL(request3) {
      return request3.urlList[request3.urlList.length - 1];
    }
    function requestBadPort(request3) {
      const url2 = requestCurrentURL(request3);
      if (/^https?:/.test(url2.protocol) && badPorts.includes(url2.port)) {
        return "blocked";
      }
      return "allowed";
    }
    function isFileLike(object) {
      if (!File) {
        File = require_file().File;
      }
      return object instanceof File || object && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(File)$/.test(object[Symbol.toStringTag]);
    }
    function isValidReasonPhrase(statusText) {
      for (let i = 0; i < statusText.length; ++i) {
        const c = statusText.charCodeAt(i);
        if (!(c === 9 || c >= 32 && c <= 126 || c >= 128 && c <= 255)) {
          return false;
        }
      }
      return true;
    }
    function isTokenChar(c) {
      return !(c >= 127 || c <= 32 || c === "(" || c === ")" || c === "<" || c === ">" || c === "@" || c === "," || c === ";" || c === ":" || c === "\\" || c === '"' || c === "/" || c === "[" || c === "]" || c === "?" || c === "=" || c === "{" || c === "}");
    }
    function isValidHTTPToken(characters) {
      if (!characters || typeof characters !== "string") {
        return false;
      }
      for (let i = 0; i < characters.length; ++i) {
        const c = characters.charCodeAt(i);
        if (c > 127 || !isTokenChar(c)) {
          return false;
        }
      }
      return true;
    }
    function setRequestReferrerPolicyOnRedirect(request3, actualResponse) {
      const policy = "";
      if (policy !== "") {
        request3.referrerPolicy = policy;
      }
    }
    function crossOriginResourcePolicyCheck() {
      return "allowed";
    }
    function corsCheck() {
      return "success";
    }
    function TAOCheck() {
      return "success";
    }
    function appendFetchMetadata(httpRequest) {
      let header = null;
      header = httpRequest.mode;
      httpRequest.headersList.set("sec-fetch-mode", header);
    }
    function appendRequestOriginHeader(request3) {
      let serializedOrigin = request3.origin;
      if (request3.responseTainting === "cors" || request3.mode === "websocket") {
        if (serializedOrigin) {
          request3.headersList.append("Origin", serializedOrigin);
        }
      } else if (request3.method !== "GET" && request3.method !== "HEAD") {
        switch (request3.referrerPolicy) {
          case "no-referrer":
            serializedOrigin = null;
            break;
          case "no-referrer-when-downgrade":
          case "strict-origin":
          case "strict-origin-when-cross-origin":
            if (/^https:/.test(request3.origin) && !/^https:/.test(requestCurrentURL(request3))) {
              serializedOrigin = null;
            }
            break;
          case "same-origin":
            if (!sameOrigin(request3, requestCurrentURL(request3))) {
              serializedOrigin = null;
            }
            break;
          default:
        }
        if (serializedOrigin) {
          request3.headersList.append("Origin", serializedOrigin);
        }
      }
    }
    function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
      return performance2.now();
    }
    function createOpaqueTimingInfo(timingInfo) {
      return {
        startTime: timingInfo.startTime ?? 0,
        redirectStartTime: 0,
        redirectEndTime: 0,
        postRedirectStartTime: timingInfo.startTime ?? 0,
        finalServiceWorkerStartTime: 0,
        finalNetworkResponseStartTime: 0,
        finalNetworkRequestStartTime: 0,
        endTime: 0,
        encodedBodySize: 0,
        decodedBodySize: 0,
        finalConnectionTimingInfo: null
      };
    }
    function makePolicyContainer() {
      return {};
    }
    function clonePolicyContainer() {
      return {};
    }
    function determineRequestsReferrer(request3) {
      return "no-referrer";
    }
    function matchRequestIntegrity(request3, bytes) {
      return false;
    }
    function tryUpgradeRequestToAPotentiallyTrustworthyURL(request3) {
    }
    function sameOrigin(A, B) {
      if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
        return true;
      }
      return false;
    }
    function CORBCheck(request3, response) {
      return "allowed";
    }
    function createDeferredPromise() {
      let res;
      let rej;
      const promise = new Promise((resolve2, reject2) => {
        res = resolve2;
        rej = reject2;
      });
      return { promise, resolve: res, reject: rej };
    }
    function isAborted(fetchParams) {
      return fetchParams.controller.state === "aborted";
    }
    function isCancelled(fetchParams) {
      return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
    }
    function normalizeMethod(method) {
      return /^(DELETE|GET|HEAD|OPTIONS|POST|PUT)$/i.test(method) ? method.toUpperCase() : method;
    }
    module2.exports = {
      isAborted,
      isCancelled,
      createDeferredPromise,
      ReadableStreamFrom,
      toUSVString,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      coarsenedSharedCurrentTime,
      matchRequestIntegrity,
      determineRequestsReferrer,
      makePolicyContainer,
      clonePolicyContainer,
      appendFetchMetadata,
      appendRequestOriginHeader,
      TAOCheck,
      corsCheck,
      crossOriginResourcePolicyCheck,
      createOpaqueTimingInfo,
      setRequestReferrerPolicyOnRedirect,
      isValidHTTPToken,
      requestBadPort,
      requestCurrentURL,
      responseURL,
      responseLocationURL,
      isBlobLike,
      isFileLike,
      isValidReasonPhrase,
      sameOrigin,
      CORBCheck,
      normalizeMethod
    };
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/fetch/formdata.js
var require_formdata = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/fetch/formdata.js"(exports2, module2) {
    "use strict";
    var { isBlobLike, isFileLike, toUSVString } = require_util2();
    var { kState } = require_symbols2();
    var { File, FileLike } = require_file();
    var { Blob } = (init_buffer_es6(), __toCommonJS(buffer_es6_exports));
    var FormData = class {
      constructor(...args) {
        if (args.length > 0 && !(args[0]?.constructor?.name === "HTMLFormElement")) {
          throw new TypeError("Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'");
        }
        this[kState] = [];
      }
      append(...args) {
        if (!(this instanceof FormData)) {
          throw new TypeError("Illegal invocation");
        }
        if (args.length < 2) {
          throw new TypeError(`Failed to execute 'append' on 'FormData': 2 arguments required, but only ${args.length} present.`);
        }
        if (args.length === 3 && !isBlobLike(args[1])) {
          throw new TypeError("Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'");
        }
        const name = toUSVString(args[0]);
        const filename = args.length === 3 ? toUSVString(args[2]) : void 0;
        const value = isBlobLike(args[1]) ? args[1] : toUSVString(args[1]);
        const entry = makeEntry(name, value, filename);
        this[kState].push(entry);
      }
      delete(...args) {
        if (!(this instanceof FormData)) {
          throw new TypeError("Illegal invocation");
        }
        if (args.length < 1) {
          throw new TypeError(`Failed to execute 'delete' on 'FormData': 1 arguments required, but only ${args.length} present.`);
        }
        const name = toUSVString(args[0]);
        const next = [];
        for (const entry of this[kState]) {
          if (entry.name !== name) {
            next.push(entry);
          }
        }
        this[kState] = next;
      }
      get(...args) {
        if (!(this instanceof FormData)) {
          throw new TypeError("Illegal invocation");
        }
        if (args.length < 1) {
          throw new TypeError(`Failed to execute 'get' on 'FormData': 1 arguments required, but only ${args.length} present.`);
        }
        const name = toUSVString(args[0]);
        const idx = this[kState].findIndex((entry) => entry.name === name);
        if (idx === -1) {
          return null;
        }
        return this[kState][idx].value;
      }
      getAll(...args) {
        if (!(this instanceof FormData)) {
          throw new TypeError("Illegal invocation");
        }
        if (args.length < 1) {
          throw new TypeError(`Failed to execute 'getAll' on 'FormData': 1 arguments required, but only ${args.length} present.`);
        }
        const name = toUSVString(args[0]);
        return this[kState].filter((entry) => entry.name === name).map((entry) => entry.value);
      }
      has(...args) {
        if (!(this instanceof FormData)) {
          throw new TypeError("Illegal invocation");
        }
        if (args.length < 1) {
          throw new TypeError(`Failed to execute 'has' on 'FormData': 1 arguments required, but only ${args.length} present.`);
        }
        const name = toUSVString(args[0]);
        return this[kState].findIndex((entry) => entry.name === name) !== -1;
      }
      set(...args) {
        if (!(this instanceof FormData)) {
          throw new TypeError("Illegal invocation");
        }
        if (args.length < 2) {
          throw new TypeError(`Failed to execute 'set' on 'FormData': 2 arguments required, but only ${args.length} present.`);
        }
        if (args.length === 3 && !isBlobLike(args[1])) {
          throw new TypeError("Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'");
        }
        const name = toUSVString(args[0]);
        const filename = args.length === 3 ? toUSVString(args[2]) : void 0;
        const value = isBlobLike(args[1]) ? args[1] : toUSVString(args[1]);
        const entry = makeEntry(name, value, filename);
        const idx = this[kState].findIndex((entry2) => entry2.name === name);
        if (idx !== -1) {
          this[kState] = [
            ...this[kState].slice(0, idx),
            entry,
            ...this[kState].slice(idx + 1).filter((entry2) => entry2.name !== name)
          ];
        } else {
          this[kState].push(entry);
        }
      }
      get [Symbol.toStringTag]() {
        if (!(this instanceof FormData)) {
          throw new TypeError("Illegal invocation");
        }
        return this.constructor.name;
      }
      *entries() {
        if (!(this instanceof FormData)) {
          throw new TypeError("Illegal invocation");
        }
        for (const pair of this) {
          yield pair;
        }
      }
      *keys() {
        if (!(this instanceof FormData)) {
          throw new TypeError("Illegal invocation");
        }
        for (const [key] of this) {
          yield key;
        }
      }
      *values() {
        if (!(this instanceof FormData)) {
          throw new TypeError("Illegal invocation");
        }
        for (const [, value] of this) {
          yield value;
        }
      }
      *[Symbol.iterator]() {
        for (const { name, value } of this[kState]) {
          yield [name, value];
        }
      }
    };
    function makeEntry(name, value, filename) {
      const entry = {
        name: null,
        value: null
      };
      entry.name = name;
      if (isBlobLike(value) && !isFileLike(value)) {
        value = value instanceof Blob ? new File([value], "blob") : new FileLike(value, "blob");
      }
      if (isFileLike(value) && filename != null) {
        value = value instanceof File ? new File([value], filename) : new FileLike(value, filename);
      }
      entry.value = value;
      return entry;
    }
    module2.exports = { FormData: globalThis.FormData ?? FormData };
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/fetch/body.js
var require_body = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/fetch/body.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    var { ReadableStreamFrom, toUSVString, isBlobLike } = require_util2();
    var { FormData } = require_formdata();
    var { kState } = require_symbols2();
    var { Blob } = (init_buffer_es6(), __toCommonJS(buffer_es6_exports));
    var { kBodyUsed } = require_symbols();
    var assert3 = (init_assert(), __toCommonJS(assert_exports));
    var { NotSupportedError } = require_errors();
    var { isErrored } = require_util();
    var { isUint8Array } = __require("util/types");
    var ReadableStream2;
    async function* blobGen(blob) {
      if (blob.stream) {
        yield* blob.stream();
      } else {
        yield await blob.arrayBuffer();
      }
    }
    function extractBody(object, keepalive = false) {
      if (!ReadableStream2) {
        ReadableStream2 = __require("stream/web").ReadableStream;
      }
      let stream = null;
      let action = null;
      let source = null;
      let length = null;
      let contentType = null;
      if (object == null) {
      } else if (object instanceof URLSearchParams) {
        source = object.toString();
        contentType = "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (object instanceof ArrayBuffer || ArrayBuffer.isView(object)) {
        if (object instanceof DataView) {
          object = object.buffer;
        }
        source = new Uint8Array(object);
      } else if (object instanceof FormData) {
        const boundary = "----formdata-undici-" + Math.random();
        const prefix = `--${boundary}\r
Content-Disposition: form-data`;
        const escape2 = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
        const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
        action = async function* (object2) {
          const enc = new TextEncoder();
          for (const [name, value] of object2) {
            if (typeof value === "string") {
              yield enc.encode(prefix + `; name="${escape2(normalizeLinefeeds(name))}"\r
\r
${normalizeLinefeeds(value)}\r
`);
            } else {
              yield enc.encode(prefix + `; name="${escape2(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape2(value.name)}"` : "") + `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`);
              yield* blobGen(value);
              yield enc.encode("\r\n");
            }
          }
          yield enc.encode(`--${boundary}--`);
        };
        source = object;
        contentType = "multipart/form-data; boundary=" + boundary;
      } else if (isBlobLike(object)) {
        action = blobGen;
        source = object;
        length = object.size;
        if (object.type) {
          contentType = object.type;
        }
      } else if (typeof object[Symbol.asyncIterator] === "function") {
        if (keepalive) {
          throw new TypeError("keepalive");
        }
        if (util.isDisturbed(object) || object.locked) {
          throw new TypeError("Response body object should not be disturbed or locked");
        }
        stream = object instanceof ReadableStream2 ? object : ReadableStreamFrom(object);
      } else {
        source = toUSVString(object);
        contentType = "text/plain;charset=UTF-8";
      }
      if (typeof source === "string" || util.isBuffer(source)) {
        length = Buffer.byteLength(source);
      }
      if (action != null) {
        let iterator;
        stream = new ReadableStream2({
          async start() {
            iterator = action(object)[Symbol.asyncIterator]();
          },
          async pull(controller) {
            const { value, done: done2 } = await iterator.next();
            if (done2) {
              queueMicrotask(() => {
                controller.close();
              });
            } else {
              if (!isErrored(stream)) {
                controller.enqueue(new Uint8Array(value));
              }
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          }
        });
      } else if (!stream) {
        stream = new ReadableStream2({
          async pull(controller) {
            controller.enqueue(typeof source === "string" ? new TextEncoder().encode(source) : source);
            queueMicrotask(() => {
              controller.close();
            });
          }
        });
      }
      const body = { stream, source, length };
      return [body, contentType];
    }
    function safelyExtractBody(object, keepalive = false) {
      if (!ReadableStream2) {
        ReadableStream2 = __require("stream/web").ReadableStream;
      }
      if (object instanceof ReadableStream2) {
        assert3(!util.isDisturbed(object), "disturbed");
        assert3(!object.locked, "locked");
      }
      return extractBody(object, keepalive);
    }
    function cloneBody(body) {
      const [out1, out2] = body.stream.tee();
      body.stream = out1;
      return {
        stream: out2,
        length: body.length,
        source: body.source
      };
    }
    var methods = {
      async blob() {
        const chunks = [];
        if (this[kState].body) {
          if (isUint8Array(this[kState].body)) {
            chunks.push(this[kState].body);
          } else {
            const stream = this[kState].body.stream;
            if (util.isDisturbed(stream)) {
              throw new TypeError("disturbed");
            }
            if (stream.locked) {
              throw new TypeError("locked");
            }
            stream[kBodyUsed] = true;
            for await (const chunk of stream) {
              chunks.push(chunk);
            }
          }
        }
        return new Blob(chunks, { type: this.headers.get("Content-Type") || "" });
      },
      async arrayBuffer() {
        const blob = await this.blob();
        return await blob.arrayBuffer();
      },
      async text() {
        const blob = await this.blob();
        return toUSVString(await blob.text());
      },
      async json() {
        return JSON.parse(await this.text());
      },
      async formData() {
        const contentType = this.headers.get("Content-Type");
        if (/multipart\/form-data/.test(contentType)) {
          throw new NotSupportedError("multipart/form-data not supported");
        } else if (/application\/x-www-form-urlencoded/.test(contentType)) {
          let entries;
          try {
            entries = new URLSearchParams(await this.text());
          } catch (err2) {
            throw Object.assign(new TypeError(), { cause: err2 });
          }
          const formData = new FormData();
          for (const [name, value] of entries) {
            formData.append(name, value);
          }
          return formData;
        } else {
          throw new TypeError();
        }
      }
    };
    var properties = {
      body: {
        enumerable: true,
        get() {
          return this[kState].body ? this[kState].body.stream : null;
        }
      },
      bodyUsed: {
        enumerable: true,
        get() {
          return this[kState].body && util.isDisturbed(this[kState].body.stream);
        }
      }
    };
    function mixinBody(prototype) {
      Object.assign(prototype, methods);
      Object.defineProperties(prototype, properties);
    }
    module2.exports = {
      extractBody,
      safelyExtractBody,
      cloneBody,
      mixinBody
    };
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/fetch/response.js
var require_response = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/fetch/response.js"(exports2, module2) {
    "use strict";
    var { Headers, HeadersList, fill } = require_headers();
    var { AbortError } = require_errors();
    var { extractBody, cloneBody, mixinBody } = require_body();
    var util = require_util();
    var { kEnumerableProperty } = util;
    var { responseURL, isValidReasonPhrase, toUSVString, isCancelled, isAborted } = require_util2();
    var {
      redirectStatus,
      nullBodyStatus,
      forbiddenResponseHeaderNames,
      corsSafeListedResponseHeaderNames
    } = require_constants2();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
    var { kHeadersList } = require_symbols();
    var assert3 = (init_assert(), __toCommonJS(assert_exports));
    var Response2 = class {
      static error() {
        const relevantRealm = { settingsObject: {} };
        const responseObject = new Response2();
        responseObject[kState] = makeNetworkError();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        return responseObject;
      }
      static redirect(...args) {
        const relevantRealm = { settingsObject: {} };
        if (args.length < 1) {
          throw new TypeError(`Failed to execute 'redirect' on 'Response': 1 argument required, but only ${args.length} present.`);
        }
        const status2 = args.length >= 2 ? args[1] : 302;
        const url2 = toUSVString(args[0]);
        let parsedURL;
        try {
          parsedURL = new URL(url2);
        } catch (err2) {
          throw Object.assign(new TypeError("Failed to parse URL from " + url2), {
            cause: err2
          });
        }
        if (!redirectStatus.includes(status2)) {
          throw new RangeError("Invalid status code");
        }
        const responseObject = new Response2();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        responseObject[kState].status = status2;
        const value = parsedURL.toString();
        responseObject[kState].headersList.push("location", value);
        return responseObject;
      }
      constructor(...args) {
        if (args.length >= 1 && typeof args[1] !== "object" && args[1] !== void 0) {
          throw new TypeError("Failed to construct 'Request': cannot convert to dictionary.");
        }
        const body = args.length >= 1 ? args[0] : null;
        const init = args.length >= 2 ? args[1] ?? {} : {};
        this[kRealm] = { settingsObject: {} };
        if ("status" in init && init.status !== void 0) {
          if (!Number.isFinite(init.status)) {
            throw new TypeError();
          }
          if (init.status < 200 || init.status > 599) {
            throw new RangeError(`Failed to construct 'Response': The status provided (${init.status}) is outside the range [200, 599].`);
          }
        }
        if ("statusText" in init && init.statusText !== void 0) {
          if (!isValidReasonPhrase(String(init.statusText))) {
            throw new TypeError("Invalid statusText");
          }
        }
        this[kState] = makeResponse({});
        this[kHeaders] = new Headers();
        this[kHeaders][kGuard] = "response";
        this[kHeaders][kHeadersList] = this[kState].headersList;
        this[kHeaders][kRealm] = this[kRealm];
        if ("status" in init && init.status !== void 0) {
          this[kState].status = init.status;
        }
        if ("statusText" in init && init.statusText !== void 0) {
          this[kState].statusText = String(init.statusText);
        }
        if ("headers" in init) {
          fill(this[kState].headersList, init.headers);
        }
        if (body != null) {
          if (nullBodyStatus.includes(init.status)) {
            throw new TypeError("Response with null body status cannot have body");
          }
          const [extractedBody, contentType] = extractBody(body);
          this[kState].body = extractedBody;
          if (contentType && !this.headers.has("content-type")) {
            this.headers.set("content-type", contentType);
          }
        }
      }
      get [Symbol.toStringTag]() {
        if (!(this instanceof Response2)) {
          throw new TypeError("Illegal invocation");
        }
        return this.constructor.name;
      }
      get type() {
        if (!(this instanceof Response2)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].type;
      }
      get url() {
        if (!(this instanceof Response2)) {
          throw new TypeError("Illegal invocation");
        }
        let url2 = responseURL(this[kState]);
        if (url2 == null) {
          return "";
        }
        if (url2.hash) {
          url2 = new URL(url2);
          url2.hash = "";
        }
        return url2.toString();
      }
      get redirected() {
        if (!(this instanceof Response2)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].urlList.length > 1;
      }
      get status() {
        if (!(this instanceof Response2)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].status;
      }
      get ok() {
        if (!(this instanceof Response2)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].status >= 200 && this[kState].status <= 299;
      }
      get statusText() {
        if (!(this instanceof Response2)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].statusText;
      }
      get headers() {
        if (!(this instanceof Response2)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kHeaders];
      }
      clone() {
        if (!(this instanceof Response2)) {
          throw new TypeError("Illegal invocation");
        }
        if (this.bodyUsed || this.body && this.body.locked) {
          throw new TypeError();
        }
        const clonedResponse = cloneResponse(this[kState]);
        const clonedResponseObject = new Response2();
        clonedResponseObject[kState] = clonedResponse;
        clonedResponseObject[kRealm] = this[kRealm];
        clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;
        clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];
        clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];
        return clonedResponseObject;
      }
    };
    mixinBody(Response2.prototype);
    Object.defineProperties(Response2.prototype, {
      type: kEnumerableProperty,
      url: kEnumerableProperty,
      status: kEnumerableProperty,
      ok: kEnumerableProperty,
      redirected: kEnumerableProperty,
      statusText: kEnumerableProperty,
      headers: kEnumerableProperty,
      clone: kEnumerableProperty
    });
    function cloneResponse(response) {
      if (response.internalResponse) {
        return filterResponse(cloneResponse(response.internalResponse), response.type);
      }
      const newResponse = makeResponse({ ...response, body: null });
      if (response.body != null) {
        newResponse.body = cloneBody(response.body);
      }
      return newResponse;
    }
    function makeResponse(init) {
      return {
        aborted: false,
        rangeRequested: false,
        timingAllowPassed: false,
        requestIncludesCredentials: false,
        type: "default",
        status: 200,
        timingInfo: null,
        cacheState: "",
        statusText: "",
        ...init,
        headersList: init.headersList ? new HeadersList(...init.headersList) : new HeadersList(),
        urlList: init.urlList ? [...init.urlList] : []
      };
    }
    function makeNetworkError(reason) {
      return makeResponse({
        type: "error",
        status: 0,
        error: reason instanceof Error ? reason : new Error(reason ? String(reason) : reason, {
          cause: reason instanceof Error ? reason : void 0
        }),
        aborted: reason && reason.name === "AbortError"
      });
    }
    function makeFilteredResponse(response, state) {
      state = {
        internalResponse: response,
        ...state
      };
      return new Proxy(response, {
        get(target, p) {
          return p in state ? state[p] : target[p];
        },
        set(target, p, value) {
          assert3(!(p in state));
          target[p] = value;
          return true;
        }
      });
    }
    function makeFilteredHeadersList(headersList, filter) {
      return new Proxy(headersList, {
        get(target, prop) {
          if (prop === "get" || prop === "has") {
            return (name) => filter(name) ? target[prop](name) : void 0;
          } else if (prop === "slice") {
            return (...args) => {
              assert3(args.length === 0);
              const arr = [];
              for (let index = 0; index < target.length; index += 2) {
                if (filter(target[index])) {
                  arr.push(target[index], target[index + 1]);
                }
              }
              return arr;
            };
          } else {
            return target[prop];
          }
        }
      });
    }
    function filterResponse(response, type) {
      if (type === "basic") {
        return makeFilteredResponse(response, {
          type: "basic",
          headersList: makeFilteredHeadersList(response.headersList, (name) => !forbiddenResponseHeaderNames.includes(name))
        });
      } else if (type === "cors") {
        return makeFilteredResponse(response, {
          type: "cors",
          headersList: makeFilteredHeadersList(response.headersList, (name) => !corsSafeListedResponseHeaderNames.includes(name))
        });
      } else if (type === "opaque") {
        return makeFilteredResponse(response, {
          type: "opaque",
          urlList: Object.freeze([]),
          status: 0,
          statusText: "",
          body: null
        });
      } else if (type === "opaqueredirect") {
        return makeFilteredResponse(response, {
          type: "opaqueredirect",
          status: 0,
          statusText: "",
          headersList: makeFilteredHeadersList(response.headersList, () => false),
          body: null
        });
      } else {
        assert3(false);
      }
    }
    function makeAppropriateNetworkError(fetchParams) {
      assert3(isCancelled(fetchParams));
      return isAborted(fetchParams) ? makeNetworkError(new AbortError()) : makeNetworkError(fetchParams.controller.terminated.reason);
    }
    module2.exports = {
      makeNetworkError,
      makeResponse,
      makeAppropriateNetworkError,
      filterResponse,
      Response: Response2
    };
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/fetch/request.js
var require_request2 = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/fetch/request.js"(exports2, module2) {
    "use strict";
    var { extractBody, mixinBody, cloneBody } = require_body();
    var { Headers, fill: fillHeaders, HeadersList } = require_headers();
    var util = require_util();
    var {
      isValidHTTPToken,
      sameOrigin,
      toUSVString,
      normalizeMethod
    } = require_util2();
    var {
      forbiddenMethods,
      corsSafeListedMethods,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache
    } = require_constants2();
    var { kEnumerableProperty } = util;
    var { kHeaders, kSignal, kState, kGuard, kRealm } = require_symbols2();
    var { kHeadersList } = require_symbols();
    var assert3 = (init_assert(), __toCommonJS(assert_exports));
    var TransformStream;
    var kInit = Symbol("init");
    var requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {
      signal.removeEventListener("abort", abort);
    });
    var Request2 = class {
      constructor(...args) {
        if (args[0] === kInit) {
          return;
        }
        if (args.length < 1) {
          throw new TypeError(`Failed to construct 'Request': 1 argument required, but only ${args.length} present.`);
        }
        if (args.length >= 1 && typeof args[1] !== "object" && args[1] !== void 0) {
          throw new TypeError("Failed to construct 'Request': cannot convert to dictionary.");
        }
        const input = args[0] instanceof Request2 ? args[0] : toUSVString(args[0]);
        const init = args.length >= 1 ? args[1] ?? {} : {};
        this[kRealm] = { settingsObject: {} };
        let request3 = null;
        let fallbackMode = null;
        const baseUrl = this[kRealm].settingsObject.baseUrl;
        let signal = null;
        if (typeof input === "string") {
          let parsedURL;
          try {
            parsedURL = new URL(input, baseUrl);
          } catch (err2) {
            throw new TypeError("Failed to parse URL from " + input, { cause: err2 });
          }
          if (parsedURL.username || parsedURL.password) {
            throw new TypeError("Request cannot be constructed from a URL that includes credentials: " + input);
          }
          request3 = makeRequest({ urlList: [parsedURL] });
          fallbackMode = "cors";
        } else {
          assert3(input instanceof Request2);
          request3 = input[kState];
          signal = input[kSignal];
        }
        const origin = this[kRealm].settingsObject.origin;
        let window2 = "client";
        if (request3.window?.constructor?.name === "EnvironmentSettingsObject" && sameOrigin(request3.window, origin)) {
          window2 = request3.window;
        }
        if (init.window !== void 0 && init.window != null) {
          throw new TypeError(`'window' option '${window2}' must be null`);
        }
        if (init.window !== void 0) {
          window2 = "no-window";
        }
        request3 = makeRequest({
          method: request3.method,
          headersList: request3.headersList,
          unsafeRequest: request3.unsafeRequest,
          client: this[kRealm].settingsObject,
          window: window2,
          priority: request3.priority,
          origin: request3.origin,
          referrer: request3.referrer,
          referrerPolicy: request3.referrerPolicy,
          mode: request3.mode,
          credentials: request3.credentials,
          cache: request3.cache,
          redirect: request3.redirect,
          integrity: request3.integrity,
          keepalive: request3.keepalive,
          reloadNavigation: request3.reloadNavigation,
          historyNavigation: request3.historyNavigation,
          urlList: [...request3.urlList]
        });
        if (Object.keys(init).length > 0) {
          if (request3.mode === "navigate") {
            request3.mode = "same-origin";
          }
          request3.reloadNavigation = false;
          request3.historyNavigation = false;
          request3.origin = "client";
          request3.referrer = "client";
          request3.referrerPolicy = "";
          request3.url = request3.urlList[request3.urlList.length - 1];
          request3.urlList = [request3.url];
        }
        if (init.referrer !== void 0) {
          const referrer = init.referrer;
          if (referrer === "") {
            request3.referrer = "no-referrer";
          } else {
            let parsedReferrer;
            try {
              parsedReferrer = new URL(referrer, baseUrl);
            } catch (err2) {
              throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err2 });
            }
            request3.referrer = parsedReferrer;
          }
        }
        if (init.referrerPolicy !== void 0) {
          request3.referrerPolicy = init.referrerPolicy;
          if (!referrerPolicy.includes(request3.referrerPolicy)) {
            throw new TypeError(`Failed to construct 'Request': The provided value '${request3.referrerPolicy}' is not a valid enum value of type ReferrerPolicy.`);
          }
        }
        let mode;
        if (init.mode !== void 0) {
          mode = init.mode;
          if (!requestMode.includes(mode)) {
            throw new TypeError(`Failed to construct 'Request': The provided value '${request3.mode}' is not a valid enum value of type RequestMode.`);
          }
        } else {
          mode = fallbackMode;
        }
        if (mode === "navigate") {
          throw new TypeError();
        }
        if (mode != null) {
          request3.mode = mode;
        }
        if (init.credentials !== void 0) {
          request3.credentials = init.credentials;
          if (!requestCredentials.includes(request3.credentials)) {
            throw new TypeError(`Failed to construct 'Request': The provided value '${request3.credentials}' is not a valid enum value of type RequestCredentials.`);
          }
        }
        if (init.cache !== void 0) {
          request3.cache = init.cache;
          if (!requestCache.includes(request3.cache)) {
            throw new TypeError(`Failed to construct 'Request': The provided value '${request3.cache}' is not a valid enum value of type RequestCache.`);
          }
        }
        if (request3.cache === "only-if-cached" && request3.mode !== "same-origin") {
          throw new TypeError("'only-if-cached' can be set only with 'same-origin' mode");
        }
        if (init.redirect !== void 0) {
          request3.redirect = init.redirect;
          if (!requestRedirect.includes(request3.redirect)) {
            throw new TypeError(`Failed to construct 'Request': The provided value '${request3.redirect}' is not a valid enum value of type RequestRedirect.`);
          }
        }
        if (init.integrity !== void 0 && init.integrity != null) {
          request3.integrity = String(init.integrity);
        }
        if (init.keepalive !== void 0) {
          request3.keepalive = Boolean(init.keepalive);
        }
        if (init.method !== void 0) {
          let method = init.method;
          if (!isValidHTTPToken(init.method)) {
            throw TypeError(`'${init.method}' is not a valid HTTP method.`);
          }
          if (forbiddenMethods.indexOf(method.toUpperCase()) !== -1) {
            throw TypeError(`'${init.method}' HTTP method is unsupported.`);
          }
          method = normalizeMethod(init.method);
          request3.method = method;
        }
        if (init.signal !== void 0) {
          signal = init.signal;
        }
        this[kState] = request3;
        const ac2 = new AbortController();
        this[kSignal] = ac2.signal;
        this[kSignal][kRealm] = this[kRealm];
        if (signal != null) {
          if (!signal || typeof signal.aborted !== "boolean" || typeof signal.addEventListener !== "function") {
            throw new TypeError("Failed to construct 'Request': member signal is not of type AbortSignal.");
          }
          if (signal.aborted) {
            ac2.abort();
          } else {
            const abort = () => ac2.abort();
            signal.addEventListener("abort", abort, { once: true });
            requestFinalizer.register(this, { signal, abort });
          }
        }
        this[kHeaders] = new Headers();
        this[kHeaders][kGuard] = "request";
        this[kHeaders][kHeadersList] = request3.headersList;
        this[kHeaders][kRealm] = this[kRealm];
        if (mode === "no-cors") {
          if (!corsSafeListedMethods.includes(request3.method)) {
            throw new TypeError(`'${request3.method} is unsupported in no-cors mode.`);
          }
          this[kHeaders][kGuard] = "request-no-cors";
        }
        if (Object.keys(init).length !== 0) {
          let headers = new Headers(this.headers);
          if (init.headers !== void 0) {
            headers = init.headers;
          }
          this[kState].headersList = new HeadersList();
          this[kHeaders][kHeadersList] = this[kState].headersList;
          if (headers instanceof Headers) {
            this[kState].headersList.push(...headers[kHeadersList]);
          } else {
            fillHeaders(this[kState].headersList, headers);
          }
        }
        const inputBody = input instanceof Request2 ? input[kState].body : null;
        if ((init.body !== void 0 && init.body != null || inputBody != null) && (request3.method === "GET" || request3.method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body.");
        }
        let initBody = null;
        if (init.body !== void 0 && init.body != null) {
          const [extractedBody, contentType] = extractBody(init.body, request3.keepalive);
          initBody = extractedBody;
          if (contentType && !this[kHeaders].has("content-type")) {
            this[kHeaders].append("content-type", contentType);
          }
        }
        const inputOrInitBody = initBody ?? inputBody;
        if (inputOrInitBody != null && inputOrInitBody.source == null) {
          if (request3.mode !== "same-origin" && request3.mode !== "cors") {
            throw new TypeError('If request is made from ReadableStream, mode should be "same-origin" or "cors"');
          }
          request3.useCORSPreflightFlag = true;
        }
        let finalBody = inputOrInitBody;
        if (initBody == null && inputBody != null) {
          if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {
            throw new TypeError("Cannot construct a Request with a Request object that has already been used.");
          }
          if (!TransformStream) {
            TransformStream = __require("stream/web").TransformStream;
          }
          const identityTransform = new TransformStream();
          inputBody.stream.pipeThrough(identityTransform);
          finalBody = {
            source: inputBody.source,
            length: inputBody.length,
            stream: identityTransform.readable
          };
        }
        this[kState].body = finalBody;
      }
      get [Symbol.toStringTag]() {
        if (!(this instanceof Request2)) {
          throw new TypeError("Illegal invocation");
        }
        return this.constructor.name;
      }
      get method() {
        if (!(this instanceof Request2)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].method;
      }
      get url() {
        if (!(this instanceof Request2)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].url.toString();
      }
      get headers() {
        if (!(this instanceof Request2)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kHeaders];
      }
      get destination() {
        if (!(this instanceof Request2)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].destination;
      }
      get referrer() {
        if (!(this instanceof Request2)) {
          throw new TypeError("Illegal invocation");
        }
        if (this[kState].referrer === "no-referrer") {
          return "";
        }
        if (this[kState].referrer === "client") {
          return "about:client";
        }
        return this[kState].referrer.toString();
      }
      get referrerPolicy() {
        if (!(this instanceof Request2)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].referrerPolicy;
      }
      get mode() {
        if (!(this instanceof Request2)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].mode;
      }
      get credentials() {
        return this[kState].credentials;
      }
      get cache() {
        if (!(this instanceof Request2)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].cache;
      }
      get redirect() {
        if (!(this instanceof Request2)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].redirect;
      }
      get integrity() {
        if (!(this instanceof Request2)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].integrity;
      }
      get keepalive() {
        if (!(this instanceof Request2)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].keepalive;
      }
      get isReloadNavigation() {
        if (!(this instanceof Request2)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].reloadNavigation;
      }
      get isHistoryNavigation() {
        if (!(this instanceof Request2)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].historyNavigation;
      }
      get signal() {
        if (!(this instanceof Request2)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kSignal];
      }
      clone() {
        if (!(this instanceof Request2)) {
          throw new TypeError("Illegal invocation");
        }
        if (this.bodyUsed || this.body?.locked) {
          throw new TypeError("unusable");
        }
        const clonedRequest = cloneRequest(this[kState]);
        const clonedRequestObject = new Request2(kInit);
        clonedRequestObject[kState] = clonedRequest;
        clonedRequestObject[kRealm] = this[kRealm];
        clonedRequestObject[kHeaders] = new Headers();
        clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;
        clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];
        clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];
        const ac2 = new AbortController();
        if (this.signal.aborted) {
          ac2.abort();
        } else {
          this.signal.addEventListener("abort", function() {
            ac2.abort();
          }, { once: true });
        }
        clonedRequestObject[kSignal] = ac2.signal;
        return clonedRequestObject;
      }
    };
    mixinBody(Request2.prototype);
    function makeRequest(init) {
      const request3 = {
        method: "GET",
        localURLsOnly: false,
        unsafeRequest: false,
        body: null,
        client: null,
        reservedClient: null,
        replacesClientId: "",
        window: "client",
        keepalive: false,
        serviceWorkers: "all",
        initiator: "",
        destination: "",
        priority: null,
        origin: "client",
        policyContainer: "client",
        referrer: "client",
        referrerPolicy: "",
        mode: "no-cors",
        useCORSPreflightFlag: false,
        credentials: "same-origin",
        useCredentials: false,
        cache: "default",
        redirect: "follow",
        integrity: "",
        cryptoGraphicsNonceMetadata: "",
        parserMetadata: "",
        reloadNavigation: false,
        historyNavigation: false,
        userActivation: false,
        taintedOrigin: false,
        redirectCount: 0,
        responseTainting: "basic",
        preventNoCacheCacheControlHeaderModification: false,
        done: false,
        timingAllowFailed: false,
        ...init,
        headersList: init.headersList ? new HeadersList(...init.headersList) : new HeadersList(),
        urlList: init.urlList ? [...init.urlList.map((url2) => new URL(url2))] : []
      };
      request3.url = request3.urlList[0];
      return request3;
    }
    function cloneRequest(request3) {
      const newRequest = makeRequest({ ...request3, body: null });
      if (request3.body != null) {
        newRequest.body = cloneBody(request3.body);
      }
      return newRequest;
    }
    Object.defineProperties(Request2.prototype, {
      method: kEnumerableProperty,
      url: kEnumerableProperty,
      headers: kEnumerableProperty,
      redirect: kEnumerableProperty,
      clone: kEnumerableProperty,
      signal: kEnumerableProperty
    });
    module2.exports = { Request: Request2, makeRequest };
  }
});

// node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/zlib-lib/messages.js
var messages_default;
var init_messages = __esm({
  "node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/zlib-lib/messages.js"() {
    messages_default = {
      2: "need dictionary",
      1: "stream end",
      0: "",
      "-1": "file error",
      "-2": "stream error",
      "-3": "data error",
      "-4": "insufficient memory",
      "-5": "buffer error",
      "-6": "incompatible version"
    };
  }
});

// node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/zlib-lib/zstream.js
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream_default;
var init_zstream = __esm({
  "node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/zlib-lib/zstream.js"() {
    zstream_default = ZStream;
  }
});

// node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/zlib-lib/utils.js
function arraySet(dest, src, src_offs, len, dest_offs) {
  if (src.subarray && dest.subarray) {
    dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
    return;
  }
  for (var i = 0; i < len; i++) {
    dest[dest_offs + i] = src[src_offs + i];
  }
}
var Buf8, Buf16, Buf32;
var init_utils = __esm({
  "node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/zlib-lib/utils.js"() {
    "use strict";
    Buf8 = Uint8Array;
    Buf16 = Uint16Array;
    Buf32 = Int32Array;
  }
});

// node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/zlib-lib/trees.js
function zero(buf) {
  var len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}
function put_short(s, w) {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
}
function send_bits(s, value, length) {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
}
function send_code(s, c, tree) {
  send_bits(s, tree[c * 2], tree[c * 2 + 1]);
}
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}
function gen_bitlen(s, desc) {
  var tree = desc.dyn_tree;
  var max_code = desc.max_code;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var extra = desc.stat_desc.extra_bits;
  var base2 = desc.stat_desc.extra_base;
  var max_length = desc.stat_desc.max_length;
  var h;
  var n, m;
  var bits;
  var xbits;
  var f;
  var overflow = 0;
  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base2) {
      xbits = extra[n - base2];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
}
function gen_codes(tree, max_code, bl_count) {
  var next_code = new Array(MAX_BITS + 1);
  var code = 0;
  var bits;
  var n;
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = code + bl_count[bits - 1] << 1;
  }
  for (n = 0; n <= max_code; n++) {
    var len = tree[n * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n * 2] = bi_reverse(next_code[len]++, len);
  }
}
function tr_static_init() {
  var n;
  var bits;
  var length;
  var code;
  var dist;
  var bl_count = new Array(MAX_BITS + 1);
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  }
  _length_code[length - 1] = code;
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  }
  dist >>= 7;
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES + 1, bl_count);
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1] = 5;
    static_dtree[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
}
function init_block(s) {
  var n;
  for (n = 0; n < L_CODES; n++) {
    s.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES; n++) {
    s.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES; n++) {
    s.bl_tree[n * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}
function bi_windup(s) {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}
function copy_block(s, buf, len, header) {
  bi_windup(s);
  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
  arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
}
function pqdownheap(s, tree, k2) {
  var v = s.heap[k2];
  var j2 = k2 << 1;
  while (j2 <= s.heap_len) {
    if (j2 < s.heap_len && smaller(tree, s.heap[j2 + 1], s.heap[j2], s.depth)) {
      j2++;
    }
    if (smaller(tree, v, s.heap[j2], s.depth)) {
      break;
    }
    s.heap[k2] = s.heap[j2];
    k2 = j2;
    j2 <<= 1;
  }
  s.heap[k2] = v;
}
function compress_block(s, ltree, dtree) {
  var dist;
  var lc2;
  var lx = 0;
  var code;
  var extra;
  if (s.last_lit !== 0) {
    do {
      dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
      lc2 = s.pending_buf[s.l_buf + lx];
      lx++;
      if (dist === 0) {
        send_code(s, lc2, ltree);
      } else {
        code = _length_code[lc2];
        send_code(s, code + LITERALS + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc2 -= base_length[code];
          send_bits(s, lc2, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);
        }
      }
    } while (lx < s.last_lit);
  }
  send_code(s, END_BLOCK, ltree);
}
function build_tree(s, desc) {
  var tree = desc.dyn_tree;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems = desc.stat_desc.elems;
  var n, m;
  var max_code = -1;
  var node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;
  for (n = 0; n < elems; n++) {
    if (tree[n * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }
  node = elems;
  do {
    n = s.heap[1];
    s.heap[1] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1);
    m = s.heap[1];
    s.heap[--s.heap_max] = n;
    s.heap[--s.heap_max] = m;
    tree[node * 2] = tree[n * 2] + tree[m * 2];
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1] = tree[m * 2 + 1] = node;
    s.heap[1] = node++;
    pqdownheap(s, tree, 1);
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[1];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
}
function scan_tree(s, tree, max_code) {
  var n;
  var prevlen = -1;
  var curlen;
  var nextlen = tree[0 * 2 + 1];
  var count = 0;
  var max_count = 7;
  var min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
function send_tree(s, tree, max_code) {
  var n;
  var prevlen = -1;
  var curlen;
  var nextlen = tree[0 * 2 + 1];
  var count = 0;
  var max_count = 7;
  var min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
function build_bl_tree(s) {
  var max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
}
function send_all_trees(s, lcodes, dcodes, blcodes) {
  var rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
}
function detect_data_type(s) {
  var black_mask = 4093624447;
  var n;
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
}
function _tr_init(s) {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
}
function _tr_stored_block(s, buf, stored_len, last) {
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  copy_block(s, buf, stored_len, true);
}
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}
function _tr_flush_block(s, buf, stored_len, last) {
  var opt_lenb, static_lenb;
  var max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last) {
    bi_windup(s);
  }
}
function _tr_tally(s, dist, lc2) {
  s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
  s.pending_buf[s.l_buf + s.last_lit] = lc2 & 255;
  s.last_lit++;
  if (dist === 0) {
    s.dyn_ltree[lc2 * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code[lc2] + LITERALS + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.last_lit === s.lit_bufsize - 1;
}
var Z_FIXED, Z_BINARY, Z_TEXT, Z_UNKNOWN, STORED_BLOCK, STATIC_TREES, DYN_TREES, MIN_MATCH, MAX_MATCH, LENGTH_CODES, LITERALS, L_CODES, D_CODES, BL_CODES, HEAP_SIZE, MAX_BITS, Buf_size, MAX_BL_BITS, END_BLOCK, REP_3_6, REPZ_3_10, REPZ_11_138, extra_lbits, extra_dbits, extra_blbits, bl_order, DIST_CODE_LEN, static_ltree, static_dtree, _dist_code, _length_code, base_length, base_dist, static_l_desc, static_d_desc, static_bl_desc, static_init_done;
var init_trees = __esm({
  "node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/zlib-lib/trees.js"() {
    "use strict";
    init_utils();
    Z_FIXED = 4;
    Z_BINARY = 0;
    Z_TEXT = 1;
    Z_UNKNOWN = 2;
    STORED_BLOCK = 0;
    STATIC_TREES = 1;
    DYN_TREES = 2;
    MIN_MATCH = 3;
    MAX_MATCH = 258;
    LENGTH_CODES = 29;
    LITERALS = 256;
    L_CODES = LITERALS + 1 + LENGTH_CODES;
    D_CODES = 30;
    BL_CODES = 19;
    HEAP_SIZE = 2 * L_CODES + 1;
    MAX_BITS = 15;
    Buf_size = 16;
    MAX_BL_BITS = 7;
    END_BLOCK = 256;
    REP_3_6 = 16;
    REPZ_3_10 = 17;
    REPZ_11_138 = 18;
    extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
    extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
    bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    DIST_CODE_LEN = 512;
    static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    base_length = new Array(LENGTH_CODES);
    zero(base_length);
    base_dist = new Array(D_CODES);
    zero(base_dist);
    static_init_done = false;
  }
});

// node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/zlib-lib/adler32.js
function adler32(adler, buf, len, pos) {
  var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len !== 0) {
    n = len > 2e3 ? 2e3 : len;
    len -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
}
var adler32_default;
var init_adler32 = __esm({
  "node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/zlib-lib/adler32.js"() {
    adler32_default = adler32;
  }
});

// node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/zlib-lib/crc32.js
function makeTable() {
  var c, table = [];
  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k2 = 0; k2 < 8; k2++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }
  return table;
}
function crc32(crc, buf, len, pos) {
  var t = crcTable, end = pos + len;
  crc ^= -1;
  for (var i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
}
var crcTable, crc32_default;
var init_crc32 = __esm({
  "node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/zlib-lib/crc32.js"() {
    crcTable = makeTable();
    crc32_default = crc32;
  }
});

// node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/zlib-lib/deflate.js
function err(strm, errorCode) {
  strm.msg = messages_default[errorCode];
  return errorCode;
}
function rank(f) {
  return (f << 1) - (f > 4 ? 9 : 0);
}
function zero2(buf) {
  var len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
function flush_pending(strm) {
  var s = strm.state;
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}
function flush_block_only(s, last) {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}
function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}
function putShortMSB(s, b) {
  s.pending_buf[s.pending++] = b >>> 8 & 255;
  s.pending_buf[s.pending++] = b & 255;
}
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_default(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_default(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
}
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;
  var scan = s.strstart;
  var match;
  var len;
  var best_len = s.prev_length;
  var nice_match = s.nice_match;
  var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  var _win = s.window;
  var wmask = s.w_mask;
  var prev = s.prev;
  var strend = s.strstart + MAX_MATCH2;
  var scan_end1 = _win[scan + best_len - 1];
  var scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH2 - (strend - scan);
    scan = strend - MAX_MATCH2;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n);
      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    if (s.lookahead + s.insert >= MIN_MATCH2) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
      while (s.insert) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH2 - 1]) & s.hash_mask;
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH2) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
}
function deflate_stored(s, flush) {
  var max_block_size = 65535;
  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }
  for (; ; ) {
    if (s.lookahead <= 1) {
      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.strstart += s.lookahead;
    s.lookahead = 0;
    var max_start = s.block_start + max_block_size;
    if (s.strstart === 0 || s.strstart >= max_start) {
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.strstart > s.block_start) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_NEED_MORE;
}
function deflate_fast(s, flush) {
  var hash_head;
  var bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH2) {
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH2 - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH2) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH2);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH2) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH2 - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH2 - 1 ? s.strstart : MIN_MATCH2 - 1;
  if (flush === Z_FINISH) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_slow(s, flush) {
  var hash_head;
  var bflush;
  var max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH2) {
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH2 - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH2 - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH2 && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH2 - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH2 && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH2;
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH2);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH2 - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH2 - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH2 - 1 ? s.strstart : MIN_MATCH2 - 1;
  if (flush === Z_FINISH) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_rle(s, flush) {
  var bflush;
  var prev;
  var scan, strend;
  var _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH2) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH2 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH2 && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH2;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH2 - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH2) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH2);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_huff(s, flush) {
  var bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
function lm_init(s) {
  s.window_size = 2 * s.w_size;
  zero2(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH2 - 1;
  s.match_available = 0;
  s.ins_h = 0;
}
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Buf16(HEAP_SIZE2 * 2);
  this.dyn_dtree = new Buf16((2 * D_CODES2 + 1) * 2);
  this.bl_tree = new Buf16((2 * BL_CODES2 + 1) * 2);
  zero2(this.dyn_ltree);
  zero2(this.dyn_dtree);
  zero2(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Buf16(MAX_BITS2 + 1);
  this.heap = new Buf16(2 * L_CODES2 + 1);
  zero2(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Buf16(2 * L_CODES2 + 1);
  zero2(this.depth);
  this.l_buf = 0;
  this.lit_bufsize = 0;
  this.last_lit = 0;
  this.d_buf = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
function deflateResetKeep(strm) {
  var s;
  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN2;
  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = s.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = Z_NO_FLUSH;
  _tr_init(s);
  return Z_OK;
}
function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}
function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) {
    return Z_STREAM_ERROR;
  }
  var wrap2 = 1;
  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap2 = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap2 = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED2) {
    return err(strm, Z_STREAM_ERROR);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  var s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.wrap = wrap2;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH2 - 1) / MIN_MATCH2);
  s.window = new Buf8(s.w_size * 2);
  s.head = new Buf16(s.hash_size);
  s.prev = new Buf16(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Buf8(s.pending_buf_size);
  s.d_buf = 1 * s.lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
}
function deflate(strm, flush) {
  var old_flush, s;
  var beg, val;
  if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }
  s = strm.state;
  if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }
  s.strm = strm;
  old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.status === INIT_STATE) {
    if (s.wrap === 2) {
      strm.adler = 0;
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) {
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      } else {
        put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
        put_byte(s, s.gzhead.time & 255);
        put_byte(s, s.gzhead.time >> 8 & 255);
        put_byte(s, s.gzhead.time >> 16 & 255);
        put_byte(s, s.gzhead.time >> 24 & 255);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, s.gzhead.os & 255);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 255);
          put_byte(s, s.gzhead.extra.length >> 8 & 255);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32_default(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    } else {
      var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
      var level_flags = -1;
      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= level_flags << 6;
      if (s.strstart !== 0) {
        header |= PRESET_DICT;
      }
      header += 31 - header % 31;
      s.status = BUSY_STATE;
      putShortMSB(s, header);
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      strm.adler = 1;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      beg = s.pending;
      while (s.gzindex < (s.gzhead.extra.length & 65535)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_default(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 255);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_default(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    } else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      beg = s.pending;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_default(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_default(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    } else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      beg = s.pending;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_default(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_default(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    } else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        strm.adler = 0;
        s.status = BUSY_STATE;
      }
    } else {
      s.status = BUSY_STATE;
    }
  }
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
    var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush !== Z_BLOCK) {
        _tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH) {
          zero2(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK;
      }
    }
  }
  if (flush !== Z_FINISH) {
    return Z_OK;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}
function deflateEnd(strm) {
  var status2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  status2 = strm.state.status;
  if (status2 !== INIT_STATE && status2 !== EXTRA_STATE && status2 !== NAME_STATE && status2 !== COMMENT_STATE && status2 !== HCRC_STATE && status2 !== BUSY_STATE && status2 !== FINISH_STATE) {
    return err(strm, Z_STREAM_ERROR);
  }
  strm.state = null;
  return status2 === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}
var Z_NO_FLUSH, Z_PARTIAL_FLUSH, Z_FULL_FLUSH, Z_FINISH, Z_BLOCK, Z_OK, Z_STREAM_END, Z_STREAM_ERROR, Z_DATA_ERROR, Z_BUF_ERROR, Z_DEFAULT_COMPRESSION, Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED2, Z_UNKNOWN2, Z_DEFLATED, MAX_MEM_LEVEL, LENGTH_CODES2, LITERALS2, L_CODES2, D_CODES2, BL_CODES2, HEAP_SIZE2, MAX_BITS2, MIN_MATCH2, MAX_MATCH2, MIN_LOOKAHEAD, PRESET_DICT, INIT_STATE, EXTRA_STATE, NAME_STATE, COMMENT_STATE, HCRC_STATE, BUSY_STATE, FINISH_STATE, BS_NEED_MORE, BS_BLOCK_DONE, BS_FINISH_STARTED, BS_FINISH_DONE, OS_CODE, configuration_table;
var init_deflate = __esm({
  "node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/zlib-lib/deflate.js"() {
    init_utils();
    init_trees();
    init_adler32();
    init_crc32();
    init_messages();
    Z_NO_FLUSH = 0;
    Z_PARTIAL_FLUSH = 1;
    Z_FULL_FLUSH = 3;
    Z_FINISH = 4;
    Z_BLOCK = 5;
    Z_OK = 0;
    Z_STREAM_END = 1;
    Z_STREAM_ERROR = -2;
    Z_DATA_ERROR = -3;
    Z_BUF_ERROR = -5;
    Z_DEFAULT_COMPRESSION = -1;
    Z_FILTERED = 1;
    Z_HUFFMAN_ONLY = 2;
    Z_RLE = 3;
    Z_FIXED2 = 4;
    Z_UNKNOWN2 = 2;
    Z_DEFLATED = 8;
    MAX_MEM_LEVEL = 9;
    LENGTH_CODES2 = 29;
    LITERALS2 = 256;
    L_CODES2 = LITERALS2 + 1 + LENGTH_CODES2;
    D_CODES2 = 30;
    BL_CODES2 = 19;
    HEAP_SIZE2 = 2 * L_CODES2 + 1;
    MAX_BITS2 = 15;
    MIN_MATCH2 = 3;
    MAX_MATCH2 = 258;
    MIN_LOOKAHEAD = MAX_MATCH2 + MIN_MATCH2 + 1;
    PRESET_DICT = 32;
    INIT_STATE = 42;
    EXTRA_STATE = 69;
    NAME_STATE = 73;
    COMMENT_STATE = 91;
    HCRC_STATE = 103;
    BUSY_STATE = 113;
    FINISH_STATE = 666;
    BS_NEED_MORE = 1;
    BS_BLOCK_DONE = 2;
    BS_FINISH_STARTED = 3;
    BS_FINISH_DONE = 4;
    OS_CODE = 3;
    configuration_table = [
      new Config(0, 0, 0, 0, deflate_stored),
      new Config(4, 4, 8, 4, deflate_fast),
      new Config(4, 5, 16, 8, deflate_fast),
      new Config(4, 6, 32, 32, deflate_fast),
      new Config(4, 4, 16, 16, deflate_slow),
      new Config(8, 16, 32, 32, deflate_slow),
      new Config(8, 16, 128, 128, deflate_slow),
      new Config(8, 32, 128, 256, deflate_slow),
      new Config(32, 128, 258, 1024, deflate_slow),
      new Config(32, 258, 258, 4096, deflate_slow)
    ];
  }
});

// node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/zlib-lib/inffast.js
function inflate_fast(strm, start) {
  var state;
  var _in;
  var last;
  var _out;
  var beg;
  var end;
  var dmax;
  var wsize;
  var whave;
  var wnext;
  var s_window;
  var hold;
  var bits;
  var lcode;
  var dcode;
  var lmask;
  var dmask;
  var here;
  var op;
  var len;
  var dist;
  var from;
  var from_source;
  var input, output;
  state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
}
var BAD, TYPE;
var init_inffast = __esm({
  "node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/zlib-lib/inffast.js"() {
    BAD = 30;
    TYPE = 12;
  }
});

// node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/zlib-lib/inftrees.js
function inflate_table(type, lens, lens_index, codes2, table, table_index, work, opts) {
  var bits = opts.bits;
  var len = 0;
  var sym = 0;
  var min = 0, max = 0;
  var root = 0;
  var curr = 0;
  var drop = 0;
  var left = 0;
  var used = 0;
  var huff = 0;
  var incr;
  var fill;
  var low;
  var mask;
  var next;
  var base2 = null;
  var base_index = 0;
  var end;
  var count = new Buf16(MAXBITS + 1);
  var offs = new Buf16(MAXBITS + 1);
  var extra = null;
  var extra_index = 0;
  var here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes2; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes2; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES) {
    base2 = extra = work;
    end = 19;
  } else if (type === LENS) {
    base2 = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;
  } else {
    base2 = dbase;
    extra = dext;
    end = -1;
  }
  huff = 0;
  sym = 0;
  len = min;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
    return 1;
  }
  var i = 0;
  for (; ; ) {
    i++;
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base2[base_index + work[sym]];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      low = huff & mask;
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
}
var MAXBITS, ENOUGH_LENS, ENOUGH_DISTS, CODES, LENS, DISTS, lbase, lext, dbase, dext;
var init_inftrees = __esm({
  "node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/zlib-lib/inftrees.js"() {
    init_utils();
    MAXBITS = 15;
    ENOUGH_LENS = 852;
    ENOUGH_DISTS = 592;
    CODES = 0;
    LENS = 1;
    DISTS = 2;
    lbase = [
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    lext = [
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ];
    dbase = [
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ];
    dext = [
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ];
  }
});

// node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/zlib-lib/inflate.js
function zswap32(q) {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
}
function InflateState() {
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Buf16(320);
  this.work = new Buf16(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
function inflateResetKeep(strm) {
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR2;
  }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Buf32(ENOUGH_LENS2);
  state.distcode = state.distdyn = new Buf32(ENOUGH_DISTS2);
  state.sane = 1;
  state.back = -1;
  return Z_OK2;
}
function inflateReset(strm) {
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR2;
  }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
}
function inflateReset2(strm, windowBits) {
  var wrap2;
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR2;
  }
  state = strm.state;
  if (windowBits < 0) {
    wrap2 = 0;
    windowBits = -windowBits;
  } else {
    wrap2 = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR2;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap2;
  state.wbits = windowBits;
  return inflateReset(strm);
}
function inflateInit2(strm, windowBits) {
  var ret;
  var state;
  if (!strm) {
    return Z_STREAM_ERROR2;
  }
  state = new InflateState();
  strm.state = state;
  state.window = null;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK2) {
    strm.state = null;
  }
  return ret;
}
function fixedtables(state) {
  if (virgin) {
    var sym;
    lenfix = new Buf32(512);
    distfix = new Buf32(32);
    sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inflate_table(LENS2, state.lens, 0, 288, lenfix, 0, state.work, {
      bits: 9
    });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inflate_table(DISTS2, state.lens, 0, 32, distfix, 0, state.work, {
      bits: 5
    });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Buf8(state.wsize);
  }
  if (copy >= state.wsize) {
    arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
}
function inflate(strm, flush) {
  var state;
  var input, output;
  var next;
  var put;
  var have, left;
  var hold;
  var bits;
  var _in, _out;
  var copy;
  var from;
  var from_source;
  var here = 0;
  var here_bits, here_op, here_val;
  var last_bits, last_op, last_val;
  var len;
  var ret;
  var hbuf = new Buf8(4);
  var opts;
  var n;
  var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR2;
  }
  state = strm.state;
  if (state.mode === TYPE2) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK2;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_default(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          state.flags = 0;
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD2;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED2) {
            strm.msg = "unknown compression method";
            state.mode = BAD2;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          } else if (len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD2;
            break;
          }
          state.dmax = 1 << len;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE2;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED2) {
            strm.msg = "unknown compression method";
            state.mode = BAD2;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD2;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_default(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_default(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_default(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_default(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        case EXTRA:
          if (state.flags & 1024) {
            copy = state.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Array(state.head.extra_len);
                }
                arraySet(state.head.extra, input, next, copy, len);
              }
              if (state.flags & 512) {
                state.check = crc32_default(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512) {
              state.check = crc32_default(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512) {
              state.check = crc32_default(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD2;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE2;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE2;
        case TYPE2:
          if (flush === Z_BLOCK2 || flush === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD2;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD2;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state.mode = COPY;
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            arraySet(output, input, next, copy, put);
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE2;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD2;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = {
            bits: state.lenbits
          };
          ret = inflate_table(CODES2, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD2;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD2;
                  break;
                }
                len = state.lens[state.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD2;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD2) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD2;
            break;
          }
          state.lenbits = 9;
          opts = {
            bits: state.lenbits
          };
          ret = inflate_table(LENS2, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD2;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = {
            bits: state.distbits
          };
          ret = inflate_table(DISTS2, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD2;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inflate_fast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE2) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE2;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD2;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        case LENEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD2;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        case DISTEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD2;
            break;
          }
          state.mode = MATCH;
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset > copy) {
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD2;
                break;
              }
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            } else {
              from = state.wnext - copy;
            }
            if (copy > state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from = put - state.offset;
            copy = state.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (_out) {
              strm.adler = state.check = state.flags ? crc32_default(state.check, output, _out, put - _out) : adler32_default(state.check, output, _out, put - _out);
            }
            _out = left;
            if ((state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD2;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD2;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        case DONE:
          ret = Z_STREAM_END2;
          break inf_leave;
        case BAD2:
          ret = Z_DATA_ERROR2;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR;
        case SYNC:
        default:
          return Z_STREAM_ERROR2;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD2 && (state.mode < CHECK || flush !== Z_FINISH2)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = state.flags ? crc32_default(state.check, output, _out, strm.next_out - _out) : adler32_default(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE2 ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH2) && ret === Z_OK2) {
    ret = Z_BUF_ERROR2;
  }
  return ret;
}
function inflateEnd(strm) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR2;
  }
  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK2;
}
var CODES2, LENS2, DISTS2, Z_FINISH2, Z_BLOCK2, Z_TREES, Z_OK2, Z_STREAM_END2, Z_NEED_DICT, Z_STREAM_ERROR2, Z_DATA_ERROR2, Z_MEM_ERROR, Z_BUF_ERROR2, Z_DEFLATED2, HEAD, FLAGS, TIME, OS, EXLEN, EXTRA, NAME, COMMENT, HCRC, DICTID, DICT, TYPE2, TYPEDO, STORED, COPY_, COPY, TABLE, LENLENS, CODELENS, LEN_, LEN, LENEXT, DIST, DISTEXT, MATCH, LIT, CHECK, LENGTH, DONE, BAD2, MEM, SYNC, ENOUGH_LENS2, ENOUGH_DISTS2, virgin, lenfix, distfix;
var init_inflate = __esm({
  "node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/zlib-lib/inflate.js"() {
    "use strict";
    init_utils();
    init_adler32();
    init_crc32();
    init_inffast();
    init_inftrees();
    CODES2 = 0;
    LENS2 = 1;
    DISTS2 = 2;
    Z_FINISH2 = 4;
    Z_BLOCK2 = 5;
    Z_TREES = 6;
    Z_OK2 = 0;
    Z_STREAM_END2 = 1;
    Z_NEED_DICT = 2;
    Z_STREAM_ERROR2 = -2;
    Z_DATA_ERROR2 = -3;
    Z_MEM_ERROR = -4;
    Z_BUF_ERROR2 = -5;
    Z_DEFLATED2 = 8;
    HEAD = 1;
    FLAGS = 2;
    TIME = 3;
    OS = 4;
    EXLEN = 5;
    EXTRA = 6;
    NAME = 7;
    COMMENT = 8;
    HCRC = 9;
    DICTID = 10;
    DICT = 11;
    TYPE2 = 12;
    TYPEDO = 13;
    STORED = 14;
    COPY_ = 15;
    COPY = 16;
    TABLE = 17;
    LENLENS = 18;
    CODELENS = 19;
    LEN_ = 20;
    LEN = 21;
    LENEXT = 22;
    DIST = 23;
    DISTEXT = 24;
    MATCH = 25;
    LIT = 26;
    CHECK = 27;
    LENGTH = 28;
    DONE = 29;
    BAD2 = 30;
    MEM = 31;
    SYNC = 32;
    ENOUGH_LENS2 = 852;
    ENOUGH_DISTS2 = 592;
    virgin = true;
  }
});

// node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/zlib-lib/binding.js
var binding_exports = {};
__export(binding_exports, {
  DEFLATE: () => DEFLATE,
  DEFLATERAW: () => DEFLATERAW,
  GUNZIP: () => GUNZIP,
  GZIP: () => GZIP,
  INFLATE: () => INFLATE,
  INFLATERAW: () => INFLATERAW,
  NONE: () => NONE,
  UNZIP: () => UNZIP,
  Z_BEST_COMPRESSION: () => Z_BEST_COMPRESSION,
  Z_BEST_SPEED: () => Z_BEST_SPEED,
  Z_BINARY: () => Z_BINARY2,
  Z_BLOCK: () => Z_BLOCK3,
  Z_BUF_ERROR: () => Z_BUF_ERROR3,
  Z_DATA_ERROR: () => Z_DATA_ERROR3,
  Z_DEFAULT_COMPRESSION: () => Z_DEFAULT_COMPRESSION2,
  Z_DEFAULT_STRATEGY: () => Z_DEFAULT_STRATEGY,
  Z_DEFLATED: () => Z_DEFLATED3,
  Z_ERRNO: () => Z_ERRNO,
  Z_FILTERED: () => Z_FILTERED2,
  Z_FINISH: () => Z_FINISH3,
  Z_FIXED: () => Z_FIXED3,
  Z_FULL_FLUSH: () => Z_FULL_FLUSH2,
  Z_HUFFMAN_ONLY: () => Z_HUFFMAN_ONLY2,
  Z_NEED_DICT: () => Z_NEED_DICT2,
  Z_NO_COMPRESSION: () => Z_NO_COMPRESSION,
  Z_NO_FLUSH: () => Z_NO_FLUSH2,
  Z_OK: () => Z_OK3,
  Z_PARTIAL_FLUSH: () => Z_PARTIAL_FLUSH2,
  Z_RLE: () => Z_RLE2,
  Z_STREAM_END: () => Z_STREAM_END3,
  Z_STREAM_ERROR: () => Z_STREAM_ERROR3,
  Z_SYNC_FLUSH: () => Z_SYNC_FLUSH,
  Z_TEXT: () => Z_TEXT2,
  Z_TREES: () => Z_TREES2,
  Z_UNKNOWN: () => Z_UNKNOWN3,
  Zlib: () => Zlib
});
function Zlib(mode) {
  if (mode < DEFLATE || mode > UNZIP)
    throw new TypeError("Bad argument");
  this.mode = mode;
  this.init_done = false;
  this.write_in_progress = false;
  this.pending_close = false;
  this.windowBits = 0;
  this.level = 0;
  this.memLevel = 0;
  this.strategy = 0;
  this.dictionary = null;
}
function bufferSet(data, offset) {
  for (var i = 0; i < data.length; i++) {
    this[offset + i] = data[i];
  }
}
var NONE, DEFLATE, INFLATE, GZIP, GUNZIP, DEFLATERAW, INFLATERAW, UNZIP, Z_NO_FLUSH2, Z_PARTIAL_FLUSH2, Z_SYNC_FLUSH, Z_FULL_FLUSH2, Z_FINISH3, Z_BLOCK3, Z_TREES2, Z_OK3, Z_STREAM_END3, Z_NEED_DICT2, Z_ERRNO, Z_STREAM_ERROR3, Z_DATA_ERROR3, Z_BUF_ERROR3, Z_NO_COMPRESSION, Z_BEST_SPEED, Z_BEST_COMPRESSION, Z_DEFAULT_COMPRESSION2, Z_FILTERED2, Z_HUFFMAN_ONLY2, Z_RLE2, Z_FIXED3, Z_DEFAULT_STRATEGY, Z_BINARY2, Z_TEXT2, Z_UNKNOWN3, Z_DEFLATED3, status;
var init_binding = __esm({
  "node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/zlib-lib/binding.js"() {
    init_messages();
    init_zstream();
    init_deflate();
    init_inflate();
    NONE = 0;
    DEFLATE = 1;
    INFLATE = 2;
    GZIP = 3;
    GUNZIP = 4;
    DEFLATERAW = 5;
    INFLATERAW = 6;
    UNZIP = 7;
    Z_NO_FLUSH2 = 0;
    Z_PARTIAL_FLUSH2 = 1;
    Z_SYNC_FLUSH = 2;
    Z_FULL_FLUSH2 = 3;
    Z_FINISH3 = 4;
    Z_BLOCK3 = 5;
    Z_TREES2 = 6;
    Z_OK3 = 0;
    Z_STREAM_END3 = 1;
    Z_NEED_DICT2 = 2;
    Z_ERRNO = -1;
    Z_STREAM_ERROR3 = -2;
    Z_DATA_ERROR3 = -3;
    Z_BUF_ERROR3 = -5;
    Z_NO_COMPRESSION = 0;
    Z_BEST_SPEED = 1;
    Z_BEST_COMPRESSION = 9;
    Z_DEFAULT_COMPRESSION2 = -1;
    Z_FILTERED2 = 1;
    Z_HUFFMAN_ONLY2 = 2;
    Z_RLE2 = 3;
    Z_FIXED3 = 4;
    Z_DEFAULT_STRATEGY = 0;
    Z_BINARY2 = 0;
    Z_TEXT2 = 1;
    Z_UNKNOWN3 = 2;
    Z_DEFLATED3 = 8;
    Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
      this.windowBits = windowBits;
      this.level = level;
      this.memLevel = memLevel;
      this.strategy = strategy;
      if (this.mode === GZIP || this.mode === GUNZIP)
        this.windowBits += 16;
      if (this.mode === UNZIP)
        this.windowBits += 32;
      if (this.mode === DEFLATERAW || this.mode === INFLATERAW)
        this.windowBits = -this.windowBits;
      this.strm = new zstream_default();
      var status2;
      switch (this.mode) {
        case DEFLATE:
        case GZIP:
        case DEFLATERAW:
          status2 = deflateInit2(this.strm, this.level, Z_DEFLATED3, this.windowBits, this.memLevel, this.strategy);
          break;
        case INFLATE:
        case GUNZIP:
        case INFLATERAW:
        case UNZIP:
          status2 = inflateInit2(this.strm, this.windowBits);
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
      if (status2 !== Z_OK3) {
        this._error(status2);
        return;
      }
      this.write_in_progress = false;
      this.init_done = true;
    };
    Zlib.prototype.params = function() {
      throw new Error("deflateParams Not supported");
    };
    Zlib.prototype._writeCheck = function() {
      if (!this.init_done)
        throw new Error("write before init");
      if (this.mode === NONE)
        throw new Error("already finalized");
      if (this.write_in_progress)
        throw new Error("write already in progress");
      if (this.pending_close)
        throw new Error("close is pending");
    };
    Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
      this._writeCheck();
      this.write_in_progress = true;
      var self2 = this;
      process.nextTick(function() {
        self2.write_in_progress = false;
        var res = self2._write(flush, input, in_off, in_len, out, out_off, out_len);
        self2.callback(res[0], res[1]);
        if (self2.pending_close)
          self2.close();
      });
      return this;
    };
    Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
      this._writeCheck();
      return this._write(flush, input, in_off, in_len, out, out_off, out_len);
    };
    Zlib.prototype._write = function(flush, input, in_off, in_len, out, out_off, out_len) {
      this.write_in_progress = true;
      if (flush !== Z_NO_FLUSH2 && flush !== Z_PARTIAL_FLUSH2 && flush !== Z_SYNC_FLUSH && flush !== Z_FULL_FLUSH2 && flush !== Z_FINISH3 && flush !== Z_BLOCK3) {
        throw new Error("Invalid flush value");
      }
      if (input == null) {
        input = new Buffer(0);
        in_len = 0;
        in_off = 0;
      }
      if (out._set)
        out.set = out._set;
      else
        out.set = bufferSet;
      var strm = this.strm;
      strm.avail_in = in_len;
      strm.input = input;
      strm.next_in = in_off;
      strm.avail_out = out_len;
      strm.output = out;
      strm.next_out = out_off;
      var status2;
      switch (this.mode) {
        case DEFLATE:
        case GZIP:
        case DEFLATERAW:
          status2 = deflate(strm, flush);
          break;
        case UNZIP:
        case INFLATE:
        case GUNZIP:
        case INFLATERAW:
          status2 = inflate(strm, flush);
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
      if (status2 !== Z_STREAM_END3 && status2 !== Z_OK3) {
        this._error(status2);
      }
      this.write_in_progress = false;
      return [strm.avail_in, strm.avail_out];
    };
    Zlib.prototype.close = function() {
      if (this.write_in_progress) {
        this.pending_close = true;
        return;
      }
      this.pending_close = false;
      if (this.mode === DEFLATE || this.mode === GZIP || this.mode === DEFLATERAW) {
        deflateEnd(this.strm);
      } else {
        inflateEnd(this.strm);
      }
      this.mode = NONE;
    };
    Zlib.prototype.reset = function() {
      switch (this.mode) {
        case DEFLATE:
        case DEFLATERAW:
          status = deflateReset(this.strm);
          break;
        case INFLATE:
        case INFLATERAW:
          status = inflateReset(this.strm);
          break;
      }
      if (status !== Z_OK3) {
        this._error(status);
      }
    };
    Zlib.prototype._error = function(status2) {
      this.onerror(messages_default[status2] + ": " + this.strm.msg, status2);
      this.write_in_progress = false;
      if (this.pending_close)
        this.close();
    };
  }
});

// node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/zlib.js
var zlib_exports = {};
__export(zlib_exports, {
  Deflate: () => Deflate,
  DeflateRaw: () => DeflateRaw,
  Gunzip: () => Gunzip,
  Gzip: () => Gzip,
  Inflate: () => Inflate,
  InflateRaw: () => InflateRaw,
  Unzip: () => Unzip,
  Zlib: () => Zlib2,
  codes: () => codes,
  createDeflate: () => createDeflate,
  createDeflateRaw: () => createDeflateRaw,
  createGunzip: () => createGunzip,
  createGzip: () => createGzip,
  createInflate: () => createInflate,
  createInflateRaw: () => createInflateRaw,
  createUnzip: () => createUnzip,
  default: () => zlib_default,
  deflate: () => deflate2,
  deflateRaw: () => deflateRaw,
  deflateRawSync: () => deflateRawSync,
  deflateSync: () => deflateSync,
  gunzip: () => gunzip,
  gunzipSync: () => gunzipSync,
  gzip: () => gzip,
  gzipSync: () => gzipSync,
  inflate: () => inflate2,
  inflateRaw: () => inflateRaw,
  inflateRawSync: () => inflateRawSync,
  inflateSync: () => inflateSync,
  unzip: () => unzip,
  unzipSync: () => unzipSync
});
function assert2(a, msg) {
  if (!a) {
    throw new Error(msg);
  }
}
function createDeflate(o) {
  return new Deflate(o);
}
function createInflate(o) {
  return new Inflate(o);
}
function createDeflateRaw(o) {
  return new DeflateRaw(o);
}
function createInflateRaw(o) {
  return new InflateRaw(o);
}
function createGzip(o) {
  return new Gzip(o);
}
function createGunzip(o) {
  return new Gunzip(o);
}
function createUnzip(o) {
  return new Unzip(o);
}
function deflate2(buffer, opts, callback) {
  if (typeof opts === "function") {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Deflate(opts), buffer, callback);
}
function deflateSync(buffer, opts) {
  return zlibBufferSync(new Deflate(opts), buffer);
}
function gzip(buffer, opts, callback) {
  if (typeof opts === "function") {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Gzip(opts), buffer, callback);
}
function gzipSync(buffer, opts) {
  return zlibBufferSync(new Gzip(opts), buffer);
}
function deflateRaw(buffer, opts, callback) {
  if (typeof opts === "function") {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new DeflateRaw(opts), buffer, callback);
}
function deflateRawSync(buffer, opts) {
  return zlibBufferSync(new DeflateRaw(opts), buffer);
}
function unzip(buffer, opts, callback) {
  if (typeof opts === "function") {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Unzip(opts), buffer, callback);
}
function unzipSync(buffer, opts) {
  return zlibBufferSync(new Unzip(opts), buffer);
}
function inflate2(buffer, opts, callback) {
  if (typeof opts === "function") {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Inflate(opts), buffer, callback);
}
function inflateSync(buffer, opts) {
  return zlibBufferSync(new Inflate(opts), buffer);
}
function gunzip(buffer, opts, callback) {
  if (typeof opts === "function") {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Gunzip(opts), buffer, callback);
}
function gunzipSync(buffer, opts) {
  return zlibBufferSync(new Gunzip(opts), buffer);
}
function inflateRaw(buffer, opts, callback) {
  if (typeof opts === "function") {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new InflateRaw(opts), buffer, callback);
}
function inflateRawSync(buffer, opts) {
  return zlibBufferSync(new InflateRaw(opts), buffer);
}
function zlibBuffer(engine, buffer, callback) {
  var buffers = [];
  var nread = 0;
  engine.on("error", onError);
  engine.on("end", onEnd);
  engine.end(buffer);
  flow2();
  function flow2() {
    var chunk;
    while ((chunk = engine.read()) !== null) {
      buffers.push(chunk);
      nread += chunk.length;
    }
    engine.once("readable", flow2);
  }
  function onError(err2) {
    engine.removeListener("end", onEnd);
    engine.removeListener("readable", flow2);
    callback(err2);
  }
  function onEnd() {
    var buf = Buffer.concat(buffers, nread);
    buffers = [];
    callback(null, buf);
    engine.close();
  }
}
function zlibBufferSync(engine, buffer) {
  if (typeof buffer === "string")
    buffer = new Buffer(buffer);
  if (!Buffer.isBuffer(buffer))
    throw new TypeError("Not a string or buffer");
  var flushFlag = binding2.Z_FINISH;
  return engine._processChunk(buffer, flushFlag);
}
function Deflate(opts) {
  if (!(this instanceof Deflate))
    return new Deflate(opts);
  Zlib2.call(this, opts, binding2.DEFLATE);
}
function Inflate(opts) {
  if (!(this instanceof Inflate))
    return new Inflate(opts);
  Zlib2.call(this, opts, binding2.INFLATE);
}
function Gzip(opts) {
  if (!(this instanceof Gzip))
    return new Gzip(opts);
  Zlib2.call(this, opts, binding2.GZIP);
}
function Gunzip(opts) {
  if (!(this instanceof Gunzip))
    return new Gunzip(opts);
  Zlib2.call(this, opts, binding2.GUNZIP);
}
function DeflateRaw(opts) {
  if (!(this instanceof DeflateRaw))
    return new DeflateRaw(opts);
  Zlib2.call(this, opts, binding2.DEFLATERAW);
}
function InflateRaw(opts) {
  if (!(this instanceof InflateRaw))
    return new InflateRaw(opts);
  Zlib2.call(this, opts, binding2.INFLATERAW);
}
function Unzip(opts) {
  if (!(this instanceof Unzip))
    return new Unzip(opts);
  Zlib2.call(this, opts, binding2.UNZIP);
}
function Zlib2(opts, mode) {
  this._opts = opts = opts || {};
  this._chunkSize = opts.chunkSize || binding2.Z_DEFAULT_CHUNK;
  Transform.call(this, opts);
  if (opts.flush) {
    if (opts.flush !== binding2.Z_NO_FLUSH && opts.flush !== binding2.Z_PARTIAL_FLUSH && opts.flush !== binding2.Z_SYNC_FLUSH && opts.flush !== binding2.Z_FULL_FLUSH && opts.flush !== binding2.Z_FINISH && opts.flush !== binding2.Z_BLOCK) {
      throw new Error("Invalid flush flag: " + opts.flush);
    }
  }
  this._flushFlag = opts.flush || binding2.Z_NO_FLUSH;
  if (opts.chunkSize) {
    if (opts.chunkSize < binding2.Z_MIN_CHUNK || opts.chunkSize > binding2.Z_MAX_CHUNK) {
      throw new Error("Invalid chunk size: " + opts.chunkSize);
    }
  }
  if (opts.windowBits) {
    if (opts.windowBits < binding2.Z_MIN_WINDOWBITS || opts.windowBits > binding2.Z_MAX_WINDOWBITS) {
      throw new Error("Invalid windowBits: " + opts.windowBits);
    }
  }
  if (opts.level) {
    if (opts.level < binding2.Z_MIN_LEVEL || opts.level > binding2.Z_MAX_LEVEL) {
      throw new Error("Invalid compression level: " + opts.level);
    }
  }
  if (opts.memLevel) {
    if (opts.memLevel < binding2.Z_MIN_MEMLEVEL || opts.memLevel > binding2.Z_MAX_MEMLEVEL) {
      throw new Error("Invalid memLevel: " + opts.memLevel);
    }
  }
  if (opts.strategy) {
    if (opts.strategy != binding2.Z_FILTERED && opts.strategy != binding2.Z_HUFFMAN_ONLY && opts.strategy != binding2.Z_RLE && opts.strategy != binding2.Z_FIXED && opts.strategy != binding2.Z_DEFAULT_STRATEGY) {
      throw new Error("Invalid strategy: " + opts.strategy);
    }
  }
  if (opts.dictionary) {
    if (!Buffer.isBuffer(opts.dictionary)) {
      throw new Error("Invalid dictionary: it should be a Buffer instance");
    }
  }
  this._binding = new binding2.Zlib(mode);
  var self2 = this;
  this._hadError = false;
  this._binding.onerror = function(message, errno) {
    self2._binding = null;
    self2._hadError = true;
    var error2 = new Error(message);
    error2.errno = errno;
    error2.code = binding2.codes[errno];
    self2.emit("error", error2);
  };
  var level = binding2.Z_DEFAULT_COMPRESSION;
  if (typeof opts.level === "number")
    level = opts.level;
  var strategy = binding2.Z_DEFAULT_STRATEGY;
  if (typeof opts.strategy === "number")
    strategy = opts.strategy;
  this._binding.init(opts.windowBits || binding2.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || binding2.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);
  this._buffer = new Buffer(this._chunkSize);
  this._offset = 0;
  this._closed = false;
  this._level = level;
  this._strategy = strategy;
  this.once("end", this.close);
}
var binding2, codes, zlib_default;
var init_zlib = __esm({
  "node_modules/.pnpm/rollup-plugin-node-builtins@2.1.2/node_modules/rollup-plugin-node-builtins/src/es6/zlib.js"() {
    init_stream();
    init_binding();
    init_util();
    binding2 = {};
    Object.keys(binding_exports).forEach(function(key) {
      binding2[key] = binding_exports[key];
    });
    binding2.Z_MIN_WINDOWBITS = 8;
    binding2.Z_MAX_WINDOWBITS = 15;
    binding2.Z_DEFAULT_WINDOWBITS = 15;
    binding2.Z_MIN_CHUNK = 64;
    binding2.Z_MAX_CHUNK = Infinity;
    binding2.Z_DEFAULT_CHUNK = 16 * 1024;
    binding2.Z_MIN_MEMLEVEL = 1;
    binding2.Z_MAX_MEMLEVEL = 9;
    binding2.Z_DEFAULT_MEMLEVEL = 8;
    binding2.Z_MIN_LEVEL = -1;
    binding2.Z_MAX_LEVEL = 9;
    binding2.Z_DEFAULT_LEVEL = binding2.Z_DEFAULT_COMPRESSION;
    codes = {
      Z_OK: binding2.Z_OK,
      Z_STREAM_END: binding2.Z_STREAM_END,
      Z_NEED_DICT: binding2.Z_NEED_DICT,
      Z_ERRNO: binding2.Z_ERRNO,
      Z_STREAM_ERROR: binding2.Z_STREAM_ERROR,
      Z_DATA_ERROR: binding2.Z_DATA_ERROR,
      Z_MEM_ERROR: binding2.Z_MEM_ERROR,
      Z_BUF_ERROR: binding2.Z_BUF_ERROR,
      Z_VERSION_ERROR: binding2.Z_VERSION_ERROR
    };
    Object.keys(codes).forEach(function(k2) {
      codes[codes[k2]] = k2;
    });
    (0, import_inherits.default)(Zlib2, Transform);
    Zlib2.prototype.params = function(level, strategy, callback) {
      if (level < binding2.Z_MIN_LEVEL || level > binding2.Z_MAX_LEVEL) {
        throw new RangeError("Invalid compression level: " + level);
      }
      if (strategy != binding2.Z_FILTERED && strategy != binding2.Z_HUFFMAN_ONLY && strategy != binding2.Z_RLE && strategy != binding2.Z_FIXED && strategy != binding2.Z_DEFAULT_STRATEGY) {
        throw new TypeError("Invalid strategy: " + strategy);
      }
      if (this._level !== level || this._strategy !== strategy) {
        var self2 = this;
        this.flush(binding2.Z_SYNC_FLUSH, function() {
          self2._binding.params(level, strategy);
          if (!self2._hadError) {
            self2._level = level;
            self2._strategy = strategy;
            if (callback)
              callback();
          }
        });
      } else {
        process.nextTick(callback);
      }
    };
    Zlib2.prototype.reset = function() {
      return this._binding.reset();
    };
    Zlib2.prototype._flush = function(callback) {
      this._transform(new Buffer(0), "", callback);
    };
    Zlib2.prototype.flush = function(kind, callback) {
      var ws2 = this._writableState;
      if (typeof kind === "function" || kind === void 0 && !callback) {
        callback = kind;
        kind = binding2.Z_FULL_FLUSH;
      }
      if (ws2.ended) {
        if (callback)
          process.nextTick(callback);
      } else if (ws2.ending) {
        if (callback)
          this.once("end", callback);
      } else if (ws2.needDrain) {
        var self2 = this;
        this.once("drain", function() {
          self2.flush(callback);
        });
      } else {
        this._flushFlag = kind;
        this.write(new Buffer(0), "", callback);
      }
    };
    Zlib2.prototype.close = function(callback) {
      if (callback)
        process.nextTick(callback);
      if (this._closed)
        return;
      this._closed = true;
      this._binding.close();
      var self2 = this;
      process.nextTick(function() {
        self2.emit("close");
      });
    };
    Zlib2.prototype._transform = function(chunk, encoding, cb) {
      var flushFlag;
      var ws2 = this._writableState;
      var ending = ws2.ending || ws2.ended;
      var last = ending && (!chunk || ws2.length === chunk.length);
      if (!chunk === null && !Buffer.isBuffer(chunk))
        return cb(new Error("invalid input"));
      if (last)
        flushFlag = binding2.Z_FINISH;
      else {
        flushFlag = this._flushFlag;
        if (chunk.length >= ws2.length) {
          this._flushFlag = this._opts.flush || binding2.Z_NO_FLUSH;
        }
      }
      this._processChunk(chunk, flushFlag, cb);
    };
    Zlib2.prototype._processChunk = function(chunk, flushFlag, cb) {
      var availInBefore = chunk && chunk.length;
      var availOutBefore = this._chunkSize - this._offset;
      var inOff = 0;
      var self2 = this;
      var async = typeof cb === "function";
      if (!async) {
        var buffers = [];
        var nread = 0;
        var error2;
        this.on("error", function(er2) {
          error2 = er2;
        });
        do {
          var res = this._binding.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
        } while (!this._hadError && callback(res[0], res[1]));
        if (this._hadError) {
          throw error2;
        }
        var buf = Buffer.concat(buffers, nread);
        this.close();
        return buf;
      }
      var req = this._binding.write(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
      req.buffer = chunk;
      req.callback = callback;
      function callback(availInAfter, availOutAfter) {
        if (self2._hadError)
          return;
        var have = availOutBefore - availOutAfter;
        assert2(have >= 0, "have should not go down");
        if (have > 0) {
          var out = self2._buffer.slice(self2._offset, self2._offset + have);
          self2._offset += have;
          if (async) {
            self2.push(out);
          } else {
            buffers.push(out);
            nread += out.length;
          }
        }
        if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
          availOutBefore = self2._chunkSize;
          self2._offset = 0;
          self2._buffer = new Buffer(self2._chunkSize);
        }
        if (availOutAfter === 0) {
          inOff += availInBefore - availInAfter;
          availInBefore = availInAfter;
          if (!async)
            return true;
          var newReq = self2._binding.write(flushFlag, chunk, inOff, availInBefore, self2._buffer, self2._offset, self2._chunkSize);
          newReq.callback = callback;
          newReq.buffer = chunk;
          return;
        }
        if (!async)
          return false;
        cb();
      }
    };
    (0, import_inherits.default)(Deflate, Zlib2);
    (0, import_inherits.default)(Inflate, Zlib2);
    (0, import_inherits.default)(Gzip, Zlib2);
    (0, import_inherits.default)(Gunzip, Zlib2);
    (0, import_inherits.default)(DeflateRaw, Zlib2);
    (0, import_inherits.default)(InflateRaw, Zlib2);
    (0, import_inherits.default)(Unzip, Zlib2);
    zlib_default = {
      codes,
      createDeflate,
      createInflate,
      createDeflateRaw,
      createInflateRaw,
      createGzip,
      createGunzip,
      createUnzip,
      deflate: deflate2,
      deflateSync,
      gzip,
      gzipSync,
      deflateRaw,
      deflateRawSync,
      unzip,
      unzipSync,
      inflate: inflate2,
      inflateSync,
      gunzip,
      gunzipSync,
      inflateRaw,
      inflateRawSync,
      Deflate,
      Inflate,
      Gzip,
      Gunzip,
      DeflateRaw,
      InflateRaw,
      Unzip,
      Zlib: Zlib2
    };
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/fetch/dataURL.js
var require_dataURL = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/fetch/dataURL.js"(exports2, module2) {
    var assert3 = (init_assert(), __toCommonJS(assert_exports));
    var { atob } = (init_buffer_es6(), __toCommonJS(buffer_es6_exports));
    var encoder = new TextEncoder();
    function dataURLProcessor(dataURL) {
      assert3(dataURL.protocol === "data:");
      let input = URLSerializer(dataURL, true);
      input = input.slice(5);
      const position = { position: 0 };
      let mimeType = collectASequenceOfCodePoints((char) => char !== ",", input, position);
      const mimeTypeLength = mimeType.length;
      mimeType = mimeType.replace(/^(\u0020)+|(\u0020)+$/g, "");
      if (position.position >= input.length) {
        return "failure";
      }
      position.position++;
      const encodedBody = input.slice(mimeTypeLength + 1);
      let body = stringPercentDecode(encodedBody);
      if (/;(\u0020){0,}base64$/i.test(mimeType)) {
        const stringBody = decodeURIComponent(new TextDecoder("utf-8").decode(body));
        body = forgivingBase64(stringBody);
        if (body === "failure") {
          return "failure";
        }
        mimeType = mimeType.slice(0, -6);
        mimeType = mimeType.replace(/(\u0020)+$/, "");
        mimeType = mimeType.slice(0, -1);
      }
      if (mimeType.startsWith(";")) {
        mimeType = "text/plain" + mimeType;
      }
      let mimeTypeRecord = parseMIMEType(mimeType);
      if (mimeTypeRecord === "failure") {
        mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
      }
      return { mimeType: mimeTypeRecord, body };
    }
    function URLSerializer(url2, excludeFragment = false) {
      let output = url2.protocol;
      if (url2.host.length > 0) {
        output += "//";
        if (url2.username.length > 0 || url2.password.length > 0) {
          output += url2.username;
          if (url2.password.length > 0) {
            output += ":" + url2.password;
          }
          output += "@";
        }
        output += decodeURIComponent(url2.host);
        if (url2.port.length > 0) {
          output += ":" + url2.port;
        }
      }
      if (url2.host.length === 0 && url2.pathname.length > 1 && url2.href.slice(url2.protocol.length + 1)[0] === ".") {
        output += "/.";
      }
      output += url2.pathname;
      if (url2.search.length > 0) {
        output += url2.search;
      }
      if (excludeFragment === false && url2.hash.length > 0) {
        output += url2.hash;
      }
      return output;
    }
    function collectASequenceOfCodePoints(condition, input, position) {
      let result = "";
      while (position.position < input.length && condition(input[position.position])) {
        result += input[position.position];
        position.position++;
      }
      return result;
    }
    function stringPercentDecode(input) {
      const bytes = encoder.encode(input);
      return percentDecode(bytes);
    }
    function percentDecode(input) {
      const output = [];
      for (let i = 0; i < input.length; i++) {
        const byte = input[i];
        if (byte !== 37) {
          output.push(byte);
        } else if (byte === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))) {
          output.push(37);
        } else {
          const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);
          const bytePoint = Number.parseInt(nextTwoBytes, 16);
          output.push(bytePoint);
          i += 2;
        }
      }
      return Uint8Array.of(...output);
    }
    function parseMIMEType(input) {
      input = input.trim();
      const position = { position: 0 };
      const type = collectASequenceOfCodePoints((char) => char !== "/", input, position);
      if (type.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(type)) {
        return "failure";
      }
      if (position.position > input.length) {
        return "failure";
      }
      position.position++;
      let subtype = collectASequenceOfCodePoints((char) => char !== ";", input, position);
      subtype = subtype.trim();
      if (subtype.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(subtype)) {
        return "failure";
      }
      const mimeType = {
        type: type.toLowerCase(),
        subtype: subtype.toLowerCase(),
        parameters: /* @__PURE__ */ new Map()
      };
      while (position.position < input.length) {
        position.position++;
        collectASequenceOfCodePoints((char) => /(\u000A|\u000D|\u0009|\u0020)/.test(char), input, position);
        let parameterName = collectASequenceOfCodePoints((char) => char !== ";" && char !== "=", input, position);
        parameterName = parameterName.toLowerCase();
        if (position.position < input.length) {
          if (input[position.position] === ";") {
            continue;
          }
          position.position++;
        }
        if (position.position > input.length) {
          break;
        }
        let parameterValue = null;
        if (input[position.position] === '"') {
          parameterValue = collectAnHTTPQuotedString(input, position);
          collectASequenceOfCodePoints((char) => char !== ";", input, position);
        } else {
          parameterValue = collectASequenceOfCodePoints((char) => char !== ";", input, position);
          parameterValue = parameterValue.trim();
          if (parameterValue.length === 0) {
            continue;
          }
        }
        if (parameterName.length !== 0 && /^[!#$%&'*+-.^_|~A-z0-9]+$/.test(parameterName) && !/^(\u0009|\x{0020}-\x{007E}|\x{0080}-\x{00FF})+$/.test(parameterValue) && !mimeType.parameters.has(parameterName)) {
          mimeType.parameters.set(parameterName, parameterValue);
        }
      }
      return mimeType;
    }
    function forgivingBase64(data) {
      data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, "");
      if (data.length % 4 === 0) {
        data = data.replace(/=?=$/, "");
      }
      if (data.length % 4 === 1) {
        return "failure";
      }
      if (/[^+/0-9A-Za-z]/.test(data)) {
        return "failure";
      }
      const binary = atob(data);
      const bytes = new Uint8Array(binary.length);
      for (let byte = 0; byte < binary.length; byte++) {
        bytes[byte] = binary.charCodeAt(byte);
      }
      return bytes;
    }
    function collectAnHTTPQuotedString(input, position, extractValue) {
      const positionStart = position.position;
      let value = "";
      assert3(input[position.position] === '"');
      position.position++;
      while (true) {
        value += collectASequenceOfCodePoints((char) => char !== '"' && char !== "\\", input, position);
        if (position.position >= input.length) {
          break;
        }
        const quoteOrBackslash = input[position.position];
        position.position++;
        if (quoteOrBackslash === "\\") {
          if (position.position >= input.length) {
            value += "\\";
            break;
          }
          value += input[position.position];
          position.position++;
        } else {
          assert3(quoteOrBackslash === '"');
          break;
        }
      }
      if (extractValue) {
        return value;
      }
      return input.slice(positionStart, position.position);
    }
    module2.exports = {
      dataURLProcessor,
      URLSerializer,
      collectASequenceOfCodePoints,
      stringPercentDecode,
      parseMIMEType,
      collectAnHTTPQuotedString
    };
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/fetch/index.js
var require_fetch = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/lib/fetch/index.js"(exports2, module2) {
    "use strict";
    var {
      Response: Response2,
      makeNetworkError,
      makeAppropriateNetworkError,
      filterResponse,
      makeResponse
    } = require_response();
    var { Headers } = require_headers();
    var { Request: Request2, makeRequest } = require_request2();
    var zlib = (init_zlib(), __toCommonJS(zlib_exports));
    var {
      matchRequestIntegrity,
      makePolicyContainer,
      clonePolicyContainer,
      requestBadPort,
      TAOCheck,
      appendRequestOriginHeader,
      responseLocationURL,
      requestCurrentURL,
      setRequestReferrerPolicyOnRedirect,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      createOpaqueTimingInfo,
      appendFetchMetadata,
      corsCheck,
      crossOriginResourcePolicyCheck,
      determineRequestsReferrer,
      coarsenedSharedCurrentTime,
      createDeferredPromise,
      isBlobLike,
      CORBCheck,
      sameOrigin,
      isCancelled,
      isAborted
    } = require_util2();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
    var { AbortError } = require_errors();
    var assert3 = (init_assert(), __toCommonJS(assert_exports));
    var { safelyExtractBody, extractBody } = require_body();
    var {
      redirectStatus,
      nullBodyStatus,
      safeMethods,
      requestBodyHeader,
      subresource
    } = require_constants2();
    var { kHeadersList } = require_symbols();
    var EE = (init_events(), __toCommonJS(events_exports));
    var { Readable: Readable2, pipeline } = (init_stream(), __toCommonJS(stream_exports));
    var { isErrored, isReadable } = require_util();
    var { dataURLProcessor } = require_dataURL();
    var { kIsMockActive } = require_mock_symbols();
    var { TransformStream } = __require("stream/web");
    var resolveObjectURL;
    var ReadableStream2;
    var Fetch = class extends EE {
      constructor(dispatcher) {
        super();
        this.dispatcher = dispatcher;
        this.connection = null;
        this.dump = false;
        this.state = "ongoing";
      }
      terminate(reason) {
        if (this.state !== "ongoing") {
          return;
        }
        this.state = "terminated";
        this.connection?.destroy(reason);
        this.emit("terminated", reason);
      }
      abort() {
        if (this.state !== "ongoing") {
          return;
        }
        const reason = new AbortError();
        this.state = "aborted";
        this.connection?.destroy(reason);
        this.emit("terminated", reason);
      }
    };
    async function fetch3(...args) {
      if (args.length < 1) {
        throw new TypeError(`Failed to execute 'fetch' on 'Window': 1 argument required, but only ${args.length} present.`);
      }
      if (args.length >= 1 && typeof args[1] !== "object" && args[1] !== void 0) {
        throw new TypeError("Failed to execute 'fetch' on 'Window': cannot convert to dictionary.");
      }
      const resource = args[0];
      const init = args.length >= 1 ? args[1] ?? {} : {};
      const p = createDeferredPromise();
      const requestObject = new Request2(resource, init);
      const request3 = requestObject[kState];
      if (requestObject.signal.aborted) {
        abortFetch(p, request3, null);
        return p.promise;
      }
      const globalObject = request3.client.globalObject;
      if (globalObject?.constructor?.name === "ServiceWorkerGlobalScope") {
        request3.serviceWorkers = "none";
      }
      let responseObject = null;
      const relevantRealm = null;
      let locallyAborted = false;
      let controller = null;
      requestObject.signal.addEventListener("abort", () => {
        locallyAborted = true;
        abortFetch(p, request3, responseObject);
        if (controller != null) {
          controller.abort();
        }
      }, { once: true });
      const handleFetchDone = (response) => finalizeAndReportTiming(response, "fetch");
      const processResponse = (response) => {
        if (locallyAborted) {
          return;
        }
        if (response.aborted) {
          abortFetch(p, request3, responseObject);
          return;
        }
        if (response.type === "error") {
          p.reject(Object.assign(new TypeError("fetch failed"), { cause: response.error }));
          return;
        }
        responseObject = new Response2();
        responseObject[kState] = response;
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kHeadersList] = response.headersList;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        p.resolve(responseObject);
      };
      controller = fetching({
        request: request3,
        processResponseEndOfBody: handleFetchDone,
        processResponse,
        dispatcher: this
      });
      return p.promise;
    }
    function finalizeAndReportTiming(response, initiatorType = "other") {
      if (response.type === "error" && response.aborted) {
        return;
      }
      if (!response.urlList?.length) {
        return;
      }
      const originalURL = response.urlList[0];
      let timingInfo = response.timingInfo;
      let cacheState = response.cacheState;
      if (!/^https?:/.test(originalURL.protocol)) {
        return;
      }
      if (timingInfo === null) {
        return;
      }
      if (!timingInfo.timingAllowPassed) {
        timingInfo = createOpaqueTimingInfo({
          startTime: timingInfo.startTime
        });
        cacheState = "";
      }
      response.timingInfo.endTime = coarsenedSharedCurrentTime();
      response.timingInfo = timingInfo;
      markResourceTiming(timingInfo, originalURL, initiatorType, globalThis, cacheState);
    }
    function markResourceTiming() {
    }
    function abortFetch(p, request3, responseObject) {
      const error2 = new AbortError();
      p.reject(error2);
      if (request3.body != null && isReadable(request3.body?.stream)) {
        request3.body.stream.cancel(error2).catch((err2) => {
          if (err2.code === "ERR_INVALID_STATE") {
            return;
          }
          throw err2;
        });
      }
      if (responseObject == null) {
        return;
      }
      const response = responseObject[kState];
      if (response.body != null && isReadable(response.body?.stream)) {
        response.body.stream.cancel(error2).catch((err2) => {
          if (err2.code === "ERR_INVALID_STATE") {
            return;
          }
          throw err2;
        });
      }
    }
    function fetching({
      request: request3,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseEndOfBody,
      processResponseConsumeBody,
      useParallelQueue = false,
      dispatcher
    }) {
      let taskDestination = null;
      let crossOriginIsolatedCapability = false;
      if (request3.client != null) {
        taskDestination = request3.client.globalObject;
        crossOriginIsolatedCapability = request3.client.crossOriginIsolatedCapability;
      }
      const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
      const timingInfo = createOpaqueTimingInfo({
        startTime: currenTime
      });
      const fetchParams = {
        controller: new Fetch(dispatcher),
        request: request3,
        timingInfo,
        processRequestBodyChunkLength,
        processRequestEndOfBody,
        processResponse,
        processResponseConsumeBody,
        processResponseEndOfBody,
        taskDestination,
        crossOriginIsolatedCapability
      };
      assert3(!request3.body || request3.body.stream);
      if (request3.window === "client") {
        request3.window = request3.client?.globalObject?.constructor?.name === "Window" ? request3.client : "no-window";
      }
      if (request3.origin === "client") {
        request3.origin = request3.client?.origin;
      }
      if (request3.policyContainer === "client") {
        if (request3.client != null) {
          request3.policyContainer = clonePolicyContainer(request3.client.policyContainer);
        } else {
          request3.policyContainer = makePolicyContainer();
        }
      }
      if (!request3.headersList.has("accept")) {
        const value = "*/*";
        request3.headersList.append("accept", value);
      }
      if (!request3.headersList.has("accept-language")) {
        request3.headersList.append("accept-language", "*");
      }
      if (request3.priority === null) {
      }
      if (subresource.includes(request3.destination)) {
      }
      mainFetch(fetchParams).catch((err2) => {
        fetchParams.controller.terminate(err2);
      });
      return fetchParams.controller;
    }
    async function mainFetch(fetchParams, recursive = false) {
      const request3 = fetchParams.request;
      let response = null;
      if (request3.localURLsOnly && !/^(about|blob|data):/.test(requestCurrentURL(request3).protocol)) {
        response = makeNetworkError("local URLs only");
      }
      tryUpgradeRequestToAPotentiallyTrustworthyURL(request3);
      if (requestBadPort(request3) === "blocked") {
        response = makeNetworkError("bad port");
      }
      if (request3.referrerPolicy === "") {
        request3.referrerPolicy = request3.policyContainer.referrerPolicy;
      }
      if (request3.referrer !== "no-referrer") {
        request3.referrer = determineRequestsReferrer(request3);
      }
      if (response === null) {
        response = await (async () => {
          const currentURL = requestCurrentURL(request3);
          if (sameOrigin(currentURL, request3.url) && request3.responseTainting === "basic" || currentURL.protocol === "data:" || (request3.mode === "navigate" || request3.mode === "websocket")) {
            request3.responseTainting = "basic";
            return await schemeFetch(fetchParams);
          }
          if (request3.mode === "same-origin") {
            return makeNetworkError('request mode cannot be "same-origin"');
          }
          if (request3.mode === "no-cors") {
            if (request3.redirect !== "follow") {
              return makeNetworkError('redirect mode cannot be "follow" for "no-cors" request');
            }
            request3.responseTainting = "opaque";
            const noCorsResponse = await schemeFetch(fetchParams);
            if (noCorsResponse.status === 0 || CORBCheck(request3, noCorsResponse) === "allowed") {
              return noCorsResponse;
            }
            return makeResponse({ status: noCorsResponse.status });
          }
          if (!/^https?:/.test(requestCurrentURL(request3).protocol)) {
            return makeNetworkError("URL scheme must be a HTTP(S) scheme");
          }
          request3.responseTainting = "cors";
          return await httpFetch(fetchParams);
        })();
      }
      if (recursive) {
        return response;
      }
      if (response.status !== 0 && !response.internalResponse) {
        if (request3.responseTainting === "cors") {
        }
        if (request3.responseTainting === "basic") {
          response = filterResponse(response, "basic");
        } else if (request3.responseTainting === "cors") {
          response = filterResponse(response, "cors");
        } else if (request3.responseTainting === "opaque") {
          response = filterResponse(response, "opaque");
        } else {
          assert3(false);
        }
      }
      let internalResponse = response.status === 0 ? response : response.internalResponse;
      if (internalResponse.urlList.length === 0) {
        internalResponse.urlList.push(...request3.urlList);
      }
      if (!request3.timingAllowFailed) {
        response.timingAllowPassed = true;
      }
      if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request3.headers.has("range")) {
        response = internalResponse = makeNetworkError();
      }
      if (response.status !== 0 && (request3.method === "HEAD" || request3.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
        internalResponse.body = null;
        fetchParams.controller.dump = true;
      }
      if (request3.integrity) {
        const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
        if (request3.responseTainting === "opaque" || response.body == null) {
          processBodyError(response.error);
          return;
        }
        const processBody = (bytes) => {
          if (!matchRequestIntegrity(request3, bytes)) {
            processBodyError("integrity mismatch");
            return;
          }
          response.body = safelyExtractBody(bytes)[0];
          fetchFinale(fetchParams, response);
        };
        try {
          processBody(await response.arrayBuffer());
        } catch (err2) {
          processBodyError(err2);
        }
      } else {
        fetchFinale(fetchParams, response);
      }
    }
    async function schemeFetch(fetchParams) {
      const { request: request3 } = fetchParams;
      const {
        protocol: scheme,
        pathname: path
      } = new URL(requestCurrentURL(request3));
      switch (scheme) {
        case "about:": {
          if (path === "blank") {
            const resp = makeResponse({
              statusText: "OK",
              headersList: [
                "content-type",
                "text/html;charset=utf-8"
              ]
            });
            resp.urlList = [new URL("about:blank")];
            return resp;
          }
          return makeNetworkError("invalid path called");
        }
        case "blob:": {
          resolveObjectURL ?? (resolveObjectURL = (init_buffer_es6(), __toCommonJS(buffer_es6_exports)).resolveObjectURL);
          const currentURL = requestCurrentURL(request3);
          if (currentURL.search.length !== 0) {
            return makeNetworkError("NetworkError when attempting to fetch resource.");
          }
          const blob = resolveObjectURL(currentURL.toString());
          if (request3.method !== "GET" || !isBlobLike(blob)) {
            return makeNetworkError("invalid method");
          }
          const response = makeResponse({ statusText: "OK", urlList: [currentURL] });
          response.headersList.set("content-length", `${blob.size}`);
          response.headersList.set("content-type", blob.type);
          response.body = extractBody(blob)[0];
          return response;
        }
        case "data:": {
          const currentURL = requestCurrentURL(request3);
          const dataURLStruct = dataURLProcessor(currentURL);
          if (dataURLStruct === "failure") {
            return makeNetworkError("failed to fetch the data URL");
          }
          const { mimeType } = dataURLStruct;
          let contentType = `${mimeType.type}/${mimeType.subtype}`;
          const contentTypeParams = [];
          if (mimeType.parameters.size > 0) {
            contentType += ";";
          }
          for (const [key, value] of mimeType.parameters) {
            if (value.length > 0) {
              contentTypeParams.push(`${key}=${value}`);
            } else {
              contentTypeParams.push(key);
            }
          }
          contentType += contentTypeParams.join(",");
          return makeResponse({
            statusText: "OK",
            headersList: [
              "content-type",
              contentType
            ],
            body: extractBody(dataURLStruct.body)[0]
          });
        }
        case "file:": {
          return makeNetworkError("not implemented... yet...");
        }
        case "http:":
        case "https:": {
          return await httpFetch(fetchParams).catch((err2) => makeNetworkError(err2));
        }
        default: {
          return makeNetworkError("unknown scheme");
        }
      }
    }
    function finalizeResponse(fetchParams, response) {
      fetchParams.request.done = true;
      if (fetchParams.processResponseDone != null) {
        queueMicrotask(() => fetchParams.processResponseDone(response));
      }
    }
    async function fetchFinale(fetchParams, response) {
      if (response.type === "error") {
        response.urlList = [fetchParams.request.urlList[0]];
        response.timingInfo = createOpaqueTimingInfo({
          startTime: fetchParams.timingInfo.startTime
        });
      }
      const processResponseEndOfBody = () => {
        fetchParams.request.done = true;
        if (fetchParams.processResponseEndOfBody != null) {
          queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
        }
      };
      if (fetchParams.processResponse != null) {
        queueMicrotask(() => fetchParams.processResponse(response));
      }
      if (response.body == null) {
        processResponseEndOfBody();
      } else {
        const identityTransformAlgorithm = (chunk, controller) => {
          controller.enqueue(chunk);
        };
        const transformStream = new TransformStream({
          start() {
          },
          transform: identityTransformAlgorithm,
          flush: processResponseEndOfBody
        });
        response.body = { stream: response.body.stream.pipeThrough(transformStream) };
      }
      if (fetchParams.processResponseConsumeBody != null) {
        const processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes);
        const processBodyError = (failure) => fetchParams.processResponseConsumeBody(response, failure);
        if (response.body == null) {
          queueMicrotask(() => processBody(null));
        } else {
          try {
            processBody(await response.body.stream.arrayBuffer());
          } catch (err2) {
            processBodyError(err2);
          }
        }
      }
    }
    async function httpFetch(fetchParams) {
      const request3 = fetchParams.request;
      let response = null;
      let actualResponse = null;
      const timingInfo = fetchParams.timingInfo;
      if (request3.serviceWorkers === "all") {
      }
      if (response === null) {
        if (request3.redirect === "follow") {
          request3.serviceWorkers = "none";
        }
        actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
        if (request3.responseTainting === "cors" && corsCheck(request3, response) === "failure") {
          return makeNetworkError("cors failure");
        }
        if (TAOCheck(request3, response) === "failure") {
          request3.timingAllowFailed = true;
        }
      }
      if ((request3.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(request3.origin, request3.client, request3.destination, actualResponse) === "blocked") {
        return makeNetworkError("blocked");
      }
      if (redirectStatus.includes(actualResponse.status)) {
        fetchParams.controller.connection.destroy();
        if (request3.redirect === "error") {
          response = makeNetworkError();
        } else if (request3.redirect === "manual") {
          response = actualResponse;
        } else if (request3.redirect === "follow") {
          response = await httpRedirectFetch(fetchParams, response);
        } else {
          assert3(false);
        }
      }
      response.timingInfo = timingInfo;
      return response;
    }
    async function httpRedirectFetch(fetchParams, response) {
      const request3 = fetchParams.request;
      const actualResponse = response.internalResponse ? response.internalResponse : response;
      let locationURL;
      try {
        locationURL = responseLocationURL(actualResponse, requestCurrentURL(request3).hash);
        if (locationURL == null) {
          return response;
        }
      } catch (err2) {
        return makeNetworkError(err2);
      }
      if (!/^https?:/.test(locationURL.protocol)) {
        return makeNetworkError("URL scheme must be a HTTP(S) scheme");
      }
      if (request3.redirectCount === 20) {
        return makeNetworkError("redirect count exceeded");
      }
      request3.redirectCount += 1;
      if (request3.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request3, locationURL)) {
        return makeNetworkError('cross origin not allowed for request mode "cors"');
      }
      if (request3.responseTainting === "cors" && (locationURL.username || locationURL.password)) {
        return makeNetworkError('URL cannot contain credentials for request mode "cors"');
      }
      if (actualResponse.status !== 303 && request3.body != null && request3.body.source == null) {
        return makeNetworkError();
      }
      if ([301, 302].includes(actualResponse.status) && request3.method === "POST" || actualResponse.status === 303 && !["GET", "HEADER"].includes(request3.method)) {
        request3.method = "GET";
        request3.body = null;
        for (const headerName of requestBodyHeader) {
          request3.headersList.delete(headerName);
        }
      }
      if (request3.body != null) {
        assert3(request3.body.source);
        request3.body = safelyExtractBody(request3.body.source)[0];
      }
      const timingInfo = fetchParams.timingInfo;
      timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
      if (timingInfo.redirectStartTime === 0) {
        timingInfo.redirectStartTime = timingInfo.startTime;
      }
      request3.urlList.push(locationURL);
      setRequestReferrerPolicyOnRedirect(request3, actualResponse);
      return mainFetch(fetchParams, true);
    }
    async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
      const request3 = fetchParams.request;
      let httpFetchParams = null;
      let httpRequest = null;
      let response = null;
      const httpCache = null;
      const revalidatingFlag = false;
      if (request3.window === "no-window" && request3.redirect === "error") {
        httpFetchParams = fetchParams;
        httpRequest = request3;
      } else {
        httpRequest = makeRequest(request3);
        httpFetchParams = { ...fetchParams };
        httpFetchParams.request = httpRequest;
      }
      const includeCredentials = request3.credentials === "include" || request3.credentials === "same-origin" && request3.responseTainting === "basic";
      const contentLength = httpRequest.body ? httpRequest.body.length : null;
      let contentLengthHeaderValue = null;
      if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) {
        contentLengthHeaderValue = "0";
      }
      if (contentLength != null) {
        contentLengthHeaderValue = String(contentLength);
      }
      if (contentLengthHeaderValue != null) {
        httpRequest.headersList.append("content-length", contentLengthHeaderValue);
      }
      if (contentLength != null && httpRequest.keepalive) {
      }
      if (httpRequest.referrer instanceof URL) {
        httpRequest.headersList.append("referer", httpRequest.referrer.href);
      }
      appendRequestOriginHeader(httpRequest);
      appendFetchMetadata(httpRequest);
      if (!httpRequest.headersList.has("user-agent")) {
        httpRequest.headersList.append("user-agent", "undici");
      }
      if (httpRequest.cache === "default" && (httpRequest.headersList.has("if-modified-since") || httpRequest.headersList.has("if-none-match") || httpRequest.headersList.has("if-unmodified-since") || httpRequest.headersList.has("if-match") || httpRequest.headersList.has("if-range"))) {
        httpRequest.cache = "no-store";
      }
      if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.has("cache-control")) {
        httpRequest.headersList.append("cache-control", "max-age=0");
      }
      if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
        if (!httpRequest.headersList.has("pragma")) {
          httpRequest.headersList.append("pragma", "no-cache");
        }
        if (!httpRequest.headersList.has("cache-control")) {
          httpRequest.headersList.append("cache-control", "no-cache");
        }
      }
      if (httpRequest.headersList.has("range")) {
        httpRequest.headersList.append("accept-encoding", "identity");
      }
      if (!httpRequest.headersList.has("accept-encoding")) {
        if (/^https:/.test(requestCurrentURL(httpRequest).protocol)) {
          httpRequest.headersList.append("accept-encoding", "br, gzip, deflate");
        } else {
          httpRequest.headersList.append("accept-encoding", "gzip, deflate");
        }
      }
      if (includeCredentials) {
      }
      if (httpCache == null) {
        httpRequest.cache = "no-store";
      }
      if (httpRequest.mode !== "no-store" && httpRequest.mode !== "reload") {
      }
      if (response == null) {
        if (httpRequest.mode === "only-if-cached") {
          return makeNetworkError("only if cached");
        }
        const forwardResponse = await httpNetworkFetch(httpFetchParams, includeCredentials, isNewConnectionFetch);
        if (!safeMethods.includes(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {
        }
        if (revalidatingFlag && forwardResponse.status === 304) {
        }
        if (response == null) {
          response = forwardResponse;
        }
      }
      response.urlList = [...httpRequest.urlList];
      if (httpRequest.headersList.has("range")) {
        response.rangeRequested = true;
      }
      response.requestIncludesCredentials = includeCredentials;
      if (response.status === 407) {
        if (request3.window === "no-window") {
          return makeNetworkError();
        }
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        return makeNetworkError("proxy authentication required");
      }
      if (response.status === 421 && !isNewConnectionFetch && (request3.body == null || request3.body.source != null)) {
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        fetchParams.controller.connection.destroy();
        response = await httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch, true);
      }
      if (isAuthenticationFetch) {
      }
      return response;
    }
    async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
      assert3(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
      fetchParams.controller.connection = {
        abort: null,
        destroyed: false,
        destroy(err2) {
          if (!this.destroyed) {
            this.destroyed = true;
            this.abort?.(err2 ?? new AbortError());
          }
        }
      };
      const request3 = fetchParams.request;
      let response = null;
      const timingInfo = fetchParams.timingInfo;
      const httpCache = null;
      if (httpCache == null) {
        request3.cache = "no-store";
      }
      const newConnection = forceNewConnection ? "yes" : "no";
      if (request3.mode === "websocket") {
      } else {
      }
      let requestBody = null;
      if (request3.body == null && fetchParams.processRequestEndOfBody) {
        queueMicrotask(() => fetchParams.processRequestEndOfBody());
      } else if (request3.body != null) {
        const processBodyChunk = async function* (bytes) {
          if (isCancelled(fetchParams)) {
            return;
          }
          yield bytes;
          fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
        };
        const processEndOfBody = () => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (fetchParams.processRequestEndOfBody) {
            fetchParams.processRequestEndOfBody();
          }
        };
        const processBodyError = (e2) => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (e2.name === "AbortError") {
            fetchParams.controller.abort();
          } else {
            fetchParams.controller.terminate(e2);
          }
        };
        requestBody = async function* () {
          try {
            for await (const bytes of request3.body.stream) {
              yield* processBodyChunk(bytes);
            }
            processEndOfBody();
          } catch (err2) {
            processBodyError(err2);
          }
        }();
      }
      try {
        const { body, status: status2, statusText, headersList } = await dispatch({ body: requestBody });
        const iterator = body[Symbol.asyncIterator]();
        fetchParams.controller.next = () => iterator.next();
        response = makeResponse({ status: status2, statusText, headersList });
      } catch (err2) {
        if (err2.name === "AbortError") {
          fetchParams.controller.connection.destroy();
          return makeAppropriateNetworkError(fetchParams);
        }
        return makeNetworkError(err2);
      }
      const pullAlgorithm = () => {
        fetchParams.controller.resume();
      };
      const cancelAlgorithm = () => {
        fetchParams.controller.abort();
      };
      if (!ReadableStream2) {
        ReadableStream2 = __require("stream/web").ReadableStream;
      }
      const stream = new ReadableStream2({
        async start(controller) {
          fetchParams.controller.controller = controller;
        },
        async pull(controller) {
          await pullAlgorithm(controller);
        },
        async cancel(reason) {
          await cancelAlgorithm(reason);
        }
      }, { highWaterMark: 0 });
      response.body = { stream };
      fetchParams.controller.on("terminated", onAborted);
      fetchParams.controller.resume = async () => {
        while (true) {
          let bytes;
          try {
            const { done: done2, value } = await fetchParams.controller.next();
            bytes = done2 ? void 0 : value;
          } catch (err2) {
            if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
              bytes = void 0;
            } else {
              bytes = err2;
            }
          }
          if (bytes === void 0) {
            try {
              fetchParams.controller.controller.close();
            } catch (err2) {
              if (!/Controller is already closed/.test(err2)) {
                throw err2;
              }
            }
            finalizeResponse(fetchParams, response);
            return;
          }
          timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
          if (bytes instanceof Error) {
            fetchParams.controller.terminate(bytes);
            return;
          }
          fetchParams.controller.controller.enqueue(new Uint8Array(bytes));
          if (isErrored(stream)) {
            fetchParams.controller.terminate();
            return;
          }
          if (!fetchParams.controller.controller.desiredSize) {
            return;
          }
        }
      };
      function onAborted(reason) {
        if (isAborted(fetchParams)) {
          response.aborted = true;
          if (isReadable(stream)) {
            fetchParams.controller.controller.error(new AbortError());
          }
        } else {
          if (isReadable(stream)) {
            fetchParams.controller.controller.error(new TypeError("terminated", {
              cause: reason instanceof Error ? reason : void 0
            }));
          }
        }
        fetchParams.controller.connection.destroy();
      }
      return response;
      async function dispatch({ body }) {
        const url2 = requestCurrentURL(request3);
        return new Promise((resolve2, reject2) => fetchParams.controller.dispatcher.dispatch({
          path: url2.pathname + url2.search,
          origin: url2.origin,
          method: request3.method,
          body: fetchParams.controller.dispatcher[kIsMockActive] ? request3.body && request3.body.source : body,
          headers: request3.headersList,
          maxRedirections: 0
        }, {
          body: null,
          abort: null,
          onConnect(abort) {
            const { connection } = fetchParams.controller;
            if (connection.destroyed) {
              abort(new AbortError());
            } else {
              fetchParams.controller.on("terminated", abort);
              this.abort = connection.abort = abort;
            }
          },
          onHeaders(status2, headersList, resume2, statusText) {
            if (status2 < 200) {
              return;
            }
            let codings = [];
            const headers = new Headers();
            for (let n = 0; n < headersList.length; n += 2) {
              const key = headersList[n + 0].toString();
              const val = headersList[n + 1].toString();
              if (key.toLowerCase() === "content-encoding") {
                codings = val.split(",").map((x) => x.trim());
              }
              headers.append(key, val);
            }
            this.body = new Readable2({ read: resume2 });
            const decoders = [];
            for (const coding of codings) {
              if (/(x-)?gzip/.test(coding)) {
                decoders.push(zlib.createGunzip());
              } else if (/(x-)?deflate/.test(coding)) {
                decoders.push(zlib.createInflate());
              } else if (coding === "br") {
                decoders.push(zlib.createBrotliDecompress());
              } else {
                decoders.length = 0;
                break;
              }
            }
            resolve2({
              status: status2,
              statusText,
              headersList: headers[kHeadersList],
              body: decoders.length ? pipeline(this.body, ...decoders, () => {
              }) : this.body.on("error", () => {
              })
            });
            return true;
          },
          onData(chunk) {
            if (fetchParams.controller.dump) {
              return;
            }
            const bytes = chunk;
            timingInfo.encodedBodySize += bytes.byteLength;
            return this.body.push(bytes);
          },
          onComplete() {
            if (this.abort) {
              fetchParams.controller.off("terminated", this.abort);
            }
            fetchParams.controller.ended = true;
            this.body.push(null);
          },
          onError(error2) {
            if (this.abort) {
              fetchParams.controller.off("terminated", this.abort);
            }
            this.body?.destroy(error2);
            fetchParams.controller.terminate(error2);
            reject2(makeNetworkError(error2));
          }
        }));
      }
    }
    module2.exports = fetch3;
  }
});

// node_modules/.pnpm/undici@5.0.0/node_modules/undici/index.js
var require_undici = __commonJS({
  "node_modules/.pnpm/undici@5.0.0/node_modules/undici/index.js"(exports2, module2) {
    "use strict";
    var Client = require_client();
    var Dispatcher = require_dispatcher();
    var errors2 = require_errors();
    var Pool = require_pool();
    var BalancedPool = require_balanced_pool();
    var Agent2 = require_agent();
    var util = require_util();
    var { InvalidArgumentError } = errors2;
    var api = require_api();
    var buildConnector = require_connect();
    var MockClient = require_mock_client();
    var MockAgent = require_mock_agent();
    var MockPool = require_mock_pool();
    var mockErrors = require_mock_errors();
    var ProxyAgent = require_proxy_agent();
    var nodeVersion = process.versions.node.split(".");
    var nodeMajor = Number(nodeVersion[0]);
    var nodeMinor = Number(nodeVersion[1]);
    Object.assign(Dispatcher.prototype, api);
    module2.exports.Dispatcher = Dispatcher;
    module2.exports.Client = Client;
    module2.exports.Pool = Pool;
    module2.exports.BalancedPool = BalancedPool;
    module2.exports.Agent = Agent2;
    module2.exports.ProxyAgent = ProxyAgent;
    module2.exports.buildConnector = buildConnector;
    module2.exports.errors = errors2;
    var globalDispatcher = new Agent2();
    function setGlobalDispatcher(agent) {
      if (!agent || typeof agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument agent must implement Agent");
      }
      globalDispatcher = agent;
    }
    function getGlobalDispatcher() {
      return globalDispatcher;
    }
    function makeDispatcher(fn2) {
      return (url2, opts, handler) => {
        if (typeof opts === "function") {
          handler = opts;
          opts = null;
        }
        if (!url2 || typeof url2 !== "string" && typeof url2 !== "object" && !(url2 instanceof URL)) {
          throw new InvalidArgumentError("invalid url");
        }
        if (opts != null && typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (opts && opts.path != null) {
          if (typeof opts.path !== "string") {
            throw new InvalidArgumentError("invalid opts.path");
          }
          url2 = new URL(opts.path, util.parseOrigin(url2));
        } else {
          if (!opts) {
            opts = typeof url2 === "object" ? url2 : {};
          }
          url2 = util.parseURL(url2);
        }
        const { agent, dispatcher = getGlobalDispatcher() } = opts;
        if (agent) {
          throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
        }
        return fn2.call(dispatcher, {
          ...opts,
          origin: url2.origin,
          path: url2.search ? `${url2.pathname}${url2.search}` : url2.pathname,
          method: opts.method || (opts.body ? "PUT" : "GET")
        }, handler);
      };
    }
    module2.exports.setGlobalDispatcher = setGlobalDispatcher;
    module2.exports.getGlobalDispatcher = getGlobalDispatcher;
    if (nodeMajor > 16 || nodeMajor === 16 && nodeMinor >= 5) {
      let fetchImpl = null;
      module2.exports.fetch = async function fetch3(resource) {
        if (!fetchImpl) {
          fetchImpl = require_fetch();
        }
        const dispatcher = getGlobalDispatcher();
        return fetchImpl.apply(dispatcher, arguments);
      };
      module2.exports.Headers = require_headers().Headers;
      module2.exports.Response = require_response().Response;
      module2.exports.Request = require_request2().Request;
      module2.exports.FormData = require_formdata().FormData;
      module2.exports.File = require_file().File;
    }
    module2.exports.request = makeDispatcher(api.request);
    module2.exports.stream = makeDispatcher(api.stream);
    module2.exports.pipeline = makeDispatcher(api.pipeline);
    module2.exports.connect = makeDispatcher(api.connect);
    module2.exports.upgrade = makeDispatcher(api.upgrade);
    module2.exports.MockClient = MockClient;
    module2.exports.MockPool = MockPool;
    module2.exports.MockAgent = MockAgent;
    module2.exports.mockErrors = mockErrors;
  }
});

// node_modules/.pnpm/cross-undici-fetch@0.2.5/node_modules/cross-undici-fetch/dist/binary-search.js
var require_binary_search = __commonJS({
  "node_modules/.pnpm/cross-undici-fetch@0.2.5/node_modules/cross-undici-fetch/dist/binary-search.js"(exports2, module2) {
    module2.exports = function binarySearch(arr, val) {
      let low = 0;
      let high = Math.floor(arr.length / 2);
      while (high > low) {
        const mid = high + low >>> 1;
        if (val > arr[mid * 2]) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return low * 2;
    };
  }
});

// node_modules/.pnpm/cross-undici-fetch@0.2.5/node_modules/cross-undici-fetch/dist/patch-headers-list.js
var require_patch_headers_list = __commonJS({
  "node_modules/.pnpm/cross-undici-fetch@0.2.5/node_modules/cross-undici-fetch/dist/patch-headers-list.js"(exports2, module2) {
    var { validateHeaderName, validateHeaderValue } = (init_http(), __toCommonJS(http_exports));
    var binarySearch = require_binary_search();
    var {
      InvalidHTTPTokenError,
      HTTPInvalidHeaderValueError
    } = require_errors();
    function normalizeAndValidateHeaderName(name) {
      if (name === void 0) {
        throw new InvalidHTTPTokenError(`Header name ${name}`);
      }
      const normalizedHeaderName = name.toLocaleLowerCase();
      validateHeaderName(normalizedHeaderName);
      return normalizedHeaderName;
    }
    function normalizeAndValidateHeaderValue(name, value) {
      if (value === void 0) {
        throw new HTTPInvalidHeaderValueError(value, name);
      }
      const normalizedHeaderValue = `${value}`.replace(/^[\n\t\r\x20]+|[\n\t\r\x20]+$/g, "");
      validateHeaderValue(name, normalizedHeaderValue);
      return normalizedHeaderValue;
    }
    module2.exports = function patchHeadersList(HeadersList) {
      Object.defineProperties(HeadersList.prototype, {
        append: {
          configurable: true,
          enumerable: true,
          value: function append(name, value) {
            const normalizedName = normalizeAndValidateHeaderName(name);
            const normalizedValue = normalizeAndValidateHeaderValue(name, value);
            const index = binarySearch(this, normalizedName);
            if (this[index] === normalizedName) {
              this[index + 1] += `, ${normalizedValue}`;
            } else {
              this.splice(index, 0, normalizedName, normalizedValue);
            }
          }
        },
        delete: {
          configurable: true,
          enumerable: true,
          value: function headersListDelete(name) {
            const normalizedName = normalizeAndValidateHeaderName(name);
            const index = binarySearch(this, normalizedName);
            if (this[index] === normalizedName) {
              this.splice(index, 2);
            }
          }
        },
        get: {
          configurable: true,
          enumerable: true,
          value: function get2(name) {
            const normalizedName = normalizeAndValidateHeaderName(name);
            const index = binarySearch(this, normalizedName);
            if (this[index] === normalizedName) {
              return this[index + 1];
            }
            return null;
          }
        },
        has: {
          configurable: true,
          enumerable: true,
          value: function has(name) {
            const normalizedName = normalizeAndValidateHeaderName(name);
            const index = binarySearch(this, normalizedName);
            return this[index] === normalizedName;
          }
        },
        set: {
          configurable: true,
          enumerable: true,
          value: function set(name, value) {
            const normalizedName = normalizeAndValidateHeaderName(name);
            const normalizedValue = normalizeAndValidateHeaderValue(name, value);
            const index = binarySearch(this, normalizedName);
            if (this[index] === normalizedName) {
              this[index + 1] = normalizedValue;
            } else {
              this.splice(index, 0, normalizedName, normalizedValue);
            }
          }
        }
      });
    };
  }
});

// node_modules/.pnpm/webidl-conversions@3.0.1/node_modules/webidl-conversions/lib/index.js
var require_lib = __commonJS({
  "node_modules/.pnpm/webidl-conversions@3.0.1/node_modules/webidl-conversions/lib/index.js"(exports2, module2) {
    "use strict";
    var conversions = {};
    module2.exports = conversions;
    function sign(x) {
      return x < 0 ? -1 : 1;
    }
    function evenRound(x) {
      if (x % 1 === 0.5 && (x & 1) === 0) {
        return Math.floor(x);
      } else {
        return Math.round(x);
      }
    }
    function createNumberConversion(bitLength, typeOpts) {
      if (!typeOpts.unsigned) {
        --bitLength;
      }
      const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
      const upperBound = Math.pow(2, bitLength) - 1;
      const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
      const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
      return function(V, opts) {
        if (!opts)
          opts = {};
        let x = +V;
        if (opts.enforceRange) {
          if (!Number.isFinite(x)) {
            throw new TypeError("Argument is not a finite number");
          }
          x = sign(x) * Math.floor(Math.abs(x));
          if (x < lowerBound || x > upperBound) {
            throw new TypeError("Argument is not in byte range");
          }
          return x;
        }
        if (!isNaN(x) && opts.clamp) {
          x = evenRound(x);
          if (x < lowerBound)
            x = lowerBound;
          if (x > upperBound)
            x = upperBound;
          return x;
        }
        if (!Number.isFinite(x) || x === 0) {
          return 0;
        }
        x = sign(x) * Math.floor(Math.abs(x));
        x = x % moduloVal;
        if (!typeOpts.unsigned && x >= moduloBound) {
          return x - moduloVal;
        } else if (typeOpts.unsigned) {
          if (x < 0) {
            x += moduloVal;
          } else if (x === -0) {
            return 0;
          }
        }
        return x;
      };
    }
    conversions["void"] = function() {
      return void 0;
    };
    conversions["boolean"] = function(val) {
      return !!val;
    };
    conversions["byte"] = createNumberConversion(8, { unsigned: false });
    conversions["octet"] = createNumberConversion(8, { unsigned: true });
    conversions["short"] = createNumberConversion(16, { unsigned: false });
    conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
    conversions["long"] = createNumberConversion(32, { unsigned: false });
    conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
    conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
    conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
    conversions["double"] = function(V) {
      const x = +V;
      if (!Number.isFinite(x)) {
        throw new TypeError("Argument is not a finite floating-point value");
      }
      return x;
    };
    conversions["unrestricted double"] = function(V) {
      const x = +V;
      if (isNaN(x)) {
        throw new TypeError("Argument is NaN");
      }
      return x;
    };
    conversions["float"] = conversions["double"];
    conversions["unrestricted float"] = conversions["unrestricted double"];
    conversions["DOMString"] = function(V, opts) {
      if (!opts)
        opts = {};
      if (opts.treatNullAsEmptyString && V === null) {
        return "";
      }
      return String(V);
    };
    conversions["ByteString"] = function(V, opts) {
      const x = String(V);
      let c = void 0;
      for (let i = 0; (c = x.codePointAt(i)) !== void 0; ++i) {
        if (c > 255) {
          throw new TypeError("Argument is not a valid bytestring");
        }
      }
      return x;
    };
    conversions["USVString"] = function(V) {
      const S = String(V);
      const n = S.length;
      const U = [];
      for (let i = 0; i < n; ++i) {
        const c = S.charCodeAt(i);
        if (c < 55296 || c > 57343) {
          U.push(String.fromCodePoint(c));
        } else if (56320 <= c && c <= 57343) {
          U.push(String.fromCodePoint(65533));
        } else {
          if (i === n - 1) {
            U.push(String.fromCodePoint(65533));
          } else {
            const d2 = S.charCodeAt(i + 1);
            if (56320 <= d2 && d2 <= 57343) {
              const a = c & 1023;
              const b = d2 & 1023;
              U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
              ++i;
            } else {
              U.push(String.fromCodePoint(65533));
            }
          }
        }
      }
      return U.join("");
    };
    conversions["Date"] = function(V, opts) {
      if (!(V instanceof Date)) {
        throw new TypeError("Argument is not a Date object");
      }
      if (isNaN(V)) {
        return void 0;
      }
      return V;
    };
    conversions["RegExp"] = function(V, opts) {
      if (!(V instanceof RegExp)) {
        V = new RegExp(V);
      }
      return V;
    };
  }
});

// node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/utils.js"(exports2, module2) {
    "use strict";
    module2.exports.mixin = function mixin(target, source) {
      const keys2 = Object.getOwnPropertyNames(source);
      for (let i = 0; i < keys2.length; ++i) {
        Object.defineProperty(target, keys2[i], Object.getOwnPropertyDescriptor(source, keys2[i]));
      }
    };
    module2.exports.wrapperSymbol = Symbol("wrapper");
    module2.exports.implSymbol = Symbol("impl");
    module2.exports.wrapperForImpl = function(impl) {
      return impl[module2.exports.wrapperSymbol];
    };
    module2.exports.implForWrapper = function(wrapper) {
      return wrapper[module2.exports.implSymbol];
    };
  }
});

// node_modules/.pnpm/tr46@0.0.3/node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS({
  "node_modules/.pnpm/tr46@0.0.3/node_modules/tr46/lib/mappingTable.json"(exports2, module2) {
    module2.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1e3, 1e3], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6e3], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8e3, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8e3]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9e3], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [3e4]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13e3, 13e3], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43e3, 43e3], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64e3, 64e3], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66e3, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[12e4, 12e4], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128e3, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23e3]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149e3]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32e3]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195e3, 195e3], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [4e4]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918e3, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
  }
});

// node_modules/.pnpm/tr46@0.0.3/node_modules/tr46/index.js
var require_tr46 = __commonJS({
  "node_modules/.pnpm/tr46@0.0.3/node_modules/tr46/index.js"(exports2, module2) {
    "use strict";
    var punycode = (init_punycode(), __toCommonJS(punycode_exports));
    var mappingTable = require_mappingTable();
    var PROCESSING_OPTIONS = {
      TRANSITIONAL: 0,
      NONTRANSITIONAL: 1
    };
    function normalize(str) {
      return str.split("\0").map(function(s) {
        return s.normalize("NFC");
      }).join("\0");
    }
    function findStatus(val) {
      var start = 0;
      var end = mappingTable.length - 1;
      while (start <= end) {
        var mid = Math.floor((start + end) / 2);
        var target = mappingTable[mid];
        if (target[0][0] <= val && target[0][1] >= val) {
          return target;
        } else if (target[0][0] > val) {
          end = mid - 1;
        } else {
          start = mid + 1;
        }
      }
      return null;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    function countSymbols(string) {
      return string.replace(regexAstralSymbols, "_").length;
    }
    function mapChars(domain_name, useSTD3, processing_option) {
      var hasError = false;
      var processed = "";
      var len = countSymbols(domain_name);
      for (var i = 0; i < len; ++i) {
        var codePoint = domain_name.codePointAt(i);
        var status2 = findStatus(codePoint);
        switch (status2[1]) {
          case "disallowed":
            hasError = true;
            processed += String.fromCodePoint(codePoint);
            break;
          case "ignored":
            break;
          case "mapped":
            processed += String.fromCodePoint.apply(String, status2[2]);
            break;
          case "deviation":
            if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
              processed += String.fromCodePoint.apply(String, status2[2]);
            } else {
              processed += String.fromCodePoint(codePoint);
            }
            break;
          case "valid":
            processed += String.fromCodePoint(codePoint);
            break;
          case "disallowed_STD3_mapped":
            if (useSTD3) {
              hasError = true;
              processed += String.fromCodePoint(codePoint);
            } else {
              processed += String.fromCodePoint.apply(String, status2[2]);
            }
            break;
          case "disallowed_STD3_valid":
            if (useSTD3) {
              hasError = true;
            }
            processed += String.fromCodePoint(codePoint);
            break;
        }
      }
      return {
        string: processed,
        error: hasError
      };
    }
    var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
    function validateLabel(label, processing_option) {
      if (label.substr(0, 4) === "xn--") {
        label = punycode.toUnicode(label);
        processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
      }
      var error2 = false;
      if (normalize(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
        error2 = true;
      }
      var len = countSymbols(label);
      for (var i = 0; i < len; ++i) {
        var status2 = findStatus(label.codePointAt(i));
        if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status2[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status2[1] !== "valid" && status2[1] !== "deviation") {
          error2 = true;
          break;
        }
      }
      return {
        label,
        error: error2
      };
    }
    function processing(domain_name, useSTD3, processing_option) {
      var result = mapChars(domain_name, useSTD3, processing_option);
      result.string = normalize(result.string);
      var labels = result.string.split(".");
      for (var i = 0; i < labels.length; ++i) {
        try {
          var validation = validateLabel(labels[i]);
          labels[i] = validation.label;
          result.error = result.error || validation.error;
        } catch (e2) {
          result.error = true;
        }
      }
      return {
        string: labels.join("."),
        error: result.error
      };
    }
    module2.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
      var result = processing(domain_name, useSTD3, processing_option);
      var labels = result.string.split(".");
      labels = labels.map(function(l) {
        try {
          return punycode.toASCII(l);
        } catch (e2) {
          result.error = true;
          return l;
        }
      });
      if (verifyDnsLength) {
        var total = labels.slice(0, labels.length - 1).join(".").length;
        if (total.length > 253 || total.length === 0) {
          result.error = true;
        }
        for (var i = 0; i < labels.length; ++i) {
          if (labels.length > 63 || labels.length === 0) {
            result.error = true;
            break;
          }
        }
      }
      if (result.error)
        return null;
      return labels.join(".");
    };
    module2.exports.toUnicode = function(domain_name, useSTD3) {
      var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
      return {
        domain: result.string,
        error: result.error
      };
    };
    module2.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
  }
});

// node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS({
  "node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js"(exports2, module2) {
    "use strict";
    var punycode = (init_punycode(), __toCommonJS(punycode_exports));
    var tr46 = require_tr46();
    var specialSchemes = {
      ftp: 21,
      file: null,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var failure = Symbol("failure");
    function countSymbols(str) {
      return punycode.ucs2.decode(str).length;
    }
    function at(input, idx) {
      const c = input[idx];
      return isNaN(c) ? void 0 : String.fromCodePoint(c);
    }
    function isASCIIDigit(c) {
      return c >= 48 && c <= 57;
    }
    function isASCIIAlpha(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 122;
    }
    function isASCIIAlphanumeric(c) {
      return isASCIIAlpha(c) || isASCIIDigit(c);
    }
    function isASCIIHex(c) {
      return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
    }
    function isSingleDot(buffer) {
      return buffer === "." || buffer.toLowerCase() === "%2e";
    }
    function isDoubleDot(buffer) {
      buffer = buffer.toLowerCase();
      return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
    }
    function isWindowsDriveLetterCodePoints(cp1, cp2) {
      return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
    }
    function isWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
    }
    function isNormalizedWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
    }
    function containsForbiddenHostCodePoint(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function containsForbiddenHostCodePointExcludingPercent(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function isSpecialScheme(scheme) {
      return specialSchemes[scheme] !== void 0;
    }
    function isSpecial(url2) {
      return isSpecialScheme(url2.scheme);
    }
    function defaultPort(scheme) {
      return specialSchemes[scheme];
    }
    function percentEncode(c) {
      let hex = c.toString(16).toUpperCase();
      if (hex.length === 1) {
        hex = "0" + hex;
      }
      return "%" + hex;
    }
    function utf8PercentEncode(c) {
      const buf = new Buffer(c);
      let str = "";
      for (let i = 0; i < buf.length; ++i) {
        str += percentEncode(buf[i]);
      }
      return str;
    }
    function utf8PercentDecode(str) {
      const input = new Buffer(str);
      const output = [];
      for (let i = 0; i < input.length; ++i) {
        if (input[i] !== 37) {
          output.push(input[i]);
        } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
          output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
          i += 2;
        } else {
          output.push(input[i]);
        }
      }
      return new Buffer(output).toString();
    }
    function isC0ControlPercentEncode(c) {
      return c <= 31 || c > 126;
    }
    var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
    function isPathPercentEncode(c) {
      return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
    }
    var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
    function isUserinfoPercentEncode(c) {
      return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
    }
    function percentEncodeChar(c, encodeSetPredicate) {
      const cStr = String.fromCodePoint(c);
      if (encodeSetPredicate(c)) {
        return utf8PercentEncode(cStr);
      }
      return cStr;
    }
    function parseIPv4Number(input) {
      let R = 10;
      if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
        input = input.substring(2);
        R = 16;
      } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R = 8;
      }
      if (input === "") {
        return 0;
      }
      const regex2 = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
      if (regex2.test(input)) {
        return failure;
      }
      return parseInt(input, R);
    }
    function parseIPv4(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
          parts.pop();
        }
      }
      if (parts.length > 4) {
        return input;
      }
      const numbers = [];
      for (const part of parts) {
        if (part === "") {
          return input;
        }
        const n = parseIPv4Number(part);
        if (n === failure) {
          return input;
        }
        numbers.push(n);
      }
      for (let i = 0; i < numbers.length - 1; ++i) {
        if (numbers[i] > 255) {
          return failure;
        }
      }
      if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
        return failure;
      }
      let ipv4 = numbers.pop();
      let counter = 0;
      for (const n of numbers) {
        ipv4 += n * Math.pow(256, 3 - counter);
        ++counter;
      }
      return ipv4;
    }
    function serializeIPv4(address) {
      let output = "";
      let n = address;
      for (let i = 1; i <= 4; ++i) {
        output = String(n % 256) + output;
        if (i !== 4) {
          output = "." + output;
        }
        n = Math.floor(n / 256);
      }
      return output;
    }
    function parseIPv6(input) {
      const address = [0, 0, 0, 0, 0, 0, 0, 0];
      let pieceIndex = 0;
      let compress = null;
      let pointer = 0;
      input = punycode.ucs2.decode(input);
      if (input[pointer] === 58) {
        if (input[pointer + 1] !== 58) {
          return failure;
        }
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
      }
      while (pointer < input.length) {
        if (pieceIndex === 8) {
          return failure;
        }
        if (input[pointer] === 58) {
          if (compress !== null) {
            return failure;
          }
          ++pointer;
          ++pieceIndex;
          compress = pieceIndex;
          continue;
        }
        let value = 0;
        let length = 0;
        while (length < 4 && isASCIIHex(input[pointer])) {
          value = value * 16 + parseInt(at(input, pointer), 16);
          ++pointer;
          ++length;
        }
        if (input[pointer] === 46) {
          if (length === 0) {
            return failure;
          }
          pointer -= length;
          if (pieceIndex > 6) {
            return failure;
          }
          let numbersSeen = 0;
          while (input[pointer] !== void 0) {
            let ipv4Piece = null;
            if (numbersSeen > 0) {
              if (input[pointer] === 46 && numbersSeen < 4) {
                ++pointer;
              } else {
                return failure;
              }
            }
            if (!isASCIIDigit(input[pointer])) {
              return failure;
            }
            while (isASCIIDigit(input[pointer])) {
              const number = parseInt(at(input, pointer));
              if (ipv4Piece === null) {
                ipv4Piece = number;
              } else if (ipv4Piece === 0) {
                return failure;
              } else {
                ipv4Piece = ipv4Piece * 10 + number;
              }
              if (ipv4Piece > 255) {
                return failure;
              }
              ++pointer;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            ++numbersSeen;
            if (numbersSeen === 2 || numbersSeen === 4) {
              ++pieceIndex;
            }
          }
          if (numbersSeen !== 4) {
            return failure;
          }
          break;
        } else if (input[pointer] === 58) {
          ++pointer;
          if (input[pointer] === void 0) {
            return failure;
          }
        } else if (input[pointer] !== void 0) {
          return failure;
        }
        address[pieceIndex] = value;
        ++pieceIndex;
      }
      if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          const temp = address[compress + swaps - 1];
          address[compress + swaps - 1] = address[pieceIndex];
          address[pieceIndex] = temp;
          --pieceIndex;
          --swaps;
        }
      } else if (compress === null && pieceIndex !== 8) {
        return failure;
      }
      return address;
    }
    function serializeIPv6(address) {
      let output = "";
      const seqResult = findLongestZeroSequence(address);
      const compress = seqResult.idx;
      let ignore0 = false;
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
        if (ignore0 && address[pieceIndex] === 0) {
          continue;
        } else if (ignore0) {
          ignore0 = false;
        }
        if (compress === pieceIndex) {
          const separator = pieceIndex === 0 ? "::" : ":";
          output += separator;
          ignore0 = true;
          continue;
        }
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
          output += ":";
        }
      }
      return output;
    }
    function parseHost2(input, isSpecialArg) {
      if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
          return failure;
        }
        return parseIPv6(input.substring(1, input.length - 1));
      }
      if (!isSpecialArg) {
        return parseOpaqueHost(input);
      }
      const domain2 = utf8PercentDecode(input);
      const asciiDomain = tr46.toASCII(domain2, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
      if (asciiDomain === null) {
        return failure;
      }
      if (containsForbiddenHostCodePoint(asciiDomain)) {
        return failure;
      }
      const ipv4Host = parseIPv4(asciiDomain);
      if (typeof ipv4Host === "number" || ipv4Host === failure) {
        return ipv4Host;
      }
      return asciiDomain;
    }
    function parseOpaqueHost(input) {
      if (containsForbiddenHostCodePointExcludingPercent(input)) {
        return failure;
      }
      let output = "";
      const decoded = punycode.ucs2.decode(input);
      for (let i = 0; i < decoded.length; ++i) {
        output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
      }
      return output;
    }
    function findLongestZeroSequence(arr) {
      let maxIdx = null;
      let maxLen = 1;
      let currStart = null;
      let currLen = 0;
      for (let i = 0; i < arr.length; ++i) {
        if (arr[i] !== 0) {
          if (currLen > maxLen) {
            maxIdx = currStart;
            maxLen = currLen;
          }
          currStart = null;
          currLen = 0;
        } else {
          if (currStart === null) {
            currStart = i;
          }
          ++currLen;
        }
      }
      if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }
      return {
        idx: maxIdx,
        len: maxLen
      };
    }
    function serializeHost(host) {
      if (typeof host === "number") {
        return serializeIPv4(host);
      }
      if (host instanceof Array) {
        return "[" + serializeIPv6(host) + "]";
      }
      return host;
    }
    function trimControlChars(url2) {
      return url2.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
    }
    function trimTabAndNewline(url2) {
      return url2.replace(/\u0009|\u000A|\u000D/g, "");
    }
    function shortenPath(url2) {
      const path = url2.path;
      if (path.length === 0) {
        return;
      }
      if (url2.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
        return;
      }
      path.pop();
    }
    function includesCredentials(url2) {
      return url2.username !== "" || url2.password !== "";
    }
    function cannotHaveAUsernamePasswordPort(url2) {
      return url2.host === null || url2.host === "" || url2.cannotBeABaseURL || url2.scheme === "file";
    }
    function isNormalizedWindowsDriveLetter(string) {
      return /^[A-Za-z]:$/.test(string);
    }
    function URLStateMachine(input, base2, encodingOverride, url2, stateOverride) {
      this.pointer = 0;
      this.input = input;
      this.base = base2 || null;
      this.encodingOverride = encodingOverride || "utf-8";
      this.stateOverride = stateOverride;
      this.url = url2;
      this.failure = false;
      this.parseError = false;
      if (!this.url) {
        this.url = {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null,
          cannotBeABaseURL: false
        };
        const res2 = trimControlChars(this.input);
        if (res2 !== this.input) {
          this.parseError = true;
        }
        this.input = res2;
      }
      const res = trimTabAndNewline(this.input);
      if (res !== this.input) {
        this.parseError = true;
      }
      this.input = res;
      this.state = stateOverride || "scheme start";
      this.buffer = "";
      this.atFlag = false;
      this.arrFlag = false;
      this.passwordTokenSeenFlag = false;
      this.input = punycode.ucs2.decode(this.input);
      for (; this.pointer <= this.input.length; ++this.pointer) {
        const c = this.input[this.pointer];
        const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c);
        const ret = this["parse " + this.state](c, cStr);
        if (!ret) {
          break;
        } else if (ret === failure) {
          this.failure = true;
          break;
        }
      }
    }
    URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
      if (isASCIIAlpha(c)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
      } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
      if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
        this.buffer += cStr.toLowerCase();
      } else if (c === 58) {
        if (this.stateOverride) {
          if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
            return false;
          }
          if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
            return false;
          }
          if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
            return false;
          }
          if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
            return false;
          }
        }
        this.url.scheme = this.buffer;
        this.buffer = "";
        if (this.stateOverride) {
          return false;
        }
        if (this.url.scheme === "file") {
          if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
            this.parseError = true;
          }
          this.state = "file";
        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
          this.state = "special relative or authority";
        } else if (isSpecial(this.url)) {
          this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === 47) {
          this.state = "path or authority";
          ++this.pointer;
        } else {
          this.url.cannotBeABaseURL = true;
          this.url.path.push("");
          this.state = "cannot-be-a-base-URL path";
        }
      } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
      if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {
        return failure;
      } else if (this.base.cannotBeABaseURL && c === 35) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.url.cannotBeABaseURL = true;
        this.state = "fragment";
      } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
      } else {
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
      if (c === 47) {
        this.state = "authority";
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
      this.url.scheme = this.base.scheme;
      if (isNaN(c)) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c === 47) {
        this.state = "relative slash";
      } else if (c === 63) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else if (isSpecial(this.url) && c === 92) {
        this.parseError = true;
        this.state = "relative slash";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice(0, this.base.path.length - 1);
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
      if (isSpecial(this.url) && (c === 47 || c === 92)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "special authority ignore slashes";
      } else if (c === 47) {
        this.state = "authority";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "special authority ignore slashes";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
      if (c !== 47 && c !== 92) {
        this.state = "authority";
        --this.pointer;
      } else {
        this.parseError = true;
      }
      return true;
    };
    URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
      if (c === 64) {
        this.parseError = true;
        if (this.atFlag) {
          this.buffer = "%40" + this.buffer;
        }
        this.atFlag = true;
        const len = countSymbols(this.buffer);
        for (let pointer = 0; pointer < len; ++pointer) {
          const codePoint = this.buffer.codePointAt(pointer);
          if (codePoint === 58 && !this.passwordTokenSeenFlag) {
            this.passwordTokenSeenFlag = true;
            continue;
          }
          const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
          if (this.passwordTokenSeenFlag) {
            this.url.password += encodedCodePoints;
          } else {
            this.url.username += encodedCodePoints;
          }
        }
        this.buffer = "";
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        if (this.atFlag && this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
      if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
      } else if (c === 58 && !this.arrFlag) {
        if (this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        const host = parseHost2(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
        if (this.stateOverride === "hostname") {
          return false;
        }
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
          this.parseError = true;
          return failure;
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
          this.parseError = true;
          return false;
        }
        const host = parseHost2(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
          return false;
        }
      } else {
        if (c === 91) {
          this.arrFlag = true;
        } else if (c === 93) {
          this.arrFlag = false;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
      if (isASCIIDigit(c)) {
        this.buffer += cStr;
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
        if (this.buffer !== "") {
          const port = parseInt(this.buffer);
          if (port > Math.pow(2, 16) - 1) {
            this.parseError = true;
            return failure;
          }
          this.url.port = port === defaultPort(this.url.scheme) ? null : port;
          this.buffer = "";
        }
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([47, 92, 63, 35]);
    URLStateMachine.prototype["parse file"] = function parseFile(c) {
      this.url.scheme = "file";
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file slash";
      } else if (this.base !== null && this.base.scheme === "file") {
        if (isNaN(c)) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
        } else if (c === 63) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = "";
          this.state = "query";
        } else if (c === 35) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (this.input.length - this.pointer - 1 === 0 || !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            shortenPath(this.url);
          } else {
            this.parseError = true;
          }
          this.state = "path";
          --this.pointer;
        }
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file host";
      } else {
        if (this.base !== null && this.base.scheme === "file") {
          if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
            this.url.path.push(this.base.path[0]);
          } else {
            this.url.host = this.base.host;
          }
        }
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
      if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
          this.parseError = true;
          this.state = "path";
        } else if (this.buffer === "") {
          this.url.host = "";
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
        } else {
          let host = parseHost2(this.buffer, isSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          if (host === "localhost") {
            host = "";
          }
          this.url.host = host;
          if (this.stateOverride) {
            return false;
          }
          this.buffer = "";
          this.state = "path start";
        }
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
      if (isSpecial(this.url)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "path";
        if (c !== 47 && c !== 92) {
          --this.pointer;
        }
      } else if (!this.stateOverride && c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (!this.stateOverride && c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c !== void 0) {
        this.state = "path";
        if (c !== 47) {
          --this.pointer;
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse path"] = function parsePath(c) {
      if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
        if (isSpecial(this.url) && c === 92) {
          this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
          shortenPath(this.url);
          if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
            this.url.path.push("");
          }
        } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {
          this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
          if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
            if (this.url.host !== "" && this.url.host !== null) {
              this.parseError = true;
              this.url.host = "";
            }
            this.buffer = this.buffer[0] + ":";
          }
          this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (this.url.scheme === "file" && (c === void 0 || c === 63 || c === 35)) {
          while (this.url.path.length > 1 && this.url.path[0] === "") {
            this.parseError = true;
            this.url.path.shift();
          }
        }
        if (c === 63) {
          this.url.query = "";
          this.state = "query";
        }
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += percentEncodeChar(c, isPathPercentEncode);
      }
      return true;
    };
    URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
      if (c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else {
        if (!isNaN(c) && c !== 37) {
          this.parseError = true;
        }
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        if (!isNaN(c)) {
          this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
      if (isNaN(c) || !this.stateOverride && c === 35) {
        if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
          this.encodingOverride = "utf-8";
        }
        const buffer = new Buffer(this.buffer);
        for (let i = 0; i < buffer.length; ++i) {
          if (buffer[i] < 33 || buffer[i] > 126 || buffer[i] === 34 || buffer[i] === 35 || buffer[i] === 60 || buffer[i] === 62) {
            this.url.query += percentEncode(buffer[i]);
          } else {
            this.url.query += String.fromCodePoint(buffer[i]);
          }
        }
        this.buffer = "";
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
      if (isNaN(c)) {
      } else if (c === 0) {
        this.parseError = true;
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
      }
      return true;
    };
    function serializeURL(url2, excludeFragment) {
      let output = url2.scheme + ":";
      if (url2.host !== null) {
        output += "//";
        if (url2.username !== "" || url2.password !== "") {
          output += url2.username;
          if (url2.password !== "") {
            output += ":" + url2.password;
          }
          output += "@";
        }
        output += serializeHost(url2.host);
        if (url2.port !== null) {
          output += ":" + url2.port;
        }
      } else if (url2.host === null && url2.scheme === "file") {
        output += "//";
      }
      if (url2.cannotBeABaseURL) {
        output += url2.path[0];
      } else {
        for (const string of url2.path) {
          output += "/" + string;
        }
      }
      if (url2.query !== null) {
        output += "?" + url2.query;
      }
      if (!excludeFragment && url2.fragment !== null) {
        output += "#" + url2.fragment;
      }
      return output;
    }
    function serializeOrigin(tuple) {
      let result = tuple.scheme + "://";
      result += serializeHost(tuple.host);
      if (tuple.port !== null) {
        result += ":" + tuple.port;
      }
      return result;
    }
    module2.exports.serializeURL = serializeURL;
    module2.exports.serializeURLOrigin = function(url2) {
      switch (url2.scheme) {
        case "blob":
          try {
            return module2.exports.serializeURLOrigin(module2.exports.parseURL(url2.path[0]));
          } catch (e2) {
            return "null";
          }
        case "ftp":
        case "gopher":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return serializeOrigin({
            scheme: url2.scheme,
            host: url2.host,
            port: url2.port
          });
        case "file":
          return "file://";
        default:
          return "null";
      }
    };
    module2.exports.basicURLParse = function(input, options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      const usm = new URLStateMachine(input, options2.baseURL, options2.encodingOverride, options2.url, options2.stateOverride);
      if (usm.failure) {
        return "failure";
      }
      return usm.url;
    };
    module2.exports.setTheUsername = function(url2, username) {
      url2.username = "";
      const decoded = punycode.ucs2.decode(username);
      for (let i = 0; i < decoded.length; ++i) {
        url2.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
      }
    };
    module2.exports.setThePassword = function(url2, password) {
      url2.password = "";
      const decoded = punycode.ucs2.decode(password);
      for (let i = 0; i < decoded.length; ++i) {
        url2.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
      }
    };
    module2.exports.serializeHost = serializeHost;
    module2.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
    module2.exports.serializeInteger = function(integer) {
      return String(integer);
    };
    module2.exports.parseURL = function(input, options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      return module2.exports.basicURLParse(input, { baseURL: options2.baseURL, encodingOverride: options2.encodingOverride });
    };
  }
});

// node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS({
  "node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL-impl.js"(exports2) {
    "use strict";
    var usm = require_url_state_machine();
    exports2.implementation = class URLImpl {
      constructor(constructorArgs) {
        const url2 = constructorArgs[0];
        const base2 = constructorArgs[1];
        let parsedBase = null;
        if (base2 !== void 0) {
          parsedBase = usm.basicURLParse(base2);
          if (parsedBase === "failure") {
            throw new TypeError("Invalid base URL");
          }
        }
        const parsedURL = usm.basicURLParse(url2, { baseURL: parsedBase });
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get href() {
        return usm.serializeURL(this._url);
      }
      set href(v) {
        const parsedURL = usm.basicURLParse(v);
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get origin() {
        return usm.serializeURLOrigin(this._url);
      }
      get protocol() {
        return this._url.scheme + ":";
      }
      set protocol(v) {
        usm.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" });
      }
      get username() {
        return this._url.username;
      }
      set username(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setTheUsername(this._url, v);
      }
      get password() {
        return this._url.password;
      }
      set password(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setThePassword(this._url, v);
      }
      get host() {
        const url2 = this._url;
        if (url2.host === null) {
          return "";
        }
        if (url2.port === null) {
          return usm.serializeHost(url2.host);
        }
        return usm.serializeHost(url2.host) + ":" + usm.serializeInteger(url2.port);
      }
      set host(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
      }
      get hostname() {
        if (this._url.host === null) {
          return "";
        }
        return usm.serializeHost(this._url.host);
      }
      set hostname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
      }
      get port() {
        if (this._url.port === null) {
          return "";
        }
        return usm.serializeInteger(this._url.port);
      }
      set port(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        if (v === "") {
          this._url.port = null;
        } else {
          usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
        }
      }
      get pathname() {
        if (this._url.cannotBeABaseURL) {
          return this._url.path[0];
        }
        if (this._url.path.length === 0) {
          return "";
        }
        return "/" + this._url.path.join("/");
      }
      set pathname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        this._url.path = [];
        usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
      }
      get search() {
        if (this._url.query === null || this._url.query === "") {
          return "";
        }
        return "?" + this._url.query;
      }
      set search(v) {
        const url2 = this._url;
        if (v === "") {
          url2.query = null;
          return;
        }
        const input = v[0] === "?" ? v.substring(1) : v;
        url2.query = "";
        usm.basicURLParse(input, { url: url2, stateOverride: "query" });
      }
      get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
          return "";
        }
        return "#" + this._url.fragment;
      }
      set hash(v) {
        if (v === "") {
          this._url.fragment = null;
          return;
        }
        const input = v[0] === "#" ? v.substring(1) : v;
        this._url.fragment = "";
        usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
      }
      toJSON() {
        return this.href;
      }
    };
  }
});

// node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS({
  "node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL.js"(exports2, module2) {
    "use strict";
    var conversions = require_lib();
    var utils = require_utils2();
    var Impl = require_URL_impl();
    var impl = utils.implSymbol;
    function URL2(url2) {
      if (!this || this[impl] || !(this instanceof URL2)) {
        throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
      }
      if (arguments.length < 1) {
        throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
      }
      const args = [];
      for (let i = 0; i < arguments.length && i < 2; ++i) {
        args[i] = arguments[i];
      }
      args[0] = conversions["USVString"](args[0]);
      if (args[1] !== void 0) {
        args[1] = conversions["USVString"](args[1]);
      }
      module2.exports.setup(this, args);
    }
    URL2.prototype.toJSON = function toJSON() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      const args = [];
      for (let i = 0; i < arguments.length && i < 0; ++i) {
        args[i] = arguments[i];
      }
      return this[impl].toJSON.apply(this[impl], args);
    };
    Object.defineProperty(URL2.prototype, "href", {
      get() {
        return this[impl].href;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].href = V;
      },
      enumerable: true,
      configurable: true
    });
    URL2.prototype.toString = function() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      return this.href;
    };
    Object.defineProperty(URL2.prototype, "origin", {
      get() {
        return this[impl].origin;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "protocol", {
      get() {
        return this[impl].protocol;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].protocol = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "username", {
      get() {
        return this[impl].username;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].username = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "password", {
      get() {
        return this[impl].password;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].password = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "host", {
      get() {
        return this[impl].host;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].host = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "hostname", {
      get() {
        return this[impl].hostname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hostname = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "port", {
      get() {
        return this[impl].port;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].port = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "pathname", {
      get() {
        return this[impl].pathname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].pathname = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "search", {
      get() {
        return this[impl].search;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].search = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "hash", {
      get() {
        return this[impl].hash;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hash = V;
      },
      enumerable: true,
      configurable: true
    });
    module2.exports = {
      is(obj) {
        return !!obj && obj[impl] instanceof Impl.implementation;
      },
      create(constructorArgs, privateData) {
        let obj = Object.create(URL2.prototype);
        this.setup(obj, constructorArgs, privateData);
        return obj;
      },
      setup(obj, constructorArgs, privateData) {
        if (!privateData)
          privateData = {};
        privateData.wrapper = obj;
        obj[impl] = new Impl.implementation(constructorArgs, privateData);
        obj[impl][utils.wrapperSymbol] = obj;
      },
      interface: URL2,
      expose: {
        Window: { URL: URL2 },
        Worker: { URL: URL2 }
      }
    };
  }
});

// node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS({
  "node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/public-api.js"(exports2) {
    "use strict";
    exports2.URL = require_URL().interface;
    exports2.serializeURL = require_url_state_machine().serializeURL;
    exports2.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
    exports2.basicURLParse = require_url_state_machine().basicURLParse;
    exports2.setTheUsername = require_url_state_machine().setTheUsername;
    exports2.setThePassword = require_url_state_machine().setThePassword;
    exports2.serializeHost = require_url_state_machine().serializeHost;
    exports2.serializeInteger = require_url_state_machine().serializeInteger;
    exports2.parseURL = require_url_state_machine().parseURL;
  }
});

// node_modules/.pnpm/node-fetch@2.6.7/node_modules/node-fetch/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/.pnpm/node-fetch@2.6.7/node_modules/node-fetch/lib/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var Stream2 = _interopDefault((init_stream(), __toCommonJS(stream_exports)));
    var http = _interopDefault((init_http(), __toCommonJS(http_exports)));
    var Url2 = _interopDefault((init_url(), __toCommonJS(url_exports)));
    var whatwgUrl = _interopDefault(require_public_api());
    var https2 = _interopDefault((init_http(), __toCommonJS(http_exports)));
    var zlib = _interopDefault((init_zlib(), __toCommonJS(zlib_exports)));
    var Readable2 = Stream2.Readable;
    var BUFFER = Symbol("buffer");
    var TYPE3 = Symbol("type");
    var Blob = class {
      constructor() {
        this[TYPE3] = "";
        const blobParts = arguments[0];
        const options2 = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
          const a = blobParts;
          const length = Number(a.length);
          for (let i = 0; i < length; i++) {
            const element = a[i];
            let buffer;
            if (element instanceof Buffer) {
              buffer = element;
            } else if (ArrayBuffer.isView(element)) {
              buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
            } else if (element instanceof ArrayBuffer) {
              buffer = Buffer.from(element);
            } else if (element instanceof Blob) {
              buffer = element[BUFFER];
            } else {
              buffer = Buffer.from(typeof element === "string" ? element : String(element));
            }
            size += buffer.length;
            buffers.push(buffer);
          }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type = options2 && options2.type !== void 0 && String(options2.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
          this[TYPE3] = type;
        }
      }
      get size() {
        return this[BUFFER].length;
      }
      get type() {
        return this[TYPE3];
      }
      text() {
        return Promise.resolve(this[BUFFER].toString());
      }
      arrayBuffer() {
        const buf = this[BUFFER];
        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        return Promise.resolve(ab);
      }
      stream() {
        const readable = new Readable2();
        readable._read = function() {
        };
        readable.push(this[BUFFER]);
        readable.push(null);
        return readable;
      }
      toString() {
        return "[object Blob]";
      }
      slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === void 0) {
          relativeStart = 0;
        } else if (start < 0) {
          relativeStart = Math.max(size + start, 0);
        } else {
          relativeStart = Math.min(start, size);
        }
        if (end === void 0) {
          relativeEnd = size;
        } else if (end < 0) {
          relativeEnd = Math.max(size + end, 0);
        } else {
          relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new Blob([], { type: arguments[2] });
        blob[BUFFER] = slicedBuffer;
        return blob;
      }
    };
    Object.defineProperties(Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function FetchError(message, type, systemError) {
      Error.call(this, message);
      this.message = message;
      this.type = type;
      if (systemError) {
        this.code = this.errno = systemError.code;
      }
      Error.captureStackTrace(this, this.constructor);
    }
    FetchError.prototype = Object.create(Error.prototype);
    FetchError.prototype.constructor = FetchError;
    FetchError.prototype.name = "FetchError";
    var convert;
    try {
      convert = __require("encoding").convert;
    } catch (e2) {
    }
    var INTERNALS = Symbol("Body internals");
    var PassThrough2 = Stream2.PassThrough;
    function Body(body) {
      var _this = this;
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
      let size = _ref$size === void 0 ? 0 : _ref$size;
      var _ref$timeout = _ref.timeout;
      let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
      if (body == null) {
        body = null;
      } else if (isURLSearchParams(body)) {
        body = Buffer.from(body.toString());
      } else if (isBlob(body))
        ;
      else if (Buffer.isBuffer(body))
        ;
      else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        body = Buffer.from(body);
      } else if (ArrayBuffer.isView(body)) {
        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
      } else if (body instanceof Stream2)
        ;
      else {
        body = Buffer.from(String(body));
      }
      this[INTERNALS] = {
        body,
        disturbed: false,
        error: null
      };
      this.size = size;
      this.timeout = timeout;
      if (body instanceof Stream2) {
        body.on("error", function(err2) {
          const error2 = err2.name === "AbortError" ? err2 : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err2.message}`, "system", err2);
          _this[INTERNALS].error = error2;
        });
      }
    }
    Body.prototype = {
      get body() {
        return this[INTERNALS].body;
      },
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      },
      arrayBuffer() {
        return consumeBody.call(this).then(function(buf) {
          return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
      },
      blob() {
        let ct2 = this.headers && this.headers.get("content-type") || "";
        return consumeBody.call(this).then(function(buf) {
          return Object.assign(new Blob([], {
            type: ct2.toLowerCase()
          }), {
            [BUFFER]: buf
          });
        });
      },
      json() {
        var _this2 = this;
        return consumeBody.call(this).then(function(buffer) {
          try {
            return JSON.parse(buffer.toString());
          } catch (err2) {
            return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err2.message}`, "invalid-json"));
          }
        });
      },
      text() {
        return consumeBody.call(this).then(function(buffer) {
          return buffer.toString();
        });
      },
      buffer() {
        return consumeBody.call(this);
      },
      textConverted() {
        var _this3 = this;
        return consumeBody.call(this).then(function(buffer) {
          return convertBody(buffer, _this3.headers);
        });
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    Body.mixIn = function(proto) {
      for (const name of Object.getOwnPropertyNames(Body.prototype)) {
        if (!(name in proto)) {
          const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
          Object.defineProperty(proto, name, desc);
        }
      }
    };
    function consumeBody() {
      var _this4 = this;
      if (this[INTERNALS].disturbed) {
        return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
      }
      this[INTERNALS].disturbed = true;
      if (this[INTERNALS].error) {
        return Body.Promise.reject(this[INTERNALS].error);
      }
      let body = this.body;
      if (body === null) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      if (isBlob(body)) {
        body = body.stream();
      }
      if (Buffer.isBuffer(body)) {
        return Body.Promise.resolve(body);
      }
      if (!(body instanceof Stream2)) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      let accum = [];
      let accumBytes = 0;
      let abort = false;
      return new Body.Promise(function(resolve2, reject2) {
        let resTimeout;
        if (_this4.timeout) {
          resTimeout = setTimeout(function() {
            abort = true;
            reject2(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
          }, _this4.timeout);
        }
        body.on("error", function(err2) {
          if (err2.name === "AbortError") {
            abort = true;
            reject2(err2);
          } else {
            reject2(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err2.message}`, "system", err2));
          }
        });
        body.on("data", function(chunk) {
          if (abort || chunk === null) {
            return;
          }
          if (_this4.size && accumBytes + chunk.length > _this4.size) {
            abort = true;
            reject2(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
            return;
          }
          accumBytes += chunk.length;
          accum.push(chunk);
        });
        body.on("end", function() {
          if (abort) {
            return;
          }
          clearTimeout(resTimeout);
          try {
            resolve2(Buffer.concat(accum, accumBytes));
          } catch (err2) {
            reject2(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err2.message}`, "system", err2));
          }
        });
      });
    }
    function convertBody(buffer, headers) {
      if (typeof convert !== "function") {
        throw new Error("The package `encoding` must be installed to use the textConverted() function");
      }
      const ct2 = headers.get("content-type");
      let charset = "utf-8";
      let res, str;
      if (ct2) {
        res = /charset=([^;]*)/i.exec(ct2);
      }
      str = buffer.slice(0, 1024).toString();
      if (!res && str) {
        res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
      }
      if (!res && str) {
        res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
        if (!res) {
          res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
          if (res) {
            res.pop();
          }
        }
        if (res) {
          res = /charset=(.*)/i.exec(res.pop());
        }
      }
      if (!res && str) {
        res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
      }
      if (res) {
        charset = res.pop();
        if (charset === "gb2312" || charset === "gbk") {
          charset = "gb18030";
        }
      }
      return convert(buffer, "UTF-8", charset).toString();
    }
    function isURLSearchParams(obj) {
      if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
        return false;
      }
      return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
    }
    function isBlob(obj) {
      return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
    }
    function clone(instance) {
      let p1, p2;
      let body = instance.body;
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof Stream2 && typeof body.getBoundary !== "function") {
        p1 = new PassThrough2();
        p2 = new PassThrough2();
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS].body = p1;
        body = p2;
      }
      return body;
    }
    function extractContentType(body) {
      if (body === null) {
        return null;
      } else if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      } else if (isURLSearchParams(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isBlob(body)) {
        return body.type || null;
      } else if (Buffer.isBuffer(body)) {
        return null;
      } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        return null;
      } else if (ArrayBuffer.isView(body)) {
        return null;
      } else if (typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      } else if (body instanceof Stream2) {
        return null;
      } else {
        return "text/plain;charset=UTF-8";
      }
    }
    function getTotalBytes(instance) {
      const body = instance.body;
      if (body === null) {
        return 0;
      } else if (isBlob(body)) {
        return body.size;
      } else if (Buffer.isBuffer(body)) {
        return body.length;
      } else if (body && typeof body.getLengthSync === "function") {
        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || body.hasKnownLength && body.hasKnownLength()) {
          return body.getLengthSync();
        }
        return null;
      } else {
        return null;
      }
    }
    function writeToStream(dest, instance) {
      const body = instance.body;
      if (body === null) {
        dest.end();
      } else if (isBlob(body)) {
        body.stream().pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    }
    Body.Promise = global.Promise;
    var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    function validateName(name) {
      name = `${name}`;
      if (invalidTokenRegex.test(name) || name === "") {
        throw new TypeError(`${name} is not a legal HTTP header name`);
      }
    }
    function validateValue(value) {
      value = `${value}`;
      if (invalidHeaderCharRegex.test(value)) {
        throw new TypeError(`${value} is not a legal HTTP header value`);
      }
    }
    function find(map3, name) {
      name = name.toLowerCase();
      for (const key in map3) {
        if (key.toLowerCase() === name) {
          return key;
        }
      }
      return void 0;
    }
    var MAP = Symbol("map");
    var Headers = class {
      constructor() {
        let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        this[MAP] = /* @__PURE__ */ Object.create(null);
        if (init instanceof Headers) {
          const rawHeaders = init.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames) {
            for (const value of rawHeaders[headerName]) {
              this.append(headerName, value);
            }
          }
          return;
        }
        if (init == null)
          ;
        else if (typeof init === "object") {
          const method = init[Symbol.iterator];
          if (method != null) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            const pairs = [];
            for (const pair of init) {
              if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                throw new TypeError("Each header pair must be iterable");
              }
              pairs.push(Array.from(pair));
            }
            for (const pair of pairs) {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              this.append(pair[0], pair[1]);
            }
          } else {
            for (const key of Object.keys(init)) {
              const value = init[key];
              this.append(key, value);
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object");
        }
      }
      get(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key === void 0) {
          return null;
        }
        return this[MAP][key].join(", ");
      }
      forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
        let pairs = getHeaders(this);
        let i = 0;
        while (i < pairs.length) {
          var _pairs$i = pairs[i];
          const name = _pairs$i[0], value = _pairs$i[1];
          callback.call(thisArg, value, name, this);
          pairs = getHeaders(this);
          i++;
        }
      }
      set(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        this[MAP][key !== void 0 ? key : name] = [value];
      }
      append(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          this[MAP][key].push(value);
        } else {
          this[MAP][name] = [value];
        }
      }
      has(name) {
        name = `${name}`;
        validateName(name);
        return find(this[MAP], name) !== void 0;
      }
      delete(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          delete this[MAP][key];
        }
      }
      raw() {
        return this[MAP];
      }
      keys() {
        return createHeadersIterator(this, "key");
      }
      values() {
        return createHeadersIterator(this, "value");
      }
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
      }
    };
    Headers.prototype.entries = Headers.prototype[Symbol.iterator];
    Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Headers.prototype, {
      get: { enumerable: true },
      forEach: { enumerable: true },
      set: { enumerable: true },
      append: { enumerable: true },
      has: { enumerable: true },
      delete: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true }
    });
    function getHeaders(headers) {
      let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
      const keys2 = Object.keys(headers[MAP]).sort();
      return keys2.map(kind === "key" ? function(k2) {
        return k2.toLowerCase();
      } : kind === "value" ? function(k2) {
        return headers[MAP][k2].join(", ");
      } : function(k2) {
        return [k2.toLowerCase(), headers[MAP][k2].join(", ")];
      });
    }
    var INTERNAL = Symbol("internal");
    function createHeadersIterator(target, kind) {
      const iterator = Object.create(HeadersIteratorPrototype);
      iterator[INTERNAL] = {
        target,
        kind,
        index: 0
      };
      return iterator;
    }
    var HeadersIteratorPrototype = Object.setPrototypeOf({
      next() {
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
          throw new TypeError("Value of `this` is not a HeadersIterator");
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
        const values = getHeaders(target, kind);
        const len = values.length;
        if (index >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        this[INTERNAL].index = index + 1;
        return {
          value: values[index],
          done: false
        };
      }
    }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function exportNodeCompatibleHeaders(headers) {
      const obj = Object.assign({ __proto__: null }, headers[MAP]);
      const hostHeaderKey = find(headers[MAP], "Host");
      if (hostHeaderKey !== void 0) {
        obj[hostHeaderKey] = obj[hostHeaderKey][0];
      }
      return obj;
    }
    function createHeadersLenient(obj) {
      const headers = new Headers();
      for (const name of Object.keys(obj)) {
        if (invalidTokenRegex.test(name)) {
          continue;
        }
        if (Array.isArray(obj[name])) {
          for (const val of obj[name]) {
            if (invalidHeaderCharRegex.test(val)) {
              continue;
            }
            if (headers[MAP][name] === void 0) {
              headers[MAP][name] = [val];
            } else {
              headers[MAP][name].push(val);
            }
          }
        } else if (!invalidHeaderCharRegex.test(obj[name])) {
          headers[MAP][name] = [obj[name]];
        }
      }
      return headers;
    }
    var INTERNALS$1 = Symbol("Response internals");
    var STATUS_CODES2 = http.STATUS_CODES;
    var Response2 = class {
      constructor() {
        let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        Body.call(this, body, opts);
        const status2 = opts.status || 200;
        const headers = new Headers(opts.headers);
        if (body != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: opts.url,
          status: status2,
          statusText: opts.statusText || STATUS_CODES2[status2],
          headers,
          counter: opts.counter
        };
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      clone() {
        return new Response2(clone(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected
        });
      }
    };
    Body.mixIn(Response2.prototype);
    Object.defineProperties(Response2.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    Object.defineProperty(Response2.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true
    });
    var INTERNALS$2 = Symbol("Request internals");
    var URL2 = Url2.URL || whatwgUrl.URL;
    var parse_url = Url2.parse;
    var format_url = Url2.format;
    function parseURL(urlStr) {
      if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
        urlStr = new URL2(urlStr).toString();
      }
      return parse_url(urlStr);
    }
    var streamDestructionSupported = "destroy" in Stream2.Readable.prototype;
    function isRequest(input) {
      return typeof input === "object" && typeof input[INTERNALS$2] === "object";
    }
    function isAbortSignal(signal) {
      const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
      return !!(proto && proto.constructor.name === "AbortSignal");
    }
    var Request2 = class {
      constructor(input) {
        let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsedURL;
        if (!isRequest(input)) {
          if (input && input.href) {
            parsedURL = parseURL(input.href);
          } else {
            parsedURL = parseURL(`${input}`);
          }
          input = {};
        } else {
          parsedURL = parseURL(input.url);
        }
        let method = init.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
        Body.call(this, inputBody, {
          timeout: init.timeout || input.timeout || 0,
          size: init.size || input.size || 0
        });
        const headers = new Headers(init.headers || input.headers || {});
        if (inputBody != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init)
          signal = init.signal;
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS$2] = {
          method,
          redirect: init.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
        this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
      }
      get method() {
        return this[INTERNALS$2].method;
      }
      get url() {
        return format_url(this[INTERNALS$2].parsedURL);
      }
      get headers() {
        return this[INTERNALS$2].headers;
      }
      get redirect() {
        return this[INTERNALS$2].redirect;
      }
      get signal() {
        return this[INTERNALS$2].signal;
      }
      clone() {
        return new Request2(this);
      }
    };
    Body.mixIn(Request2.prototype);
    Object.defineProperty(Request2.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Request2.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    function getNodeRequestOptions(request3) {
      const parsedURL = request3[INTERNALS$2].parsedURL;
      const headers = new Headers(request3[INTERNALS$2].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      if (!parsedURL.protocol || !parsedURL.hostname) {
        throw new TypeError("Only absolute URLs are supported");
      }
      if (!/^https?:$/.test(parsedURL.protocol)) {
        throw new TypeError("Only HTTP(S) protocols are supported");
      }
      if (request3.signal && request3.body instanceof Stream2.Readable && !streamDestructionSupported) {
        throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
      }
      let contentLengthValue = null;
      if (request3.body == null && /^(POST|PUT)$/i.test(request3.method)) {
        contentLengthValue = "0";
      }
      if (request3.body != null) {
        const totalBytes = getTotalBytes(request3);
        if (typeof totalBytes === "number") {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
      }
      if (request3.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate");
      }
      let agent = request3.agent;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close");
      }
      return Object.assign({}, parsedURL, {
        method: request3.method,
        headers: exportNodeCompatibleHeaders(headers),
        agent
      });
    }
    function AbortError(message) {
      Error.call(this, message);
      this.type = "aborted";
      this.message = message;
      Error.captureStackTrace(this, this.constructor);
    }
    AbortError.prototype = Object.create(Error.prototype);
    AbortError.prototype.constructor = AbortError;
    AbortError.prototype.name = "AbortError";
    var URL$1 = Url2.URL || whatwgUrl.URL;
    var PassThrough$1 = Stream2.PassThrough;
    var isDomainOrSubdomain = function isDomainOrSubdomain2(destination, original) {
      const orig = new URL$1(original).hostname;
      const dest = new URL$1(destination).hostname;
      return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
    };
    function fetch3(url2, opts) {
      if (!fetch3.Promise) {
        throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
      }
      Body.Promise = fetch3.Promise;
      return new fetch3.Promise(function(resolve2, reject2) {
        const request3 = new Request2(url2, opts);
        const options2 = getNodeRequestOptions(request3);
        const send = (options2.protocol === "https:" ? https2 : http).request;
        const signal = request3.signal;
        let response = null;
        const abort = function abort2() {
          let error2 = new AbortError("The user aborted a request.");
          reject2(error2);
          if (request3.body && request3.body instanceof Stream2.Readable) {
            request3.body.destroy(error2);
          }
          if (!response || !response.body)
            return;
          response.body.emit("error", error2);
        };
        if (signal && signal.aborted) {
          abort();
          return;
        }
        const abortAndFinalize = function abortAndFinalize2() {
          abort();
          finalize();
        };
        const req = send(options2);
        let reqTimeout;
        if (signal) {
          signal.addEventListener("abort", abortAndFinalize);
        }
        function finalize() {
          req.abort();
          if (signal)
            signal.removeEventListener("abort", abortAndFinalize);
          clearTimeout(reqTimeout);
        }
        if (request3.timeout) {
          req.once("socket", function(socket) {
            reqTimeout = setTimeout(function() {
              reject2(new FetchError(`network timeout at: ${request3.url}`, "request-timeout"));
              finalize();
            }, request3.timeout);
          });
        }
        req.on("error", function(err2) {
          reject2(new FetchError(`request to ${request3.url} failed, reason: ${err2.message}`, "system", err2));
          finalize();
        });
        req.on("response", function(res) {
          clearTimeout(reqTimeout);
          const headers = createHeadersLenient(res.headers);
          if (fetch3.isRedirect(res.statusCode)) {
            const location = headers.get("Location");
            let locationURL = null;
            try {
              locationURL = location === null ? null : new URL$1(location, request3.url).toString();
            } catch (err2) {
              if (request3.redirect !== "manual") {
                reject2(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
                finalize();
                return;
              }
            }
            switch (request3.redirect) {
              case "error":
                reject2(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request3.url}`, "no-redirect"));
                finalize();
                return;
              case "manual":
                if (locationURL !== null) {
                  try {
                    headers.set("Location", locationURL);
                  } catch (err2) {
                    reject2(err2);
                  }
                }
                break;
              case "follow":
                if (locationURL === null) {
                  break;
                }
                if (request3.counter >= request3.follow) {
                  reject2(new FetchError(`maximum redirect reached at: ${request3.url}`, "max-redirect"));
                  finalize();
                  return;
                }
                const requestOpts = {
                  headers: new Headers(request3.headers),
                  follow: request3.follow,
                  counter: request3.counter + 1,
                  agent: request3.agent,
                  compress: request3.compress,
                  method: request3.method,
                  body: request3.body,
                  signal: request3.signal,
                  timeout: request3.timeout,
                  size: request3.size
                };
                if (!isDomainOrSubdomain(request3.url, locationURL)) {
                  for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                    requestOpts.headers.delete(name);
                  }
                }
                if (res.statusCode !== 303 && request3.body && getTotalBytes(request3) === null) {
                  reject2(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                  finalize();
                  return;
                }
                if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request3.method === "POST") {
                  requestOpts.method = "GET";
                  requestOpts.body = void 0;
                  requestOpts.headers.delete("content-length");
                }
                resolve2(fetch3(new Request2(locationURL, requestOpts)));
                finalize();
                return;
            }
          }
          res.once("end", function() {
            if (signal)
              signal.removeEventListener("abort", abortAndFinalize);
          });
          let body = res.pipe(new PassThrough$1());
          const response_options = {
            url: request3.url,
            status: res.statusCode,
            statusText: res.statusMessage,
            headers,
            size: request3.size,
            timeout: request3.timeout,
            counter: request3.counter
          };
          const codings = headers.get("Content-Encoding");
          if (!request3.compress || request3.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
            response = new Response2(body, response_options);
            resolve2(response);
            return;
          }
          const zlibOptions = {
            flush: zlib.Z_SYNC_FLUSH,
            finishFlush: zlib.Z_SYNC_FLUSH
          };
          if (codings == "gzip" || codings == "x-gzip") {
            body = body.pipe(zlib.createGunzip(zlibOptions));
            response = new Response2(body, response_options);
            resolve2(response);
            return;
          }
          if (codings == "deflate" || codings == "x-deflate") {
            const raw2 = res.pipe(new PassThrough$1());
            raw2.once("data", function(chunk) {
              if ((chunk[0] & 15) === 8) {
                body = body.pipe(zlib.createInflate());
              } else {
                body = body.pipe(zlib.createInflateRaw());
              }
              response = new Response2(body, response_options);
              resolve2(response);
            });
            return;
          }
          if (codings == "br" && typeof zlib.createBrotliDecompress === "function") {
            body = body.pipe(zlib.createBrotliDecompress());
            response = new Response2(body, response_options);
            resolve2(response);
            return;
          }
          response = new Response2(body, response_options);
          resolve2(response);
        });
        writeToStream(req, request3);
      });
    }
    fetch3.isRedirect = function(code) {
      return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
    };
    fetch3.Promise = global.Promise;
    module2.exports = exports2 = fetch3;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = exports2;
    exports2.Headers = Headers;
    exports2.Request = Request2;
    exports2.Response = Response2;
    exports2.FetchError = FetchError;
  }
});

// node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/cjs/util/createBoundary.js
var require_createBoundary = __commonJS({
  "node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/cjs/util/createBoundary.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var alphabet = "abcdefghijklmnopqrstuvwxyz0123456789";
    function createBoundary() {
      let size = 16;
      let res = "";
      while (size--) {
        res += alphabet[Math.random() * alphabet.length << 0];
      }
      return res;
    }
    exports2.default = createBoundary;
  }
});

// node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/cjs/util/isPlainObject.js
var require_isPlainObject = __commonJS({
  "node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/cjs/util/isPlainObject.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var getType = (value) => Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
    function isPlainObject(value) {
      if (getType(value) !== "object") {
        return false;
      }
      const pp = Object.getPrototypeOf(value);
      if (pp === null || pp === void 0) {
        return true;
      }
      const Ctor = pp.constructor && pp.constructor.toString();
      return Ctor === Object.toString();
    }
    exports2.default = isPlainObject;
  }
});

// node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/cjs/util/normalizeValue.js
var require_normalizeValue = __commonJS({
  "node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/cjs/util/normalizeValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var normalizeValue = (value) => String(value).replace(/\r|\n/g, (match, i, str) => {
      if (match === "\r" && str[i + 1] !== "\n" || match === "\n" && str[i - 1] !== "\r") {
        return "\r\n";
      }
      return match;
    });
    exports2.default = normalizeValue;
  }
});

// node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/cjs/util/escapeName.js
var require_escapeName = __commonJS({
  "node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/cjs/util/escapeName.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var escapeName = (name) => String(name).replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/"/g, "%22");
    exports2.default = escapeName;
  }
});

// node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/cjs/util/isFunction.js
var require_isFunction2 = __commonJS({
  "node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/cjs/util/isFunction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var isFunction3 = (value) => typeof value === "function";
    exports2.default = isFunction3;
  }
});

// node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/cjs/util/isFileLike.js
var require_isFileLike = __commonJS({
  "node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/cjs/util/isFileLike.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isFileLike = void 0;
    var isFunction_1 = __importDefault(require_isFunction2());
    var isFileLike = (value) => Boolean(value && typeof value === "object" && (0, isFunction_1.default)(value.constructor) && value[Symbol.toStringTag] === "File" && (0, isFunction_1.default)(value.stream) && value.name != null && value.size != null && value.lastModified != null);
    exports2.isFileLike = isFileLike;
  }
});

// node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/cjs/util/isFormData.js
var require_isFormData = __commonJS({
  "node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/cjs/util/isFormData.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isFormDataLike = exports2.isFormData = void 0;
    var isFunction_1 = __importDefault(require_isFunction2());
    var isFormData = (value) => Boolean(value && (0, isFunction_1.default)(value.constructor) && value[Symbol.toStringTag] === "FormData" && (0, isFunction_1.default)(value.append) && (0, isFunction_1.default)(value.getAll) && (0, isFunction_1.default)(value.entries) && (0, isFunction_1.default)(value[Symbol.iterator]));
    exports2.isFormData = isFormData;
    exports2.isFormDataLike = exports2.isFormData;
  }
});

// node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/cjs/FormDataEncoder.js
var require_FormDataEncoder = __commonJS({
  "node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/cjs/FormDataEncoder.js"(exports2) {
    "use strict";
    var __classPrivateFieldSet = exports2 && exports2.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _FormDataEncoder_instances;
    var _FormDataEncoder_CRLF;
    var _FormDataEncoder_CRLF_BYTES;
    var _FormDataEncoder_CRLF_BYTES_LENGTH;
    var _FormDataEncoder_DASHES;
    var _FormDataEncoder_encoder;
    var _FormDataEncoder_footer;
    var _FormDataEncoder_form;
    var _FormDataEncoder_options;
    var _FormDataEncoder_getFieldHeader;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Encoder = exports2.FormDataEncoder = void 0;
    var createBoundary_1 = __importDefault(require_createBoundary());
    var isPlainObject_1 = __importDefault(require_isPlainObject());
    var normalizeValue_1 = __importDefault(require_normalizeValue());
    var escapeName_1 = __importDefault(require_escapeName());
    var isFileLike_1 = require_isFileLike();
    var isFormData_1 = require_isFormData();
    var defaultOptions = {
      enableAdditionalHeaders: false
    };
    var FormDataEncoder = class {
      constructor(form, boundaryOrOptions, options2) {
        _FormDataEncoder_instances.add(this);
        _FormDataEncoder_CRLF.set(this, "\r\n");
        _FormDataEncoder_CRLF_BYTES.set(this, void 0);
        _FormDataEncoder_CRLF_BYTES_LENGTH.set(this, void 0);
        _FormDataEncoder_DASHES.set(this, "-".repeat(2));
        _FormDataEncoder_encoder.set(this, new TextEncoder());
        _FormDataEncoder_footer.set(this, void 0);
        _FormDataEncoder_form.set(this, void 0);
        _FormDataEncoder_options.set(this, void 0);
        if (!(0, isFormData_1.isFormData)(form)) {
          throw new TypeError("Expected first argument to be a FormData instance.");
        }
        let boundary;
        if ((0, isPlainObject_1.default)(boundaryOrOptions)) {
          options2 = boundaryOrOptions;
        } else {
          boundary = boundaryOrOptions;
        }
        if (!boundary) {
          boundary = (0, createBoundary_1.default)();
        }
        if (typeof boundary !== "string") {
          throw new TypeError("Expected boundary argument to be a string.");
        }
        if (options2 && !(0, isPlainObject_1.default)(options2)) {
          throw new TypeError("Expected options argument to be an object.");
        }
        __classPrivateFieldSet(this, _FormDataEncoder_form, form, "f");
        __classPrivateFieldSet(this, _FormDataEncoder_options, { ...defaultOptions, ...options2 }, "f");
        __classPrivateFieldSet(this, _FormDataEncoder_CRLF_BYTES, __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode(__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f")), "f");
        __classPrivateFieldSet(this, _FormDataEncoder_CRLF_BYTES_LENGTH, __classPrivateFieldGet(this, _FormDataEncoder_CRLF_BYTES, "f").byteLength, "f");
        this.boundary = `form-data-boundary-${boundary}`;
        this.contentType = `multipart/form-data; boundary=${this.boundary}`;
        __classPrivateFieldSet(this, _FormDataEncoder_footer, __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode(`${__classPrivateFieldGet(this, _FormDataEncoder_DASHES, "f")}${this.boundary}${__classPrivateFieldGet(this, _FormDataEncoder_DASHES, "f")}${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f").repeat(2)}`), "f");
        this.contentLength = String(this.getContentLength());
        this.headers = Object.freeze({
          "Content-Type": this.contentType,
          "Content-Length": this.contentLength
        });
        Object.defineProperties(this, {
          boundary: { writable: false, configurable: false },
          contentType: { writable: false, configurable: false },
          contentLength: { writable: false, configurable: false },
          headers: { writable: false, configurable: false }
        });
      }
      getContentLength() {
        let length = 0;
        for (const [name, raw2] of __classPrivateFieldGet(this, _FormDataEncoder_form, "f")) {
          const value = (0, isFileLike_1.isFileLike)(raw2) ? raw2 : __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode((0, normalizeValue_1.default)(raw2));
          length += __classPrivateFieldGet(this, _FormDataEncoder_instances, "m", _FormDataEncoder_getFieldHeader).call(this, name, value).byteLength;
          length += (0, isFileLike_1.isFileLike)(value) ? value.size : value.byteLength;
          length += __classPrivateFieldGet(this, _FormDataEncoder_CRLF_BYTES_LENGTH, "f");
        }
        return length + __classPrivateFieldGet(this, _FormDataEncoder_footer, "f").byteLength;
      }
      *values() {
        for (const [name, raw2] of __classPrivateFieldGet(this, _FormDataEncoder_form, "f").entries()) {
          const value = (0, isFileLike_1.isFileLike)(raw2) ? raw2 : __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode((0, normalizeValue_1.default)(raw2));
          yield __classPrivateFieldGet(this, _FormDataEncoder_instances, "m", _FormDataEncoder_getFieldHeader).call(this, name, value);
          yield value;
          yield __classPrivateFieldGet(this, _FormDataEncoder_CRLF_BYTES, "f");
        }
        yield __classPrivateFieldGet(this, _FormDataEncoder_footer, "f");
      }
      async *encode() {
        for (const part of this.values()) {
          if ((0, isFileLike_1.isFileLike)(part)) {
            yield* part.stream();
          } else {
            yield part;
          }
        }
      }
      [(_FormDataEncoder_CRLF = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_CRLF_BYTES = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_CRLF_BYTES_LENGTH = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_DASHES = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_encoder = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_footer = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_form = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_options = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_instances = /* @__PURE__ */ new WeakSet(), _FormDataEncoder_getFieldHeader = function _FormDataEncoder_getFieldHeader2(name, value) {
        let header = "";
        header += `${__classPrivateFieldGet(this, _FormDataEncoder_DASHES, "f")}${this.boundary}${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f")}`;
        header += `Content-Disposition: form-data; name="${(0, escapeName_1.default)(name)}"`;
        if ((0, isFileLike_1.isFileLike)(value)) {
          header += `; filename="${(0, escapeName_1.default)(value.name)}"${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f")}`;
          header += `Content-Type: ${value.type || "application/octet-stream"}`;
        }
        if (__classPrivateFieldGet(this, _FormDataEncoder_options, "f").enableAdditionalHeaders === true) {
          header += `${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f")}Content-Length: ${(0, isFileLike_1.isFileLike)(value) ? value.size : value.byteLength}`;
        }
        return __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode(`${header}${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f").repeat(2)}`);
      }, Symbol.iterator)]() {
        return this.values();
      }
      [Symbol.asyncIterator]() {
        return this.encode();
      }
    };
    exports2.FormDataEncoder = FormDataEncoder;
    exports2.Encoder = FormDataEncoder;
  }
});

// node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/cjs/FileLike.js
var require_FileLike = __commonJS({
  "node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/cjs/FileLike.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/cjs/FormDataLike.js
var require_FormDataLike = __commonJS({
  "node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/cjs/FormDataLike.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/.pnpm/form-data-encoder@1.7.2/node_modules/form-data-encoder/lib/cjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o, k22, { enumerable: true, get: function() {
        return m[k2];
      } });
    } : function(o, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m[k2];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_FormDataEncoder(), exports2);
    __exportStar(require_FileLike(), exports2);
    __exportStar(require_FormDataLike(), exports2);
    __exportStar(require_isFileLike(), exports2);
    __exportStar(require_isFormData(), exports2);
  }
});

// node_modules/.pnpm/cross-undici-fetch@0.2.5/node_modules/cross-undici-fetch/dist/create-node-ponyfill.js
var require_create_node_ponyfill = __commonJS({
  "node_modules/.pnpm/cross-undici-fetch@0.2.5/node_modules/cross-undici-fetch/dist/create-node-ponyfill.js"(exports2, module2) {
    module2.exports = function createNodePonyfill(opts = {}) {
      const ponyfills = {};
      ponyfills.fetch = globalThis.fetch;
      ponyfills.Headers = globalThis.Headers;
      ponyfills.Request = globalThis.Request;
      ponyfills.Response = globalThis.Response;
      ponyfills.FormData = globalThis.FormData;
      ponyfills.AbortController = globalThis.AbortController;
      ponyfills.ReadableStream = globalThis.ReadableStream;
      ponyfills.WritableStream = globalThis.WritableStream;
      ponyfills.TransformStream = globalThis.TransformStream;
      ponyfills.Blob = globalThis.Blob;
      ponyfills.File = globalThis.File;
      if (!ponyfills.AbortController) {
        const abortControllerModule = require_abort_controller();
        ponyfills.AbortController = abortControllerModule.default || abortControllerModule;
      }
      if (!ponyfills.Blob) {
        const bufferModule = (init_buffer_es6(), __toCommonJS(buffer_es6_exports));
        ponyfills.Blob = bufferModule.Blob;
      }
      if (!ponyfills.Blob) {
        const formDataModule = require_cjs();
        ponyfills.Blob = formDataModule.Blob;
      }
      if (!ponyfills.ReadableStream) {
        try {
          const streamsWeb = __require("stream/web");
          ponyfills.ReadableStream = streamsWeb.ReadableStream;
          ponyfills.WritableStream = streamsWeb.WritableStream;
          ponyfills.TransformStream = streamsWeb.TransformStream;
        } catch (e2) {
          const streamsWeb = require_ponyfill2();
          ponyfills.ReadableStream = streamsWeb.ReadableStream;
          ponyfills.WritableStream = streamsWeb.WritableStream;
          ponyfills.TransformStream = streamsWeb.TransformStream;
        }
      }
      if (!ponyfills.fetch || !ponyfills.Request || !ponyfills.Headers || !ponyfills.Response || ponyfills.Request.prototype.textConverted || opts.useNodeFetch) {
        const [
          nodeMajorStr,
          nodeMinorStr
        ] = process.versions.node.split(".");
        const nodeMajor = parseInt(nodeMajorStr);
        const nodeMinor = parseInt(nodeMinorStr);
        const addFormDataToRequest = require_add_formdata_to_request();
        if (!opts.useNodeFetch && (nodeMajor > 16 || nodeMajor === 16 && nodeMinor >= 5)) {
          let Request3 = function(requestOrUrl, options2) {
            if (typeof requestOrUrl === "string") {
              options2 = options2 || {};
              options2.headers = new undici.Headers(options2.headers || {});
              options2.headers.delete("connection");
              if (options2.body != null && options2.body.read && options2.body.on) {
                const readable = options2.body;
                options2.body = new ponyfills.ReadableStream({
                  pull(controller) {
                    const chunk = readable.read();
                    if (chunk != null) {
                      controller.enqueue(chunk);
                    } else {
                      controller.close();
                    }
                  },
                  close(e2) {
                    readable.destroy(e2);
                  }
                });
              }
              return new undici.Request(requestOrUrl, options2);
            }
            const newRequestObj = requestOrUrl.clone();
            Object.defineProperty(newRequestObj, "headers", {
              value: newRequestObj.headers || new undici.Headers({})
            });
            newRequestObj.headers.delete("connection");
            return newRequestObj;
          };
          var Request2 = Request3;
          const undici = require_undici();
          ponyfills.Headers = undici.Headers;
          const patchHeadersList = require_patch_headers_list();
          const { HeadersList } = require_headers();
          patchHeadersList(HeadersList);
          const streams = (init_stream(), __toCommonJS(stream_exports));
          ponyfills.Request = Request3;
          const fetch3 = function(requestOrUrl, options2) {
            if (typeof requestOrUrl === "string") {
              return fetch3(new Request3(requestOrUrl, options2));
            }
            return undici.fetch(requestOrUrl);
          };
          ponyfills.fetch = fetch3;
          ponyfills.Response = undici.Response;
          ponyfills.FormData = undici.FormData;
          ponyfills.File = undici.File;
          addFormDataToRequest(undici.Request, undici.File, undici.FormData);
        } else {
          let Request3 = function(requestOrUrl, options2) {
            if (typeof requestOrUrl === "string") {
              if (/^\/\//.test(requestOrUrl)) {
                requestOrUrl = "https:" + requestOrUrl;
              }
              options2 = options2 || {};
              options2.headers = new nodeFetch.Headers(options2.headers || {});
              options2.headers.set("Connection", "keep-alive");
              if (options2.body != null) {
                if (options2.body[Symbol.toStringTag] === "FormData") {
                  const encoder = new formDataEncoderModule.FormDataEncoder(options2.body);
                  for (const headerKey in encoder.headers) {
                    options2.headers.set(headerKey, encoder.headers[headerKey]);
                  }
                  options2.body = streams.Readable.from(encoder.encode());
                }
                if (options2.body[Symbol.toStringTag] === "ReadableStream") {
                  options2.body = streams.Readable.from(options2.body);
                }
              }
              return new nodeFetch.Request(requestOrUrl, options2);
            }
            return requestOrUrl.clone();
          };
          var Request2 = Request3;
          const nodeFetch = require_lib2();
          const realFetch = nodeFetch.default || nodeFetch;
          ponyfills.Headers = nodeFetch.Headers;
          const formDataEncoderModule = require_cjs2();
          const streams = (init_stream(), __toCommonJS(stream_exports));
          ;
          ponyfills.Request = Request3;
          const fetch3 = function(requestOrUrl, options2) {
            if (typeof requestOrUrl === "string") {
              return fetch3(new Request3(requestOrUrl, options2));
            }
            return realFetch(requestOrUrl);
          };
          ponyfills.fetch = fetch3;
          ponyfills.Response = function Response2(body, init) {
            if (body != null && body[Symbol.toStringTag] === "ReadableStream") {
              const actualBody = streams.Readable.from(body);
              return new nodeFetch.Response(actualBody, init);
            }
            return new nodeFetch.Response(body, init);
          };
          const formDataModule = require_cjs();
          ponyfills.FormData = formDataModule.FormData;
          ponyfills.File = formDataModule.File;
          addFormDataToRequest(nodeFetch.Request, formDataModule.File, formDataModule.FormData);
        }
      }
      return ponyfills;
    };
  }
});

// node_modules/.pnpm/cross-undici-fetch@0.2.5/node_modules/cross-undici-fetch/dist/node-ponyfill.js
var require_node_ponyfill = __commonJS({
  "node_modules/.pnpm/cross-undici-fetch@0.2.5/node_modules/cross-undici-fetch/dist/node-ponyfill.js"(exports2, module2) {
    var createNodePonyfill = require_create_node_ponyfill();
    var ponyfills = createNodePonyfill();
    module2.exports.fetch = ponyfills.fetch;
    module2.exports.Headers = ponyfills.Headers;
    module2.exports.Request = ponyfills.Request;
    module2.exports.Response = ponyfills.Response;
    module2.exports.FormData = ponyfills.FormData;
    module2.exports.AbortController = ponyfills.AbortController;
    module2.exports.ReadableStream = ponyfills.ReadableStream;
    module2.exports.WritableStream = ponyfills.WritableStream;
    module2.exports.TransformStream = ponyfills.TransformStream;
    module2.exports.Blob = ponyfills.Blob;
    module2.exports.File = ponyfills.File;
    exports2.create = createNodePonyfill;
  }
});

// node_modules/.pnpm/@repeaterjs+repeater@3.0.4/node_modules/@repeaterjs/repeater/cjs/repeater.js
var require_repeater = __commonJS({
  "node_modules/.pnpm/@repeaterjs+repeater@3.0.4/node_modules/@repeaterjs/repeater/cjs/repeater.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var extendStatics = function(d2, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
        d3.__proto__ = b2;
      } || function(d3, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d3[p] = b2[p];
      };
      return extendStatics(d2, b);
    };
    function __extends(d2, b) {
      extendStatics(d2, b);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject3) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject3(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject3(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }
    function __generator(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y2, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y2 && (t = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t = y2["return"]) && t.call(y2), 0) : y2.next) && !(t = t.call(y2, op[1])).done)
              return t;
            if (y2 = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y2 = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e2) {
            op = [6, e2];
            y2 = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    }
    function __values(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __await(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n) {
        if (g[n])
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume2(n, v);
            });
          };
      }
      function resume2(n, v) {
        try {
          step(g[n](v));
        } catch (e2) {
          settle(q[0][3], e2);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject3) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume2("next", value);
      }
      function reject3(value) {
        resume2("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume2(q[0][0], q[0][1]);
      }
    }
    var RepeaterOverflowError = function(_super) {
      __extends(RepeaterOverflowError2, _super);
      function RepeaterOverflowError2(message) {
        var _this = _super.call(this, message) || this;
        Object.defineProperty(_this, "name", {
          value: "RepeaterOverflowError",
          enumerable: false
        });
        if (typeof Object.setPrototypeOf === "function") {
          Object.setPrototypeOf(_this, _this.constructor.prototype);
        } else {
          _this.__proto__ = _this.constructor.prototype;
        }
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(_this, _this.constructor);
        }
        return _this;
      }
      return RepeaterOverflowError2;
    }(Error);
    var FixedBuffer = function() {
      function FixedBuffer2(capacity) {
        if (capacity < 0) {
          throw new RangeError("Capacity may not be less than 0");
        }
        this._c = capacity;
        this._q = [];
      }
      Object.defineProperty(FixedBuffer2.prototype, "empty", {
        get: function() {
          return this._q.length === 0;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FixedBuffer2.prototype, "full", {
        get: function() {
          return this._q.length >= this._c;
        },
        enumerable: false,
        configurable: true
      });
      FixedBuffer2.prototype.add = function(value) {
        if (this.full) {
          throw new Error("Buffer full");
        } else {
          this._q.push(value);
        }
      };
      FixedBuffer2.prototype.remove = function() {
        if (this.empty) {
          throw new Error("Buffer empty");
        }
        return this._q.shift();
      };
      return FixedBuffer2;
    }();
    var SlidingBuffer = function() {
      function SlidingBuffer2(capacity) {
        if (capacity < 1) {
          throw new RangeError("Capacity may not be less than 1");
        }
        this._c = capacity;
        this._q = [];
      }
      Object.defineProperty(SlidingBuffer2.prototype, "empty", {
        get: function() {
          return this._q.length === 0;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(SlidingBuffer2.prototype, "full", {
        get: function() {
          return false;
        },
        enumerable: false,
        configurable: true
      });
      SlidingBuffer2.prototype.add = function(value) {
        while (this._q.length >= this._c) {
          this._q.shift();
        }
        this._q.push(value);
      };
      SlidingBuffer2.prototype.remove = function() {
        if (this.empty) {
          throw new Error("Buffer empty");
        }
        return this._q.shift();
      };
      return SlidingBuffer2;
    }();
    var DroppingBuffer = function() {
      function DroppingBuffer2(capacity) {
        if (capacity < 1) {
          throw new RangeError("Capacity may not be less than 1");
        }
        this._c = capacity;
        this._q = [];
      }
      Object.defineProperty(DroppingBuffer2.prototype, "empty", {
        get: function() {
          return this._q.length === 0;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DroppingBuffer2.prototype, "full", {
        get: function() {
          return false;
        },
        enumerable: false,
        configurable: true
      });
      DroppingBuffer2.prototype.add = function(value) {
        if (this._q.length < this._c) {
          this._q.push(value);
        }
      };
      DroppingBuffer2.prototype.remove = function() {
        if (this.empty) {
          throw new Error("Buffer empty");
        }
        return this._q.shift();
      };
      return DroppingBuffer2;
    }();
    function swallow(value) {
      if (value != null && typeof value.then === "function") {
        value.then(NOOP, NOOP);
      }
    }
    var Initial = 0;
    var Started = 1;
    var Stopped = 2;
    var Done = 3;
    var Rejected = 4;
    var MAX_QUEUE_LENGTH = 1024;
    var NOOP = function() {
    };
    function consumeExecution(r) {
      var err2 = r.err;
      var execution = Promise.resolve(r.execution).then(function(value) {
        if (err2 != null) {
          throw err2;
        }
        return value;
      });
      r.err = void 0;
      r.execution = execution.then(function() {
        return void 0;
      }, function() {
        return void 0;
      });
      return r.pending === void 0 ? execution : r.pending.then(function() {
        return execution;
      });
    }
    function createIteration(r, value) {
      var done2 = r.state >= Done;
      return Promise.resolve(value).then(function(value2) {
        if (!done2 && r.state >= Rejected) {
          return consumeExecution(r).then(function(value3) {
            return {
              value: value3,
              done: true
            };
          });
        }
        return { value: value2, done: done2 };
      });
    }
    function stop(r, err2) {
      var e_1, _a3;
      if (r.state >= Stopped) {
        return;
      }
      r.state = Stopped;
      r.onnext();
      r.onstop();
      if (r.err == null) {
        r.err = err2;
      }
      if (r.pushes.length === 0 && (typeof r.buffer === "undefined" || r.buffer.empty)) {
        finish(r);
      } else {
        try {
          for (var _b = __values(r.pushes), _d = _b.next(); !_d.done; _d = _b.next()) {
            var push_1 = _d.value;
            push_1.resolve();
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_d && !_d.done && (_a3 = _b.return))
              _a3.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
    }
    function finish(r) {
      var e_2, _a3;
      if (r.state >= Done) {
        return;
      }
      if (r.state < Stopped) {
        stop(r);
      }
      r.state = Done;
      r.buffer = void 0;
      try {
        for (var _b = __values(r.nexts), _d = _b.next(); !_d.done; _d = _b.next()) {
          var next = _d.value;
          var execution = r.pending === void 0 ? consumeExecution(r) : r.pending.then(function() {
            return consumeExecution(r);
          });
          next.resolve(createIteration(r, execution));
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (_d && !_d.done && (_a3 = _b.return))
            _a3.call(_b);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
      r.pushes = [];
      r.nexts = [];
    }
    function reject2(r) {
      if (r.state >= Rejected) {
        return;
      }
      if (r.state < Done) {
        finish(r);
      }
      r.state = Rejected;
    }
    function push(r, value) {
      swallow(value);
      if (r.pushes.length >= MAX_QUEUE_LENGTH) {
        throw new RepeaterOverflowError("No more than " + MAX_QUEUE_LENGTH + " pending calls to push are allowed on a single repeater.");
      } else if (r.state >= Stopped) {
        return Promise.resolve(void 0);
      }
      var valueP = r.pending === void 0 ? Promise.resolve(value) : r.pending.then(function() {
        return value;
      });
      valueP = valueP.catch(function(err2) {
        if (r.state < Stopped) {
          r.err = err2;
        }
        reject2(r);
        return void 0;
      });
      var nextP;
      if (r.nexts.length) {
        var next_1 = r.nexts.shift();
        next_1.resolve(createIteration(r, valueP));
        if (r.nexts.length) {
          nextP = Promise.resolve(r.nexts[0].value);
        } else {
          nextP = new Promise(function(resolve2) {
            return r.onnext = resolve2;
          });
        }
      } else if (typeof r.buffer !== "undefined" && !r.buffer.full) {
        r.buffer.add(valueP);
        nextP = Promise.resolve(void 0);
      } else {
        nextP = new Promise(function(resolve2) {
          return r.pushes.push({ resolve: resolve2, value: valueP });
        });
      }
      var floating = true;
      var next = {};
      var unhandled = nextP.catch(function(err2) {
        if (floating) {
          throw err2;
        }
        return void 0;
      });
      next.then = function(onfulfilled, onrejected) {
        floating = false;
        return Promise.prototype.then.call(nextP, onfulfilled, onrejected);
      };
      next.catch = function(onrejected) {
        floating = false;
        return Promise.prototype.catch.call(nextP, onrejected);
      };
      next.finally = nextP.finally.bind(nextP);
      r.pending = valueP.then(function() {
        return unhandled;
      }).catch(function(err2) {
        r.err = err2;
        reject2(r);
      });
      return next;
    }
    function createStop(r) {
      var stop1 = stop.bind(null, r);
      var stopP = new Promise(function(resolve2) {
        return r.onstop = resolve2;
      });
      stop1.then = stopP.then.bind(stopP);
      stop1.catch = stopP.catch.bind(stopP);
      stop1.finally = stopP.finally.bind(stopP);
      return stop1;
    }
    function execute2(r) {
      if (r.state >= Started) {
        return;
      }
      r.state = Started;
      var push1 = push.bind(null, r);
      var stop1 = createStop(r);
      r.execution = new Promise(function(resolve2) {
        return resolve2(r.executor(push1, stop1));
      });
      r.execution.catch(function() {
        return stop(r);
      });
    }
    var records = /* @__PURE__ */ new WeakMap();
    var Repeater3 = function() {
      function Repeater4(executor, buffer) {
        records.set(this, {
          executor,
          buffer,
          err: void 0,
          state: Initial,
          pushes: [],
          nexts: [],
          pending: void 0,
          execution: void 0,
          onnext: NOOP,
          onstop: NOOP
        });
      }
      Repeater4.prototype.next = function(value) {
        swallow(value);
        var r = records.get(this);
        if (r === void 0) {
          throw new Error("WeakMap error");
        }
        if (r.nexts.length >= MAX_QUEUE_LENGTH) {
          throw new RepeaterOverflowError("No more than " + MAX_QUEUE_LENGTH + " pending calls to next are allowed on a single repeater.");
        }
        if (r.state <= Initial) {
          execute2(r);
        }
        r.onnext(value);
        if (typeof r.buffer !== "undefined" && !r.buffer.empty) {
          var result = createIteration(r, r.buffer.remove());
          if (r.pushes.length) {
            var push_2 = r.pushes.shift();
            r.buffer.add(push_2.value);
            r.onnext = push_2.resolve;
          }
          return result;
        } else if (r.pushes.length) {
          var push_3 = r.pushes.shift();
          r.onnext = push_3.resolve;
          return createIteration(r, push_3.value);
        } else if (r.state >= Stopped) {
          finish(r);
          return createIteration(r, consumeExecution(r));
        }
        return new Promise(function(resolve2) {
          return r.nexts.push({ resolve: resolve2, value });
        });
      };
      Repeater4.prototype.return = function(value) {
        swallow(value);
        var r = records.get(this);
        if (r === void 0) {
          throw new Error("WeakMap error");
        }
        finish(r);
        r.execution = Promise.resolve(r.execution).then(function() {
          return value;
        });
        return createIteration(r, consumeExecution(r));
      };
      Repeater4.prototype.throw = function(err2) {
        var r = records.get(this);
        if (r === void 0) {
          throw new Error("WeakMap error");
        }
        if (r.state <= Initial || r.state >= Stopped || typeof r.buffer !== "undefined" && !r.buffer.empty) {
          finish(r);
          if (r.err == null) {
            r.err = err2;
          }
          return createIteration(r, consumeExecution(r));
        }
        return this.next(Promise.reject(err2));
      };
      Repeater4.prototype[Symbol.asyncIterator] = function() {
        return this;
      };
      Repeater4.race = race;
      Repeater4.merge = merge;
      Repeater4.zip = zip;
      Repeater4.latest = latest;
      return Repeater4;
    }();
    function getIterators(values, options2) {
      var e_3, _a3;
      var iters = [];
      var _loop_1 = function(value2) {
        if (value2 != null && typeof value2[Symbol.asyncIterator] === "function") {
          iters.push(value2[Symbol.asyncIterator]());
        } else if (value2 != null && typeof value2[Symbol.iterator] === "function") {
          iters.push(value2[Symbol.iterator]());
        } else {
          iters.push(function valueToAsyncIterator() {
            return __asyncGenerator(this, arguments, function valueToAsyncIterator_1() {
              return __generator(this, function(_a4) {
                switch (_a4.label) {
                  case 0:
                    if (!options2.yieldValues)
                      return [3, 3];
                    return [4, __await(value2)];
                  case 1:
                    return [4, _a4.sent()];
                  case 2:
                    _a4.sent();
                    _a4.label = 3;
                  case 3:
                    if (!options2.returnValues)
                      return [3, 5];
                    return [4, __await(value2)];
                  case 4:
                    return [2, _a4.sent()];
                  case 5:
                    return [2];
                }
              });
            });
          }());
        }
      };
      try {
        for (var values_1 = __values(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {
          var value = values_1_1.value;
          _loop_1(value);
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (values_1_1 && !values_1_1.done && (_a3 = values_1.return))
            _a3.call(values_1);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      return iters;
    }
    function race(contenders) {
      var _this = this;
      var iters = getIterators(contenders, { returnValues: true });
      return new Repeater3(function(push2, stop2) {
        return __awaiter(_this, void 0, void 0, function() {
          var advance, stopped, finalIteration, iteration, i_1, _loop_2;
          return __generator(this, function(_a3) {
            switch (_a3.label) {
              case 0:
                if (!iters.length) {
                  stop2();
                  return [2];
                }
                stopped = false;
                stop2.then(function() {
                  advance();
                  stopped = true;
                });
                _a3.label = 1;
              case 1:
                _a3.trys.push([1, , 5, 7]);
                iteration = void 0;
                i_1 = 0;
                _loop_2 = function() {
                  var j2, iters_1, iters_1_1, iter;
                  var e_4, _a4;
                  return __generator(this, function(_b) {
                    switch (_b.label) {
                      case 0:
                        j2 = i_1;
                        try {
                          for (iters_1 = (e_4 = void 0, __values(iters)), iters_1_1 = iters_1.next(); !iters_1_1.done; iters_1_1 = iters_1.next()) {
                            iter = iters_1_1.value;
                            Promise.resolve(iter.next()).then(function(iteration2) {
                              if (iteration2.done) {
                                stop2();
                                if (finalIteration === void 0) {
                                  finalIteration = iteration2;
                                }
                              } else if (i_1 === j2) {
                                i_1++;
                                advance(iteration2);
                              }
                            }, function(err2) {
                              return stop2(err2);
                            });
                          }
                        } catch (e_4_1) {
                          e_4 = { error: e_4_1 };
                        } finally {
                          try {
                            if (iters_1_1 && !iters_1_1.done && (_a4 = iters_1.return))
                              _a4.call(iters_1);
                          } finally {
                            if (e_4)
                              throw e_4.error;
                          }
                        }
                        return [4, new Promise(function(resolve2) {
                          return advance = resolve2;
                        })];
                      case 1:
                        iteration = _b.sent();
                        if (!(iteration !== void 0))
                          return [3, 3];
                        return [4, push2(iteration.value)];
                      case 2:
                        _b.sent();
                        _b.label = 3;
                      case 3:
                        return [2];
                    }
                  });
                };
                _a3.label = 2;
              case 2:
                if (!!stopped)
                  return [3, 4];
                return [5, _loop_2()];
              case 3:
                _a3.sent();
                return [3, 2];
              case 4:
                return [2, finalIteration && finalIteration.value];
              case 5:
                stop2();
                return [4, Promise.race(iters.map(function(iter) {
                  return iter.return && iter.return();
                }))];
              case 6:
                _a3.sent();
                return [7];
              case 7:
                return [2];
            }
          });
        });
      });
    }
    function merge(contenders) {
      var _this = this;
      var iters = getIterators(contenders, { yieldValues: true });
      return new Repeater3(function(push2, stop2) {
        return __awaiter(_this, void 0, void 0, function() {
          var advances, stopped, finalIteration;
          var _this2 = this;
          return __generator(this, function(_a3) {
            switch (_a3.label) {
              case 0:
                if (!iters.length) {
                  stop2();
                  return [2];
                }
                advances = [];
                stopped = false;
                stop2.then(function() {
                  var e_5, _a4;
                  stopped = true;
                  try {
                    for (var advances_1 = __values(advances), advances_1_1 = advances_1.next(); !advances_1_1.done; advances_1_1 = advances_1.next()) {
                      var advance = advances_1_1.value;
                      advance();
                    }
                  } catch (e_5_1) {
                    e_5 = { error: e_5_1 };
                  } finally {
                    try {
                      if (advances_1_1 && !advances_1_1.done && (_a4 = advances_1.return))
                        _a4.call(advances_1);
                    } finally {
                      if (e_5)
                        throw e_5.error;
                    }
                  }
                });
                _a3.label = 1;
              case 1:
                _a3.trys.push([1, , 3, 4]);
                return [4, Promise.all(iters.map(function(iter, i) {
                  return __awaiter(_this2, void 0, void 0, function() {
                    var iteration, _a4;
                    return __generator(this, function(_b) {
                      switch (_b.label) {
                        case 0:
                          _b.trys.push([0, , 6, 9]);
                          _b.label = 1;
                        case 1:
                          if (!!stopped)
                            return [3, 5];
                          Promise.resolve(iter.next()).then(function(iteration2) {
                            return advances[i](iteration2);
                          }, function(err2) {
                            return stop2(err2);
                          });
                          return [4, new Promise(function(resolve2) {
                            advances[i] = resolve2;
                          })];
                        case 2:
                          iteration = _b.sent();
                          if (!(iteration !== void 0))
                            return [3, 4];
                          if (iteration.done) {
                            finalIteration = iteration;
                            return [2];
                          }
                          return [4, push2(iteration.value)];
                        case 3:
                          _b.sent();
                          _b.label = 4;
                        case 4:
                          return [3, 1];
                        case 5:
                          return [3, 9];
                        case 6:
                          _a4 = iter.return;
                          if (!_a4)
                            return [3, 8];
                          return [4, iter.return()];
                        case 7:
                          _a4 = _b.sent();
                          _b.label = 8;
                        case 8:
                          return [7];
                        case 9:
                          return [2];
                      }
                    });
                  });
                }))];
              case 2:
                _a3.sent();
                return [2, finalIteration && finalIteration.value];
              case 3:
                stop2();
                return [7];
              case 4:
                return [2];
            }
          });
        });
      });
    }
    function zip(contenders) {
      var _this = this;
      var iters = getIterators(contenders, { returnValues: true });
      return new Repeater3(function(push2, stop2) {
        return __awaiter(_this, void 0, void 0, function() {
          var advance, stopped, iterations, values;
          return __generator(this, function(_a3) {
            switch (_a3.label) {
              case 0:
                if (!iters.length) {
                  stop2();
                  return [2, []];
                }
                stopped = false;
                stop2.then(function() {
                  advance();
                  stopped = true;
                });
                _a3.label = 1;
              case 1:
                _a3.trys.push([1, , 6, 8]);
                _a3.label = 2;
              case 2:
                if (!!stopped)
                  return [3, 5];
                Promise.all(iters.map(function(iter) {
                  return iter.next();
                })).then(function(iterations2) {
                  return advance(iterations2);
                }, function(err2) {
                  return stop2(err2);
                });
                return [4, new Promise(function(resolve2) {
                  return advance = resolve2;
                })];
              case 3:
                iterations = _a3.sent();
                if (iterations === void 0) {
                  return [2];
                }
                values = iterations.map(function(iteration) {
                  return iteration.value;
                });
                if (iterations.some(function(iteration) {
                  return iteration.done;
                })) {
                  return [2, values];
                }
                return [4, push2(values)];
              case 4:
                _a3.sent();
                return [3, 2];
              case 5:
                return [3, 8];
              case 6:
                stop2();
                return [4, Promise.all(iters.map(function(iter) {
                  return iter.return && iter.return();
                }))];
              case 7:
                _a3.sent();
                return [7];
              case 8:
                return [2];
            }
          });
        });
      });
    }
    function latest(contenders) {
      var _this = this;
      var iters = getIterators(contenders, {
        yieldValues: true,
        returnValues: true
      });
      return new Repeater3(function(push2, stop2) {
        return __awaiter(_this, void 0, void 0, function() {
          var advance, advances, stopped, iterations_1, values_2;
          var _this2 = this;
          return __generator(this, function(_a3) {
            switch (_a3.label) {
              case 0:
                if (!iters.length) {
                  stop2();
                  return [2, []];
                }
                advances = [];
                stopped = false;
                stop2.then(function() {
                  var e_6, _a4;
                  advance();
                  try {
                    for (var advances_2 = __values(advances), advances_2_1 = advances_2.next(); !advances_2_1.done; advances_2_1 = advances_2.next()) {
                      var advance1 = advances_2_1.value;
                      advance1();
                    }
                  } catch (e_6_1) {
                    e_6 = { error: e_6_1 };
                  } finally {
                    try {
                      if (advances_2_1 && !advances_2_1.done && (_a4 = advances_2.return))
                        _a4.call(advances_2);
                    } finally {
                      if (e_6)
                        throw e_6.error;
                    }
                  }
                  stopped = true;
                });
                _a3.label = 1;
              case 1:
                _a3.trys.push([1, , 5, 7]);
                Promise.all(iters.map(function(iter) {
                  return iter.next();
                })).then(function(iterations) {
                  return advance(iterations);
                }, function(err2) {
                  return stop2(err2);
                });
                return [4, new Promise(function(resolve2) {
                  return advance = resolve2;
                })];
              case 2:
                iterations_1 = _a3.sent();
                if (iterations_1 === void 0) {
                  return [2];
                }
                values_2 = iterations_1.map(function(iteration) {
                  return iteration.value;
                });
                if (iterations_1.every(function(iteration) {
                  return iteration.done;
                })) {
                  return [2, values_2];
                }
                return [4, push2(values_2.slice())];
              case 3:
                _a3.sent();
                return [4, Promise.all(iters.map(function(iter, i) {
                  return __awaiter(_this2, void 0, void 0, function() {
                    var iteration;
                    return __generator(this, function(_a4) {
                      switch (_a4.label) {
                        case 0:
                          if (iterations_1[i].done) {
                            return [2, iterations_1[i].value];
                          }
                          _a4.label = 1;
                        case 1:
                          if (!!stopped)
                            return [3, 4];
                          Promise.resolve(iter.next()).then(function(iteration2) {
                            return advances[i](iteration2);
                          }, function(err2) {
                            return stop2(err2);
                          });
                          return [4, new Promise(function(resolve2) {
                            return advances[i] = resolve2;
                          })];
                        case 2:
                          iteration = _a4.sent();
                          if (iteration === void 0) {
                            return [2, iterations_1[i].value];
                          } else if (iteration.done) {
                            return [2, iteration.value];
                          }
                          values_2[i] = iteration.value;
                          return [4, push2(values_2.slice())];
                        case 3:
                          _a4.sent();
                          return [3, 1];
                        case 4:
                          return [2];
                      }
                    });
                  });
                }))];
              case 4:
                return [2, _a3.sent()];
              case 5:
                stop2();
                return [4, Promise.all(iters.map(function(iter) {
                  return iter.return && iter.return();
                }))];
              case 6:
                _a3.sent();
                return [7];
              case 7:
                return [2];
            }
          });
        });
      });
    }
    exports2.DroppingBuffer = DroppingBuffer;
    exports2.FixedBuffer = FixedBuffer;
    exports2.MAX_QUEUE_LENGTH = MAX_QUEUE_LENGTH;
    exports2.Repeater = Repeater3;
    exports2.RepeaterOverflowError = RepeaterOverflowError;
    exports2.SlidingBuffer = SlidingBuffer;
  }
});

// node_modules/.pnpm/@prisma+client@3.13.0_prisma@3.13.0/node_modules/@prisma/client/runtime/proxy.js
var require_proxy = __commonJS({
  "node_modules/.pnpm/@prisma+client@3.13.0_prisma@3.13.0/node_modules/@prisma/client/runtime/proxy.js"(exports, module) {
    var Sn = Object.defineProperty;
    var nu = (e2) => Sn(e2, "__esModule", { value: true });
    var y = (e2, t) => Sn(e2, "name", { value: t, configurable: true });
    var iu = (e2, t) => {
      nu(e2);
      for (var r in t)
        Sn(e2, r, { get: t[r], enumerable: true });
    };
    iu(exports, { DMMF: () => Vn, DMMFClass: () => Dn, Decimal: () => Vr, Engine: () => Jr, PrismaClientInitializationError: () => Xt, PrismaClientKnownRequestError: () => _r, PrismaClientRustPanicError: () => er, PrismaClientUnknownRequestError: () => tr, PrismaClientValidationError: () => or, Sql: () => uf, decompressFromBase64: () => sf, empty: () => lf, findSync: () => cf, getPrismaClient: () => tu, join: () => ff, makeDocument: () => Li, raw: () => pf, sqltag: () => df, transformDocument: () => Ui, unpack: () => Ji, warnEnvConflicts: () => hf });
    var ro = {};
    var au = Object.create;
    var cr = Object.defineProperty;
    var su = Object.getOwnPropertyDescriptor;
    var uu = Object.getOwnPropertyNames;
    var lu = Object.getPrototypeOf;
    var cu = Object.prototype.hasOwnProperty;
    var no = y((e2) => cr(e2, "__esModule", { value: true }), "Ui");
    var d = y((e2, t) => cr(e2, "name", { value: t, configurable: true }), "u");
    var fr = y((e2, t) => () => (e2 && (t = e2(e2 = 0)), t), "sr");
    var ve = y((e2, t) => () => (t || e2((t = { exports: {} }).exports, t), t.exports), "W");
    var io = y((e2, t) => {
      no(e2);
      for (var r in t)
        cr(e2, r, { get: t[r], enumerable: true });
    }, "Vi");
    var fu = y((e2, t, r) => {
      if (t && typeof t == "object" || typeof t == "function")
        for (let n of uu(t))
          !cu.call(e2, n) && n !== "default" && cr(e2, n, { get: () => t[n], enumerable: !(r = su(t, n)) || r.enumerable });
      return e2;
    }, "Ul");
    var Ae = y((e2) => fu(no(cr(e2 != null ? au(lu(e2)) : {}, "default", e2 && e2.__esModule && "default" in e2 ? { get: () => e2.default, enumerable: true } : { value: e2, enumerable: true })), e2), "Z");
    var pr;
    var j = fr(() => {
      pr = {};
    });
    var ct;
    var N = fr(() => {
      ct = {};
    });
    function ue(e2) {
      return () => e2;
    }
    y(ue, "q");
    function Ye() {
      return we;
    }
    y(Ye, "Me");
    var oo;
    var we;
    var k = fr(() => {
      d(ue, "noop"), oo = Promise.resolve(), d(Ye, "getProcess"), we = { abort: ue(void 0), addListener: ue(Ye()), allowedNodeEnvironmentFlags: /* @__PURE__ */ new Set(), arch: "x64", argv: ["/bin/node"], argv0: "node", chdir: ue(void 0), config: { target_defaults: { cflags: [], default_configuration: "", defines: [], include_dirs: [], libraries: [] }, variables: { clang: 0, host_arch: "x64", node_install_npm: false, node_install_waf: false, node_prefix: "", node_shared_openssl: false, node_shared_v8: false, node_shared_zlib: false, node_use_dtrace: false, node_use_etw: false, node_use_openssl: false, target_arch: "x64", v8_no_strict_aliasing: 0, v8_use_snapshot: false, visibility: "" } }, connected: false, cpuUsage: () => ({ user: 0, system: 0 }), cwd: () => "/", debugPort: 0, disconnect: ue(void 0), domain: { run: ue(void 0), add: ue(void 0), remove: ue(void 0), bind: ue(void 0), intercept: ue(void 0), ...Ye() }, emit: ue(Ye()), emitWarning: ue(void 0), env: {}, eventNames: () => [], execArgv: [], execPath: "/", exit: ue(void 0), features: { inspector: false, debug: false, uv: false, ipv6: false, tls_alpn: false, tls_sni: false, tls_ocsp: false, tls: false }, getMaxListeners: ue(0), getegid: ue(0), geteuid: ue(0), getgid: ue(0), getgroups: ue([]), getuid: ue(0), hasUncaughtExceptionCaptureCallback: ue(false), hrtime: ue([0, 0]), platform: "linux", kill: ue(true), listenerCount: ue(0), listeners: ue([]), memoryUsage: ue({ arrayBuffers: 0, external: 0, heapTotal: 0, heapUsed: 0, rss: 0 }), nextTick: (e2, ...t) => {
        oo.then(() => e2(...t)).catch((r) => {
          setTimeout(() => {
            throw r;
          }, 0);
        });
      }, off: ue(Ye()), on: ue(Ye()), once: ue(Ye()), openStdin: ue({}), pid: 0, ppid: 0, prependListener: ue(Ye()), prependOnceListener: ue(Ye()), rawListeners: ue([]), release: { name: "node" }, removeAllListeners: ue(Ye()), removeListener: ue(Ye()), resourceUsage: ue({ fsRead: 0, fsWrite: 0, involuntaryContextSwitches: 0, ipcReceived: 0, ipcSent: 0, majorPageFault: 0, maxRSS: 0, minorPageFault: 0, sharedMemorySize: 0, signalsCount: 0, swappedOut: 0, systemCPUTime: 0, unsharedDataSize: 0, unsharedStackSize: 0, userCPUTime: 0, voluntaryContextSwitches: 0 }), setMaxListeners: ue(Ye()), setUncaughtExceptionCaptureCallback: ue(void 0), setegid: ue(void 0), seteuid: ue(void 0), setgid: ue(void 0), setgroups: ue(void 0), setuid: ue(void 0), stderr: { fd: 2 }, stdin: { fd: 0 }, stdout: { fd: 1 }, title: "node", traceDeprecation: false, umask: ue(0), uptime: ue(0), version: "", versions: { http_parser: "", node: "", v8: "", ares: "", uv: "", zlib: "", modules: "", openssl: "" } };
    });
    var pu = ve((e2) => {
      j(), N(), I(), k();
      var t = d((u, h) => () => (h || u((h = { exports: {} }).exports, h), h.exports), "q"), r = t((u) => {
        "use strict";
        u.byteLength = re, u.toByteArray = ee, u.fromByteArray = Re;
        var h = [], m = [], _ = typeof Uint8Array != "undefined" ? Uint8Array : Array, O = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        for (M = 0, L = O.length; M < L; ++M)
          h[M] = O[M], m[O.charCodeAt(M)] = M;
        var M, L;
        m["-".charCodeAt(0)] = 62, m["_".charCodeAt(0)] = 63;
        function J(ie) {
          var he = ie.length;
          if (he % 4 > 0)
            throw new Error("Invalid string. Length must be a multiple of 4");
          var _e = ie.indexOf("=");
          _e === -1 && (_e = he);
          var xe = _e === he ? 0 : 4 - _e % 4;
          return [_e, xe];
        }
        y(J, "a"), d(J, "j");
        function re(ie) {
          var he = J(ie), _e = he[0], xe = he[1];
          return (_e + xe) * 3 / 4 - xe;
        }
        y(re, "l"), d(re, "sr");
        function X(ie, he, _e) {
          return (he + _e) * 3 / 4 - _e;
        }
        y(X, "c"), d(X, "lr");
        function ee(ie) {
          var he, _e = J(ie), xe = _e[0], Ne = _e[1], ce = new _(X(ie, xe, Ne)), ge = 0, ye = Ne > 0 ? xe - 4 : xe, me;
          for (me = 0; me < ye; me += 4)
            he = m[ie.charCodeAt(me)] << 18 | m[ie.charCodeAt(me + 1)] << 12 | m[ie.charCodeAt(me + 2)] << 6 | m[ie.charCodeAt(me + 3)], ce[ge++] = he >> 16 & 255, ce[ge++] = he >> 8 & 255, ce[ge++] = he & 255;
          return Ne === 2 && (he = m[ie.charCodeAt(me)] << 2 | m[ie.charCodeAt(me + 1)] >> 4, ce[ge++] = he & 255), Ne === 1 && (he = m[ie.charCodeAt(me)] << 10 | m[ie.charCodeAt(me + 1)] << 4 | m[ie.charCodeAt(me + 2)] >> 2, ce[ge++] = he >> 8 & 255, ce[ge++] = he & 255), ce;
        }
        y(ee, "f"), d(ee, "ar");
        function ne(ie) {
          return h[ie >> 18 & 63] + h[ie >> 12 & 63] + h[ie >> 6 & 63] + h[ie & 63];
        }
        y(ne, "p"), d(ne, "yr");
        function Te(ie, he, _e) {
          for (var xe, Ne = [], ce = he; ce < _e; ce += 3)
            xe = (ie[ce] << 16 & 16711680) + (ie[ce + 1] << 8 & 65280) + (ie[ce + 2] & 255), Ne.push(ne(xe));
          return Ne.join("");
        }
        y(Te, "y"), d(Te, "wr");
        function Re(ie) {
          for (var he, _e = ie.length, xe = _e % 3, Ne = [], ce = 16383, ge = 0, ye = _e - xe; ge < ye; ge += ce)
            Ne.push(Te(ie, ge, ge + ce > ye ? ye : ge + ce));
          return xe === 1 ? (he = ie[_e - 1], Ne.push(h[he >> 2] + h[he << 4 & 63] + "==")) : xe === 2 && (he = (ie[_e - 2] << 8) + ie[_e - 1], Ne.push(h[he >> 10] + h[he >> 4 & 63] + h[he << 2 & 63] + "=")), Ne.join("");
        }
        y(Re, "w"), d(Re, "xr");
      }), n = t((u) => {
        u.read = function(h, m, _, O, M) {
          var L, J, re = M * 8 - O - 1, X = (1 << re) - 1, ee = X >> 1, ne = -7, Te = _ ? M - 1 : 0, Re = _ ? -1 : 1, ie = h[m + Te];
          for (Te += Re, L = ie & (1 << -ne) - 1, ie >>= -ne, ne += re; ne > 0; L = L * 256 + h[m + Te], Te += Re, ne -= 8)
            ;
          for (J = L & (1 << -ne) - 1, L >>= -ne, ne += O; ne > 0; J = J * 256 + h[m + Te], Te += Re, ne -= 8)
            ;
          if (L === 0)
            L = 1 - ee;
          else {
            if (L === X)
              return J ? NaN : (ie ? -1 : 1) * (1 / 0);
            J = J + Math.pow(2, O), L = L - ee;
          }
          return (ie ? -1 : 1) * J * Math.pow(2, L - O);
        }, u.write = function(h, m, _, O, M, L) {
          var J, re, X, ee = L * 8 - M - 1, ne = (1 << ee) - 1, Te = ne >> 1, Re = M === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, ie = O ? 0 : L - 1, he = O ? 1 : -1, _e = m < 0 || m === 0 && 1 / m < 0 ? 1 : 0;
          for (m = Math.abs(m), isNaN(m) || m === 1 / 0 ? (re = isNaN(m) ? 1 : 0, J = ne) : (J = Math.floor(Math.log(m) / Math.LN2), m * (X = Math.pow(2, -J)) < 1 && (J--, X *= 2), J + Te >= 1 ? m += Re / X : m += Re * Math.pow(2, 1 - Te), m * X >= 2 && (J++, X /= 2), J + Te >= ne ? (re = 0, J = ne) : J + Te >= 1 ? (re = (m * X - 1) * Math.pow(2, M), J = J + Te) : (re = m * Math.pow(2, Te - 1) * Math.pow(2, M), J = 0)); M >= 8; h[_ + ie] = re & 255, ie += he, re /= 256, M -= 8)
            ;
          for (J = J << M | re, ee += M; ee > 0; h[_ + ie] = J & 255, ie += he, J /= 256, ee -= 8)
            ;
          h[_ + ie - he] |= _e * 128;
        };
      }), i = r(), a = n(), o = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
      e2.Buffer = c, e2.SlowBuffer = q, e2.INSPECT_MAX_BYTES = 50;
      var l = 2147483647;
      e2.kMaxLength = l, c.TYPED_ARRAY_SUPPORT = f(), !c.TYPED_ARRAY_SUPPORT && typeof console != "undefined" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
      function f() {
        try {
          let u = new Uint8Array(1), h = { foo: function() {
            return 42;
          } };
          return Object.setPrototypeOf(h, Uint8Array.prototype), Object.setPrototypeOf(u, h), u.foo() === 42;
        } catch (u) {
          return false;
        }
      }
      y(f, "Hl"), d(f, "Br"), Object.defineProperty(c.prototype, "parent", { enumerable: true, get: function() {
        if (c.isBuffer(this))
          return this.buffer;
      } }), Object.defineProperty(c.prototype, "offset", { enumerable: true, get: function() {
        if (c.isBuffer(this))
          return this.byteOffset;
      } });
      function s(u) {
        if (u > l)
          throw new RangeError('The value "' + u + '" is invalid for option "size"');
        let h = new Uint8Array(u);
        return Object.setPrototypeOf(h, c.prototype), h;
      }
      y(s, "Je"), d(s, "d");
      function c(u, h, m) {
        if (typeof u == "number") {
          if (typeof h == "string")
            throw new TypeError('The "string" argument must be of type string. Received type number');
          return b(u);
        }
        return p(u, h, m);
      }
      y(c, "O"), d(c, "h"), c.poolSize = 8192;
      function p(u, h, m) {
        if (typeof u == "string")
          return w(u, h);
        if (ArrayBuffer.isView(u))
          return x(u);
        if (u == null)
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof u);
        if (U(u, ArrayBuffer) || u && U(u.buffer, ArrayBuffer) || typeof SharedArrayBuffer != "undefined" && (U(u, SharedArrayBuffer) || u && U(u.buffer, SharedArrayBuffer)))
          return S(u, h, m);
        if (typeof u == "number")
          throw new TypeError('The "value" argument must not be of type number. Received type number');
        let _ = u.valueOf && u.valueOf();
        if (_ != null && _ !== u)
          return c.from(_, h, m);
        let O = A(u);
        if (O)
          return O;
        if (typeof Symbol != "undefined" && Symbol.toPrimitive != null && typeof u[Symbol.toPrimitive] == "function")
          return c.from(u[Symbol.toPrimitive]("string"), h, m);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof u);
      }
      y(p, "zi"), d(p, "z"), c.from = function(u, h, m) {
        return p(u, h, m);
      }, Object.setPrototypeOf(c.prototype, Uint8Array.prototype), Object.setPrototypeOf(c, Uint8Array);
      function g(u) {
        if (typeof u != "number")
          throw new TypeError('"size" argument must be of type number');
        if (u < 0)
          throw new RangeError('The value "' + u + '" is invalid for option "size"');
      }
      y(g, "Wi"), d(g, "J");
      function v(u, h, m) {
        return g(u), u <= 0 ? s(u) : h !== void 0 ? typeof m == "string" ? s(u).fill(h, m) : s(u).fill(h) : s(u);
      }
      y(v, "Yl"), d(v, "Er"), c.alloc = function(u, h, m) {
        return v(u, h, m);
      };
      function b(u) {
        return g(u), s(u < 0 ? 0 : F(u) | 0);
      }
      y(b, "Qn"), d(b, "D"), c.allocUnsafe = function(u) {
        return b(u);
      }, c.allocUnsafeSlow = function(u) {
        return b(u);
      };
      function w(u, h) {
        if ((typeof h != "string" || h === "") && (h = "utf8"), !c.isEncoding(h))
          throw new TypeError("Unknown encoding: " + h);
        let m = R(u, h) | 0, _ = s(m), O = _.write(u, h);
        return O !== m && (_ = _.slice(0, O)), _;
      }
      y(w, "Ql"), d(w, "dr");
      function E(u) {
        let h = u.length < 0 ? 0 : F(u.length) | 0, m = s(h);
        for (let _ = 0; _ < h; _ += 1)
          m[_] = u[_] & 255;
        return m;
      }
      y(E, "Kn"), d(E, "b");
      function x(u) {
        if (U(u, Uint8Array)) {
          let h = new Uint8Array(u);
          return S(h.buffer, h.byteOffset, h.byteLength);
        }
        return E(u);
      }
      y(x, "Kl"), d(x, "gr");
      function S(u, h, m) {
        if (h < 0 || u.byteLength < h)
          throw new RangeError('"offset" is outside of buffer bounds');
        if (u.byteLength < h + (m || 0))
          throw new RangeError('"length" is outside of buffer bounds');
        let _;
        return h === void 0 && m === void 0 ? _ = new Uint8Array(u) : m === void 0 ? _ = new Uint8Array(u, h) : _ = new Uint8Array(u, h, m), Object.setPrototypeOf(_, c.prototype), _;
      }
      y(S, "Hi"), d(S, "$");
      function A(u) {
        if (c.isBuffer(u)) {
          let h = F(u.length) | 0, m = s(h);
          return m.length === 0 || u.copy(m, 0, 0, h), m;
        }
        if (u.length !== void 0)
          return typeof u.length != "number" || Q(u.length) ? s(0) : E(u);
        if (u.type === "Buffer" && Array.isArray(u.data))
          return E(u.data);
      }
      y(A, "Zl"), d(A, "mr");
      function F(u) {
        if (u >= l)
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + l.toString(16) + " bytes");
        return u | 0;
      }
      y(F, "Zn"), d(F, "P");
      function q(u) {
        return +u != u && (u = 0), c.alloc(+u);
      }
      y(q, "Xl"), d(q, "Ir"), c.isBuffer = function(u) {
        return u != null && u._isBuffer === true && u !== c.prototype;
      }, c.compare = function(u, h) {
        if (U(u, Uint8Array) && (u = c.from(u, u.offset, u.byteLength)), U(h, Uint8Array) && (h = c.from(h, h.offset, h.byteLength)), !c.isBuffer(u) || !c.isBuffer(h))
          throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (u === h)
          return 0;
        let m = u.length, _ = h.length;
        for (let O = 0, M = Math.min(m, _); O < M; ++O)
          if (u[O] !== h[O]) {
            m = u[O], _ = h[O];
            break;
          }
        return m < _ ? -1 : _ < m ? 1 : 0;
      }, c.isEncoding = function(u) {
        switch (String(u).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      }, c.concat = function(u, h) {
        if (!Array.isArray(u))
          throw new TypeError('"list" argument must be an Array of Buffers');
        if (u.length === 0)
          return c.alloc(0);
        let m;
        if (h === void 0)
          for (h = 0, m = 0; m < u.length; ++m)
            h += u[m].length;
        let _ = c.allocUnsafe(h), O = 0;
        for (m = 0; m < u.length; ++m) {
          let M = u[m];
          if (U(M, Uint8Array))
            O + M.length > _.length ? (c.isBuffer(M) || (M = c.from(M)), M.copy(_, O)) : Uint8Array.prototype.set.call(_, M, O);
          else if (c.isBuffer(M))
            M.copy(_, O);
          else
            throw new TypeError('"list" argument must be an Array of Buffers');
          O += M.length;
        }
        return _;
      };
      function R(u, h) {
        if (c.isBuffer(u))
          return u.length;
        if (ArrayBuffer.isView(u) || U(u, ArrayBuffer))
          return u.byteLength;
        if (typeof u != "string")
          throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof u);
        let m = u.length, _ = arguments.length > 2 && arguments[2] === true;
        if (!_ && m === 0)
          return 0;
        let O = false;
        for (; ; )
          switch (h) {
            case "ascii":
            case "latin1":
            case "binary":
              return m;
            case "utf8":
            case "utf-8":
              return kt(u).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return m * 2;
            case "hex":
              return m >>> 1;
            case "base64":
              return $(u).length;
            default:
              if (O)
                return _ ? -1 : kt(u).length;
              h = ("" + h).toLowerCase(), O = true;
          }
      }
      y(R, "Yi"), d(R, "K"), c.byteLength = R;
      function C(u, h, m) {
        let _ = false;
        if ((h === void 0 || h < 0) && (h = 0), h > this.length || ((m === void 0 || m > this.length) && (m = this.length), m <= 0) || (m >>>= 0, h >>>= 0, m <= h))
          return "";
        for (u || (u = "utf8"); ; )
          switch (u) {
            case "hex":
              return _t(this, h, m);
            case "utf8":
            case "utf-8":
              return De(this, h, m);
            case "ascii":
              return Dt(this, h, m);
            case "latin1":
            case "binary":
              return jt(this, h, m);
            case "base64":
              return le(this, h, m);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return sr(this, h, m);
            default:
              if (_)
                throw new TypeError("Unknown encoding: " + u);
              u = (u + "").toLowerCase(), _ = true;
          }
      }
      y(C, "ec"), d(C, "Fr"), c.prototype._isBuffer = true;
      function B(u, h, m) {
        let _ = u[h];
        u[h] = u[m], u[m] = _;
      }
      y(B, "yt"), d(B, "I"), c.prototype.swap16 = function() {
        let u = this.length;
        if (u % 2 != 0)
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let h = 0; h < u; h += 2)
          B(this, h, h + 1);
        return this;
      }, c.prototype.swap32 = function() {
        let u = this.length;
        if (u % 4 != 0)
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let h = 0; h < u; h += 4)
          B(this, h, h + 3), B(this, h + 1, h + 2);
        return this;
      }, c.prototype.swap64 = function() {
        let u = this.length;
        if (u % 8 != 0)
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let h = 0; h < u; h += 8)
          B(this, h, h + 7), B(this, h + 1, h + 6), B(this, h + 2, h + 5), B(this, h + 3, h + 4);
        return this;
      }, c.prototype.toString = function() {
        let u = this.length;
        return u === 0 ? "" : arguments.length === 0 ? De(this, 0, u) : C.apply(this, arguments);
      }, c.prototype.toLocaleString = c.prototype.toString, c.prototype.equals = function(u) {
        if (!c.isBuffer(u))
          throw new TypeError("Argument must be a Buffer");
        return this === u ? true : c.compare(this, u) === 0;
      }, c.prototype.inspect = function() {
        let u = "", h = e2.INSPECT_MAX_BYTES;
        return u = this.toString("hex", 0, h).replace(/(.{2})/g, "$1 ").trim(), this.length > h && (u += " ... "), "<Buffer " + u + ">";
      }, o && (c.prototype[o] = c.prototype.inspect), c.prototype.compare = function(u, h, m, _, O) {
        if (U(u, Uint8Array) && (u = c.from(u, u.offset, u.byteLength)), !c.isBuffer(u))
          throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof u);
        if (h === void 0 && (h = 0), m === void 0 && (m = u ? u.length : 0), _ === void 0 && (_ = 0), O === void 0 && (O = this.length), h < 0 || m > u.length || _ < 0 || O > this.length)
          throw new RangeError("out of range index");
        if (_ >= O && h >= m)
          return 0;
        if (_ >= O)
          return -1;
        if (h >= m)
          return 1;
        if (h >>>= 0, m >>>= 0, _ >>>= 0, O >>>= 0, this === u)
          return 0;
        let M = O - _, L = m - h, J = Math.min(M, L), re = this.slice(_, O), X = u.slice(h, m);
        for (let ee = 0; ee < J; ++ee)
          if (re[ee] !== X[ee]) {
            M = re[ee], L = X[ee];
            break;
          }
        return M < L ? -1 : L < M ? 1 : 0;
      };
      function W(u, h, m, _, O) {
        if (u.length === 0)
          return -1;
        if (typeof m == "string" ? (_ = m, m = 0) : m > 2147483647 ? m = 2147483647 : m < -2147483648 && (m = -2147483648), m = +m, Q(m) && (m = O ? 0 : u.length - 1), m < 0 && (m = u.length + m), m >= u.length) {
          if (O)
            return -1;
          m = u.length - 1;
        } else if (m < 0)
          if (O)
            m = 0;
          else
            return -1;
        if (typeof h == "string" && (h = c.from(h, _)), c.isBuffer(h))
          return h.length === 0 ? -1 : G(u, h, m, _, O);
        if (typeof h == "number")
          return h = h & 255, typeof Uint8Array.prototype.indexOf == "function" ? O ? Uint8Array.prototype.indexOf.call(u, h, m) : Uint8Array.prototype.lastIndexOf.call(u, h, m) : G(u, [h], m, _, O);
        throw new TypeError("val must be string, number or Buffer");
      }
      y(W, "Qi"), d(W, "Z");
      function G(u, h, m, _, O) {
        let M = 1, L = u.length, J = h.length;
        if (_ !== void 0 && (_ = String(_).toLowerCase(), _ === "ucs2" || _ === "ucs-2" || _ === "utf16le" || _ === "utf-16le")) {
          if (u.length < 2 || h.length < 2)
            return -1;
          M = 2, L /= 2, J /= 2, m /= 2;
        }
        function re(ee, ne) {
          return M === 1 ? ee[ne] : ee.readUInt16BE(ne * M);
        }
        y(re, "l"), d(re, "c");
        let X;
        if (O) {
          let ee = -1;
          for (X = m; X < L; X++)
            if (re(u, X) === re(h, ee === -1 ? 0 : X - ee)) {
              if (ee === -1 && (ee = X), X - ee + 1 === J)
                return ee * M;
            } else
              ee !== -1 && (X -= X - ee), ee = -1;
        } else
          for (m + J > L && (m = L - J), X = m; X >= 0; X--) {
            let ee = true;
            for (let ne = 0; ne < J; ne++)
              if (re(u, X + ne) !== re(h, ne)) {
                ee = false;
                break;
              }
            if (ee)
              return X;
          }
        return -1;
      }
      y(G, "Ki"), d(G, "Q"), c.prototype.includes = function(u, h, m) {
        return this.indexOf(u, h, m) !== -1;
      }, c.prototype.indexOf = function(u, h, m) {
        return W(this, u, h, m, true);
      }, c.prototype.lastIndexOf = function(u, h, m) {
        return W(this, u, h, m, false);
      };
      function pe(u, h, m, _) {
        m = Number(m) || 0;
        let O = u.length - m;
        _ ? (_ = Number(_), _ > O && (_ = O)) : _ = O;
        let M = h.length;
        _ > M / 2 && (_ = M / 2);
        let L;
        for (L = 0; L < _; ++L) {
          let J = parseInt(h.substr(L * 2, 2), 16);
          if (Q(J))
            return L;
          u[m + L] = J;
        }
        return L;
      }
      y(pe, "tc"), d(pe, "Ar");
      function H(u, h, m, _) {
        return P(kt(h, u.length - m), u, m, _);
      }
      y(H, "rc"), d(H, "Ur");
      function de(u, h, m, _) {
        return P(lr(h), u, m, _);
      }
      y(de, "nc"), d(de, "Rr");
      function be(u, h, m, _) {
        return P($(h), u, m, _);
      }
      y(be, "oc"), d(be, "Tr");
      function se(u, h, m, _) {
        return P(T(h, u.length - m), u, m, _);
      }
      y(se, "ic"), d(se, "Cr"), c.prototype.write = function(u, h, m, _) {
        if (h === void 0)
          _ = "utf8", m = this.length, h = 0;
        else if (m === void 0 && typeof h == "string")
          _ = h, m = this.length, h = 0;
        else if (isFinite(h))
          h = h >>> 0, isFinite(m) ? (m = m >>> 0, _ === void 0 && (_ = "utf8")) : (_ = m, m = void 0);
        else
          throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        let O = this.length - h;
        if ((m === void 0 || m > O) && (m = O), u.length > 0 && (m < 0 || h < 0) || h > this.length)
          throw new RangeError("Attempt to write outside buffer bounds");
        _ || (_ = "utf8");
        let M = false;
        for (; ; )
          switch (_) {
            case "hex":
              return pe(this, u, h, m);
            case "utf8":
            case "utf-8":
              return H(this, u, h, m);
            case "ascii":
            case "latin1":
            case "binary":
              return de(this, u, h, m);
            case "base64":
              return be(this, u, h, m);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return se(this, u, h, m);
            default:
              if (M)
                throw new TypeError("Unknown encoding: " + _);
              _ = ("" + _).toLowerCase(), M = true;
          }
      }, c.prototype.toJSON = function() {
        return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
      };
      function le(u, h, m) {
        return h === 0 && m === u.length ? i.fromByteArray(u) : i.fromByteArray(u.slice(h, m));
      }
      y(le, "sc"), d(le, "Sr");
      function De(u, h, m) {
        m = Math.min(u.length, m);
        let _ = [], O = h;
        for (; O < m; ) {
          let M = u[O], L = null, J = M > 239 ? 4 : M > 223 ? 3 : M > 191 ? 2 : 1;
          if (O + J <= m) {
            let re, X, ee, ne;
            switch (J) {
              case 1:
                M < 128 && (L = M);
                break;
              case 2:
                re = u[O + 1], (re & 192) == 128 && (ne = (M & 31) << 6 | re & 63, ne > 127 && (L = ne));
                break;
              case 3:
                re = u[O + 1], X = u[O + 2], (re & 192) == 128 && (X & 192) == 128 && (ne = (M & 15) << 12 | (re & 63) << 6 | X & 63, ne > 2047 && (ne < 55296 || ne > 57343) && (L = ne));
                break;
              case 4:
                re = u[O + 1], X = u[O + 2], ee = u[O + 3], (re & 192) == 128 && (X & 192) == 128 && (ee & 192) == 128 && (ne = (M & 15) << 18 | (re & 63) << 12 | (X & 63) << 6 | ee & 63, ne > 65535 && ne < 1114112 && (L = ne));
            }
          }
          L === null ? (L = 65533, J = 1) : L > 65535 && (L -= 65536, _.push(L >>> 10 & 1023 | 55296), L = 56320 | L & 1023), _.push(L), O += J;
        }
        return ar(_);
      }
      y(De, "Zi"), d(De, "v");
      var Pt = 4096;
      function ar(u) {
        let h = u.length;
        if (h <= Pt)
          return String.fromCharCode.apply(String, u);
        let m = "", _ = 0;
        for (; _ < h; )
          m += String.fromCharCode.apply(String, u.slice(_, _ += Pt));
        return m;
      }
      y(ar, "ac"), d(ar, "_r");
      function Dt(u, h, m) {
        let _ = "";
        m = Math.min(u.length, m);
        for (let O = h; O < m; ++O)
          _ += String.fromCharCode(u[O] & 127);
        return _;
      }
      y(Dt, "uc"), d(Dt, "Lr");
      function jt(u, h, m) {
        let _ = "";
        m = Math.min(u.length, m);
        for (let O = h; O < m; ++O)
          _ += String.fromCharCode(u[O]);
        return _;
      }
      y(jt, "lc"), d(jt, "Nr");
      function _t(u, h, m) {
        let _ = u.length;
        (!h || h < 0) && (h = 0), (!m || m < 0 || m > _) && (m = _);
        let O = "";
        for (let M = h; M < m; ++M)
          O += Y[u[M]];
        return O;
      }
      y(_t, "cc"), d(_t, "Mr");
      function sr(u, h, m) {
        let _ = u.slice(h, m), O = "";
        for (let M = 0; M < _.length - 1; M += 2)
          O += String.fromCharCode(_[M] + _[M + 1] * 256);
        return O;
      }
      y(sr, "fc"), d(sr, "kr"), c.prototype.slice = function(u, h) {
        let m = this.length;
        u = ~~u, h = h === void 0 ? m : ~~h, u < 0 ? (u += m, u < 0 && (u = 0)) : u > m && (u = m), h < 0 ? (h += m, h < 0 && (h = 0)) : h > m && (h = m), h < u && (h = u);
        let _ = this.subarray(u, h);
        return Object.setPrototypeOf(_, c.prototype), _;
      };
      function Oe(u, h, m) {
        if (u % 1 != 0 || u < 0)
          throw new RangeError("offset is not uint");
        if (u + h > m)
          throw new RangeError("Trying to access beyond buffer length");
      }
      y(Oe, "oe"), d(Oe, "a"), c.prototype.readUintLE = c.prototype.readUIntLE = function(u, h, m) {
        u = u >>> 0, h = h >>> 0, m || Oe(u, h, this.length);
        let _ = this[u], O = 1, M = 0;
        for (; ++M < h && (O *= 256); )
          _ += this[u + M] * O;
        return _;
      }, c.prototype.readUintBE = c.prototype.readUIntBE = function(u, h, m) {
        u = u >>> 0, h = h >>> 0, m || Oe(u, h, this.length);
        let _ = this[u + --h], O = 1;
        for (; h > 0 && (O *= 256); )
          _ += this[u + --h] * O;
        return _;
      }, c.prototype.readUint8 = c.prototype.readUInt8 = function(u, h) {
        return u = u >>> 0, h || Oe(u, 1, this.length), this[u];
      }, c.prototype.readUint16LE = c.prototype.readUInt16LE = function(u, h) {
        return u = u >>> 0, h || Oe(u, 2, this.length), this[u] | this[u + 1] << 8;
      }, c.prototype.readUint16BE = c.prototype.readUInt16BE = function(u, h) {
        return u = u >>> 0, h || Oe(u, 2, this.length), this[u] << 8 | this[u + 1];
      }, c.prototype.readUint32LE = c.prototype.readUInt32LE = function(u, h) {
        return u = u >>> 0, h || Oe(u, 4, this.length), (this[u] | this[u + 1] << 8 | this[u + 2] << 16) + this[u + 3] * 16777216;
      }, c.prototype.readUint32BE = c.prototype.readUInt32BE = function(u, h) {
        return u = u >>> 0, h || Oe(u, 4, this.length), this[u] * 16777216 + (this[u + 1] << 16 | this[u + 2] << 8 | this[u + 3]);
      }, c.prototype.readBigUInt64LE = z(function(u) {
        u = u >>> 0, dt(u, "offset");
        let h = this[u], m = this[u + 7];
        (h === void 0 || m === void 0) && ht(u, this.length - 8);
        let _ = h + this[++u] * 2 ** 8 + this[++u] * 2 ** 16 + this[++u] * 2 ** 24, O = this[++u] + this[++u] * 2 ** 8 + this[++u] * 2 ** 16 + m * 2 ** 24;
        return BigInt(_) + (BigInt(O) << BigInt(32));
      }), c.prototype.readBigUInt64BE = z(function(u) {
        u = u >>> 0, dt(u, "offset");
        let h = this[u], m = this[u + 7];
        (h === void 0 || m === void 0) && ht(u, this.length - 8);
        let _ = h * 2 ** 24 + this[++u] * 2 ** 16 + this[++u] * 2 ** 8 + this[++u], O = this[++u] * 2 ** 24 + this[++u] * 2 ** 16 + this[++u] * 2 ** 8 + m;
        return (BigInt(_) << BigInt(32)) + BigInt(O);
      }), c.prototype.readIntLE = function(u, h, m) {
        u = u >>> 0, h = h >>> 0, m || Oe(u, h, this.length);
        let _ = this[u], O = 1, M = 0;
        for (; ++M < h && (O *= 256); )
          _ += this[u + M] * O;
        return O *= 128, _ >= O && (_ -= Math.pow(2, 8 * h)), _;
      }, c.prototype.readIntBE = function(u, h, m) {
        u = u >>> 0, h = h >>> 0, m || Oe(u, h, this.length);
        let _ = h, O = 1, M = this[u + --_];
        for (; _ > 0 && (O *= 256); )
          M += this[u + --_] * O;
        return O *= 128, M >= O && (M -= Math.pow(2, 8 * h)), M;
      }, c.prototype.readInt8 = function(u, h) {
        return u = u >>> 0, h || Oe(u, 1, this.length), this[u] & 128 ? (255 - this[u] + 1) * -1 : this[u];
      }, c.prototype.readInt16LE = function(u, h) {
        u = u >>> 0, h || Oe(u, 2, this.length);
        let m = this[u] | this[u + 1] << 8;
        return m & 32768 ? m | 4294901760 : m;
      }, c.prototype.readInt16BE = function(u, h) {
        u = u >>> 0, h || Oe(u, 2, this.length);
        let m = this[u + 1] | this[u] << 8;
        return m & 32768 ? m | 4294901760 : m;
      }, c.prototype.readInt32LE = function(u, h) {
        return u = u >>> 0, h || Oe(u, 4, this.length), this[u] | this[u + 1] << 8 | this[u + 2] << 16 | this[u + 3] << 24;
      }, c.prototype.readInt32BE = function(u, h) {
        return u = u >>> 0, h || Oe(u, 4, this.length), this[u] << 24 | this[u + 1] << 16 | this[u + 2] << 8 | this[u + 3];
      }, c.prototype.readBigInt64LE = z(function(u) {
        u = u >>> 0, dt(u, "offset");
        let h = this[u], m = this[u + 7];
        (h === void 0 || m === void 0) && ht(u, this.length - 8);
        let _ = this[u + 4] + this[u + 5] * 2 ** 8 + this[u + 6] * 2 ** 16 + (m << 24);
        return (BigInt(_) << BigInt(32)) + BigInt(h + this[++u] * 2 ** 8 + this[++u] * 2 ** 16 + this[++u] * 2 ** 24);
      }), c.prototype.readBigInt64BE = z(function(u) {
        u = u >>> 0, dt(u, "offset");
        let h = this[u], m = this[u + 7];
        (h === void 0 || m === void 0) && ht(u, this.length - 8);
        let _ = (h << 24) + this[++u] * 2 ** 16 + this[++u] * 2 ** 8 + this[++u];
        return (BigInt(_) << BigInt(32)) + BigInt(this[++u] * 2 ** 24 + this[++u] * 2 ** 16 + this[++u] * 2 ** 8 + m);
      }), c.prototype.readFloatLE = function(u, h) {
        return u = u >>> 0, h || Oe(u, 4, this.length), a.read(this, u, true, 23, 4);
      }, c.prototype.readFloatBE = function(u, h) {
        return u = u >>> 0, h || Oe(u, 4, this.length), a.read(this, u, false, 23, 4);
      }, c.prototype.readDoubleLE = function(u, h) {
        return u = u >>> 0, h || Oe(u, 8, this.length), a.read(this, u, true, 52, 8);
      }, c.prototype.readDoubleBE = function(u, h) {
        return u = u >>> 0, h || Oe(u, 8, this.length), a.read(this, u, false, 52, 8);
      };
      function Se(u, h, m, _, O, M) {
        if (!c.isBuffer(u))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (h > O || h < M)
          throw new RangeError('"value" argument is out of bounds');
        if (m + _ > u.length)
          throw new RangeError("Index out of range");
      }
      y(Se, "we"), d(Se, "y"), c.prototype.writeUintLE = c.prototype.writeUIntLE = function(u, h, m, _) {
        if (u = +u, h = h >>> 0, m = m >>> 0, !_) {
          let L = Math.pow(2, 8 * m) - 1;
          Se(this, u, h, m, L, 0);
        }
        let O = 1, M = 0;
        for (this[h] = u & 255; ++M < m && (O *= 256); )
          this[h + M] = u / O & 255;
        return h + m;
      }, c.prototype.writeUintBE = c.prototype.writeUIntBE = function(u, h, m, _) {
        if (u = +u, h = h >>> 0, m = m >>> 0, !_) {
          let L = Math.pow(2, 8 * m) - 1;
          Se(this, u, h, m, L, 0);
        }
        let O = m - 1, M = 1;
        for (this[h + O] = u & 255; --O >= 0 && (M *= 256); )
          this[h + O] = u / M & 255;
        return h + m;
      }, c.prototype.writeUint8 = c.prototype.writeUInt8 = function(u, h, m) {
        return u = +u, h = h >>> 0, m || Se(this, u, h, 1, 255, 0), this[h] = u & 255, h + 1;
      }, c.prototype.writeUint16LE = c.prototype.writeUInt16LE = function(u, h, m) {
        return u = +u, h = h >>> 0, m || Se(this, u, h, 2, 65535, 0), this[h] = u & 255, this[h + 1] = u >>> 8, h + 2;
      }, c.prototype.writeUint16BE = c.prototype.writeUInt16BE = function(u, h, m) {
        return u = +u, h = h >>> 0, m || Se(this, u, h, 2, 65535, 0), this[h] = u >>> 8, this[h + 1] = u & 255, h + 2;
      }, c.prototype.writeUint32LE = c.prototype.writeUInt32LE = function(u, h, m) {
        return u = +u, h = h >>> 0, m || Se(this, u, h, 4, 4294967295, 0), this[h + 3] = u >>> 24, this[h + 2] = u >>> 16, this[h + 1] = u >>> 8, this[h] = u & 255, h + 4;
      }, c.prototype.writeUint32BE = c.prototype.writeUInt32BE = function(u, h, m) {
        return u = +u, h = h >>> 0, m || Se(this, u, h, 4, 4294967295, 0), this[h] = u >>> 24, this[h + 1] = u >>> 16, this[h + 2] = u >>> 8, this[h + 3] = u & 255, h + 4;
      };
      function Vt(u, h, m, _, O) {
        Et(h, _, O, u, m, 7);
        let M = Number(h & BigInt(4294967295));
        u[m++] = M, M = M >> 8, u[m++] = M, M = M >> 8, u[m++] = M, M = M >> 8, u[m++] = M;
        let L = Number(h >> BigInt(32) & BigInt(4294967295));
        return u[m++] = L, L = L >> 8, u[m++] = L, L = L >> 8, u[m++] = L, L = L >> 8, u[m++] = L, m;
      }
      y(Vt, "es"), d(Vt, "tr");
      function We(u, h, m, _, O) {
        Et(h, _, O, u, m, 7);
        let M = Number(h & BigInt(4294967295));
        u[m + 7] = M, M = M >> 8, u[m + 6] = M, M = M >> 8, u[m + 5] = M, M = M >> 8, u[m + 4] = M;
        let L = Number(h >> BigInt(32) & BigInt(4294967295));
        return u[m + 3] = L, L = L >> 8, u[m + 2] = L, L = L >> 8, u[m + 1] = L, L = L >> 8, u[m] = L, m + 8;
      }
      y(We, "ts"), d(We, "ir"), c.prototype.writeBigUInt64LE = z(function(u, h = 0) {
        return Vt(this, u, h, BigInt(0), BigInt("0xffffffffffffffff"));
      }), c.prototype.writeBigUInt64BE = z(function(u, h = 0) {
        return We(this, u, h, BigInt(0), BigInt("0xffffffffffffffff"));
      }), c.prototype.writeIntLE = function(u, h, m, _) {
        if (u = +u, h = h >>> 0, !_) {
          let J = Math.pow(2, 8 * m - 1);
          Se(this, u, h, m, J - 1, -J);
        }
        let O = 0, M = 1, L = 0;
        for (this[h] = u & 255; ++O < m && (M *= 256); )
          u < 0 && L === 0 && this[h + O - 1] !== 0 && (L = 1), this[h + O] = (u / M >> 0) - L & 255;
        return h + m;
      }, c.prototype.writeIntBE = function(u, h, m, _) {
        if (u = +u, h = h >>> 0, !_) {
          let J = Math.pow(2, 8 * m - 1);
          Se(this, u, h, m, J - 1, -J);
        }
        let O = m - 1, M = 1, L = 0;
        for (this[h + O] = u & 255; --O >= 0 && (M *= 256); )
          u < 0 && L === 0 && this[h + O + 1] !== 0 && (L = 1), this[h + O] = (u / M >> 0) - L & 255;
        return h + m;
      }, c.prototype.writeInt8 = function(u, h, m) {
        return u = +u, h = h >>> 0, m || Se(this, u, h, 1, 127, -128), u < 0 && (u = 255 + u + 1), this[h] = u & 255, h + 1;
      }, c.prototype.writeInt16LE = function(u, h, m) {
        return u = +u, h = h >>> 0, m || Se(this, u, h, 2, 32767, -32768), this[h] = u & 255, this[h + 1] = u >>> 8, h + 2;
      }, c.prototype.writeInt16BE = function(u, h, m) {
        return u = +u, h = h >>> 0, m || Se(this, u, h, 2, 32767, -32768), this[h] = u >>> 8, this[h + 1] = u & 255, h + 2;
      }, c.prototype.writeInt32LE = function(u, h, m) {
        return u = +u, h = h >>> 0, m || Se(this, u, h, 4, 2147483647, -2147483648), this[h] = u & 255, this[h + 1] = u >>> 8, this[h + 2] = u >>> 16, this[h + 3] = u >>> 24, h + 4;
      }, c.prototype.writeInt32BE = function(u, h, m) {
        return u = +u, h = h >>> 0, m || Se(this, u, h, 4, 2147483647, -2147483648), u < 0 && (u = 4294967295 + u + 1), this[h] = u >>> 24, this[h + 1] = u >>> 16, this[h + 2] = u >>> 8, this[h + 3] = u & 255, h + 4;
      }, c.prototype.writeBigInt64LE = z(function(u, h = 0) {
        return Vt(this, u, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      }), c.prototype.writeBigInt64BE = z(function(u, h = 0) {
        return We(this, u, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function at(u, h, m, _, O, M) {
        if (m + _ > u.length)
          throw new RangeError("Index out of range");
        if (m < 0)
          throw new RangeError("Index out of range");
      }
      y(at, "rs"), d(at, "nr");
      function et(u, h, m, _, O) {
        return h = +h, m = m >>> 0, O || at(u, h, m, 4, 34028234663852886e22, -34028234663852886e22), a.write(u, h, m, _, 23, 4), m + 4;
      }
      y(et, "ns"), d(et, "er"), c.prototype.writeFloatLE = function(u, h, m) {
        return et(this, u, h, true, m);
      }, c.prototype.writeFloatBE = function(u, h, m) {
        return et(this, u, h, false, m);
      };
      function pt(u, h, m, _, O) {
        return h = +h, m = m >>> 0, O || at(u, h, m, 8, 17976931348623157e292, -17976931348623157e292), a.write(u, h, m, _, 52, 8), m + 8;
      }
      y(pt, "os"), d(pt, "or"), c.prototype.writeDoubleLE = function(u, h, m) {
        return pt(this, u, h, true, m);
      }, c.prototype.writeDoubleBE = function(u, h, m) {
        return pt(this, u, h, false, m);
      }, c.prototype.copy = function(u, h, m, _) {
        if (!c.isBuffer(u))
          throw new TypeError("argument should be a Buffer");
        if (m || (m = 0), !_ && _ !== 0 && (_ = this.length), h >= u.length && (h = u.length), h || (h = 0), _ > 0 && _ < m && (_ = m), _ === m || u.length === 0 || this.length === 0)
          return 0;
        if (h < 0)
          throw new RangeError("targetStart out of bounds");
        if (m < 0 || m >= this.length)
          throw new RangeError("Index out of range");
        if (_ < 0)
          throw new RangeError("sourceEnd out of bounds");
        _ > this.length && (_ = this.length), u.length - h < _ - m && (_ = u.length - h + m);
        let O = _ - m;
        return this === u && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(h, m, _) : Uint8Array.prototype.set.call(u, this.subarray(m, _), h), O;
      }, c.prototype.fill = function(u, h, m, _) {
        if (typeof u == "string") {
          if (typeof h == "string" ? (_ = h, h = 0, m = this.length) : typeof m == "string" && (_ = m, m = this.length), _ !== void 0 && typeof _ != "string")
            throw new TypeError("encoding must be a string");
          if (typeof _ == "string" && !c.isEncoding(_))
            throw new TypeError("Unknown encoding: " + _);
          if (u.length === 1) {
            let M = u.charCodeAt(0);
            (_ === "utf8" && M < 128 || _ === "latin1") && (u = M);
          }
        } else
          typeof u == "number" ? u = u & 255 : typeof u == "boolean" && (u = Number(u));
        if (h < 0 || this.length < h || this.length < m)
          throw new RangeError("Out of range index");
        if (m <= h)
          return this;
        h = h >>> 0, m = m === void 0 ? this.length : m >>> 0, u || (u = 0);
        let O;
        if (typeof u == "number")
          for (O = h; O < m; ++O)
            this[O] = u;
        else {
          let M = c.isBuffer(u) ? u : c.from(u, _), L = M.length;
          if (L === 0)
            throw new TypeError('The value "' + u + '" is invalid for argument "value"');
          for (O = 0; O < m - h; ++O)
            this[O + h] = M[O % L];
        }
        return this;
      };
      var Ve = {};
      function st(u, h, m) {
        Ve[u] = class extends m {
          constructor() {
            super();
            Object.defineProperty(this, "message", { value: h.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${u}]`, this.stack, delete this.name;
          }
          get code() {
            return u;
          }
          set code(_) {
            Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: _, writable: true });
          }
          toString() {
            return `${this.name} [${u}]: ${this.message}`;
          }
        };
      }
      y(st, "Xn"), d(st, "O"), st("ERR_BUFFER_OUT_OF_BOUNDS", function(u) {
        return u ? `${u} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
      }, RangeError), st("ERR_INVALID_ARG_TYPE", function(u, h) {
        return `The "${u}" argument must be of type number. Received type ${typeof h}`;
      }, TypeError), st("ERR_OUT_OF_RANGE", function(u, h, m) {
        let _ = `The value of "${u}" is out of range.`, O = m;
        return Number.isInteger(m) && Math.abs(m) > 2 ** 32 ? O = Gt(String(m)) : typeof m == "bigint" && (O = String(m), (m > BigInt(2) ** BigInt(32) || m < -(BigInt(2) ** BigInt(32))) && (O = Gt(O)), O += "n"), _ += ` It must be ${h}. Received ${O}`, _;
      }, RangeError);
      function Gt(u) {
        let h = "", m = u.length, _ = u[0] === "-" ? 1 : 0;
        for (; m >= _ + 4; m -= 3)
          h = `_${u.slice(m - 3, m)}${h}`;
        return `${u.slice(0, m)}${h}`;
      }
      y(Gt, "is"), d(Gt, "ur");
      function Nt(u, h, m) {
        dt(h, "offset"), (u[h] === void 0 || u[h + m] === void 0) && ht(h, u.length - (m + 1));
      }
      y(Nt, "pc"), d(Nt, "Dr");
      function Et(u, h, m, _, O, M) {
        if (u > m || u < h) {
          let L = typeof h == "bigint" ? "n" : "", J;
          throw M > 3 ? h === 0 || h === BigInt(0) ? J = `>= 0${L} and < 2${L} ** ${(M + 1) * 8}${L}` : J = `>= -(2${L} ** ${(M + 1) * 8 - 1}${L}) and < 2 ** ${(M + 1) * 8 - 1}${L}` : J = `>= ${h}${L} and <= ${m}${L}`, new Ve.ERR_OUT_OF_RANGE("value", J, u);
        }
        Nt(_, O, M);
      }
      y(Et, "ss"), d(Et, "hr");
      function dt(u, h) {
        if (typeof u != "number")
          throw new Ve.ERR_INVALID_ARG_TYPE(h, "number", u);
      }
      y(dt, "Ot"), d(dt, "R");
      function ht(u, h, m) {
        throw Math.floor(u) !== u ? (dt(u, m), new Ve.ERR_OUT_OF_RANGE(m || "offset", "an integer", u)) : h < 0 ? new Ve.ERR_BUFFER_OUT_OF_BOUNDS() : new Ve.ERR_OUT_OF_RANGE(m || "offset", `>= ${m ? 1 : 0} and <= ${h}`, u);
      }
      y(ht, "ar"), d(ht, "T");
      var ur = /[^+/0-9A-Za-z-_]/g;
      function ut(u) {
        if (u = u.split("=")[0], u = u.trim().replace(ur, ""), u.length < 2)
          return "";
        for (; u.length % 4 != 0; )
          u = u + "=";
        return u;
      }
      y(ut, "gc"), d(ut, "$r");
      function kt(u, h) {
        h = h || 1 / 0;
        let m, _ = u.length, O = null, M = [];
        for (let L = 0; L < _; ++L) {
          if (m = u.charCodeAt(L), m > 55295 && m < 57344) {
            if (!O) {
              if (m > 56319) {
                (h -= 3) > -1 && M.push(239, 191, 189);
                continue;
              } else if (L + 1 === _) {
                (h -= 3) > -1 && M.push(239, 191, 189);
                continue;
              }
              O = m;
              continue;
            }
            if (m < 56320) {
              (h -= 3) > -1 && M.push(239, 191, 189), O = m;
              continue;
            }
            m = (O - 55296 << 10 | m - 56320) + 65536;
          } else
            O && (h -= 3) > -1 && M.push(239, 191, 189);
          if (O = null, m < 128) {
            if ((h -= 1) < 0)
              break;
            M.push(m);
          } else if (m < 2048) {
            if ((h -= 2) < 0)
              break;
            M.push(m >> 6 | 192, m & 63 | 128);
          } else if (m < 65536) {
            if ((h -= 3) < 0)
              break;
            M.push(m >> 12 | 224, m >> 6 & 63 | 128, m & 63 | 128);
          } else if (m < 1114112) {
            if ((h -= 4) < 0)
              break;
            M.push(m >> 18 | 240, m >> 12 & 63 | 128, m >> 6 & 63 | 128, m & 63 | 128);
          } else
            throw new Error("Invalid code point");
        }
        return M;
      }
      y(kt, "eo"), d(kt, "G");
      function lr(u) {
        let h = [];
        for (let m = 0; m < u.length; ++m)
          h.push(u.charCodeAt(m) & 255);
        return h;
      }
      y(lr, "mc"), d(lr, "Pr");
      function T(u, h) {
        let m, _, O, M = [];
        for (let L = 0; L < u.length && !((h -= 2) < 0); ++L)
          m = u.charCodeAt(L), _ = m >> 8, O = m % 256, M.push(O), M.push(_);
        return M;
      }
      y(T, "hc"), d(T, "Or");
      function $(u) {
        return i.toByteArray(ut(u));
      }
      y($, "as"), d($, "fr");
      function P(u, h, m, _) {
        let O;
        for (O = 0; O < _ && !(O + m >= h.length || O >= u.length); ++O)
          h[O + m] = u[O];
        return O;
      }
      y(P, "Wr"), d(P, "_");
      function U(u, h) {
        return u instanceof h || u != null && u.constructor != null && u.constructor.name != null && u.constructor.name === h.name;
      }
      y(U, "$e"), d(U, "E");
      function Q(u) {
        return u !== u;
      }
      y(Q, "to"), d(Q, "Y");
      var Y = function() {
        let u = "0123456789abcdef", h = new Array(256);
        for (let m = 0; m < 16; ++m) {
          let _ = m * 16;
          for (let O = 0; O < 16; ++O)
            h[_ + O] = u[m] + u[O];
        }
        return h;
      }();
      function z(u) {
        return typeof BigInt == "undefined" ? Z : u;
      }
      y(z, "Xe"), d(z, "g");
      function Z() {
        throw new Error("BigInt not supported");
      }
      y(Z, "bc"), d(Z, "Yr");
    });
    var Ge;
    var I = fr(() => {
      Ge = Ae(pu());
    });
    var du = ve((e2, t) => {
      j(), N(), I(), k();
      var r = function() {
        var n = String.fromCharCode, i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$", o = {};
        function l(s, c) {
          if (!o[s]) {
            o[s] = {};
            for (var p = 0; p < s.length; p++)
              o[s][s.charAt(p)] = p;
          }
          return o[s][c];
        }
        y(l, "o"), d(l, "getBaseValue");
        var f = { compressToBase64: function(s) {
          if (s == null)
            return "";
          var c = f._compress(s, 6, function(p) {
            return i.charAt(p);
          });
          switch (c.length % 4) {
            default:
            case 0:
              return c;
            case 1:
              return c + "===";
            case 2:
              return c + "==";
            case 3:
              return c + "=";
          }
        }, decompressFromBase64: function(s) {
          return s == null ? "" : s == "" ? null : f._decompress(s.length, 32, function(c) {
            return l(i, s.charAt(c));
          });
        }, compressToUTF16: function(s) {
          return s == null ? "" : f._compress(s, 15, function(c) {
            return n(c + 32);
          }) + " ";
        }, decompressFromUTF16: function(s) {
          return s == null ? "" : s == "" ? null : f._decompress(s.length, 16384, function(c) {
            return s.charCodeAt(c) - 32;
          });
        }, compressToUint8Array: function(s) {
          for (var c = f.compress(s), p = new Uint8Array(c.length * 2), g = 0, v = c.length; g < v; g++) {
            var b = c.charCodeAt(g);
            p[g * 2] = b >>> 8, p[g * 2 + 1] = b % 256;
          }
          return p;
        }, decompressFromUint8Array: function(s) {
          if (s == null)
            return f.decompress(s);
          for (var c = new Array(s.length / 2), p = 0, g = c.length; p < g; p++)
            c[p] = s[p * 2] * 256 + s[p * 2 + 1];
          var v = [];
          return c.forEach(function(b) {
            v.push(n(b));
          }), f.decompress(v.join(""));
        }, compressToEncodedURIComponent: function(s) {
          return s == null ? "" : f._compress(s, 6, function(c) {
            return a.charAt(c);
          });
        }, decompressFromEncodedURIComponent: function(s) {
          return s == null ? "" : s == "" ? null : (s = s.replace(/ /g, "+"), f._decompress(s.length, 32, function(c) {
            return l(a, s.charAt(c));
          }));
        }, compress: function(s) {
          return f._compress(s, 16, function(c) {
            return n(c);
          });
        }, _compress: function(s, c, p) {
          if (s == null)
            return "";
          var g, v, b = {}, w = {}, E = "", x = "", S = "", A = 2, F = 3, q = 2, R = [], C = 0, B = 0, W;
          for (W = 0; W < s.length; W += 1)
            if (E = s.charAt(W), Object.prototype.hasOwnProperty.call(b, E) || (b[E] = F++, w[E] = true), x = S + E, Object.prototype.hasOwnProperty.call(b, x))
              S = x;
            else {
              if (Object.prototype.hasOwnProperty.call(w, S)) {
                if (S.charCodeAt(0) < 256) {
                  for (g = 0; g < q; g++)
                    C = C << 1, B == c - 1 ? (B = 0, R.push(p(C)), C = 0) : B++;
                  for (v = S.charCodeAt(0), g = 0; g < 8; g++)
                    C = C << 1 | v & 1, B == c - 1 ? (B = 0, R.push(p(C)), C = 0) : B++, v = v >> 1;
                } else {
                  for (v = 1, g = 0; g < q; g++)
                    C = C << 1 | v, B == c - 1 ? (B = 0, R.push(p(C)), C = 0) : B++, v = 0;
                  for (v = S.charCodeAt(0), g = 0; g < 16; g++)
                    C = C << 1 | v & 1, B == c - 1 ? (B = 0, R.push(p(C)), C = 0) : B++, v = v >> 1;
                }
                A--, A == 0 && (A = Math.pow(2, q), q++), delete w[S];
              } else
                for (v = b[S], g = 0; g < q; g++)
                  C = C << 1 | v & 1, B == c - 1 ? (B = 0, R.push(p(C)), C = 0) : B++, v = v >> 1;
              A--, A == 0 && (A = Math.pow(2, q), q++), b[x] = F++, S = String(E);
            }
          if (S !== "") {
            if (Object.prototype.hasOwnProperty.call(w, S)) {
              if (S.charCodeAt(0) < 256) {
                for (g = 0; g < q; g++)
                  C = C << 1, B == c - 1 ? (B = 0, R.push(p(C)), C = 0) : B++;
                for (v = S.charCodeAt(0), g = 0; g < 8; g++)
                  C = C << 1 | v & 1, B == c - 1 ? (B = 0, R.push(p(C)), C = 0) : B++, v = v >> 1;
              } else {
                for (v = 1, g = 0; g < q; g++)
                  C = C << 1 | v, B == c - 1 ? (B = 0, R.push(p(C)), C = 0) : B++, v = 0;
                for (v = S.charCodeAt(0), g = 0; g < 16; g++)
                  C = C << 1 | v & 1, B == c - 1 ? (B = 0, R.push(p(C)), C = 0) : B++, v = v >> 1;
              }
              A--, A == 0 && (A = Math.pow(2, q), q++), delete w[S];
            } else
              for (v = b[S], g = 0; g < q; g++)
                C = C << 1 | v & 1, B == c - 1 ? (B = 0, R.push(p(C)), C = 0) : B++, v = v >> 1;
            A--, A == 0 && (A = Math.pow(2, q), q++);
          }
          for (v = 2, g = 0; g < q; g++)
            C = C << 1 | v & 1, B == c - 1 ? (B = 0, R.push(p(C)), C = 0) : B++, v = v >> 1;
          for (; ; )
            if (C = C << 1, B == c - 1) {
              R.push(p(C));
              break;
            } else
              B++;
          return R.join("");
        }, decompress: function(s) {
          return s == null ? "" : s == "" ? null : f._decompress(s.length, 32768, function(c) {
            return s.charCodeAt(c);
          });
        }, _decompress: function(s, c, p) {
          var g = [], v, b = 4, w = 4, E = 3, x = "", S = [], A, F, q, R, C, B, W, G = { val: p(0), position: c, index: 1 };
          for (A = 0; A < 3; A += 1)
            g[A] = A;
          for (q = 0, C = Math.pow(2, 2), B = 1; B != C; )
            R = G.val & G.position, G.position >>= 1, G.position == 0 && (G.position = c, G.val = p(G.index++)), q |= (R > 0 ? 1 : 0) * B, B <<= 1;
          switch (v = q) {
            case 0:
              for (q = 0, C = Math.pow(2, 8), B = 1; B != C; )
                R = G.val & G.position, G.position >>= 1, G.position == 0 && (G.position = c, G.val = p(G.index++)), q |= (R > 0 ? 1 : 0) * B, B <<= 1;
              W = n(q);
              break;
            case 1:
              for (q = 0, C = Math.pow(2, 16), B = 1; B != C; )
                R = G.val & G.position, G.position >>= 1, G.position == 0 && (G.position = c, G.val = p(G.index++)), q |= (R > 0 ? 1 : 0) * B, B <<= 1;
              W = n(q);
              break;
            case 2:
              return "";
          }
          for (g[3] = W, F = W, S.push(W); ; ) {
            if (G.index > s)
              return "";
            for (q = 0, C = Math.pow(2, E), B = 1; B != C; )
              R = G.val & G.position, G.position >>= 1, G.position == 0 && (G.position = c, G.val = p(G.index++)), q |= (R > 0 ? 1 : 0) * B, B <<= 1;
            switch (W = q) {
              case 0:
                for (q = 0, C = Math.pow(2, 8), B = 1; B != C; )
                  R = G.val & G.position, G.position >>= 1, G.position == 0 && (G.position = c, G.val = p(G.index++)), q |= (R > 0 ? 1 : 0) * B, B <<= 1;
                g[w++] = n(q), W = w - 1, b--;
                break;
              case 1:
                for (q = 0, C = Math.pow(2, 16), B = 1; B != C; )
                  R = G.val & G.position, G.position >>= 1, G.position == 0 && (G.position = c, G.val = p(G.index++)), q |= (R > 0 ? 1 : 0) * B, B <<= 1;
                g[w++] = n(q), W = w - 1, b--;
                break;
              case 2:
                return S.join("");
            }
            if (b == 0 && (b = Math.pow(2, E), E++), g[W])
              x = g[W];
            else if (W === w)
              x = F + F.charAt(0);
            else
              return null;
            S.push(x), g[w++] = F + x.charAt(0), b--, F = x, b == 0 && (b = Math.pow(2, E), E++);
          }
        } };
        return f;
      }();
      typeof t != "undefined" && t != null && (t.exports = r);
    });
    var hu = ve((e2, t) => {
      j(), N(), I(), k(), t.exports = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
    });
    var ao = ve((e2, t) => {
      j(), N(), I(), k();
      var r = hu(), n = {};
      for (let o of Object.keys(r))
        n[r[o]] = o;
      var i = { rgb: { channels: 3, labels: "rgb" }, hsl: { channels: 3, labels: "hsl" }, hsv: { channels: 3, labels: "hsv" }, hwb: { channels: 3, labels: "hwb" }, cmyk: { channels: 4, labels: "cmyk" }, xyz: { channels: 3, labels: "xyz" }, lab: { channels: 3, labels: "lab" }, lch: { channels: 3, labels: "lch" }, hex: { channels: 1, labels: ["hex"] }, keyword: { channels: 1, labels: ["keyword"] }, ansi16: { channels: 1, labels: ["ansi16"] }, ansi256: { channels: 1, labels: ["ansi256"] }, hcg: { channels: 3, labels: ["h", "c", "g"] }, apple: { channels: 3, labels: ["r16", "g16", "b16"] }, gray: { channels: 1, labels: ["gray"] } };
      t.exports = i;
      for (let o of Object.keys(i)) {
        if (!("channels" in i[o]))
          throw new Error("missing channels property: " + o);
        if (!("labels" in i[o]))
          throw new Error("missing channel labels property: " + o);
        if (i[o].labels.length !== i[o].channels)
          throw new Error("channel and label counts mismatch: " + o);
        let { channels: l, labels: f } = i[o];
        delete i[o].channels, delete i[o].labels, Object.defineProperty(i[o], "channels", { value: l }), Object.defineProperty(i[o], "labels", { value: f });
      }
      i.rgb.hsl = function(o) {
        let l = o[0] / 255, f = o[1] / 255, s = o[2] / 255, c = Math.min(l, f, s), p = Math.max(l, f, s), g = p - c, v, b;
        p === c ? v = 0 : l === p ? v = (f - s) / g : f === p ? v = 2 + (s - l) / g : s === p && (v = 4 + (l - f) / g), v = Math.min(v * 60, 360), v < 0 && (v += 360);
        let w = (c + p) / 2;
        return p === c ? b = 0 : w <= 0.5 ? b = g / (p + c) : b = g / (2 - p - c), [v, b * 100, w * 100];
      }, i.rgb.hsv = function(o) {
        let l, f, s, c, p, g = o[0] / 255, v = o[1] / 255, b = o[2] / 255, w = Math.max(g, v, b), E = w - Math.min(g, v, b), x = d(function(S) {
          return (w - S) / 6 / E + 1 / 2;
        }, "diffc");
        return E === 0 ? (c = 0, p = 0) : (p = E / w, l = x(g), f = x(v), s = x(b), g === w ? c = s - f : v === w ? c = 1 / 3 + l - s : b === w && (c = 2 / 3 + f - l), c < 0 ? c += 1 : c > 1 && (c -= 1)), [c * 360, p * 100, w * 100];
      }, i.rgb.hwb = function(o) {
        let l = o[0], f = o[1], s = o[2], c = i.rgb.hsl(o)[0], p = 1 / 255 * Math.min(l, Math.min(f, s));
        return s = 1 - 1 / 255 * Math.max(l, Math.max(f, s)), [c, p * 100, s * 100];
      }, i.rgb.cmyk = function(o) {
        let l = o[0] / 255, f = o[1] / 255, s = o[2] / 255, c = Math.min(1 - l, 1 - f, 1 - s), p = (1 - l - c) / (1 - c) || 0, g = (1 - f - c) / (1 - c) || 0, v = (1 - s - c) / (1 - c) || 0;
        return [p * 100, g * 100, v * 100, c * 100];
      };
      function a(o, l) {
        return (o[0] - l[0]) ** 2 + (o[1] - l[1]) ** 2 + (o[2] - l[2]) ** 2;
      }
      y(a, "vc"), d(a, "comparativeDistance"), i.rgb.keyword = function(o) {
        let l = n[o];
        if (l)
          return l;
        let f = 1 / 0, s;
        for (let c of Object.keys(r)) {
          let p = r[c], g = a(o, p);
          g < f && (f = g, s = c);
        }
        return s;
      }, i.keyword.rgb = function(o) {
        return r[o];
      }, i.rgb.xyz = function(o) {
        let l = o[0] / 255, f = o[1] / 255, s = o[2] / 255;
        l = l > 0.04045 ? ((l + 0.055) / 1.055) ** 2.4 : l / 12.92, f = f > 0.04045 ? ((f + 0.055) / 1.055) ** 2.4 : f / 12.92, s = s > 0.04045 ? ((s + 0.055) / 1.055) ** 2.4 : s / 12.92;
        let c = l * 0.4124 + f * 0.3576 + s * 0.1805, p = l * 0.2126 + f * 0.7152 + s * 0.0722, g = l * 0.0193 + f * 0.1192 + s * 0.9505;
        return [c * 100, p * 100, g * 100];
      }, i.rgb.lab = function(o) {
        let l = i.rgb.xyz(o), f = l[0], s = l[1], c = l[2];
        f /= 95.047, s /= 100, c /= 108.883, f = f > 8856e-6 ? f ** (1 / 3) : 7.787 * f + 16 / 116, s = s > 8856e-6 ? s ** (1 / 3) : 7.787 * s + 16 / 116, c = c > 8856e-6 ? c ** (1 / 3) : 7.787 * c + 16 / 116;
        let p = 116 * s - 16, g = 500 * (f - s), v = 200 * (s - c);
        return [p, g, v];
      }, i.hsl.rgb = function(o) {
        let l = o[0] / 360, f = o[1] / 100, s = o[2] / 100, c, p, g;
        if (f === 0)
          return g = s * 255, [g, g, g];
        s < 0.5 ? c = s * (1 + f) : c = s + f - s * f;
        let v = 2 * s - c, b = [0, 0, 0];
        for (let w = 0; w < 3; w++)
          p = l + 1 / 3 * -(w - 1), p < 0 && p++, p > 1 && p--, 6 * p < 1 ? g = v + (c - v) * 6 * p : 2 * p < 1 ? g = c : 3 * p < 2 ? g = v + (c - v) * (2 / 3 - p) * 6 : g = v, b[w] = g * 255;
        return b;
      }, i.hsl.hsv = function(o) {
        let l = o[0], f = o[1] / 100, s = o[2] / 100, c = f, p = Math.max(s, 0.01);
        s *= 2, f *= s <= 1 ? s : 2 - s, c *= p <= 1 ? p : 2 - p;
        let g = (s + f) / 2, v = s === 0 ? 2 * c / (p + c) : 2 * f / (s + f);
        return [l, v * 100, g * 100];
      }, i.hsv.rgb = function(o) {
        let l = o[0] / 60, f = o[1] / 100, s = o[2] / 100, c = Math.floor(l) % 6, p = l - Math.floor(l), g = 255 * s * (1 - f), v = 255 * s * (1 - f * p), b = 255 * s * (1 - f * (1 - p));
        switch (s *= 255, c) {
          case 0:
            return [s, b, g];
          case 1:
            return [v, s, g];
          case 2:
            return [g, s, b];
          case 3:
            return [g, v, s];
          case 4:
            return [b, g, s];
          case 5:
            return [s, g, v];
        }
      }, i.hsv.hsl = function(o) {
        let l = o[0], f = o[1] / 100, s = o[2] / 100, c = Math.max(s, 0.01), p, g;
        g = (2 - f) * s;
        let v = (2 - f) * c;
        return p = f * c, p /= v <= 1 ? v : 2 - v, p = p || 0, g /= 2, [l, p * 100, g * 100];
      }, i.hwb.rgb = function(o) {
        let l = o[0] / 360, f = o[1] / 100, s = o[2] / 100, c = f + s, p;
        c > 1 && (f /= c, s /= c);
        let g = Math.floor(6 * l), v = 1 - s;
        p = 6 * l - g, (g & 1) != 0 && (p = 1 - p);
        let b = f + p * (v - f), w, E, x;
        switch (g) {
          default:
          case 6:
          case 0:
            w = v, E = b, x = f;
            break;
          case 1:
            w = b, E = v, x = f;
            break;
          case 2:
            w = f, E = v, x = b;
            break;
          case 3:
            w = f, E = b, x = v;
            break;
          case 4:
            w = b, E = f, x = v;
            break;
          case 5:
            w = v, E = f, x = b;
            break;
        }
        return [w * 255, E * 255, x * 255];
      }, i.cmyk.rgb = function(o) {
        let l = o[0] / 100, f = o[1] / 100, s = o[2] / 100, c = o[3] / 100, p = 1 - Math.min(1, l * (1 - c) + c), g = 1 - Math.min(1, f * (1 - c) + c), v = 1 - Math.min(1, s * (1 - c) + c);
        return [p * 255, g * 255, v * 255];
      }, i.xyz.rgb = function(o) {
        let l = o[0] / 100, f = o[1] / 100, s = o[2] / 100, c, p, g;
        return c = l * 3.2406 + f * -1.5372 + s * -0.4986, p = l * -0.9689 + f * 1.8758 + s * 0.0415, g = l * 0.0557 + f * -0.204 + s * 1.057, c = c > 31308e-7 ? 1.055 * c ** (1 / 2.4) - 0.055 : c * 12.92, p = p > 31308e-7 ? 1.055 * p ** (1 / 2.4) - 0.055 : p * 12.92, g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92, c = Math.min(Math.max(0, c), 1), p = Math.min(Math.max(0, p), 1), g = Math.min(Math.max(0, g), 1), [c * 255, p * 255, g * 255];
      }, i.xyz.lab = function(o) {
        let l = o[0], f = o[1], s = o[2];
        l /= 95.047, f /= 100, s /= 108.883, l = l > 8856e-6 ? l ** (1 / 3) : 7.787 * l + 16 / 116, f = f > 8856e-6 ? f ** (1 / 3) : 7.787 * f + 16 / 116, s = s > 8856e-6 ? s ** (1 / 3) : 7.787 * s + 16 / 116;
        let c = 116 * f - 16, p = 500 * (l - f), g = 200 * (f - s);
        return [c, p, g];
      }, i.lab.xyz = function(o) {
        let l = o[0], f = o[1], s = o[2], c, p, g;
        p = (l + 16) / 116, c = f / 500 + p, g = p - s / 200;
        let v = p ** 3, b = c ** 3, w = g ** 3;
        return p = v > 8856e-6 ? v : (p - 16 / 116) / 7.787, c = b > 8856e-6 ? b : (c - 16 / 116) / 7.787, g = w > 8856e-6 ? w : (g - 16 / 116) / 7.787, c *= 95.047, p *= 100, g *= 108.883, [c, p, g];
      }, i.lab.lch = function(o) {
        let l = o[0], f = o[1], s = o[2], c;
        c = Math.atan2(s, f) * 360 / 2 / Math.PI, c < 0 && (c += 360);
        let p = Math.sqrt(f * f + s * s);
        return [l, p, c];
      }, i.lch.lab = function(o) {
        let l = o[0], f = o[1], s = o[2] / 360 * 2 * Math.PI, c = f * Math.cos(s), p = f * Math.sin(s);
        return [l, c, p];
      }, i.rgb.ansi16 = function(o, l = null) {
        let [f, s, c] = o, p = l === null ? i.rgb.hsv(o)[2] : l;
        if (p = Math.round(p / 50), p === 0)
          return 30;
        let g = 30 + (Math.round(c / 255) << 2 | Math.round(s / 255) << 1 | Math.round(f / 255));
        return p === 2 && (g += 60), g;
      }, i.hsv.ansi16 = function(o) {
        return i.rgb.ansi16(i.hsv.rgb(o), o[2]);
      }, i.rgb.ansi256 = function(o) {
        let l = o[0], f = o[1], s = o[2];
        return l === f && f === s ? l < 8 ? 16 : l > 248 ? 231 : Math.round((l - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(l / 255 * 5) + 6 * Math.round(f / 255 * 5) + Math.round(s / 255 * 5);
      }, i.ansi16.rgb = function(o) {
        let l = o % 10;
        if (l === 0 || l === 7)
          return o > 50 && (l += 3.5), l = l / 10.5 * 255, [l, l, l];
        let f = (~~(o > 50) + 1) * 0.5, s = (l & 1) * f * 255, c = (l >> 1 & 1) * f * 255, p = (l >> 2 & 1) * f * 255;
        return [s, c, p];
      }, i.ansi256.rgb = function(o) {
        if (o >= 232) {
          let p = (o - 232) * 10 + 8;
          return [p, p, p];
        }
        o -= 16;
        let l, f = Math.floor(o / 36) / 5 * 255, s = Math.floor((l = o % 36) / 6) / 5 * 255, c = l % 6 / 5 * 255;
        return [f, s, c];
      }, i.rgb.hex = function(o) {
        let l = (((Math.round(o[0]) & 255) << 16) + ((Math.round(o[1]) & 255) << 8) + (Math.round(o[2]) & 255)).toString(16).toUpperCase();
        return "000000".substring(l.length) + l;
      }, i.hex.rgb = function(o) {
        let l = o.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!l)
          return [0, 0, 0];
        let f = l[0];
        l[0].length === 3 && (f = f.split("").map((v) => v + v).join(""));
        let s = parseInt(f, 16), c = s >> 16 & 255, p = s >> 8 & 255, g = s & 255;
        return [c, p, g];
      }, i.rgb.hcg = function(o) {
        let l = o[0] / 255, f = o[1] / 255, s = o[2] / 255, c = Math.max(Math.max(l, f), s), p = Math.min(Math.min(l, f), s), g = c - p, v, b;
        return g < 1 ? v = p / (1 - g) : v = 0, g <= 0 ? b = 0 : c === l ? b = (f - s) / g % 6 : c === f ? b = 2 + (s - l) / g : b = 4 + (l - f) / g, b /= 6, b %= 1, [b * 360, g * 100, v * 100];
      }, i.hsl.hcg = function(o) {
        let l = o[1] / 100, f = o[2] / 100, s = f < 0.5 ? 2 * l * f : 2 * l * (1 - f), c = 0;
        return s < 1 && (c = (f - 0.5 * s) / (1 - s)), [o[0], s * 100, c * 100];
      }, i.hsv.hcg = function(o) {
        let l = o[1] / 100, f = o[2] / 100, s = l * f, c = 0;
        return s < 1 && (c = (f - s) / (1 - s)), [o[0], s * 100, c * 100];
      }, i.hcg.rgb = function(o) {
        let l = o[0] / 360, f = o[1] / 100, s = o[2] / 100;
        if (f === 0)
          return [s * 255, s * 255, s * 255];
        let c = [0, 0, 0], p = l % 1 * 6, g = p % 1, v = 1 - g, b = 0;
        switch (Math.floor(p)) {
          case 0:
            c[0] = 1, c[1] = g, c[2] = 0;
            break;
          case 1:
            c[0] = v, c[1] = 1, c[2] = 0;
            break;
          case 2:
            c[0] = 0, c[1] = 1, c[2] = g;
            break;
          case 3:
            c[0] = 0, c[1] = v, c[2] = 1;
            break;
          case 4:
            c[0] = g, c[1] = 0, c[2] = 1;
            break;
          default:
            c[0] = 1, c[1] = 0, c[2] = v;
        }
        return b = (1 - f) * s, [(f * c[0] + b) * 255, (f * c[1] + b) * 255, (f * c[2] + b) * 255];
      }, i.hcg.hsv = function(o) {
        let l = o[1] / 100, f = o[2] / 100, s = l + f * (1 - l), c = 0;
        return s > 0 && (c = l / s), [o[0], c * 100, s * 100];
      }, i.hcg.hsl = function(o) {
        let l = o[1] / 100, f = o[2] / 100 * (1 - l) + 0.5 * l, s = 0;
        return f > 0 && f < 0.5 ? s = l / (2 * f) : f >= 0.5 && f < 1 && (s = l / (2 * (1 - f))), [o[0], s * 100, f * 100];
      }, i.hcg.hwb = function(o) {
        let l = o[1] / 100, f = o[2] / 100, s = l + f * (1 - l);
        return [o[0], (s - l) * 100, (1 - s) * 100];
      }, i.hwb.hcg = function(o) {
        let l = o[1] / 100, f = o[2] / 100, s = 1 - f, c = s - l, p = 0;
        return c < 1 && (p = (s - c) / (1 - c)), [o[0], c * 100, p * 100];
      }, i.apple.rgb = function(o) {
        return [o[0] / 65535 * 255, o[1] / 65535 * 255, o[2] / 65535 * 255];
      }, i.rgb.apple = function(o) {
        return [o[0] / 255 * 65535, o[1] / 255 * 65535, o[2] / 255 * 65535];
      }, i.gray.rgb = function(o) {
        return [o[0] / 100 * 255, o[0] / 100 * 255, o[0] / 100 * 255];
      }, i.gray.hsl = function(o) {
        return [0, 0, o[0]];
      }, i.gray.hsv = i.gray.hsl, i.gray.hwb = function(o) {
        return [0, 100, o[0]];
      }, i.gray.cmyk = function(o) {
        return [0, 0, 0, o[0]];
      }, i.gray.lab = function(o) {
        return [o[0], 0, 0];
      }, i.gray.hex = function(o) {
        let l = Math.round(o[0] / 100 * 255) & 255, f = ((l << 16) + (l << 8) + l).toString(16).toUpperCase();
        return "000000".substring(f.length) + f;
      }, i.rgb.gray = function(o) {
        return [(o[0] + o[1] + o[2]) / 3 / 255 * 100];
      };
    });
    var gu = ve((e2, t) => {
      j(), N(), I(), k();
      var r = ao();
      function n() {
        let l = {}, f = Object.keys(r);
        for (let s = f.length, c = 0; c < s; c++)
          l[f[c]] = { distance: -1, parent: null };
        return l;
      }
      y(n, "Ec"), d(n, "buildGraph");
      function i(l) {
        let f = n(), s = [l];
        for (f[l].distance = 0; s.length; ) {
          let c = s.pop(), p = Object.keys(r[c]);
          for (let g = p.length, v = 0; v < g; v++) {
            let b = p[v], w = f[b];
            w.distance === -1 && (w.distance = f[c].distance + 1, w.parent = c, s.unshift(b));
          }
        }
        return f;
      }
      y(i, "_c"), d(i, "deriveBFS");
      function a(l, f) {
        return function(s) {
          return f(l(s));
        };
      }
      y(a, "Ac"), d(a, "link");
      function o(l, f) {
        let s = [f[l].parent, l], c = r[f[l].parent][l], p = f[l].parent;
        for (; f[p].parent; )
          s.unshift(f[p].parent), c = a(r[f[p].parent][p], c), p = f[p].parent;
        return c.conversion = s, c;
      }
      y(o, "xc"), d(o, "wrapConversion"), t.exports = function(l) {
        let f = i(l), s = {}, c = Object.keys(f);
        for (let p = c.length, g = 0; g < p; g++) {
          let v = c[g];
          f[v].parent !== null && (s[v] = o(v, f));
        }
        return s;
      };
    });
    var yu = ve((e2, t) => {
      j(), N(), I(), k();
      var r = ao(), n = gu(), i = {}, a = Object.keys(r);
      function o(f) {
        let s = d(function(...c) {
          let p = c[0];
          return p == null ? p : (p.length > 1 && (c = p), f(c));
        }, "wrappedFn");
        return "conversion" in f && (s.conversion = f.conversion), s;
      }
      y(o, "Sc"), d(o, "wrapRaw");
      function l(f) {
        let s = d(function(...c) {
          let p = c[0];
          if (p == null)
            return p;
          p.length > 1 && (c = p);
          let g = f(c);
          if (typeof g == "object")
            for (let v = g.length, b = 0; b < v; b++)
              g[b] = Math.round(g[b]);
          return g;
        }, "wrappedFn");
        return "conversion" in f && (s.conversion = f.conversion), s;
      }
      y(l, "Mc"), d(l, "wrapRounded"), a.forEach((f) => {
        i[f] = {}, Object.defineProperty(i[f], "channels", { value: r[f].channels }), Object.defineProperty(i[f], "labels", { value: r[f].labels });
        let s = n(f);
        Object.keys(s).forEach((c) => {
          let p = s[c];
          i[f][c] = l(p), i[f][c].raw = o(p);
        });
      }), t.exports = i;
    });
    var mu = ve((e2, t) => {
      j(), N(), I(), k();
      var r = d((p, g) => (...v) => `\x1B[${p(...v) + g}m`, "wrapAnsi16"), n = d((p, g) => (...v) => {
        let b = p(...v);
        return `\x1B[${38 + g};5;${b}m`;
      }, "wrapAnsi256"), i = d((p, g) => (...v) => {
        let b = p(...v);
        return `\x1B[${38 + g};2;${b[0]};${b[1]};${b[2]}m`;
      }, "wrapAnsi16m"), a = d((p) => p, "ansi2ansi"), o = d((p, g, v) => [p, g, v], "rgb2rgb"), l = d((p, g, v) => {
        Object.defineProperty(p, g, { get: () => {
          let b = v();
          return Object.defineProperty(p, g, { value: b, enumerable: true, configurable: true }), b;
        }, enumerable: true, configurable: true });
      }, "setLazyProperty"), f, s = d((p, g, v, b) => {
        f === void 0 && (f = yu());
        let w = b ? 10 : 0, E = {};
        for (let [x, S] of Object.entries(f)) {
          let A = x === "ansi16" ? "ansi" : x;
          x === g ? E[A] = p(v, w) : typeof S == "object" && (E[A] = p(S[g], w));
        }
        return E;
      }, "makeDynamicStyles");
      function c() {
        let p = /* @__PURE__ */ new Map(), g = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], blackBright: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } };
        g.color.gray = g.color.blackBright, g.bgColor.bgGray = g.bgColor.bgBlackBright, g.color.grey = g.color.blackBright, g.bgColor.bgGrey = g.bgColor.bgBlackBright;
        for (let [v, b] of Object.entries(g)) {
          for (let [w, E] of Object.entries(b))
            g[w] = { open: `\x1B[${E[0]}m`, close: `\x1B[${E[1]}m` }, b[w] = g[w], p.set(E[0], E[1]);
          Object.defineProperty(g, v, { value: b, enumerable: false });
        }
        return Object.defineProperty(g, "codes", { value: p, enumerable: false }), g.color.close = "\x1B[39m", g.bgColor.close = "\x1B[49m", l(g.color, "ansi", () => s(r, "ansi16", a, false)), l(g.color, "ansi256", () => s(n, "ansi256", a, false)), l(g.color, "ansi16m", () => s(i, "rgb", o, false)), l(g.bgColor, "ansi", () => s(r, "ansi16", a, true)), l(g.bgColor, "ansi256", () => s(n, "ansi256", a, true)), l(g.bgColor, "ansi16m", () => s(i, "rgb", o, true)), g;
      }
      y(c, "Oc"), d(c, "assembleStyles"), Object.defineProperty(t, "exports", { enumerable: true, get: c });
    });
    var vu = ve(() => {
      j(), N(), I(), k();
    });
    var bu = ve((e2, t) => {
      j(), N(), I(), k();
      var r = d((i, a, o) => {
        let l = i.indexOf(a);
        if (l === -1)
          return i;
        let f = a.length, s = 0, c = "";
        do
          c += i.substr(s, l - s) + a + o, s = l + f, l = i.indexOf(a, s);
        while (l !== -1);
        return c += i.substr(s), c;
      }, "stringReplaceAll"), n = d((i, a, o, l) => {
        let f = 0, s = "";
        do {
          let c = i[l - 1] === "\r";
          s += i.substr(f, (c ? l - 1 : l) - f) + a + (c ? `\r
` : `
`) + o, f = l + 1, l = i.indexOf(`
`, f);
        } while (l !== -1);
        return s += i.substr(f), s;
      }, "stringEncaseCRLFWithFirstIndex");
      t.exports = { stringReplaceAll: r, stringEncaseCRLFWithFirstIndex: n };
    });
    var wu = ve((e2, t) => {
      j(), N(), I(), k();
      var r = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, n = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, i = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, a = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi, o = /* @__PURE__ */ new Map([["n", `
`], ["r", "\r"], ["t", "	"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", "\x1B"], ["a", "\x07"]]);
      function l(p) {
        let g = p[0] === "u", v = p[1] === "{";
        return g && !v && p.length === 5 || p[0] === "x" && p.length === 3 ? String.fromCharCode(parseInt(p.slice(1), 16)) : g && v ? String.fromCodePoint(parseInt(p.slice(2, -1), 16)) : o.get(p) || p;
      }
      y(l, "Ms"), d(l, "unescape");
      function f(p, g) {
        let v = [], b = g.trim().split(/\s*,\s*/g), w;
        for (let E of b) {
          let x = Number(E);
          if (!Number.isNaN(x))
            v.push(x);
          else if (w = E.match(i))
            v.push(w[2].replace(a, (S, A, F) => A ? l(A) : F));
          else
            throw new Error(`Invalid Chalk template style argument: ${E} (in style '${p}')`);
        }
        return v;
      }
      y(f, "Cc"), d(f, "parseArguments");
      function s(p) {
        n.lastIndex = 0;
        let g = [], v;
        for (; (v = n.exec(p)) !== null; ) {
          let b = v[1];
          if (v[2]) {
            let w = f(b, v[2]);
            g.push([b].concat(w));
          } else
            g.push([b]);
        }
        return g;
      }
      y(s, "Dc"), d(s, "parseStyle");
      function c(p, g) {
        let v = {};
        for (let w of g)
          for (let E of w.styles)
            v[E[0]] = w.inverse ? null : E.slice(1);
        let b = p;
        for (let [w, E] of Object.entries(v))
          if (Array.isArray(E)) {
            if (!(w in b))
              throw new Error(`Unknown Chalk style: ${w}`);
            b = E.length > 0 ? b[w](...E) : b[w];
          }
        return b;
      }
      y(c, "Os"), d(c, "buildStyle"), t.exports = (p, g) => {
        let v = [], b = [], w = [];
        if (g.replace(r, (E, x, S, A, F, q) => {
          if (x)
            w.push(l(x));
          else if (A) {
            let R = w.join("");
            w = [], b.push(v.length === 0 ? R : c(p, v)(R)), v.push({ inverse: S, styles: s(A) });
          } else if (F) {
            if (v.length === 0)
              throw new Error("Found extraneous } in Chalk template literal");
            b.push(c(p, v)(w.join(""))), w = [], v.pop();
          } else
            w.push(q);
        }), b.push(w.join("")), v.length > 0) {
          let E = `Chalk template literal is missing ${v.length} closing bracket${v.length === 1 ? "" : "s"} (\`}\`)`;
          throw new Error(E);
        }
        return b.join("");
      };
    });
    var Wt = ve((e2, t) => {
      j(), N(), I(), k();
      var r = mu(), { stdout: n, stderr: i } = vu(), { stringReplaceAll: a, stringEncaseCRLFWithFirstIndex: o } = bu(), { isArray: l } = Array, f = ["ansi", "ansi", "ansi256", "ansi16m"], s = /* @__PURE__ */ Object.create(null), c = d((R, C = {}) => {
        if (C.level && !(Number.isInteger(C.level) && C.level >= 0 && C.level <= 3))
          throw new Error("The `level` option should be an integer from 0 to 3");
        let B = n ? n.level : 0;
        R.level = C.level === void 0 ? B : C.level;
      }, "applyOptions"), p = y(class {
        constructor(R) {
          return g(R);
        }
      }, "ao");
      d(p, "ChalkClass");
      var g = d((R) => {
        let C = {};
        return c(C, R), C.template = (...B) => F(C.template, ...B), Object.setPrototypeOf(C, v.prototype), Object.setPrototypeOf(C.template, C), C.template.constructor = () => {
          throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
        }, C.template.Instance = p, C.template;
      }, "chalkFactory");
      function v(R) {
        return g(R);
      }
      y(v, "Zr"), d(v, "Chalk");
      for (let [R, C] of Object.entries(r))
        s[R] = { get() {
          let B = x(this, E(C.open, C.close, this._styler), this._isEmpty);
          return Object.defineProperty(this, R, { value: B }), B;
        } };
      s.visible = { get() {
        let R = x(this, this._styler, true);
        return Object.defineProperty(this, "visible", { value: R }), R;
      } };
      var b = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
      for (let R of b)
        s[R] = { get() {
          let { level: C } = this;
          return function(...B) {
            let W = E(r.color[f[C]][R](...B), r.color.close, this._styler);
            return x(this, W, this._isEmpty);
          };
        } };
      for (let R of b) {
        let C = "bg" + R[0].toUpperCase() + R.slice(1);
        s[C] = { get() {
          let { level: B } = this;
          return function(...W) {
            let G = E(r.bgColor[f[B]][R](...W), r.bgColor.close, this._styler);
            return x(this, G, this._isEmpty);
          };
        } };
      }
      var w = Object.defineProperties(() => {
      }, { ...s, level: { enumerable: true, get() {
        return this._generator.level;
      }, set(R) {
        this._generator.level = R;
      } } }), E = d((R, C, B) => {
        let W, G;
        return B === void 0 ? (W = R, G = C) : (W = B.openAll + R, G = C + B.closeAll), { open: R, close: C, openAll: W, closeAll: G, parent: B };
      }, "createStyler"), x = d((R, C, B) => {
        let W = d((...G) => l(G[0]) && l(G[0].raw) ? S(W, F(W, ...G)) : S(W, G.length === 1 ? "" + G[0] : G.join(" ")), "builder");
        return Object.setPrototypeOf(W, w), W._generator = R, W._styler = C, W._isEmpty = B, W;
      }, "createBuilder"), S = d((R, C) => {
        if (R.level <= 0 || !C)
          return R._isEmpty ? "" : C;
        let B = R._styler;
        if (B === void 0)
          return C;
        let { openAll: W, closeAll: G } = B;
        if (C.indexOf("\x1B") !== -1)
          for (; B !== void 0; )
            C = a(C, B.close, B.open), B = B.parent;
        let pe = C.indexOf(`
`);
        return pe !== -1 && (C = o(C, G, W, pe)), W + C + G;
      }, "applyStyle"), A, F = d((R, ...C) => {
        let [B] = C;
        if (!l(B) || !l(B.raw))
          return C.join(" ");
        let W = C.slice(1), G = [B.raw[0]];
        for (let pe = 1; pe < B.length; pe++)
          G.push(String(W[pe - 1]).replace(/[{}\\]/g, "\\$&"), String(B.raw[pe]));
        return A === void 0 && (A = wu()), A(R, G.join(""));
      }, "chalkTag");
      Object.defineProperties(v.prototype, s);
      var q = v();
      q.supportsColor = n, q.stderr = v({ level: i ? i.level : 0 }), q.stderr.supportsColor = i, t.exports = q;
    });
    var so = ve((e2, t) => {
      j(), N(), I(), k(), t.exports = (r, n = 1, i) => {
        if (i = { indent: " ", includeEmptyLines: false, ...i }, typeof r != "string")
          throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof r}\``);
        if (typeof n != "number")
          throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof n}\``);
        if (typeof i.indent != "string")
          throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof i.indent}\``);
        if (n === 0)
          return r;
        let a = i.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
        return r.replace(a, i.indent.repeat(n));
      };
    });
    var uo = ve((e2, t) => {
      j(), N(), I(), k(), t.exports = function() {
        function r(n, i, a, o, l) {
          return n < i || a < i ? n > a ? a + 1 : n + 1 : o === l ? i : i + 1;
        }
        return y(r, "e"), d(r, "_min"), function(n, i) {
          if (n === i)
            return 0;
          if (n.length > i.length) {
            var a = n;
            n = i, i = a;
          }
          for (var o = n.length, l = i.length; o > 0 && n.charCodeAt(o - 1) === i.charCodeAt(l - 1); )
            o--, l--;
          for (var f = 0; f < o && n.charCodeAt(f) === i.charCodeAt(f); )
            f++;
          if (o -= f, l -= f, o === 0 || l < 3)
            return l;
          var s = 0, c, p, g, v, b, w, E, x, S, A, F, q, R = [];
          for (c = 0; c < o; c++)
            R.push(c + 1), R.push(n.charCodeAt(f + c));
          for (var C = R.length - 1; s < l - 3; )
            for (S = i.charCodeAt(f + (p = s)), A = i.charCodeAt(f + (g = s + 1)), F = i.charCodeAt(f + (v = s + 2)), q = i.charCodeAt(f + (b = s + 3)), w = s += 4, c = 0; c < C; c += 2)
              E = R[c], x = R[c + 1], p = r(E, p, g, S, x), g = r(p, g, v, A, x), v = r(g, v, b, F, x), w = r(v, b, w, q, x), R[c] = w, b = v, v = g, g = p, p = E;
          for (; s < l; )
            for (S = i.charCodeAt(f + (p = s)), w = ++s, c = 0; c < C; c += 2)
              E = R[c], R[c] = w = r(E, p, w, S, R[c + 1]), p = E;
          return w;
        };
      }();
    });
    var lo = ve((e2) => {
      j(), N(), I(), k();
      var t = d((T, $) => () => ($ || T(($ = { exports: {} }).exports, $), $.exports), "c"), r = t((T, $) => {
        "use strict";
        $.exports = function() {
          if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
            return false;
          if (typeof Symbol.iterator == "symbol")
            return true;
          var P = {}, U = Symbol("test"), Q = Object(U);
          if (typeof U == "string" || Object.prototype.toString.call(U) !== "[object Symbol]" || Object.prototype.toString.call(Q) !== "[object Symbol]")
            return false;
          var Y = 42;
          P[U] = Y;
          for (U in P)
            return false;
          if (typeof Object.keys == "function" && Object.keys(P).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(P).length !== 0)
            return false;
          var z = Object.getOwnPropertySymbols(P);
          if (z.length !== 1 || z[0] !== U || !Object.prototype.propertyIsEnumerable.call(P, U))
            return false;
          if (typeof Object.getOwnPropertyDescriptor == "function") {
            var Z = Object.getOwnPropertyDescriptor(P, U);
            if (Z.value !== Y || Z.enumerable !== true)
              return false;
          }
          return true;
        };
      }), n = t((T, $) => {
        "use strict";
        var P = r();
        $.exports = function() {
          return P() && !!Symbol.toStringTag;
        };
      }), i = t((T, $) => {
        "use strict";
        var P = typeof Symbol != "undefined" && Symbol, U = r();
        $.exports = function() {
          return typeof P != "function" || typeof Symbol != "function" || typeof P("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? false : U();
        };
      }), a = t((T, $) => {
        "use strict";
        var P = "Function.prototype.bind called on incompatible ", U = Array.prototype.slice, Q = Object.prototype.toString, Y = "[object Function]";
        $.exports = function(z) {
          var Z = this;
          if (typeof Z != "function" || Q.call(Z) !== Y)
            throw new TypeError(P + Z);
          for (var u = U.call(arguments, 1), h, m = function() {
            if (this instanceof h) {
              var J = Z.apply(this, u.concat(U.call(arguments)));
              return Object(J) === J ? J : this;
            } else
              return Z.apply(z, u.concat(U.call(arguments)));
          }, _ = Math.max(0, Z.length - u.length), O = [], M = 0; M < _; M++)
            O.push("$" + M);
          if (h = Function("binder", "return function (" + O.join(",") + "){ return binder.apply(this,arguments); }")(m), Z.prototype) {
            var L = d(function() {
            }, "p");
            L.prototype = Z.prototype, h.prototype = new L(), L.prototype = null;
          }
          return h;
        };
      }), o = t((T, $) => {
        "use strict";
        var P = a();
        $.exports = Function.prototype.bind || P;
      }), l = t((T, $) => {
        "use strict";
        var P = o();
        $.exports = P.call(Function.call, Object.prototype.hasOwnProperty);
      }), f = t((T, $) => {
        "use strict";
        var P, U = SyntaxError, Q = Function, Y = TypeError, z = d(function(ce) {
          try {
            return Q('"use strict"; return (' + ce + ").constructor;")();
          } catch (ge) {
          }
        }, "ur"), Z = Object.getOwnPropertyDescriptor;
        if (Z)
          try {
            Z({}, "");
          } catch (ce) {
            Z = null;
          }
        var u = d(function() {
          throw new Y();
        }, "pr"), h = Z ? function() {
          try {
            return arguments.callee, u;
          } catch (ce) {
            try {
              return Z(arguments, "callee").get;
            } catch (ge) {
              return u;
            }
          }
        }() : u, m = i()(), _ = Object.getPrototypeOf || function(ce) {
          return ce.__proto__;
        }, O = {}, M = typeof Uint8Array == "undefined" ? P : _(Uint8Array), L = { "%AggregateError%": typeof AggregateError == "undefined" ? P : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer == "undefined" ? P : ArrayBuffer, "%ArrayIteratorPrototype%": m ? _([][Symbol.iterator]()) : P, "%AsyncFromSyncIteratorPrototype%": P, "%AsyncFunction%": O, "%AsyncGenerator%": O, "%AsyncGeneratorFunction%": O, "%AsyncIteratorPrototype%": O, "%Atomics%": typeof Atomics == "undefined" ? P : Atomics, "%BigInt%": typeof BigInt == "undefined" ? P : BigInt, "%Boolean%": Boolean, "%DataView%": typeof DataView == "undefined" ? P : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%eval%": eval, "%EvalError%": EvalError, "%Float32Array%": typeof Float32Array == "undefined" ? P : Float32Array, "%Float64Array%": typeof Float64Array == "undefined" ? P : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry == "undefined" ? P : FinalizationRegistry, "%Function%": Q, "%GeneratorFunction%": O, "%Int8Array%": typeof Int8Array == "undefined" ? P : Int8Array, "%Int16Array%": typeof Int16Array == "undefined" ? P : Int16Array, "%Int32Array%": typeof Int32Array == "undefined" ? P : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": m ? _(_([][Symbol.iterator]())) : P, "%JSON%": typeof JSON == "object" ? JSON : P, "%Map%": typeof Map == "undefined" ? P : Map, "%MapIteratorPrototype%": typeof Map == "undefined" || !m ? P : _((/* @__PURE__ */ new Map())[Symbol.iterator]()), "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise == "undefined" ? P : Promise, "%Proxy%": typeof Proxy == "undefined" ? P : Proxy, "%RangeError%": RangeError, "%ReferenceError%": ReferenceError, "%Reflect%": typeof Reflect == "undefined" ? P : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set == "undefined" ? P : Set, "%SetIteratorPrototype%": typeof Set == "undefined" || !m ? P : _((/* @__PURE__ */ new Set())[Symbol.iterator]()), "%SharedArrayBuffer%": typeof SharedArrayBuffer == "undefined" ? P : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": m ? _(""[Symbol.iterator]()) : P, "%Symbol%": m ? Symbol : P, "%SyntaxError%": U, "%ThrowTypeError%": h, "%TypedArray%": M, "%TypeError%": Y, "%Uint8Array%": typeof Uint8Array == "undefined" ? P : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray == "undefined" ? P : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array == "undefined" ? P : Uint16Array, "%Uint32Array%": typeof Uint32Array == "undefined" ? P : Uint32Array, "%URIError%": URIError, "%WeakMap%": typeof WeakMap == "undefined" ? P : WeakMap, "%WeakRef%": typeof WeakRef == "undefined" ? P : WeakRef, "%WeakSet%": typeof WeakSet == "undefined" ? P : WeakSet }, J = d(y(function ce(ge) {
          var ye;
          if (ge === "%AsyncFunction%")
            ye = z("async function () {}");
          else if (ge === "%GeneratorFunction%")
            ye = z("function* () {}");
          else if (ge === "%AsyncGeneratorFunction%")
            ye = z("async function* () {}");
          else if (ge === "%AsyncGenerator%") {
            var me = ce("%AsyncGeneratorFunction%");
            me && (ye = me.prototype);
          } else if (ge === "%AsyncIteratorPrototype%") {
            var $e = ce("%AsyncGenerator%");
            $e && (ye = _($e.prototype));
          }
          return L[ge] = ye, ye;
        }, "V"), "r"), re = { "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, X = o(), ee = l(), ne = X.call(Function.call, Array.prototype.concat), Te = X.call(Function.apply, Array.prototype.splice), Re = X.call(Function.call, String.prototype.replace), ie = X.call(Function.call, String.prototype.slice), he = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, _e = /\\(\\)?/g, xe = d(function(ce) {
          var ge = ie(ce, 0, 1), ye = ie(ce, -1);
          if (ge === "%" && ye !== "%")
            throw new U("invalid intrinsic syntax, expected closing `%`");
          if (ye === "%" && ge !== "%")
            throw new U("invalid intrinsic syntax, expected opening `%`");
          var me = [];
          return Re(ce, he, function($e, ze, ke, gt) {
            me[me.length] = ke ? Re(gt, _e, "$1") : ze || $e;
          }), me;
        }, "it"), Ne = d(function(ce, ge) {
          var ye = ce, me;
          if (ee(re, ye) && (me = re[ye], ye = "%" + me[0] + "%"), ee(L, ye)) {
            var $e = L[ye];
            if ($e === O && ($e = J(ye)), typeof $e == "undefined" && !ge)
              throw new Y("intrinsic " + ce + " exists, but is not available. Please file an issue!");
            return { alias: me, name: ye, value: $e };
          }
          throw new U("intrinsic " + ce + " does not exist!");
        }, "at");
        $.exports = function(ce, ge) {
          if (typeof ce != "string" || ce.length === 0)
            throw new Y("intrinsic name must be a non-empty string");
          if (arguments.length > 1 && typeof ge != "boolean")
            throw new Y('"allowMissing" argument must be a boolean');
          var ye = xe(ce), me = ye.length > 0 ? ye[0] : "", $e = Ne("%" + me + "%", ge), ze = $e.name, ke = $e.value, gt = false, Jt = $e.alias;
          Jt && (me = Jt[0], Te(ye, ne([0, 1], Jt)));
          for (var lt = 1, yt = true; lt < ye.length; lt += 1) {
            var Be = ye[lt], At = ie(Be, 0, 1), Ot = ie(Be, -1);
            if ((At === '"' || At === "'" || At === "`" || Ot === '"' || Ot === "'" || Ot === "`") && At !== Ot)
              throw new U("property names with quotes must have matching quotes");
            if ((Be === "constructor" || !yt) && (gt = true), me += "." + Be, ze = "%" + me + "%", ee(L, ze))
              ke = L[ze];
            else if (ke != null) {
              if (!(Be in ke)) {
                if (!ge)
                  throw new Y("base intrinsic for " + ce + " exists, but the property is not available.");
                return;
              }
              if (Z && lt + 1 >= ye.length) {
                var tt = Z(ke, Be);
                yt = !!tt, yt && "get" in tt && !("originalValue" in tt.get) ? ke = tt.get : ke = ke[Be];
              } else
                yt = ee(ke, Be), ke = ke[Be];
              yt && !gt && (L[ze] = ke);
            }
          }
          return ke;
        };
      }), s = t((T, $) => {
        "use strict";
        var P = o(), U = f(), Q = U("%Function.prototype.apply%"), Y = U("%Function.prototype.call%"), z = U("%Reflect.apply%", true) || P.call(Y, Q), Z = U("%Object.getOwnPropertyDescriptor%", true), u = U("%Object.defineProperty%", true), h = U("%Math.max%");
        if (u)
          try {
            u({}, "a", { value: 1 });
          } catch (_) {
            u = null;
          }
        $.exports = function(_) {
          var O = z(P, Y, arguments);
          if (Z && u) {
            var M = Z(O, "length");
            M.configurable && u(O, "length", { value: 1 + h(0, _.length - (arguments.length - 1)) });
          }
          return O;
        };
        var m = d(function() {
          return z(P, Q, arguments);
        }, "Kr");
        u ? u($.exports, "apply", { value: m }) : $.exports.apply = m;
      }), c = t((T, $) => {
        "use strict";
        var P = f(), U = s(), Q = U(P("String.prototype.indexOf"));
        $.exports = function(Y, z) {
          var Z = P(Y, !!z);
          return typeof Z == "function" && Q(Y, ".prototype.") > -1 ? U(Z) : Z;
        };
      }), p = t((T, $) => {
        "use strict";
        var P = n()(), U = c(), Q = U("Object.prototype.toString"), Y = d(function(u) {
          return P && u && typeof u == "object" && Symbol.toStringTag in u ? false : Q(u) === "[object Arguments]";
        }, "H"), z = d(function(u) {
          return Y(u) ? true : u !== null && typeof u == "object" && typeof u.length == "number" && u.length >= 0 && Q(u) !== "[object Array]" && Q(u.callee) === "[object Function]";
        }, "te"), Z = function() {
          return Y(arguments);
        }();
        Y.isLegacyArguments = z, $.exports = Z ? Y : z;
      }), g = t((T, $) => {
        "use strict";
        var P = Object.prototype.toString, U = Function.prototype.toString, Q = /^\s*(?:function)?\*/, Y = n()(), z = Object.getPrototypeOf, Z = d(function() {
          if (!Y)
            return false;
          try {
            return Function("return function*() {}")();
          } catch (h) {
          }
        }, "dt"), u;
        $.exports = function(h) {
          if (typeof h != "function")
            return false;
          if (Q.test(U.call(h)))
            return true;
          if (!Y) {
            var m = P.call(h);
            return m === "[object GeneratorFunction]";
          }
          if (!z)
            return false;
          if (typeof u == "undefined") {
            var _ = Z();
            u = _ ? z(_) : false;
          }
          return z(h) === u;
        };
      }), v = t((T, $) => {
        var P = Object.prototype.hasOwnProperty, U = Object.prototype.toString;
        $.exports = function(Q, Y, z) {
          if (U.call(Y) !== "[object Function]")
            throw new TypeError("iterator must be a function");
          var Z = Q.length;
          if (Z === +Z)
            for (var u = 0; u < Z; u++)
              Y.call(z, Q[u], u, Q);
          else
            for (var h in Q)
              P.call(Q, h) && Y.call(z, Q[h], h, Q);
        };
      }), b = t((T, $) => {
        "use strict";
        var P = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"], U = typeof ct == "undefined" ? pr : ct;
        $.exports = function() {
          for (var Q = [], Y = 0; Y < P.length; Y++)
            typeof U[P[Y]] == "function" && (Q[Q.length] = P[Y]);
          return Q;
        };
      }), w = t((T, $) => {
        "use strict";
        var P = f(), U = P("%Object.getOwnPropertyDescriptor%", true);
        if (U)
          try {
            U([], "length");
          } catch (Q) {
            U = null;
          }
        $.exports = U;
      }), E = t((T, $) => {
        "use strict";
        var P = v(), U = b(), Q = c(), Y = Q("Object.prototype.toString"), z = n()(), Z = typeof ct == "undefined" ? pr : ct, u = U(), h = Q("Array.prototype.indexOf", true) || function(J, re) {
          for (var X = 0; X < J.length; X += 1)
            if (J[X] === re)
              return X;
          return -1;
        }, m = Q("String.prototype.slice"), _ = {}, O = w(), M = Object.getPrototypeOf;
        z && O && M && P(u, function(J) {
          var re = new Z[J]();
          if (Symbol.toStringTag in re) {
            var X = M(re), ee = O(X, Symbol.toStringTag);
            if (!ee) {
              var ne = M(X);
              ee = O(ne, Symbol.toStringTag);
            }
            _[J] = ee.get;
          }
        });
        var L = d(function(J) {
          var re = false;
          return P(_, function(X, ee) {
            if (!re)
              try {
                re = X.call(J) === ee;
              } catch (ne) {
              }
          }), re;
        }, "jt");
        $.exports = function(J) {
          if (!J || typeof J != "object")
            return false;
          if (!z || !(Symbol.toStringTag in J)) {
            var re = m(Y(J), 8, -1);
            return h(u, re) > -1;
          }
          return O ? L(J) : false;
        };
      }), x = t((T, $) => {
        "use strict";
        var P = v(), U = b(), Q = c(), Y = Q("Object.prototype.toString"), z = n()(), Z = typeof ct == "undefined" ? pr : ct, u = U(), h = Q("String.prototype.slice"), m = {}, _ = w(), O = Object.getPrototypeOf;
        z && _ && O && P(u, function(J) {
          if (typeof Z[J] == "function") {
            var re = new Z[J]();
            if (Symbol.toStringTag in re) {
              var X = O(re), ee = _(X, Symbol.toStringTag);
              if (!ee) {
                var ne = O(X);
                ee = _(ne, Symbol.toStringTag);
              }
              m[J] = ee.get;
            }
          }
        });
        var M = d(function(J) {
          var re = false;
          return P(m, function(X, ee) {
            if (!re)
              try {
                var ne = X.call(J);
                ne === ee && (re = ne);
              } catch (Te) {
              }
          }), re;
        }, "Ft"), L = E();
        $.exports = function(J) {
          return L(J) ? !z || !(Symbol.toStringTag in J) ? h(Y(J), 8, -1) : M(J) : false;
        };
      }), S = t((T) => {
        "use strict";
        var $ = p(), P = g(), U = x(), Q = E();
        function Y(V) {
          return V.call.bind(V);
        }
        y(Y, "i"), d(Y, "F");
        var z = typeof BigInt != "undefined", Z = typeof Symbol != "undefined", u = Y(Object.prototype.toString), h = Y(Number.prototype.valueOf), m = Y(String.prototype.valueOf), _ = Y(Boolean.prototype.valueOf);
        z && (O = Y(BigInt.prototype.valueOf));
        var O;
        Z && (M = Y(Symbol.prototype.valueOf));
        var M;
        function L(V, ru) {
          if (typeof V != "object")
            return false;
          try {
            return ru(V), true;
          } catch (gf) {
            return false;
          }
        }
        y(L, "A"), d(L, "D"), T.isArgumentsObject = $, T.isGeneratorFunction = P, T.isTypedArray = Q;
        function J(V) {
          return typeof Promise != "undefined" && V instanceof Promise || V !== null && typeof V == "object" && typeof V.then == "function" && typeof V.catch == "function";
        }
        y(J, "b"), d(J, "Mt"), T.isPromise = J;
        function re(V) {
          return typeof ArrayBuffer != "undefined" && ArrayBuffer.isView ? ArrayBuffer.isView(V) : Q(V) || At(V);
        }
        y(re, "E"), d(re, "qt"), T.isArrayBufferView = re;
        function X(V) {
          return U(V) === "Uint8Array";
        }
        y(X, "P"), d(X, "Gt"), T.isUint8Array = X;
        function ee(V) {
          return U(V) === "Uint8ClampedArray";
        }
        y(ee, "T"), d(ee, "$t"), T.isUint8ClampedArray = ee;
        function ne(V) {
          return U(V) === "Uint16Array";
        }
        y(ne, "M"), d(ne, "Wt"), T.isUint16Array = ne;
        function Te(V) {
          return U(V) === "Uint32Array";
        }
        y(Te, "S"), d(Te, "zt"), T.isUint32Array = Te;
        function Re(V) {
          return U(V) === "Int8Array";
        }
        y(Re, "I"), d(Re, "Ct"), T.isInt8Array = Re;
        function ie(V) {
          return U(V) === "Int16Array";
        }
        y(ie, "F"), d(ie, "_t"), T.isInt16Array = ie;
        function he(V) {
          return U(V) === "Int32Array";
        }
        y(he, "N"), d(he, "Vt"), T.isInt32Array = he;
        function _e(V) {
          return U(V) === "Float32Array";
        }
        y(_e, "J"), d(_e, "Jt"), T.isFloat32Array = _e;
        function xe(V) {
          return U(V) === "Float64Array";
        }
        y(xe, "Y"), d(xe, "Ht"), T.isFloat64Array = xe;
        function Ne(V) {
          return U(V) === "BigInt64Array";
        }
        y(Ne, "de"), d(Ne, "Lt"), T.isBigInt64Array = Ne;
        function ce(V) {
          return U(V) === "BigUint64Array";
        }
        y(ce, "V"), d(ce, "Zt"), T.isBigUint64Array = ce;
        function ge(V) {
          return u(V) === "[object Map]";
        }
        y(ge, "Q"), d(ge, "Y"), ge.working = typeof Map != "undefined" && ge(/* @__PURE__ */ new Map());
        function ye(V) {
          return typeof Map == "undefined" ? false : ge.working ? ge(V) : V instanceof Map;
        }
        y(ye, "L"), d(ye, "Yt"), T.isMap = ye;
        function me(V) {
          return u(V) === "[object Set]";
        }
        y(me, "X"), d(me, "K"), me.working = typeof Set != "undefined" && me(/* @__PURE__ */ new Set());
        function $e(V) {
          return typeof Set == "undefined" ? false : me.working ? me(V) : V instanceof Set;
        }
        y($e, "H"), d($e, "Kt"), T.isSet = $e;
        function ze(V) {
          return u(V) === "[object WeakMap]";
        }
        y(ze, "G"), d(ze, "Q"), ze.working = typeof WeakMap != "undefined" && ze(/* @__PURE__ */ new WeakMap());
        function ke(V) {
          return typeof WeakMap == "undefined" ? false : ze.working ? ze(V) : V instanceof WeakMap;
        }
        y(ke, "le"), d(ke, "Qt"), T.isWeakMap = ke;
        function gt(V) {
          return u(V) === "[object WeakSet]";
        }
        y(gt, "Qe"), d(gt, "jr"), gt.working = typeof WeakSet != "undefined" && gt(/* @__PURE__ */ new WeakSet());
        function Jt(V) {
          return gt(V);
        }
        y(Jt, "or"), d(Jt, "Xt"), T.isWeakSet = Jt;
        function lt(V) {
          return u(V) === "[object ArrayBuffer]";
        }
        y(lt, "Ge"), d(lt, "X"), lt.working = typeof ArrayBuffer != "undefined" && lt(new ArrayBuffer());
        function yt(V) {
          return typeof ArrayBuffer == "undefined" ? false : lt.working ? lt(V) : V instanceof ArrayBuffer;
        }
        y(yt, "Ke"), d(yt, "Te"), T.isArrayBuffer = yt;
        function Be(V) {
          return u(V) === "[object DataView]";
        }
        y(Be, "be"), d(Be, "rr"), Be.working = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined" && Be(new DataView(new ArrayBuffer(1), 0, 1));
        function At(V) {
          return typeof DataView == "undefined" ? false : Be.working ? Be(V) : V instanceof DataView;
        }
        y(At, "ht"), d(At, "Ie"), T.isDataView = At;
        var Ot = typeof SharedArrayBuffer != "undefined" ? SharedArrayBuffer : void 0;
        function tt(V) {
          return u(V) === "[object SharedArrayBuffer]";
        }
        y(tt, "De"), d(tt, "N");
        function wn(V) {
          return typeof Ot == "undefined" ? false : (typeof tt.working == "undefined" && (tt.working = tt(new Ot())), tt.working ? tt(V) : V instanceof Ot);
        }
        y(wn, "Ci"), d(wn, "Fe"), T.isSharedArrayBuffer = wn;
        function Hi(V) {
          return u(V) === "[object AsyncFunction]";
        }
        y(Hi, "Ol"), d(Hi, "rn"), T.isAsyncFunction = Hi;
        function Zi(V) {
          return u(V) === "[object Map Iterator]";
        }
        y(Zi, "Il"), d(Zi, "en"), T.isMapIterator = Zi;
        function Ki(V) {
          return u(V) === "[object Set Iterator]";
        }
        y(Ki, "kl"), d(Ki, "tn"), T.isSetIterator = Ki;
        function Qi(V) {
          return u(V) === "[object Generator]";
        }
        y(Qi, "jl"), d(Qi, "nn"), T.isGeneratorObject = Qi;
        function Xi(V) {
          return u(V) === "[object WebAssembly.Module]";
        }
        y(Xi, "Fl"), d(Xi, "on"), T.isWebAssemblyCompiledModule = Xi;
        function _n(V) {
          return L(V, h);
        }
        y(_n, "Di"), d(_n, "Ue"), T.isNumberObject = _n;
        function En(V) {
          return L(V, m);
        }
        y(En, "$i"), d(En, "ke"), T.isStringObject = En;
        function An(V) {
          return L(V, _);
        }
        y(An, "Bi"), d(An, "Re"), T.isBooleanObject = An;
        function On(V) {
          return z && L(V, O);
        }
        y(On, "Li"), d(On, "De"), T.isBigIntObject = On;
        function Tn(V) {
          return Z && L(V, M);
        }
        y(Tn, "qi"), d(Tn, "Ne"), T.isSymbolObject = Tn;
        function eo(V) {
          return _n(V) || En(V) || An(V) || On(V) || Tn(V);
        }
        y(eo, "Rl"), d(eo, "an"), T.isBoxedPrimitive = eo;
        function to(V) {
          return typeof Uint8Array != "undefined" && (yt(V) || wn(V));
        }
        y(to, "Nl"), d(to, "fn"), T.isAnyArrayBuffer = to, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(V) {
          Object.defineProperty(T, V, { enumerable: false, value: function() {
            throw new Error(V + " is not supported in userland");
          } });
        });
      }), A = t((T, $) => {
        $.exports = function(P) {
          return P instanceof Ge.Buffer;
        };
      }), F = t((T, $) => {
        typeof Object.create == "function" ? $.exports = function(P, U) {
          U && (P.super_ = U, P.prototype = Object.create(U.prototype, { constructor: { value: P, enumerable: false, writable: true, configurable: true } }));
        } : $.exports = function(P, U) {
          if (U) {
            P.super_ = U;
            var Q = d(function() {
            }, "n");
            Q.prototype = U.prototype, P.prototype = new Q(), P.prototype.constructor = P;
          }
        };
      }), q = Object.getOwnPropertyDescriptors || function(T) {
        for (var $ = Object.keys(T), P = {}, U = 0; U < $.length; U++)
          P[$[U]] = Object.getOwnPropertyDescriptor(T, $[U]);
        return P;
      }, R = /%[sdj%]/g;
      e2.format = function(T) {
        if (!Se(T)) {
          for (var $ = [], P = 0; P < arguments.length; P++)
            $.push(G(arguments[P]));
          return $.join(" ");
        }
        for (var P = 1, U = arguments, Q = U.length, Y = String(T).replace(R, function(u) {
          if (u === "%%")
            return "%";
          if (P >= Q)
            return u;
          switch (u) {
            case "%s":
              return String(U[P++]);
            case "%d":
              return Number(U[P++]);
            case "%j":
              try {
                return JSON.stringify(U[P++]);
              } catch (h) {
                return "[Circular]";
              }
            default:
              return u;
          }
        }), z = U[P]; P < Q; z = U[++P])
          _t(z) || !et(z) ? Y += " " + z : Y += " " + G(z);
        return Y;
      }, e2.deprecate = function(T, $) {
        if (typeof we != "undefined" && we.noDeprecation === true)
          return T;
        if (typeof we == "undefined")
          return function() {
            return e2.deprecate(T, $).apply(this, arguments);
          };
        var P = false;
        function U() {
          if (!P) {
            if (we.throwDeprecation)
              throw new Error($);
            we.traceDeprecation ? console.trace($) : console.error($), P = true;
          }
          return T.apply(this, arguments);
        }
        return y(U, "n"), d(U, "n"), U;
      };
      var C = {}, B = /^$/;
      we.env.NODE_DEBUG && (W = we.env.NODE_DEBUG, W = W.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), B = new RegExp("^" + W + "$", "i"));
      var W;
      e2.debuglog = function(T) {
        if (T = T.toUpperCase(), !C[T])
          if (B.test(T)) {
            var $ = we.pid;
            C[T] = function() {
              var P = e2.format.apply(e2, arguments);
              console.error("%s %d: %s", T, $, P);
            };
          } else
            C[T] = function() {
            };
        return C[T];
      };
      function G(T, $) {
        var P = { seen: [], stylize: H };
        return arguments.length >= 3 && (P.depth = arguments[2]), arguments.length >= 4 && (P.colors = arguments[3]), jt($) ? P.showHidden = $ : $ && e2._extend(P, $), We(P.showHidden) && (P.showHidden = false), We(P.depth) && (P.depth = 2), We(P.colors) && (P.colors = false), We(P.customInspect) && (P.customInspect = true), P.colors && (P.stylize = pe), be(P, T, P.depth);
      }
      y(G, "it"), d(G, "A"), e2.inspect = G, G.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, G.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" };
      function pe(T, $) {
        var P = G.styles[$];
        return P ? "\x1B[" + G.colors[P][0] + "m" + T + "\x1B[" + G.colors[P][1] + "m" : T;
      }
      y(pe, "Kf"), d(pe, "yn");
      function H(T, $) {
        return T;
      }
      y(H, "Zf"), d(H, "un");
      function de(T) {
        var $ = {};
        return T.forEach(function(P, U) {
          $[P] = true;
        }), $;
      }
      y(de, "Xf"), d(de, "pn");
      function be(T, $, P) {
        if (T.customInspect && $ && st($.inspect) && $.inspect !== e2.inspect && !($.constructor && $.constructor.prototype === $)) {
          var U = $.inspect(P, T);
          return Se(U) || (U = be(T, U, P)), U;
        }
        var Q = se(T, $);
        if (Q)
          return Q;
        var Y = Object.keys($), z = de(Y);
        if (T.showHidden && (Y = Object.getOwnPropertyNames($)), Ve($) && (Y.indexOf("message") >= 0 || Y.indexOf("description") >= 0))
          return le($);
        if (Y.length === 0) {
          if (st($)) {
            var Z = $.name ? ": " + $.name : "";
            return T.stylize("[Function" + Z + "]", "special");
          }
          if (at($))
            return T.stylize(RegExp.prototype.toString.call($), "regexp");
          if (pt($))
            return T.stylize(Date.prototype.toString.call($), "date");
          if (Ve($))
            return le($);
        }
        var u = "", h = false, m = ["{", "}"];
        if (Dt($) && (h = true, m = ["[", "]"]), st($)) {
          var _ = $.name ? ": " + $.name : "";
          u = " [Function" + _ + "]";
        }
        if (at($) && (u = " " + RegExp.prototype.toString.call($)), pt($) && (u = " " + Date.prototype.toUTCString.call($)), Ve($) && (u = " " + le($)), Y.length === 0 && (!h || $.length == 0))
          return m[0] + u + m[1];
        if (P < 0)
          return at($) ? T.stylize(RegExp.prototype.toString.call($), "regexp") : T.stylize("[Object]", "special");
        T.seen.push($);
        var O;
        return h ? O = De(T, $, P, z, Y) : O = Y.map(function(M) {
          return Pt(T, $, P, z, M, h);
        }), T.seen.pop(), ar(O, u, m);
      }
      y(be, "gn"), d(be, "nr");
      function se(T, $) {
        if (We($))
          return T.stylize("undefined", "undefined");
        if (Se($)) {
          var P = "'" + JSON.stringify($).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return T.stylize(P, "string");
        }
        if (Oe($))
          return T.stylize("" + $, "number");
        if (jt($))
          return T.stylize("" + $, "boolean");
        if (_t($))
          return T.stylize("null", "null");
      }
      y(se, "ep"), d(se, "cn");
      function le(T) {
        return "[" + Error.prototype.toString.call(T) + "]";
      }
      y(le, "xo"), d(le, "Tr");
      function De(T, $, P, U, Q) {
        for (var Y = [], z = 0, Z = $.length; z < Z; ++z)
          ur($, String(z)) ? Y.push(Pt(T, $, P, U, String(z), true)) : Y.push("");
        return Q.forEach(function(u) {
          u.match(/^\d+$/) || Y.push(Pt(T, $, P, U, u, true));
        }), Y;
      }
      y(De, "tp"), d(De, "ln");
      function Pt(T, $, P, U, Q, Y) {
        var z, Z, u;
        if (u = Object.getOwnPropertyDescriptor($, Q) || { value: $[Q] }, u.get ? u.set ? Z = T.stylize("[Getter/Setter]", "special") : Z = T.stylize("[Getter]", "special") : u.set && (Z = T.stylize("[Setter]", "special")), ur(U, Q) || (z = "[" + Q + "]"), Z || (T.seen.indexOf(u.value) < 0 ? (_t(P) ? Z = be(T, u.value, null) : Z = be(T, u.value, P - 1), Z.indexOf(`
`) > -1 && (Y ? Z = Z.split(`
`).map(function(h) {
          return "  " + h;
        }).join(`
`).substr(2) : Z = `
` + Z.split(`
`).map(function(h) {
          return "   " + h;
        }).join(`
`))) : Z = T.stylize("[Circular]", "special")), We(z)) {
          if (Y && Q.match(/^\d+$/))
            return Z;
          z = JSON.stringify("" + Q), z.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (z = z.substr(1, z.length - 2), z = T.stylize(z, "name")) : (z = z.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), z = T.stylize(z, "string"));
        }
        return z + ": " + Z;
      }
      y(Pt, "Po"), d(Pt, "Ir");
      function ar(T, $, P) {
        var U = 0, Q = T.reduce(function(Y, z) {
          return U++, z.indexOf(`
`) >= 0 && U++, Y + z.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0);
        return Q > 60 ? P[0] + ($ === "" ? "" : $ + `
 `) + " " + T.join(`,
  `) + " " + P[1] : P[0] + $ + " " + T.join(", ") + " " + P[1];
      }
      y(ar, "rp"), d(ar, "gn"), e2.types = S();
      function Dt(T) {
        return Array.isArray(T);
      }
      y(Dt, "ca"), d(Dt, "ze"), e2.isArray = Dt;
      function jt(T) {
        return typeof T == "boolean";
      }
      y(jt, "To"), d(jt, "Fr"), e2.isBoolean = jt;
      function _t(T) {
        return T === null;
      }
      y(_t, "mn"), d(_t, "or"), e2.isNull = _t;
      function sr(T) {
        return T == null;
      }
      y(sr, "np"), d(sr, "dn"), e2.isNullOrUndefined = sr;
      function Oe(T) {
        return typeof T == "number";
      }
      y(Oe, "fa"), d(Oe, "Ce"), e2.isNumber = Oe;
      function Se(T) {
        return typeof T == "string";
      }
      y(Se, "hn"), d(Se, "ir"), e2.isString = Se;
      function Vt(T) {
        return typeof T == "symbol";
      }
      y(Vt, "op"), d(Vt, "bn"), e2.isSymbol = Vt;
      function We(T) {
        return T === void 0;
      }
      y(We, "vt"), d(We, "O"), e2.isUndefined = We;
      function at(T) {
        return et(T) && Nt(T) === "[object RegExp]";
      }
      y(at, "mr"), d(at, "x"), e2.isRegExp = at, e2.types.isRegExp = at;
      function et(T) {
        return typeof T == "object" && T !== null;
      }
      y(et, "Ut"), d(et, "U"), e2.isObject = et;
      function pt(T) {
        return et(T) && Nt(T) === "[object Date]";
      }
      y(pt, "yn"), d(pt, "ar"), e2.isDate = pt, e2.types.isDate = pt;
      function Ve(T) {
        return et(T) && (Nt(T) === "[object Error]" || T instanceof Error);
      }
      y(Ve, "hr"), d(Ve, "M"), e2.isError = Ve, e2.types.isNativeError = Ve;
      function st(T) {
        return typeof T == "function";
      }
      y(st, "bn"), d(st, "fr"), e2.isFunction = st;
      function Gt(T) {
        return T === null || typeof T == "boolean" || typeof T == "number" || typeof T == "string" || typeof T == "symbol" || typeof T == "undefined";
      }
      y(Gt, "ip"), d(Gt, "mn"), e2.isPrimitive = Gt, e2.isBuffer = A();
      function Nt(T) {
        return Object.prototype.toString.call(T);
      }
      y(Nt, "So"), d(Nt, "Ur");
      function Et(T) {
        return T < 10 ? "0" + T.toString(10) : T.toString(10);
      }
      y(Et, "Mo"), d(Et, "kr");
      var dt = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      function ht() {
        var T = new Date(), $ = [Et(T.getHours()), Et(T.getMinutes()), Et(T.getSeconds())].join(":");
        return [T.getDate(), dt[T.getMonth()], $].join(" ");
      }
      y(ht, "ap"), d(ht, "hn"), e2.log = function() {
        console.log("%s - %s", ht(), e2.format.apply(e2, arguments));
      }, e2.inherits = F(), e2._extend = function(T, $) {
        if (!$ || !et($))
          return T;
        for (var P = Object.keys($), U = P.length; U--; )
          T[P[U]] = $[P[U]];
        return T;
      };
      function ur(T, $) {
        return Object.prototype.hasOwnProperty.call(T, $);
      }
      y(ur, "pa"), d(ur, "_e");
      var ut = typeof Symbol != "undefined" ? Symbol("util.promisify.custom") : void 0;
      e2.promisify = function(T) {
        if (typeof T != "function")
          throw new TypeError('The "original" argument must be of type Function');
        if (ut && T[ut]) {
          var $ = T[ut];
          if (typeof $ != "function")
            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
          return Object.defineProperty($, ut, { value: $, enumerable: false, writable: false, configurable: true }), $;
        }
        function $() {
          for (var P, U, Q = new Promise(function(Z, u) {
            P = Z, U = u;
          }), Y = [], z = 0; z < arguments.length; z++)
            Y.push(arguments[z]);
          Y.push(function(Z, u) {
            Z ? U(Z) : P(u);
          });
          try {
            T.apply(this, Y);
          } catch (Z) {
            U(Z);
          }
          return Q;
        }
        return y($, "t"), d($, "t"), Object.setPrototypeOf($, Object.getPrototypeOf(T)), ut && Object.defineProperty($, ut, { value: $, enumerable: false, writable: false, configurable: true }), Object.defineProperties($, q(T));
      }, e2.promisify.custom = ut;
      function kt(T, $) {
        if (!T) {
          var P = new Error("Promise was rejected with a falsy value");
          P.reason = T, T = P;
        }
        return $(T);
      }
      y(kt, "up"), d(kt, "vn");
      function lr(T) {
        if (typeof T != "function")
          throw new TypeError('The "original" argument must be of type Function');
        function $() {
          for (var P = [], U = 0; U < arguments.length; U++)
            P.push(arguments[U]);
          var Q = P.pop();
          if (typeof Q != "function")
            throw new TypeError("The last argument must be of type Function");
          var Y = this, z = d(function() {
            return Q.apply(Y, arguments);
          }, "i");
          T.apply(this, P).then(function(Z) {
            we.nextTick(z.bind(null, null, Z));
          }, function(Z) {
            we.nextTick(kt.bind(null, Z, z));
          });
        }
        return y($, "t"), d($, "e"), Object.setPrototypeOf($, Object.getPrototypeOf(T)), Object.defineProperties($, q(T)), $;
      }
      y(lr, "lp"), d(lr, "Sn"), e2.callbackify = lr;
    });
    var _u = ve((e2) => {
      j(), N(), I(), k(), e2.isatty = function() {
        return false;
      };
      function t() {
        throw new Error("tty.ReadStream is not implemented");
      }
      y(t, "cp"), d(t, "t"), e2.ReadStream = t;
      function r() {
        throw new Error("tty.WriteStream is not implemented");
      }
      y(r, "fp"), d(r, "e"), e2.WriteStream = r;
    });
    var Eu = ve((e2, t) => {
      j(), N(), I(), k();
      var r = 1e3, n = r * 60, i = n * 60, a = i * 24, o = a * 7, l = a * 365.25;
      t.exports = function(g, v) {
        v = v || {};
        var b = typeof g;
        if (b === "string" && g.length > 0)
          return f(g);
        if (b === "number" && isFinite(g))
          return v.long ? c(g) : s(g);
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(g));
      };
      function f(g) {
        if (g = String(g), !(g.length > 100)) {
          var v = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(g);
          if (v) {
            var b = parseFloat(v[1]), w = (v[2] || "ms").toLowerCase();
            switch (w) {
              case "years":
              case "year":
              case "yrs":
              case "yr":
              case "y":
                return b * l;
              case "weeks":
              case "week":
              case "w":
                return b * o;
              case "days":
              case "day":
              case "d":
                return b * a;
              case "hours":
              case "hour":
              case "hrs":
              case "hr":
              case "h":
                return b * i;
              case "minutes":
              case "minute":
              case "mins":
              case "min":
              case "m":
                return b * n;
              case "seconds":
              case "second":
              case "secs":
              case "sec":
              case "s":
                return b * r;
              case "milliseconds":
              case "millisecond":
              case "msecs":
              case "msec":
              case "ms":
                return b;
              default:
                return;
            }
          }
        }
      }
      y(f, "gp"), d(f, "parse");
      function s(g) {
        var v = Math.abs(g);
        return v >= a ? Math.round(g / a) + "d" : v >= i ? Math.round(g / i) + "h" : v >= n ? Math.round(g / n) + "m" : v >= r ? Math.round(g / r) + "s" : g + "ms";
      }
      y(s, "mp"), d(s, "fmtShort");
      function c(g) {
        var v = Math.abs(g);
        return v >= a ? p(g, v, a, "day") : v >= i ? p(g, v, i, "hour") : v >= n ? p(g, v, n, "minute") : v >= r ? p(g, v, r, "second") : g + " ms";
      }
      y(c, "hp"), d(c, "fmtLong");
      function p(g, v, b, w) {
        var E = v >= b * 1.5;
        return Math.round(g / b) + " " + w + (E ? "s" : "");
      }
      y(p, "vn"), d(p, "plural");
    });
    var Au = ve((e2) => {
      j(), N(), I(), k();
      var t = Object.defineProperty, r = d((f) => t(f, "__esModule", { value: true }), "__markAsModule"), n = d((f, s) => t(f, "name", { value: s, configurable: true }), "__name"), i = d((f, s) => {
        r(f);
        for (var c in s)
          t(f, c, { get: s[c], enumerable: true });
      }, "__export");
      i(e2, { setup: () => l });
      var a = Object.defineProperty, o = n((f, s) => a(f, "name", { value: s, configurable: true }), "__name");
      function l(f) {
        let s = o((S, A) => {
          let F, q = null, R, C, B = o((...W) => {
            let G = B, pe = Number(new Date()), H = pe - (F || pe);
            G.diff = H, G.prev = F, G.curr = pe, F = pe, W[0] = s.coerce(W[0]), typeof W[0] != "string" && W.unshift("%O");
            let de = 0;
            W[0] = W[0].replace(/%([a-zA-Z%])/g, (be, se) => {
              if (be === "%%")
                return "%";
              de++;
              let le = s.formatters[se];
              if (typeof le == "function") {
                let De = W[de];
                be = le.call(G, De), W.splice(de, 1), de--;
              }
              return be;
            }), s.formatArgs.call(G, W), A && typeof A == "function" && A.apply(G, W), B.enabled && (G.log || s.log).apply(G, W);
          }, "debug");
          return B.namespace = S, B.useColors = s.useColors(), B.color = s.selectColor(S), B.extend = p, B.destroy = s.destroy, Object.defineProperty(B, "enabled", { enumerable: true, configurable: false, get: () => q !== null ? q : (R !== s.namespaces && (R = s.namespaces, C = s.enabled(S)), C), set: (W) => {
            q = W;
          } }), typeof s.init == "function" && s.init(B), B;
        }, "createDebug");
        s.debug = s, s.default = s, s.coerce = E, s.disable = v, s.enable = g, s.enabled = b, s.humanize = Eu(), s.destroy = x, Object.keys(f).forEach((S) => {
          s[S] = f[S];
        }), s.names = [], s.skips = [], s.formatters = {};
        function c(S) {
          let A = 0;
          for (let F = 0; F < S.length; F++)
            A = (A << 5) - A + S.charCodeAt(F), A |= 0;
          return s.colors[Math.abs(A) % s.colors.length];
        }
        y(c, "r"), d(c, "selectColor"), n(c, "selectColor"), o(c, "selectColor"), s.selectColor = c;
        function p(S, A) {
          let F = s(this.namespace + (typeof A == "undefined" ? ":" : A) + S);
          return F.log = this.log, F;
        }
        y(p, "n"), d(p, "extend"), n(p, "extend"), o(p, "extend");
        function g(S) {
          s.save(S), s.namespaces = S, s.names = [], s.skips = [];
          let A, F = (typeof S == "string" ? S : "").split(/[\s,]+/), q = F.length;
          for (A = 0; A < q; A++)
            !F[A] || (S = F[A].replace(/\*/g, ".*?"), S[0] === "-" ? s.skips.push(new RegExp("^" + S.slice(1) + "$")) : s.names.push(new RegExp("^" + S + "$")));
        }
        y(g, "o"), d(g, "enable"), n(g, "enable"), o(g, "enable");
        function v() {
          let S = [...s.names.map(w), ...s.skips.map(w).map((A) => "-" + A)].join(",");
          return s.enable(""), S;
        }
        y(v, "i"), d(v, "disable"), n(v, "disable"), o(v, "disable");
        function b(S) {
          if (S[S.length - 1] === "*")
            return true;
          let A, F;
          for (A = 0, F = s.skips.length; A < F; A++)
            if (s.skips[A].test(S))
              return false;
          for (A = 0, F = s.names.length; A < F; A++)
            if (s.names[A].test(S))
              return true;
          return false;
        }
        y(b, "s"), d(b, "enabled"), n(b, "enabled"), o(b, "enabled");
        function w(S) {
          return S.toString().substring(2, S.toString().length - 2).replace(/\.\*\?$/, "*");
        }
        y(w, "a"), d(w, "toNamespace"), n(w, "toNamespace"), o(w, "toNamespace");
        function E(S) {
          return S instanceof Error ? S.stack || S.message : S;
        }
        y(E, "l"), d(E, "coerce"), n(E, "coerce"), o(E, "coerce");
        function x() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        return y(x, "c"), d(x, "destroy"), n(x, "destroy"), o(x, "destroy"), s.enable(s.load()), s;
      }
      y(l, "ko"), d(l, "setup"), n(l, "setup"), o(l, "setup");
    });
    var Ou = ve((e2, t) => {
      j(), N(), I(), k();
      var r = Object.create, n = Object.defineProperty, i = Object.getOwnPropertyDescriptor, a = Object.getOwnPropertyNames, o = Object.getPrototypeOf, l = Object.prototype.hasOwnProperty, f = d((H) => n(H, "__esModule", { value: true }), "__markAsModule"), s = d((H, de) => n(H, "name", { value: de, configurable: true }), "__name"), c = d((H, de) => {
        f(H);
        for (var be in de)
          n(H, be, { get: de[be], enumerable: true });
      }, "__export"), p = d((H, de, be) => {
        if (de && typeof de == "object" || typeof de == "function")
          for (let se of a(de))
            !l.call(H, se) && se !== "default" && n(H, se, { get: () => de[se], enumerable: !(be = i(de, se)) || be.enumerable });
        return H;
      }, "__reExport"), g = d((H) => p(f(n(H != null ? r(o(H)) : {}, "default", H && H.__esModule && "default" in H ? { get: () => H.default, enumerable: true } : { value: H, enumerable: true })), H), "__toModule");
      c(e2, { default: () => G });
      var v = g(_u()), b = g(lo()), w = g(Au()), E = Object.defineProperty, x = s((H, de) => E(H, "name", { value: de, configurable: true }), "__name");
      e2.init = B, e2.log = q, e2.formatArgs = A, e2.save = R, e2.load = C, e2.useColors = S, e2.destroy = b.default.deprecate(() => {
      }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."), e2.colors = [6, 2, 3, 4, 5, 1], e2.inspectOpts = Object.keys(we.env).filter((H) => /^debug_/i.test(H)).reduce((H, de) => {
        let be = de.substring(6).toLowerCase().replace(/_([a-z])/g, (le, De) => De.toUpperCase()), se = we.env[de];
        return /^(yes|on|true|enabled)$/i.test(se) ? se = true : /^(no|off|false|disabled)$/i.test(se) ? se = false : se === "null" ? se = null : se = Number(se), H[be] = se, H;
      }, {});
      function S() {
        var H;
        return "colors" in e2.inspectOpts ? Boolean(e2.inspectOpts.colors) : v.default.isatty((H = we.stderr) == null ? void 0 : H.fd);
      }
      y(S, "Fo"), d(S, "useColors"), s(S, "useColors"), x(S, "useColors");
      function A(H) {
        let { namespace: de, useColors: be } = this;
        if (be) {
          let se = this.color, le = "\x1B[3" + (se < 8 ? se : "8;5;" + se), De = `  ${le};1m${de} \x1B[0m`;
          H[0] = De + H[0].split(`
`).join(`
` + De), H.push(le + "m+" + t.exports.humanize(this.diff) + "\x1B[0m");
        } else
          H[0] = F() + de + " " + H[0];
      }
      y(A, "Ro"), d(A, "formatArgs"), s(A, "formatArgs"), x(A, "formatArgs");
      function F() {
        return e2.inspectOpts.hideDate ? "" : new Date().toISOString() + " ";
      }
      y(F, "No"), d(F, "getDate"), s(F, "getDate"), x(F, "getDate");
      function q(...H) {
        return we.stderr.write(b.default.format(...H) + `
`);
      }
      y(q, "Co"), d(q, "log"), s(q, "log"), x(q, "log");
      function R(H) {
        H ? we.env.DEBUG = H : delete we.env.DEBUG;
      }
      y(R, "Do"), d(R, "save"), s(R, "save"), x(R, "save");
      function C() {
        return we.env.DEBUG;
      }
      y(C, "$o"), d(C, "load"), s(C, "load"), x(C, "load");
      function B(H) {
        H.inspectOpts = {};
        let de = Object.keys(e2.inspectOpts);
        for (let be = 0; be < de.length; be++)
          H.inspectOpts[de[be]] = e2.inspectOpts[de[be]];
      }
      y(B, "Bo"), d(B, "init"), s(B, "init"), x(B, "init");
      var W = (0, w.setup)(e2);
      t.exports = W;
      var G = W, { formatters: pe } = W;
      pe.o = function(H) {
        return this.inspectOpts.colors = this.useColors, b.default.inspect(H, this.inspectOpts).split(`
`).map((de) => de.trim()).join(" ");
      }, pe.O = function(H) {
        return this.inspectOpts.colors = this.useColors, b.default.inspect(H, this.inspectOpts);
      };
    });
    var co = ve((e2) => {
      j(), N(), I(), k();
      var t = Object.create, r = Object.defineProperty, n = Object.getOwnPropertyDescriptor, i = Object.getOwnPropertyNames, a = Object.getPrototypeOf, o = Object.prototype.hasOwnProperty, l = d((A) => r(A, "__esModule", { value: true }), "__markAsModule"), f = d((A, F) => r(A, "name", { value: F, configurable: true }), "__name"), s = d((A, F) => {
        l(A);
        for (var q in F)
          r(A, q, { get: F[q], enumerable: true });
      }, "__export"), c = d((A, F, q) => {
        if (F && typeof F == "object" || typeof F == "function")
          for (let R of i(F))
            !o.call(A, R) && R !== "default" && r(A, R, { get: () => F[R], enumerable: !(q = n(F, R)) || q.enumerable });
        return A;
      }, "__reExport"), p = d((A) => c(l(r(A != null ? t(a(A)) : {}, "default", A && A.__esModule && "default" in A ? { get: () => A.default, enumerable: true } : { value: A, enumerable: true })), A), "__toModule");
      s(e2, { Debug: () => x, default: () => x, getLogs: () => S });
      var g = p(Ou()), v = Object.defineProperty, b = f((A, F) => v(A, "name", { value: F, configurable: true }), "__name"), w = [], E = 100;
      function x(A) {
        return (0, g.default)(A, (...F) => {
          w.push(F), w.length > E && w.shift();
        });
      }
      y(x, "zt"), d(x, "Debug"), f(x, "Debug"), b(x, "Debug"), x.enable = (A) => {
        g.default.enable(A);
      }, x.enabled = (A) => g.default.enabled(A);
      function S(A = 7500) {
        let F = w.map((q) => q.map((R) => typeof R == "string" ? R : JSON.stringify(R)).join("  ")).join(`
`);
        return F.length < A ? F : F.slice(-A);
      }
      y(S, "Go"), d(S, "getLogs"), f(S, "getLogs"), b(S, "getLogs");
    });
    var Tu = ve(() => {
      j(), N(), I(), k();
    });
    var Su = ve((e2, t) => {
      j(), N(), I(), k();
      var r = Object.prototype.hasOwnProperty, n = "~";
      function i() {
      }
      y(i, "wr"), d(i, "_"), Object.create && (i.prototype = /* @__PURE__ */ Object.create(null), new i().__proto__ || (n = false));
      function a(s, c, p) {
        this.fn = s, this.context = c, this.once = p || false;
      }
      y(a, "Up"), d(a, "g");
      function o(s, c, p, g, v) {
        if (typeof p != "function")
          throw new TypeError("The listener must be a function");
        var b = new a(p, g || s, v), w = n ? n + c : c;
        return s._events[w] ? s._events[w].fn ? s._events[w] = [s._events[w], b] : s._events[w].push(b) : (s._events[w] = b, s._eventsCount++), s;
      }
      y(o, "Pa"), d(o, "w");
      function l(s, c) {
        --s._eventsCount == 0 ? s._events = new i() : delete s._events[c];
      }
      y(l, "An"), d(l, "y");
      function f() {
        this._events = new i(), this._eventsCount = 0;
      }
      y(f, "pe"), d(f, "u"), f.prototype.eventNames = function() {
        var s = [], c, p;
        if (this._eventsCount === 0)
          return s;
        for (p in c = this._events)
          r.call(c, p) && s.push(n ? p.slice(1) : p);
        return Object.getOwnPropertySymbols ? s.concat(Object.getOwnPropertySymbols(c)) : s;
      }, f.prototype.listeners = function(s) {
        var c = n ? n + s : s, p = this._events[c];
        if (!p)
          return [];
        if (p.fn)
          return [p.fn];
        for (var g = 0, v = p.length, b = new Array(v); g < v; g++)
          b[g] = p[g].fn;
        return b;
      }, f.prototype.listenerCount = function(s) {
        var c = n ? n + s : s, p = this._events[c];
        return p ? p.fn ? 1 : p.length : 0;
      }, f.prototype.emit = function(s, c, p, g, v, b) {
        var w = n ? n + s : s;
        if (!this._events[w])
          return false;
        var E = this._events[w], x = arguments.length, S, A;
        if (E.fn) {
          switch (E.once && this.removeListener(s, E.fn, void 0, true), x) {
            case 1:
              return E.fn.call(E.context), true;
            case 2:
              return E.fn.call(E.context, c), true;
            case 3:
              return E.fn.call(E.context, c, p), true;
            case 4:
              return E.fn.call(E.context, c, p, g), true;
            case 5:
              return E.fn.call(E.context, c, p, g, v), true;
            case 6:
              return E.fn.call(E.context, c, p, g, v, b), true;
          }
          for (A = 1, S = new Array(x - 1); A < x; A++)
            S[A - 1] = arguments[A];
          E.fn.apply(E.context, S);
        } else {
          var F = E.length, q;
          for (A = 0; A < F; A++)
            switch (E[A].once && this.removeListener(s, E[A].fn, void 0, true), x) {
              case 1:
                E[A].fn.call(E[A].context);
                break;
              case 2:
                E[A].fn.call(E[A].context, c);
                break;
              case 3:
                E[A].fn.call(E[A].context, c, p);
                break;
              case 4:
                E[A].fn.call(E[A].context, c, p, g);
                break;
              default:
                if (!S)
                  for (q = 1, S = new Array(x - 1); q < x; q++)
                    S[q - 1] = arguments[q];
                E[A].fn.apply(E[A].context, S);
            }
        }
        return true;
      }, f.prototype.on = function(s, c, p) {
        return o(this, s, c, p, false);
      }, f.prototype.once = function(s, c, p) {
        return o(this, s, c, p, true);
      }, f.prototype.removeListener = function(s, c, p, g) {
        var v = n ? n + s : s;
        if (!this._events[v])
          return this;
        if (!c)
          return l(this, v), this;
        var b = this._events[v];
        if (b.fn)
          b.fn === c && (!g || b.once) && (!p || b.context === p) && l(this, v);
        else {
          for (var w = 0, E = [], x = b.length; w < x; w++)
            (b[w].fn !== c || g && !b[w].once || p && b[w].context !== p) && E.push(b[w]);
          E.length ? this._events[v] = E.length === 1 ? E[0] : E : l(this, v);
        }
        return this;
      }, f.prototype.removeAllListeners = function(s) {
        var c;
        return s ? (c = n ? n + s : s, this._events[c] && l(this, c)) : (this._events = new i(), this._eventsCount = 0), this;
      }, f.prototype.off = f.prototype.removeListener, f.prototype.addListener = f.prototype.on, f.prefixed = n, f.EventEmitter = f, typeof t != "undefined" && (t.exports = f);
    });
    var fo = {};
    io(fo, { default: () => xn, existsSync: () => po });
    function po() {
      return false;
    }
    y(po, "Vp");
    var ho;
    var xn;
    var go = fr(() => {
      j(), N(), I(), k(), d(po, "existsSync"), ho = { existsSync() {
        return false;
      } }, xn = ho;
    });
    var yo = ve((e2, t) => {
      j(), N(), I(), k();
      function r(o) {
        if (typeof o != "string")
          throw new TypeError("Path must be a string. Received " + JSON.stringify(o));
      }
      y(r, "qe"), d(r, "c");
      function n(o, l) {
        for (var f = "", s = 0, c = -1, p = 0, g, v = 0; v <= o.length; ++v) {
          if (v < o.length)
            g = o.charCodeAt(v);
          else {
            if (g === 47)
              break;
            g = 47;
          }
          if (g === 47) {
            if (!(c === v - 1 || p === 1))
              if (c !== v - 1 && p === 2) {
                if (f.length < 2 || s !== 2 || f.charCodeAt(f.length - 1) !== 46 || f.charCodeAt(f.length - 2) !== 46) {
                  if (f.length > 2) {
                    var b = f.lastIndexOf("/");
                    if (b !== f.length - 1) {
                      b === -1 ? (f = "", s = 0) : (f = f.slice(0, b), s = f.length - 1 - f.lastIndexOf("/")), c = v, p = 0;
                      continue;
                    }
                  } else if (f.length === 2 || f.length === 1) {
                    f = "", s = 0, c = v, p = 0;
                    continue;
                  }
                }
                l && (f.length > 0 ? f += "/.." : f = "..", s = 2);
              } else
                f.length > 0 ? f += "/" + o.slice(c + 1, v) : f = o.slice(c + 1, v), s = v - c - 1;
            c = v, p = 0;
          } else
            g === 46 && p !== -1 ? ++p : p = -1;
        }
        return f;
      }
      y(n, "Ma"), d(n, "A");
      function i(o, l) {
        var f = l.dir || l.root, s = l.base || (l.name || "") + (l.ext || "");
        return f ? f === l.root ? f + s : f + o + s : s;
      }
      y(i, "Jp"), d(i, "b");
      var a = { resolve: function() {
        for (var o = "", l = false, f, s = arguments.length - 1; s >= -1 && !l; s--) {
          var c;
          s >= 0 ? c = arguments[s] : (f === void 0 && (f = we.cwd()), c = f), r(c), c.length !== 0 && (o = c + "/" + o, l = c.charCodeAt(0) === 47);
        }
        return o = n(o, !l), l ? o.length > 0 ? "/" + o : "/" : o.length > 0 ? o : ".";
      }, normalize: function(o) {
        if (r(o), o.length === 0)
          return ".";
        var l = o.charCodeAt(0) === 47, f = o.charCodeAt(o.length - 1) === 47;
        return o = n(o, !l), o.length === 0 && !l && (o = "."), o.length > 0 && f && (o += "/"), l ? "/" + o : o;
      }, isAbsolute: function(o) {
        return r(o), o.length > 0 && o.charCodeAt(0) === 47;
      }, join: function() {
        if (arguments.length === 0)
          return ".";
        for (var o, l = 0; l < arguments.length; ++l) {
          var f = arguments[l];
          r(f), f.length > 0 && (o === void 0 ? o = f : o += "/" + f);
        }
        return o === void 0 ? "." : a.normalize(o);
      }, relative: function(o, l) {
        if (r(o), r(l), o === l || (o = a.resolve(o), l = a.resolve(l), o === l))
          return "";
        for (var f = 1; f < o.length && o.charCodeAt(f) === 47; ++f)
          ;
        for (var s = o.length, c = s - f, p = 1; p < l.length && l.charCodeAt(p) === 47; ++p)
          ;
        for (var g = l.length, v = g - p, b = c < v ? c : v, w = -1, E = 0; E <= b; ++E) {
          if (E === b) {
            if (v > b) {
              if (l.charCodeAt(p + E) === 47)
                return l.slice(p + E + 1);
              if (E === 0)
                return l.slice(p + E);
            } else
              c > b && (o.charCodeAt(f + E) === 47 ? w = E : E === 0 && (w = 0));
            break;
          }
          var x = o.charCodeAt(f + E), S = l.charCodeAt(p + E);
          if (x !== S)
            break;
          x === 47 && (w = E);
        }
        var A = "";
        for (E = f + w + 1; E <= s; ++E)
          (E === s || o.charCodeAt(E) === 47) && (A.length === 0 ? A += ".." : A += "/..");
        return A.length > 0 ? A + l.slice(p + w) : (p += w, l.charCodeAt(p) === 47 && ++p, l.slice(p));
      }, _makeLong: function(o) {
        return o;
      }, dirname: function(o) {
        if (r(o), o.length === 0)
          return ".";
        for (var l = o.charCodeAt(0), f = l === 47, s = -1, c = true, p = o.length - 1; p >= 1; --p)
          if (l = o.charCodeAt(p), l === 47) {
            if (!c) {
              s = p;
              break;
            }
          } else
            c = false;
        return s === -1 ? f ? "/" : "." : f && s === 1 ? "//" : o.slice(0, s);
      }, basename: function(o, l) {
        if (l !== void 0 && typeof l != "string")
          throw new TypeError('"ext" argument must be a string');
        r(o);
        var f = 0, s = -1, c = true, p;
        if (l !== void 0 && l.length > 0 && l.length <= o.length) {
          if (l.length === o.length && l === o)
            return "";
          var g = l.length - 1, v = -1;
          for (p = o.length - 1; p >= 0; --p) {
            var b = o.charCodeAt(p);
            if (b === 47) {
              if (!c) {
                f = p + 1;
                break;
              }
            } else
              v === -1 && (c = false, v = p + 1), g >= 0 && (b === l.charCodeAt(g) ? --g == -1 && (s = p) : (g = -1, s = v));
          }
          return f === s ? s = v : s === -1 && (s = o.length), o.slice(f, s);
        } else {
          for (p = o.length - 1; p >= 0; --p)
            if (o.charCodeAt(p) === 47) {
              if (!c) {
                f = p + 1;
                break;
              }
            } else
              s === -1 && (c = false, s = p + 1);
          return s === -1 ? "" : o.slice(f, s);
        }
      }, extname: function(o) {
        r(o);
        for (var l = -1, f = 0, s = -1, c = true, p = 0, g = o.length - 1; g >= 0; --g) {
          var v = o.charCodeAt(g);
          if (v === 47) {
            if (!c) {
              f = g + 1;
              break;
            }
            continue;
          }
          s === -1 && (c = false, s = g + 1), v === 46 ? l === -1 ? l = g : p !== 1 && (p = 1) : l !== -1 && (p = -1);
        }
        return l === -1 || s === -1 || p === 0 || p === 1 && l === s - 1 && l === f + 1 ? "" : o.slice(l, s);
      }, format: function(o) {
        if (o === null || typeof o != "object")
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof o);
        return i("/", o);
      }, parse: function(o) {
        r(o);
        var l = { root: "", dir: "", base: "", ext: "", name: "" };
        if (o.length === 0)
          return l;
        var f = o.charCodeAt(0), s = f === 47, c;
        s ? (l.root = "/", c = 1) : c = 0;
        for (var p = -1, g = 0, v = -1, b = true, w = o.length - 1, E = 0; w >= c; --w) {
          if (f = o.charCodeAt(w), f === 47) {
            if (!b) {
              g = w + 1;
              break;
            }
            continue;
          }
          v === -1 && (b = false, v = w + 1), f === 46 ? p === -1 ? p = w : E !== 1 && (E = 1) : p !== -1 && (E = -1);
        }
        return p === -1 || v === -1 || E === 0 || E === 1 && p === v - 1 && p === g + 1 ? v !== -1 && (g === 0 && s ? l.base = l.name = o.slice(1, v) : l.base = l.name = o.slice(g, v)) : (g === 0 && s ? (l.name = o.slice(1, p), l.base = o.slice(1, v)) : (l.name = o.slice(g, p), l.base = o.slice(g, v)), l.ext = o.slice(p, v)), g > 0 ? l.dir = o.slice(0, g - 1) : s && (l.dir = "/"), l;
      }, sep: "/", delimiter: ":", win32: null, posix: null };
      a.posix = a, t.exports = a;
    });
    var xu = ve((e2, t) => {
      j(), N(), I(), k(), t.exports = ({ onlyFirst: r = false } = {}) => {
        let n = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
        return new RegExp(n, r ? void 0 : "g");
      };
    });
    var Pn = ve((e2, t) => {
      j(), N(), I(), k();
      var r = xu();
      t.exports = (n) => typeof n == "string" ? n.replace(r(), "") : n;
    });
    var Pu = ve((e2, t) => {
      j(), N(), I(), k();
      var r = Symbol("arg flag"), n = y(class extends Error {
        constructor(a, o) {
          super(a);
          this.name = "ArgError", this.code = o, Object.setPrototypeOf(this, n.prototype);
        }
      }, "Ee");
      d(n, "ArgError");
      function i(a, { argv: o = we.argv.slice(2), permissive: l = false, stopAtPositional: f = false } = {}) {
        if (!a)
          throw new n("argument specification object is required", "ARG_CONFIG_NO_SPEC");
        let s = { _: [] }, c = {}, p = {};
        for (let g of Object.keys(a)) {
          if (!g)
            throw new n("argument key cannot be an empty string", "ARG_CONFIG_EMPTY_KEY");
          if (g[0] !== "-")
            throw new n(`argument key must start with '-' but found: '${g}'`, "ARG_CONFIG_NONOPT_KEY");
          if (g.length === 1)
            throw new n(`argument key must have a name; singular '-' keys are not allowed: ${g}`, "ARG_CONFIG_NONAME_KEY");
          if (typeof a[g] == "string") {
            c[g] = a[g];
            continue;
          }
          let v = a[g], b = false;
          if (Array.isArray(v) && v.length === 1 && typeof v[0] == "function") {
            let [w] = v;
            v = d((E, x, S = []) => (S.push(w(E, x, S[S.length - 1])), S), "type"), b = w === Boolean || w[r] === true;
          } else if (typeof v == "function")
            b = v === Boolean || v[r] === true;
          else
            throw new n(`type missing or not a function or valid array type: ${g}`, "ARG_CONFIG_VAD_TYPE");
          if (g[1] !== "-" && g.length > 2)
            throw new n(`short argument keys (with a single hyphen) must have only one character: ${g}`, "ARG_CONFIG_SHORTOPT_TOOLONG");
          p[g] = [v, b];
        }
        for (let g = 0, v = o.length; g < v; g++) {
          let b = o[g];
          if (f && s._.length > 0) {
            s._ = s._.concat(o.slice(g));
            break;
          }
          if (b === "--") {
            s._ = s._.concat(o.slice(g + 1));
            break;
          }
          if (b.length > 1 && b[0] === "-") {
            let w = b[1] === "-" || b.length === 2 ? [b] : b.slice(1).split("").map((E) => `-${E}`);
            for (let E = 0; E < w.length; E++) {
              let x = w[E], [S, A] = x[1] === "-" ? x.split(/=(.*)/, 2) : [x, void 0], F = S;
              for (; F in c; )
                F = c[F];
              if (!(F in p))
                if (l) {
                  s._.push(x);
                  continue;
                } else
                  throw new n(`unknown or unexpected option: ${S}`, "ARG_UNKNOWN_OPTION");
              let [q, R] = p[F];
              if (!R && E + 1 < w.length)
                throw new n(`option requires argument (but was followed by another short argument): ${S}`, "ARG_MISSING_REQUIRED_SHORTARG");
              if (R)
                s[F] = q(true, F, s[F]);
              else if (A === void 0) {
                if (o.length < g + 2 || o[g + 1].length > 1 && o[g + 1][0] === "-" && !(o[g + 1].match(/^-?\d*(\.(?=\d))?\d*$/) && (q === Number || typeof BigInt != "undefined" && q === BigInt))) {
                  let C = S === F ? "" : ` (alias for ${F})`;
                  throw new n(`option requires argument: ${S}${C}`, "ARG_MISSING_REQUIRED_LONGARG");
                }
                s[F] = q(o[g + 1], F, s[F]), ++g;
              } else
                s[F] = q(A, F, s[F]);
            }
          } else
            s._.push(b);
        }
        return s;
      }
      y(i, "Tr"), d(i, "arg"), i.flag = (a) => (a[r] = true, a), i.COUNT = i.flag((a, o, l) => (l || 0) + 1), i.ArgError = n, t.exports = i;
    });
    var ju = ve((e2, t) => {
      j(), N(), I(), k(), t.exports = (r) => {
        let n = r.match(/^[ \t]*(?=\S)/gm);
        return n ? n.reduce((i, a) => Math.min(i, a.length), 1 / 0) : 0;
      };
    });
    var mo = ve((e2, t) => {
      j(), N(), I(), k();
      var r = ju();
      t.exports = (n) => {
        let i = r(n);
        if (i === 0)
          return n;
        let a = new RegExp(`^[ \\t]{${i}}`, "gm");
        return n.replace(a, "");
      };
    });
    var Nu = ve(() => {
      j(), N(), I(), k();
    });
    var vo = ve((e2) => {
      j(), N(), I(), k(), Object.defineProperty(e2, "__esModule", { value: true }), e2.sqltag = e2.empty = e2.raw = e2.join = e2.Sql = void 0;
      var t = lo(), r = y(class {
        constructor(o, l) {
          let f = l.length, s = o.length;
          if (s === 0)
            throw new TypeError("Expected at least 1 string");
          if (s - 1 !== f)
            throw new TypeError(`Expected ${s} strings to have ${s - 1} values`);
          for (let g of l)
            g instanceof r && (f += g.values.length - 1, s += g.strings.length - 2);
          this.values = new Array(f), this.strings = new Array(s), this.strings[0] = o[0];
          let c = 1, p = 0;
          for (; c < o.length; ) {
            let g = l[c - 1], v = o[c++];
            if (g instanceof r) {
              this.strings[p] += g.strings[0];
              let b = 0;
              for (; b < g.values.length; )
                this.values[p++] = g.values[b++], this.strings[p] = g.strings[b];
              this.strings[p] += v;
            } else
              this.values[p++] = g, this.strings[p] = v;
          }
        }
        get text() {
          return this.strings.reduce((o, l, f) => `${o}$${f}${l}`);
        }
        get sql() {
          return this.strings.join("?");
        }
        [t.inspect.custom]() {
          return { text: this.text, sql: this.sql, values: this.values };
        }
      }, "je");
      d(r, "Sql"), e2.Sql = r, Object.defineProperty(r.prototype, "sql", { enumerable: true }), Object.defineProperty(r.prototype, "text", { enumerable: true });
      function n(o, l = ",") {
        if (o.length === 0)
          throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");
        return new r(["", ...Array(o.length - 1).fill(l), ""], o);
      }
      y(n, "rg"), d(n, "join"), e2.join = n;
      function i(o) {
        return new r([o], []);
      }
      y(i, "ou"), d(i, "raw"), e2.raw = i, e2.empty = i("");
      function a(o, ...l) {
        return new r(o, l);
      }
      y(a, "iu"), d(a, "sqltag"), e2.sqltag = a, e2.default = a;
    });
    var ku = ve((e2, t) => {
      j(), N(), I(), k(), t.exports = (r) => Object.prototype.toString.call(r) === "[object RegExp]";
    });
    var Iu = ve((e2, t) => {
      j(), N(), I(), k(), t.exports = (r) => {
        let n = typeof r;
        return r !== null && (n === "object" || n === "function");
      };
    });
    var $u = ve((e2) => {
      j(), N(), I(), k(), Object.defineProperty(e2, "__esModule", { value: true }), e2.default = (t) => Object.getOwnPropertySymbols(t).filter((r) => Object.prototype.propertyIsEnumerable.call(t, r));
    });
    var Mu = ve((e2, t) => {
      t.exports = { name: "@prisma/client", version: "3.13.0", description: "Prisma Client is an auto-generated, type-safe and modern JavaScript/TypeScript ORM for Node.js that's tailored to your data. Supports MySQL, PostgreSQL, MariaDB, SQLite databases.", keywords: ["orm", "prisma2", "prisma", "client", "query", "database", "sql", "postgres", "postgresql", "mysql", "sqlite", "mariadb", "mssql", "typescript", "query-builder"], main: "index.js", browser: "index-browser.js", types: "index.d.ts", license: "Apache-2.0", engines: { node: ">=12.6" }, homepage: "https://www.prisma.io", repository: { type: "git", url: "https://github.com/prisma/prisma.git", directory: "packages/client" }, author: "Tim Suchanek <suchanek@prisma.io>", maintainers: ["Jo\xEBl Galeran <galeran@prisma.io>", "Pierre-Antoine Mills <mills@prisma.io>", "Alexey Orlenko <orlenko@prisma.io>"], bugs: "https://github.com/prisma/prisma/issues", scripts: { dev: "DEV=true node -r esbuild-register helpers/build.ts", build: "node -r esbuild-register helpers/build.ts", test: "jest --verbose", "test:functional": "pnpm run test:functional:code && pnpm run test:functional:types", "test:functional:code": "jest --verbose --config=tests/functional/jest.config.js --testPathIgnorePatterns typescript", "test:functional:types": "jest --verbose --config=tests/functional/jest.config.js -- typescript", "test-notypes": "jest --verbose --testPathIgnorePatterns src/__tests__/types/types.test.ts", generate: "node scripts/postinstall.js", postinstall: "node scripts/postinstall.js", prepare: "cp scripts/backup-index.js index.js && cp scripts/backup-index.d.ts index.d.ts", prepublishOnly: "pnpm run build" }, files: ["README.md", "runtime", "scripts", "generator-build", "index.js", "index.d.ts", "index-browser.js"], devDependencies: { "@jest/test-sequencer": "27.5.1", "@microsoft/api-extractor": "7.19.3", "@opentelemetry/api": "1.0.3", "@prisma/debug": "workspace:*", "@prisma/engine-core": "workspace:*", "@prisma/engines": "3.13.0-17.efdf9b1183dddfd4258cd181a72125755215ab7b", "@prisma/fetch-engine": "3.13.0-17.efdf9b1183dddfd4258cd181a72125755215ab7b", "@prisma/generator-helper": "workspace:*", "@prisma/get-platform": "3.13.0-17.efdf9b1183dddfd4258cd181a72125755215ab7b", "@prisma/migrate": "workspace:*", "@prisma/sdk": "workspace:*", "@swc/core": "1.2.141", "@swc/jest": "0.2.17", "@timsuchanek/copy": "1.4.5", "@types/debug": "4.1.7", "@types/jest": "27.4.1", "@types/js-levenshtein": "1.1.1", "@types/mssql": "7.1.5", "@types/node": "12.20.48", "@types/pg": "8.6.5", arg: "5.0.1", benchmark: "2.1.4", chalk: "4.1.2", "decimal.js": "10.3.1", esbuild: "0.13.14", execa: "5.1.1", "flat-map-polyfill": "0.3.8", "fs-extra": "10.0.0", "fs-monkey": "1.0.3", "get-own-enumerable-property-symbols": "3.0.2", globby: "11.1.0", "indent-string": "4.0.0", "is-obj": "2.0.0", "is-regexp": "2.1.0", jest: "27.5.1", "jest-junit": "13.0.0", "js-levenshtein": "1.1.6", klona: "2.0.5", "lz-string": "1.4.4", "make-dir": "3.1.0", mariadb: "3.0.0", mssql: "8.0.1", pg: "8.7.1", "pkg-up": "3.1.0", pluralize: "8.0.0", "replace-string": "3.1.0", resolve: "1.22.0", rimraf: "3.0.2", "sort-keys": "4.2.0", "source-map-support": "0.5.21", "sql-template-tag": "4.0.0", "stacktrace-parser": "0.1.10", "strip-ansi": "6.0.1", "strip-indent": "3.0.0", "ts-jest": "27.1.4", "ts-node": "10.4.0", tsd: "0.19.1", typescript: "4.5.4" }, peerDependencies: { prisma: "*" }, peerDependenciesMeta: { prisma: { optional: true } }, dependencies: { "@prisma/engines-version": "3.13.0-17.efdf9b1183dddfd4258cd181a72125755215ab7b" }, sideEffects: false };
    });
    j();
    N();
    I();
    k();
    var Fu = Ae(du());
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    var It = Ae(Wt());
    j();
    N();
    I();
    k();
    var zt = 9e15;
    var Tt = 1e9;
    var jn = "0123456789abcdef";
    var Br = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
    var Cr = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
    var Nn = { precision: 20, rounding: 4, modulo: 1, toExpNeg: -7, toExpPos: 21, minE: -zt, maxE: zt, crypto: false };
    var bo;
    var mt;
    var ae = true;
    var qr = "[DecimalError] ";
    var St = qr + "Invalid argument: ";
    var wo = qr + "Precision limit exceeded";
    var _o = qr + "crypto unavailable";
    var Eo = "[object Decimal]";
    var Me = Math.floor;
    var Pe = Math.pow;
    var Ru = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
    var Bu = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
    var Cu = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
    var Ao = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
    var rt = 1e7;
    var oe = 7;
    var qu = 9007199254740991;
    var Lu = Br.length - 1;
    var kn = Cr.length - 1;
    var D = { toStringTag: Eo };
    D.absoluteValue = D.abs = function() {
      var e2 = new this.constructor(this);
      return e2.s < 0 && (e2.s = 1), te(e2);
    };
    D.ceil = function() {
      return te(new this.constructor(this), this.e + 1, 2);
    };
    D.clampedTo = D.clamp = function(e2, t) {
      var r, n = this, i = n.constructor;
      if (e2 = new i(e2), t = new i(t), !e2.s || !t.s)
        return new i(NaN);
      if (e2.gt(t))
        throw Error(St + t);
      return r = n.cmp(e2), r < 0 ? e2 : n.cmp(t) > 0 ? t : new i(n);
    };
    D.comparedTo = D.cmp = function(e2) {
      var t, r, n, i, a = this, o = a.d, l = (e2 = new a.constructor(e2)).d, f = a.s, s = e2.s;
      if (!o || !l)
        return !f || !s ? NaN : f !== s ? f : o === l ? 0 : !o ^ f < 0 ? 1 : -1;
      if (!o[0] || !l[0])
        return o[0] ? f : l[0] ? -s : 0;
      if (f !== s)
        return f;
      if (a.e !== e2.e)
        return a.e > e2.e ^ f < 0 ? 1 : -1;
      for (n = o.length, i = l.length, t = 0, r = n < i ? n : i; t < r; ++t)
        if (o[t] !== l[t])
          return o[t] > l[t] ^ f < 0 ? 1 : -1;
      return n === i ? 0 : n > i ^ f < 0 ? 1 : -1;
    };
    D.cosine = D.cos = function() {
      var e2, t, r = this, n = r.constructor;
      return r.d ? r.d[0] ? (e2 = n.precision, t = n.rounding, n.precision = e2 + Math.max(r.e, r.sd()) + oe, n.rounding = 1, r = Oo(n, Bn(n, r)), n.precision = e2, n.rounding = t, te(mt == 2 || mt == 3 ? r.neg() : r, e2, t, true)) : new n(1) : new n(NaN);
    };
    D.cubeRoot = D.cbrt = function() {
      var e2, t, r, n, i, a, o, l, f, s, c = this, p = c.constructor;
      if (!c.isFinite() || c.isZero())
        return new p(c);
      for (ae = false, a = c.s * Pe(c.s * c, 1 / 3), !a || Math.abs(a) == 1 / 0 ? (r = je(c.d), e2 = c.e, (a = (e2 - r.length + 1) % 3) && (r += a == 1 || a == -2 ? "0" : "00"), a = Pe(r, 1 / 3), e2 = Me((e2 + 1) / 3) - (e2 % 3 == (e2 < 0 ? -1 : 2)), a == 1 / 0 ? r = "5e" + e2 : (r = a.toExponential(), r = r.slice(0, r.indexOf("e") + 1) + e2), n = new p(r), n.s = c.s) : n = new p(a.toString()), o = (e2 = p.precision) + 3; ; )
        if (l = n, f = l.times(l).times(l), s = f.plus(c), n = Ee(s.plus(c).times(l), s.plus(f), o + 2, 1), je(l.d).slice(0, o) === (r = je(n.d)).slice(0, o))
          if (r = r.slice(o - 3, o + 1), r == "9999" || !i && r == "4999") {
            if (!i && (te(l, e2 + 1, 0), l.times(l).times(l).eq(c))) {
              n = l;
              break;
            }
            o += 4, i = 1;
          } else {
            (!+r || !+r.slice(1) && r.charAt(0) == "5") && (te(n, e2 + 1, 1), t = !n.times(n).times(n).eq(c));
            break;
          }
      return ae = true, te(n, e2, p.rounding, t);
    };
    D.decimalPlaces = D.dp = function() {
      var e2, t = this.d, r = NaN;
      if (t) {
        if (e2 = t.length - 1, r = (e2 - Me(this.e / oe)) * oe, e2 = t[e2], e2)
          for (; e2 % 10 == 0; e2 /= 10)
            r--;
        r < 0 && (r = 0);
      }
      return r;
    };
    D.dividedBy = D.div = function(e2) {
      return Ee(this, new this.constructor(e2));
    };
    D.dividedToIntegerBy = D.divToInt = function(e2) {
      var t = this, r = t.constructor;
      return te(Ee(t, new r(e2), 0, 1, 1), r.precision, r.rounding);
    };
    D.equals = D.eq = function(e2) {
      return this.cmp(e2) === 0;
    };
    D.floor = function() {
      return te(new this.constructor(this), this.e + 1, 3);
    };
    D.greaterThan = D.gt = function(e2) {
      return this.cmp(e2) > 0;
    };
    D.greaterThanOrEqualTo = D.gte = function(e2) {
      var t = this.cmp(e2);
      return t == 1 || t === 0;
    };
    D.hyperbolicCosine = D.cosh = function() {
      var e2, t, r, n, i, a = this, o = a.constructor, l = new o(1);
      if (!a.isFinite())
        return new o(a.s ? 1 / 0 : NaN);
      if (a.isZero())
        return l;
      r = o.precision, n = o.rounding, o.precision = r + Math.max(a.e, a.sd()) + 4, o.rounding = 1, i = a.d.length, i < 32 ? (e2 = Math.ceil(i / 3), t = (1 / yr(4, e2)).toString()) : (e2 = 16, t = "2.3283064365386962890625e-10"), a = $t(o, 1, a.times(t), new o(1), true);
      for (var f, s = e2, c = new o(8); s--; )
        f = a.times(a), a = l.minus(f.times(c.minus(f.times(c))));
      return te(a, o.precision = r, o.rounding = n, true);
    };
    D.hyperbolicSine = D.sinh = function() {
      var e2, t, r, n, i = this, a = i.constructor;
      if (!i.isFinite() || i.isZero())
        return new a(i);
      if (t = a.precision, r = a.rounding, a.precision = t + Math.max(i.e, i.sd()) + 4, a.rounding = 1, n = i.d.length, n < 3)
        i = $t(a, 2, i, i, true);
      else {
        e2 = 1.4 * Math.sqrt(n), e2 = e2 > 16 ? 16 : e2 | 0, i = i.times(1 / yr(5, e2)), i = $t(a, 2, i, i, true);
        for (var o, l = new a(5), f = new a(16), s = new a(20); e2--; )
          o = i.times(i), i = i.times(l.plus(o.times(f.times(o).plus(s))));
      }
      return a.precision = t, a.rounding = r, te(i, t, r, true);
    };
    D.hyperbolicTangent = D.tanh = function() {
      var e2, t, r = this, n = r.constructor;
      return r.isFinite() ? r.isZero() ? new n(r) : (e2 = n.precision, t = n.rounding, n.precision = e2 + 7, n.rounding = 1, Ee(r.sinh(), r.cosh(), n.precision = e2, n.rounding = t)) : new n(r.s);
    };
    D.inverseCosine = D.acos = function() {
      var e2, t = this, r = t.constructor, n = t.abs().cmp(1), i = r.precision, a = r.rounding;
      return n !== -1 ? n === 0 ? t.isNeg() ? He(r, i, a) : new r(0) : new r(NaN) : t.isZero() ? He(r, i + 4, a).times(0.5) : (r.precision = i + 6, r.rounding = 1, t = t.asin(), e2 = He(r, i + 4, a).times(0.5), r.precision = i, r.rounding = a, e2.minus(t));
    };
    D.inverseHyperbolicCosine = D.acosh = function() {
      var e2, t, r = this, n = r.constructor;
      return r.lte(1) ? new n(r.eq(1) ? 0 : NaN) : r.isFinite() ? (e2 = n.precision, t = n.rounding, n.precision = e2 + Math.max(Math.abs(r.e), r.sd()) + 4, n.rounding = 1, ae = false, r = r.times(r).minus(1).sqrt().plus(r), ae = true, n.precision = e2, n.rounding = t, r.ln()) : new n(r);
    };
    D.inverseHyperbolicSine = D.asinh = function() {
      var e2, t, r = this, n = r.constructor;
      return !r.isFinite() || r.isZero() ? new n(r) : (e2 = n.precision, t = n.rounding, n.precision = e2 + 2 * Math.max(Math.abs(r.e), r.sd()) + 6, n.rounding = 1, ae = false, r = r.times(r).plus(1).sqrt().plus(r), ae = true, n.precision = e2, n.rounding = t, r.ln());
    };
    D.inverseHyperbolicTangent = D.atanh = function() {
      var e2, t, r, n, i = this, a = i.constructor;
      return i.isFinite() ? i.e >= 0 ? new a(i.abs().eq(1) ? i.s / 0 : i.isZero() ? i : NaN) : (e2 = a.precision, t = a.rounding, n = i.sd(), Math.max(n, e2) < 2 * -i.e - 1 ? te(new a(i), e2, t, true) : (a.precision = r = n - i.e, i = Ee(i.plus(1), new a(1).minus(i), r + e2, 1), a.precision = e2 + 4, a.rounding = 1, i = i.ln(), a.precision = e2, a.rounding = t, i.times(0.5))) : new a(NaN);
    };
    D.inverseSine = D.asin = function() {
      var e2, t, r, n, i = this, a = i.constructor;
      return i.isZero() ? new a(i) : (t = i.abs().cmp(1), r = a.precision, n = a.rounding, t !== -1 ? t === 0 ? (e2 = He(a, r + 4, n).times(0.5), e2.s = i.s, e2) : new a(NaN) : (a.precision = r + 6, a.rounding = 1, i = i.div(new a(1).minus(i.times(i)).sqrt().plus(1)).atan(), a.precision = r, a.rounding = n, i.times(2)));
    };
    D.inverseTangent = D.atan = function() {
      var e2, t, r, n, i, a, o, l, f, s = this, c = s.constructor, p = c.precision, g = c.rounding;
      if (s.isFinite()) {
        if (s.isZero())
          return new c(s);
        if (s.abs().eq(1) && p + 4 <= kn)
          return o = He(c, p + 4, g).times(0.25), o.s = s.s, o;
      } else {
        if (!s.s)
          return new c(NaN);
        if (p + 4 <= kn)
          return o = He(c, p + 4, g).times(0.5), o.s = s.s, o;
      }
      for (c.precision = l = p + 10, c.rounding = 1, r = Math.min(28, l / oe + 2 | 0), e2 = r; e2; --e2)
        s = s.div(s.times(s).plus(1).sqrt().plus(1));
      for (ae = false, t = Math.ceil(l / oe), n = 1, f = s.times(s), o = new c(s), i = s; e2 !== -1; )
        if (i = i.times(f), a = o.minus(i.div(n += 2)), i = i.times(f), o = a.plus(i.div(n += 2)), o.d[t] !== void 0)
          for (e2 = t; o.d[e2] === a.d[e2] && e2--; )
            ;
      return r && (o = o.times(2 << r - 1)), ae = true, te(o, c.precision = p, c.rounding = g, true);
    };
    D.isFinite = function() {
      return !!this.d;
    };
    D.isInteger = D.isInt = function() {
      return !!this.d && Me(this.e / oe) > this.d.length - 2;
    };
    D.isNaN = function() {
      return !this.s;
    };
    D.isNegative = D.isNeg = function() {
      return this.s < 0;
    };
    D.isPositive = D.isPos = function() {
      return this.s > 0;
    };
    D.isZero = function() {
      return !!this.d && this.d[0] === 0;
    };
    D.lessThan = D.lt = function(e2) {
      return this.cmp(e2) < 0;
    };
    D.lessThanOrEqualTo = D.lte = function(e2) {
      return this.cmp(e2) < 1;
    };
    D.logarithm = D.log = function(e2) {
      var t, r, n, i, a, o, l, f, s = this, c = s.constructor, p = c.precision, g = c.rounding, v = 5;
      if (e2 == null)
        e2 = new c(10), t = true;
      else {
        if (e2 = new c(e2), r = e2.d, e2.s < 0 || !r || !r[0] || e2.eq(1))
          return new c(NaN);
        t = e2.eq(10);
      }
      if (r = s.d, s.s < 0 || !r || !r[0] || s.eq(1))
        return new c(r && !r[0] ? -1 / 0 : s.s != 1 ? NaN : r ? 0 : 1 / 0);
      if (t)
        if (r.length > 1)
          a = true;
        else {
          for (i = r[0]; i % 10 == 0; )
            i /= 10;
          a = i !== 1;
        }
      if (ae = false, l = p + v, o = bt(s, l), n = t ? gr(c, l + 10) : bt(e2, l), f = Ee(o, n, l, 1), Yt(f.d, i = p, g))
        do
          if (l += 10, o = bt(s, l), n = t ? gr(c, l + 10) : bt(e2, l), f = Ee(o, n, l, 1), !a) {
            +je(f.d).slice(i + 1, i + 15) + 1 == 1e14 && (f = te(f, p + 1, 0));
            break;
          }
        while (Yt(f.d, i += 10, g));
      return ae = true, te(f, p, g);
    };
    D.minus = D.sub = function(e2) {
      var t, r, n, i, a, o, l, f, s, c, p, g, v = this, b = v.constructor;
      if (e2 = new b(e2), !v.d || !e2.d)
        return !v.s || !e2.s ? e2 = new b(NaN) : v.d ? e2.s = -e2.s : e2 = new b(e2.d || v.s !== e2.s ? v : NaN), e2;
      if (v.s != e2.s)
        return e2.s = -e2.s, v.plus(e2);
      if (s = v.d, g = e2.d, l = b.precision, f = b.rounding, !s[0] || !g[0]) {
        if (g[0])
          e2.s = -e2.s;
        else if (s[0])
          e2 = new b(v);
        else
          return new b(f === 3 ? -0 : 0);
        return ae ? te(e2, l, f) : e2;
      }
      if (r = Me(e2.e / oe), c = Me(v.e / oe), s = s.slice(), a = c - r, a) {
        for (p = a < 0, p ? (t = s, a = -a, o = g.length) : (t = g, r = c, o = s.length), n = Math.max(Math.ceil(l / oe), o) + 2, a > n && (a = n, t.length = 1), t.reverse(), n = a; n--; )
          t.push(0);
        t.reverse();
      } else {
        for (n = s.length, o = g.length, p = n < o, p && (o = n), n = 0; n < o; n++)
          if (s[n] != g[n]) {
            p = s[n] < g[n];
            break;
          }
        a = 0;
      }
      for (p && (t = s, s = g, g = t, e2.s = -e2.s), o = s.length, n = g.length - o; n > 0; --n)
        s[o++] = 0;
      for (n = g.length; n > a; ) {
        if (s[--n] < g[n]) {
          for (i = n; i && s[--i] === 0; )
            s[i] = rt - 1;
          --s[i], s[n] += rt;
        }
        s[n] -= g[n];
      }
      for (; s[--o] === 0; )
        s.pop();
      for (; s[0] === 0; s.shift())
        --r;
      return s[0] ? (e2.d = s, e2.e = hr(s, r), ae ? te(e2, l, f) : e2) : new b(f === 3 ? -0 : 0);
    };
    D.modulo = D.mod = function(e2) {
      var t, r = this, n = r.constructor;
      return e2 = new n(e2), !r.d || !e2.s || e2.d && !e2.d[0] ? new n(NaN) : !e2.d || r.d && !r.d[0] ? te(new n(r), n.precision, n.rounding) : (ae = false, n.modulo == 9 ? (t = Ee(r, e2.abs(), 0, 3, 1), t.s *= e2.s) : t = Ee(r, e2, 0, n.modulo, 1), t = t.times(e2), ae = true, r.minus(t));
    };
    D.naturalExponential = D.exp = function() {
      return Lr(this);
    };
    D.naturalLogarithm = D.ln = function() {
      return bt(this);
    };
    D.negated = D.neg = function() {
      var e2 = new this.constructor(this);
      return e2.s = -e2.s, te(e2);
    };
    D.plus = D.add = function(e2) {
      var t, r, n, i, a, o, l, f, s, c, p = this, g = p.constructor;
      if (e2 = new g(e2), !p.d || !e2.d)
        return !p.s || !e2.s ? e2 = new g(NaN) : p.d || (e2 = new g(e2.d || p.s === e2.s ? p : NaN)), e2;
      if (p.s != e2.s)
        return e2.s = -e2.s, p.minus(e2);
      if (s = p.d, c = e2.d, l = g.precision, f = g.rounding, !s[0] || !c[0])
        return c[0] || (e2 = new g(p)), ae ? te(e2, l, f) : e2;
      if (a = Me(p.e / oe), n = Me(e2.e / oe), s = s.slice(), i = a - n, i) {
        for (i < 0 ? (r = s, i = -i, o = c.length) : (r = c, n = a, o = s.length), a = Math.ceil(l / oe), o = a > o ? a + 1 : o + 1, i > o && (i = o, r.length = 1), r.reverse(); i--; )
          r.push(0);
        r.reverse();
      }
      for (o = s.length, i = c.length, o - i < 0 && (i = o, r = c, c = s, s = r), t = 0; i; )
        t = (s[--i] = s[i] + c[i] + t) / rt | 0, s[i] %= rt;
      for (t && (s.unshift(t), ++n), o = s.length; s[--o] == 0; )
        s.pop();
      return e2.d = s, e2.e = hr(s, n), ae ? te(e2, l, f) : e2;
    };
    D.precision = D.sd = function(e2) {
      var t, r = this;
      if (e2 !== void 0 && e2 !== !!e2 && e2 !== 1 && e2 !== 0)
        throw Error(St + e2);
      return r.d ? (t = In(r.d), e2 && r.e + 1 > t && (t = r.e + 1)) : t = NaN, t;
    };
    D.round = function() {
      var e2 = this, t = e2.constructor;
      return te(new t(e2), e2.e + 1, t.rounding);
    };
    D.sine = D.sin = function() {
      var e2, t, r = this, n = r.constructor;
      return r.isFinite() ? r.isZero() ? new n(r) : (e2 = n.precision, t = n.rounding, n.precision = e2 + Math.max(r.e, r.sd()) + oe, n.rounding = 1, r = So(n, Bn(n, r)), n.precision = e2, n.rounding = t, te(mt > 2 ? r.neg() : r, e2, t, true)) : new n(NaN);
    };
    D.squareRoot = D.sqrt = function() {
      var e2, t, r, n, i, a, o = this, l = o.d, f = o.e, s = o.s, c = o.constructor;
      if (s !== 1 || !l || !l[0])
        return new c(!s || s < 0 && (!l || l[0]) ? NaN : l ? o : 1 / 0);
      for (ae = false, s = Math.sqrt(+o), s == 0 || s == 1 / 0 ? (t = je(l), (t.length + f) % 2 == 0 && (t += "0"), s = Math.sqrt(t), f = Me((f + 1) / 2) - (f < 0 || f % 2), s == 1 / 0 ? t = "5e" + f : (t = s.toExponential(), t = t.slice(0, t.indexOf("e") + 1) + f), n = new c(t)) : n = new c(s.toString()), r = (f = c.precision) + 3; ; )
        if (a = n, n = a.plus(Ee(o, a, r + 2, 1)).times(0.5), je(a.d).slice(0, r) === (t = je(n.d)).slice(0, r))
          if (t = t.slice(r - 3, r + 1), t == "9999" || !i && t == "4999") {
            if (!i && (te(a, f + 1, 0), a.times(a).eq(o))) {
              n = a;
              break;
            }
            r += 4, i = 1;
          } else {
            (!+t || !+t.slice(1) && t.charAt(0) == "5") && (te(n, f + 1, 1), e2 = !n.times(n).eq(o));
            break;
          }
      return ae = true, te(n, f, c.rounding, e2);
    };
    D.tangent = D.tan = function() {
      var e2, t, r = this, n = r.constructor;
      return r.isFinite() ? r.isZero() ? new n(r) : (e2 = n.precision, t = n.rounding, n.precision = e2 + 10, n.rounding = 1, r = r.sin(), r.s = 1, r = Ee(r, new n(1).minus(r.times(r)).sqrt(), e2 + 10, 0), n.precision = e2, n.rounding = t, te(mt == 2 || mt == 4 ? r.neg() : r, e2, t, true)) : new n(NaN);
    };
    D.times = D.mul = function(e2) {
      var t, r, n, i, a, o, l, f, s, c = this, p = c.constructor, g = c.d, v = (e2 = new p(e2)).d;
      if (e2.s *= c.s, !g || !g[0] || !v || !v[0])
        return new p(!e2.s || g && !g[0] && !v || v && !v[0] && !g ? NaN : !g || !v ? e2.s / 0 : e2.s * 0);
      for (r = Me(c.e / oe) + Me(e2.e / oe), f = g.length, s = v.length, f < s && (a = g, g = v, v = a, o = f, f = s, s = o), a = [], o = f + s, n = o; n--; )
        a.push(0);
      for (n = s; --n >= 0; ) {
        for (t = 0, i = f + n; i > n; )
          l = a[i] + v[n] * g[i - n - 1] + t, a[i--] = l % rt | 0, t = l / rt | 0;
        a[i] = (a[i] + t) % rt | 0;
      }
      for (; !a[--o]; )
        a.pop();
      return t ? ++r : a.shift(), e2.d = a, e2.e = hr(a, r), ae ? te(e2, p.precision, p.rounding) : e2;
    };
    D.toBinary = function(e2, t) {
      return Dr(this, 2, e2, t);
    };
    D.toDecimalPlaces = D.toDP = function(e2, t) {
      var r = this, n = r.constructor;
      return r = new n(r), e2 === void 0 ? r : (Ce(e2, 0, Tt), t === void 0 ? t = n.rounding : Ce(t, 0, 8), te(r, e2 + r.e + 1, t));
    };
    D.toExponential = function(e2, t) {
      var r, n = this, i = n.constructor;
      return e2 === void 0 ? r = nt(n, true) : (Ce(e2, 0, Tt), t === void 0 ? t = i.rounding : Ce(t, 0, 8), n = te(new i(n), e2 + 1, t), r = nt(n, true, e2 + 1)), n.isNeg() && !n.isZero() ? "-" + r : r;
    };
    D.toFixed = function(e2, t) {
      var r, n, i = this, a = i.constructor;
      return e2 === void 0 ? r = nt(i) : (Ce(e2, 0, Tt), t === void 0 ? t = a.rounding : Ce(t, 0, 8), n = te(new a(i), e2 + i.e + 1, t), r = nt(n, false, e2 + n.e + 1)), i.isNeg() && !i.isZero() ? "-" + r : r;
    };
    D.toFraction = function(e2) {
      var t, r, n, i, a, o, l, f, s, c, p, g, v = this, b = v.d, w = v.constructor;
      if (!b)
        return new w(v);
      if (s = r = new w(1), n = f = new w(0), t = new w(n), a = t.e = In(b) - v.e - 1, o = a % oe, t.d[0] = Pe(10, o < 0 ? oe + o : o), e2 == null)
        e2 = a > 0 ? t : s;
      else {
        if (l = new w(e2), !l.isInt() || l.lt(s))
          throw Error(St + l);
        e2 = l.gt(t) ? a > 0 ? t : s : l;
      }
      for (ae = false, l = new w(je(b)), c = w.precision, w.precision = a = b.length * oe * 2; p = Ee(l, t, 0, 1, 1), i = r.plus(p.times(n)), i.cmp(e2) != 1; )
        r = n, n = i, i = s, s = f.plus(p.times(i)), f = i, i = t, t = l.minus(p.times(i)), l = i;
      return i = Ee(e2.minus(r), n, 0, 1, 1), f = f.plus(i.times(s)), r = r.plus(i.times(n)), f.s = s.s = v.s, g = Ee(s, n, a, 1).minus(v).abs().cmp(Ee(f, r, a, 1).minus(v).abs()) < 1 ? [s, n] : [f, r], w.precision = c, ae = true, g;
    };
    D.toHexadecimal = D.toHex = function(e2, t) {
      return Dr(this, 16, e2, t);
    };
    D.toNearest = function(e2, t) {
      var r = this, n = r.constructor;
      if (r = new n(r), e2 == null) {
        if (!r.d)
          return r;
        e2 = new n(1), t = n.rounding;
      } else {
        if (e2 = new n(e2), t === void 0 ? t = n.rounding : Ce(t, 0, 8), !r.d)
          return e2.s ? r : e2;
        if (!e2.d)
          return e2.s && (e2.s = r.s), e2;
      }
      return e2.d[0] ? (ae = false, r = Ee(r, e2, 0, t, 1).times(e2), ae = true, te(r)) : (e2.s = r.s, r = e2), r;
    };
    D.toNumber = function() {
      return +this;
    };
    D.toOctal = function(e2, t) {
      return Dr(this, 8, e2, t);
    };
    D.toPower = D.pow = function(e2) {
      var t, r, n, i, a, o, l = this, f = l.constructor, s = +(e2 = new f(e2));
      if (!l.d || !e2.d || !l.d[0] || !e2.d[0])
        return new f(Pe(+l, s));
      if (l = new f(l), l.eq(1))
        return l;
      if (n = f.precision, a = f.rounding, e2.eq(1))
        return te(l, n, a);
      if (t = Me(e2.e / oe), t >= e2.d.length - 1 && (r = s < 0 ? -s : s) <= qu)
        return i = $n(f, l, r, n), e2.s < 0 ? new f(1).div(i) : te(i, n, a);
      if (o = l.s, o < 0) {
        if (t < e2.d.length - 1)
          return new f(NaN);
        if ((e2.d[t] & 1) == 0 && (o = 1), l.e == 0 && l.d[0] == 1 && l.d.length == 1)
          return l.s = o, l;
      }
      return r = Pe(+l, s), t = r == 0 || !isFinite(r) ? Me(s * (Math.log("0." + je(l.d)) / Math.LN10 + l.e + 1)) : new f(r + "").e, t > f.maxE + 1 || t < f.minE - 1 ? new f(t > 0 ? o / 0 : 0) : (ae = false, f.rounding = l.s = 1, r = Math.min(12, (t + "").length), i = Lr(e2.times(bt(l, n + r)), n), i.d && (i = te(i, n + 5, 1), Yt(i.d, n, a) && (t = n + 10, i = te(Lr(e2.times(bt(l, t + r)), t), t + 5, 1), +je(i.d).slice(n + 1, n + 15) + 1 == 1e14 && (i = te(i, n + 1, 0)))), i.s = o, ae = true, f.rounding = a, te(i, n, a));
    };
    D.toPrecision = function(e2, t) {
      var r, n = this, i = n.constructor;
      return e2 === void 0 ? r = nt(n, n.e <= i.toExpNeg || n.e >= i.toExpPos) : (Ce(e2, 1, Tt), t === void 0 ? t = i.rounding : Ce(t, 0, 8), n = te(new i(n), e2, t), r = nt(n, e2 <= n.e || n.e <= i.toExpNeg, e2)), n.isNeg() && !n.isZero() ? "-" + r : r;
    };
    D.toSignificantDigits = D.toSD = function(e2, t) {
      var r = this, n = r.constructor;
      return e2 === void 0 ? (e2 = n.precision, t = n.rounding) : (Ce(e2, 1, Tt), t === void 0 ? t = n.rounding : Ce(t, 0, 8)), te(new n(r), e2, t);
    };
    D.toString = function() {
      var e2 = this, t = e2.constructor, r = nt(e2, e2.e <= t.toExpNeg || e2.e >= t.toExpPos);
      return e2.isNeg() && !e2.isZero() ? "-" + r : r;
    };
    D.truncated = D.trunc = function() {
      return te(new this.constructor(this), this.e + 1, 1);
    };
    D.valueOf = D.toJSON = function() {
      var e2 = this, t = e2.constructor, r = nt(e2, e2.e <= t.toExpNeg || e2.e >= t.toExpPos);
      return e2.isNeg() ? "-" + r : r;
    };
    function je(e2) {
      var t, r, n, i = e2.length - 1, a = "", o = e2[0];
      if (i > 0) {
        for (a += o, t = 1; t < i; t++)
          n = e2[t] + "", r = oe - n.length, r && (a += vt(r)), a += n;
        o = e2[t], n = o + "", r = oe - n.length, r && (a += vt(r));
      } else if (o === 0)
        return "0";
      for (; o % 10 == 0; )
        o /= 10;
      return a + o;
    }
    y(je, "se");
    d(je, "digitsToString");
    function Ce(e2, t, r) {
      if (e2 !== ~~e2 || e2 < t || e2 > r)
        throw Error(St + e2);
    }
    y(Ce, "ve");
    d(Ce, "checkInt32");
    function Yt(e2, t, r, n) {
      var i, a, o, l;
      for (a = e2[0]; a >= 10; a /= 10)
        --t;
      return --t < 0 ? (t += oe, i = 0) : (i = Math.ceil((t + 1) / oe), t %= oe), a = Pe(10, oe - t), l = e2[i] % a | 0, n == null ? t < 3 ? (t == 0 ? l = l / 100 | 0 : t == 1 && (l = l / 10 | 0), o = r < 4 && l == 99999 || r > 3 && l == 49999 || l == 5e4 || l == 0) : o = (r < 4 && l + 1 == a || r > 3 && l + 1 == a / 2) && (e2[i + 1] / a / 100 | 0) == Pe(10, t - 2) - 1 || (l == a / 2 || l == 0) && (e2[i + 1] / a / 100 | 0) == 0 : t < 4 ? (t == 0 ? l = l / 1e3 | 0 : t == 1 ? l = l / 100 | 0 : t == 2 && (l = l / 10 | 0), o = (n || r < 4) && l == 9999 || !n && r > 3 && l == 4999) : o = ((n || r < 4) && l + 1 == a || !n && r > 3 && l + 1 == a / 2) && (e2[i + 1] / a / 1e3 | 0) == Pe(10, t - 3) - 1, o;
    }
    y(Yt, "cr");
    d(Yt, "checkRoundingDigits");
    function dr(e2, t, r) {
      for (var n, i = [0], a, o = 0, l = e2.length; o < l; ) {
        for (a = i.length; a--; )
          i[a] *= t;
        for (i[0] += jn.indexOf(e2.charAt(o++)), n = 0; n < i.length; n++)
          i[n] > r - 1 && (i[n + 1] === void 0 && (i[n + 1] = 0), i[n + 1] += i[n] / r | 0, i[n] %= r);
      }
      return i.reverse();
    }
    y(dr, "on");
    d(dr, "convertBase");
    function Oo(e2, t) {
      var r, n, i;
      if (t.isZero())
        return t;
      n = t.d.length, n < 32 ? (r = Math.ceil(n / 3), i = (1 / yr(4, r)).toString()) : (r = 16, i = "2.3283064365386962890625e-10"), e2.precision += r, t = $t(e2, 1, t.times(i), new e2(1));
      for (var a = r; a--; ) {
        var o = t.times(t);
        t = o.times(o).minus(o).times(8).plus(1);
      }
      return e2.precision -= r, t;
    }
    y(Oo, "Wc");
    d(Oo, "cosine");
    var Ee = function() {
      function e2(n, i, a) {
        var o, l = 0, f = n.length;
        for (n = n.slice(); f--; )
          o = n[f] * i + l, n[f] = o % a | 0, l = o / a | 0;
        return l && n.unshift(l), n;
      }
      y(e2, "e"), d(e2, "multiplyInteger");
      function t(n, i, a, o) {
        var l, f;
        if (a != o)
          f = a > o ? 1 : -1;
        else
          for (l = f = 0; l < a; l++)
            if (n[l] != i[l]) {
              f = n[l] > i[l] ? 1 : -1;
              break;
            }
        return f;
      }
      y(t, "t"), d(t, "compare");
      function r(n, i, a, o) {
        for (var l = 0; a--; )
          n[a] -= l, l = n[a] < i[a] ? 1 : 0, n[a] = l * o + n[a] - i[a];
        for (; !n[0] && n.length > 1; )
          n.shift();
      }
      return y(r, "r"), d(r, "subtract"), function(n, i, a, o, l, f) {
        var s, c, p, g, v, b, w, E, x, S, A, F, q, R, C, B, W, G, pe, H, de = n.constructor, be = n.s == i.s ? 1 : -1, se = n.d, le = i.d;
        if (!se || !se[0] || !le || !le[0])
          return new de(!n.s || !i.s || (se ? le && se[0] == le[0] : !le) ? NaN : se && se[0] == 0 || !le ? be * 0 : be / 0);
        for (f ? (v = 1, c = n.e - i.e) : (f = rt, v = oe, c = Me(n.e / v) - Me(i.e / v)), pe = le.length, W = se.length, x = new de(be), S = x.d = [], p = 0; le[p] == (se[p] || 0); p++)
          ;
        if (le[p] > (se[p] || 0) && c--, a == null ? (R = a = de.precision, o = de.rounding) : l ? R = a + (n.e - i.e) + 1 : R = a, R < 0)
          S.push(1), b = true;
        else {
          if (R = R / v + 2 | 0, p = 0, pe == 1) {
            for (g = 0, le = le[0], R++; (p < W || g) && R--; p++)
              C = g * f + (se[p] || 0), S[p] = C / le | 0, g = C % le | 0;
            b = g || p < W;
          } else {
            for (g = f / (le[0] + 1) | 0, g > 1 && (le = e2(le, g, f), se = e2(se, g, f), pe = le.length, W = se.length), B = pe, A = se.slice(0, pe), F = A.length; F < pe; )
              A[F++] = 0;
            H = le.slice(), H.unshift(0), G = le[0], le[1] >= f / 2 && ++G;
            do
              g = 0, s = t(le, A, pe, F), s < 0 ? (q = A[0], pe != F && (q = q * f + (A[1] || 0)), g = q / G | 0, g > 1 ? (g >= f && (g = f - 1), w = e2(le, g, f), E = w.length, F = A.length, s = t(w, A, E, F), s == 1 && (g--, r(w, pe < E ? H : le, E, f))) : (g == 0 && (s = g = 1), w = le.slice()), E = w.length, E < F && w.unshift(0), r(A, w, F, f), s == -1 && (F = A.length, s = t(le, A, pe, F), s < 1 && (g++, r(A, pe < F ? H : le, F, f))), F = A.length) : s === 0 && (g++, A = [0]), S[p++] = g, s && A[0] ? A[F++] = se[B] || 0 : (A = [se[B]], F = 1);
            while ((B++ < W || A[0] !== void 0) && R--);
            b = A[0] !== void 0;
          }
          S[0] || S.shift();
        }
        if (v == 1)
          x.e = c, bo = b;
        else {
          for (p = 1, g = S[0]; g >= 10; g /= 10)
            p++;
          x.e = p + c * v - 1, te(x, l ? a + x.e + 1 : a, o, b);
        }
        return x;
      };
    }();
    function te(e2, t, r, n) {
      var i, a, o, l, f, s, c, p, g, v = e2.constructor;
      e:
        if (t != null) {
          if (p = e2.d, !p)
            return e2;
          for (i = 1, l = p[0]; l >= 10; l /= 10)
            i++;
          if (a = t - i, a < 0)
            a += oe, o = t, c = p[g = 0], f = c / Pe(10, i - o - 1) % 10 | 0;
          else if (g = Math.ceil((a + 1) / oe), l = p.length, g >= l)
            if (n) {
              for (; l++ <= g; )
                p.push(0);
              c = f = 0, i = 1, a %= oe, o = a - oe + 1;
            } else
              break e;
          else {
            for (c = l = p[g], i = 1; l >= 10; l /= 10)
              i++;
            a %= oe, o = a - oe + i, f = o < 0 ? 0 : c / Pe(10, i - o - 1) % 10 | 0;
          }
          if (n = n || t < 0 || p[g + 1] !== void 0 || (o < 0 ? c : c % Pe(10, i - o - 1)), s = r < 4 ? (f || n) && (r == 0 || r == (e2.s < 0 ? 3 : 2)) : f > 5 || f == 5 && (r == 4 || n || r == 6 && (a > 0 ? o > 0 ? c / Pe(10, i - o) : 0 : p[g - 1]) % 10 & 1 || r == (e2.s < 0 ? 8 : 7)), t < 1 || !p[0])
            return p.length = 0, s ? (t -= e2.e + 1, p[0] = Pe(10, (oe - t % oe) % oe), e2.e = -t || 0) : p[0] = e2.e = 0, e2;
          if (a == 0 ? (p.length = g, l = 1, g--) : (p.length = g + 1, l = Pe(10, oe - a), p[g] = o > 0 ? (c / Pe(10, i - o) % Pe(10, o) | 0) * l : 0), s)
            for (; ; )
              if (g == 0) {
                for (a = 1, o = p[0]; o >= 10; o /= 10)
                  a++;
                for (o = p[0] += l, l = 1; o >= 10; o /= 10)
                  l++;
                a != l && (e2.e++, p[0] == rt && (p[0] = 1));
                break;
              } else {
                if (p[g] += l, p[g] != rt)
                  break;
                p[g--] = 0, l = 1;
              }
          for (a = p.length; p[--a] === 0; )
            p.pop();
        }
      return ae && (e2.e > v.maxE ? (e2.d = null, e2.e = NaN) : e2.e < v.minE && (e2.e = 0, e2.d = [0])), e2;
    }
    y(te, "D");
    d(te, "finalise");
    function nt(e2, t, r) {
      if (!e2.isFinite())
        return Rn(e2);
      var n, i = e2.e, a = je(e2.d), o = a.length;
      return t ? (r && (n = r - o) > 0 ? a = a.charAt(0) + "." + a.slice(1) + vt(n) : o > 1 && (a = a.charAt(0) + "." + a.slice(1)), a = a + (e2.e < 0 ? "e" : "e+") + e2.e) : i < 0 ? (a = "0." + vt(-i - 1) + a, r && (n = r - o) > 0 && (a += vt(n))) : i >= o ? (a += vt(i + 1 - o), r && (n = r - i - 1) > 0 && (a = a + "." + vt(n))) : ((n = i + 1) < o && (a = a.slice(0, n) + "." + a.slice(n)), r && (n = r - o) > 0 && (i + 1 === o && (a += "."), a += vt(n))), a;
    }
    y(nt, "Be");
    d(nt, "finiteToString");
    function hr(e2, t) {
      var r = e2[0];
      for (t *= oe; r >= 10; r /= 10)
        t++;
      return t;
    }
    y(hr, "sn");
    d(hr, "getBase10Exponent");
    function gr(e2, t, r) {
      if (t > Lu)
        throw ae = true, r && (e2.precision = r), Error(wo);
      return te(new e2(Br), t, 1, true);
    }
    y(gr, "an");
    d(gr, "getLn10");
    function He(e2, t, r) {
      if (t > kn)
        throw Error(wo);
      return te(new e2(Cr), t, r, true);
    }
    y(He, "Ie");
    d(He, "getPi");
    function In(e2) {
      var t = e2.length - 1, r = t * oe + 1;
      if (t = e2[t], t) {
        for (; t % 10 == 0; t /= 10)
          r--;
        for (t = e2[0]; t >= 10; t /= 10)
          r++;
      }
      return r;
    }
    y(In, "Vs");
    d(In, "getPrecision");
    function vt(e2) {
      for (var t = ""; e2--; )
        t += "0";
      return t;
    }
    y(vt, "rt");
    d(vt, "getZeroString");
    function $n(e2, t, r, n) {
      var i, a = new e2(1), o = Math.ceil(n / oe + 4);
      for (ae = false; ; ) {
        if (r % 2 && (a = a.times(t), Cn(a.d, o) && (i = true)), r = Me(r / 2), r === 0) {
          r = a.d.length - 1, i && a.d[r] === 0 && ++a.d[r];
          break;
        }
        t = t.times(t), Cn(t.d, o);
      }
      return ae = true, a;
    }
    y($n, "Gs");
    d($n, "intPow");
    function Mn(e2) {
      return e2.d[e2.d.length - 1] & 1;
    }
    y(Mn, "Js");
    d(Mn, "isOdd");
    function Fn(e2, t, r) {
      for (var n, i = new e2(t[0]), a = 0; ++a < t.length; )
        if (n = new e2(t[a]), n.s)
          i[r](n) && (i = n);
        else {
          i = n;
          break;
        }
      return i;
    }
    y(Fn, "zs");
    d(Fn, "maxOrMin");
    function Lr(e2, t) {
      var r, n, i, a, o, l, f, s = 0, c = 0, p = 0, g = e2.constructor, v = g.rounding, b = g.precision;
      if (!e2.d || !e2.d[0] || e2.e > 17)
        return new g(e2.d ? e2.d[0] ? e2.s < 0 ? 0 : 1 / 0 : 1 : e2.s ? e2.s < 0 ? 0 : e2 : 0 / 0);
      for (t == null ? (ae = false, f = b) : f = t, l = new g(0.03125); e2.e > -2; )
        e2 = e2.times(l), p += 5;
      for (n = Math.log(Pe(2, p)) / Math.LN10 * 2 + 5 | 0, f += n, r = a = o = new g(1), g.precision = f; ; ) {
        if (a = te(a.times(e2), f, 1), r = r.times(++c), l = o.plus(Ee(a, r, f, 1)), je(l.d).slice(0, f) === je(o.d).slice(0, f)) {
          for (i = p; i--; )
            o = te(o.times(o), f, 1);
          if (t == null)
            if (s < 3 && Yt(o.d, f - n, v, s))
              g.precision = f += 10, r = a = l = new g(1), c = 0, s++;
            else
              return te(o, g.precision = b, v, ae = true);
          else
            return g.precision = b, o;
        }
        o = l;
      }
    }
    y(Lr, "go");
    d(Lr, "naturalExponential");
    function bt(e2, t) {
      var r, n, i, a, o, l, f, s, c, p, g, v = 1, b = 10, w = e2, E = w.d, x = w.constructor, S = x.rounding, A = x.precision;
      if (w.s < 0 || !E || !E[0] || !w.e && E[0] == 1 && E.length == 1)
        return new x(E && !E[0] ? -1 / 0 : w.s != 1 ? NaN : E ? 0 : w);
      if (t == null ? (ae = false, c = A) : c = t, x.precision = c += b, r = je(E), n = r.charAt(0), Math.abs(a = w.e) < 15e14) {
        for (; n < 7 && n != 1 || n == 1 && r.charAt(1) > 3; )
          w = w.times(e2), r = je(w.d), n = r.charAt(0), v++;
        a = w.e, n > 1 ? (w = new x("0." + r), a++) : w = new x(n + "." + r.slice(1));
      } else
        return s = gr(x, c + 2, A).times(a + ""), w = bt(new x(n + "." + r.slice(1)), c - b).plus(s), x.precision = A, t == null ? te(w, A, S, ae = true) : w;
      for (p = w, f = o = w = Ee(w.minus(1), w.plus(1), c, 1), g = te(w.times(w), c, 1), i = 3; ; ) {
        if (o = te(o.times(g), c, 1), s = f.plus(Ee(o, new x(i), c, 1)), je(s.d).slice(0, c) === je(f.d).slice(0, c))
          if (f = f.times(2), a !== 0 && (f = f.plus(gr(x, c + 2, A).times(a + ""))), f = Ee(f, new x(v), c, 1), t == null)
            if (Yt(f.d, c - b, S, l))
              x.precision = c += b, s = o = w = Ee(p.minus(1), p.plus(1), c, 1), g = te(w.times(w), c, 1), i = l = 1;
            else
              return te(f, x.precision = A, S, ae = true);
          else
            return x.precision = A, f;
        f = s, i += 2;
      }
    }
    y(bt, "nt");
    d(bt, "naturalLogarithm");
    function Rn(e2) {
      return String(e2.s * e2.s / 0);
    }
    y(Rn, "Ws");
    d(Rn, "nonFiniteToString");
    function Ur(e2, t) {
      var r, n, i;
      for ((r = t.indexOf(".")) > -1 && (t = t.replace(".", "")), (n = t.search(/e/i)) > 0 ? (r < 0 && (r = n), r += +t.slice(n + 1), t = t.substring(0, n)) : r < 0 && (r = t.length), n = 0; t.charCodeAt(n) === 48; n++)
        ;
      for (i = t.length; t.charCodeAt(i - 1) === 48; --i)
        ;
      if (t = t.slice(n, i), t) {
        if (i -= n, e2.e = r = r - n - 1, e2.d = [], n = (r + 1) % oe, r < 0 && (n += oe), n < i) {
          for (n && e2.d.push(+t.slice(0, n)), i -= oe; n < i; )
            e2.d.push(+t.slice(n, n += oe));
          t = t.slice(n), n = oe - t.length;
        } else
          n -= i;
        for (; n--; )
          t += "0";
        e2.d.push(+t), ae && (e2.e > e2.constructor.maxE ? (e2.d = null, e2.e = NaN) : e2.e < e2.constructor.minE && (e2.e = 0, e2.d = [0]));
      } else
        e2.e = 0, e2.d = [0];
      return e2;
    }
    y(Ur, "mo");
    d(Ur, "parseDecimal");
    function To(e2, t) {
      var r, n, i, a, o, l, f, s, c;
      if (t.indexOf("_") > -1) {
        if (t = t.replace(/(\d)_(?=\d)/g, "$1"), Ao.test(t))
          return Ur(e2, t);
      } else if (t === "Infinity" || t === "NaN")
        return +t || (e2.s = NaN), e2.e = NaN, e2.d = null, e2;
      if (Bu.test(t))
        r = 16, t = t.toLowerCase();
      else if (Ru.test(t))
        r = 2;
      else if (Cu.test(t))
        r = 8;
      else
        throw Error(St + t);
      for (a = t.search(/p/i), a > 0 ? (f = +t.slice(a + 1), t = t.substring(2, a)) : t = t.slice(2), a = t.indexOf("."), o = a >= 0, n = e2.constructor, o && (t = t.replace(".", ""), l = t.length, a = l - a, i = $n(n, new n(r), a, a * 2)), s = dr(t, r, rt), c = s.length - 1, a = c; s[a] === 0; --a)
        s.pop();
      return a < 0 ? new n(e2.s * 0) : (e2.e = hr(s, c), e2.d = s, ae = false, o && (e2 = Ee(e2, i, l * 4)), f && (e2 = e2.times(Math.abs(f) < 54 ? Pe(2, f) : mr.pow(2, f))), ae = true, e2);
    }
    y(To, "Hc");
    d(To, "parseOther");
    function So(e2, t) {
      var r, n = t.d.length;
      if (n < 3)
        return t.isZero() ? t : $t(e2, 2, t, t);
      r = 1.4 * Math.sqrt(n), r = r > 16 ? 16 : r | 0, t = t.times(1 / yr(5, r)), t = $t(e2, 2, t, t);
      for (var i, a = new e2(5), o = new e2(16), l = new e2(20); r--; )
        i = t.times(t), t = t.times(a.plus(i.times(o.times(i).minus(l))));
      return t;
    }
    y(So, "Yc");
    d(So, "sine");
    function $t(e2, t, r, n, i) {
      var a, o, l, f, s = 1, c = e2.precision, p = Math.ceil(c / oe);
      for (ae = false, f = r.times(r), l = new e2(n); ; ) {
        if (o = Ee(l.times(f), new e2(t++ * t++), c, 1), l = i ? n.plus(o) : n.minus(o), n = Ee(o.times(f), new e2(t++ * t++), c, 1), o = l.plus(n), o.d[p] !== void 0) {
          for (a = p; o.d[a] === l.d[a] && a--; )
            ;
          if (a == -1)
            break;
        }
        a = l, l = n, n = o, o = a, s++;
      }
      return ae = true, o.d.length = p + 1, o;
    }
    y($t, "Ct");
    d($t, "taylorSeries");
    function yr(e2, t) {
      for (var r = e2; --t; )
        r *= e2;
      return r;
    }
    y(yr, "un");
    d(yr, "tinyPow");
    function Bn(e2, t) {
      var r, n = t.s < 0, i = He(e2, e2.precision, 1), a = i.times(0.5);
      if (t = t.abs(), t.lte(a))
        return mt = n ? 4 : 1, t;
      if (r = t.divToInt(i), r.isZero())
        mt = n ? 3 : 2;
      else {
        if (t = t.minus(r.times(i)), t.lte(a))
          return mt = Mn(r) ? n ? 2 : 3 : n ? 4 : 1, t;
        mt = Mn(r) ? n ? 1 : 4 : n ? 3 : 2;
      }
      return t.minus(i).abs();
    }
    y(Bn, "Hs");
    d(Bn, "toLessThanHalfPi");
    function Dr(e2, t, r, n) {
      var i, a, o, l, f, s, c, p, g, v = e2.constructor, b = r !== void 0;
      if (b ? (Ce(r, 1, Tt), n === void 0 ? n = v.rounding : Ce(n, 0, 8)) : (r = v.precision, n = v.rounding), !e2.isFinite())
        c = Rn(e2);
      else {
        for (c = nt(e2), o = c.indexOf("."), b ? (i = 2, t == 16 ? r = r * 4 - 3 : t == 8 && (r = r * 3 - 2)) : i = t, o >= 0 && (c = c.replace(".", ""), g = new v(1), g.e = c.length - o, g.d = dr(nt(g), 10, i), g.e = g.d.length), p = dr(c, 10, i), a = f = p.length; p[--f] == 0; )
          p.pop();
        if (!p[0])
          c = b ? "0p+0" : "0";
        else {
          if (o < 0 ? a-- : (e2 = new v(e2), e2.d = p, e2.e = a, e2 = Ee(e2, g, r, n, 0, i), p = e2.d, a = e2.e, s = bo), o = p[r], l = i / 2, s = s || p[r + 1] !== void 0, s = n < 4 ? (o !== void 0 || s) && (n === 0 || n === (e2.s < 0 ? 3 : 2)) : o > l || o === l && (n === 4 || s || n === 6 && p[r - 1] & 1 || n === (e2.s < 0 ? 8 : 7)), p.length = r, s)
            for (; ++p[--r] > i - 1; )
              p[r] = 0, r || (++a, p.unshift(1));
          for (f = p.length; !p[f - 1]; --f)
            ;
          for (o = 0, c = ""; o < f; o++)
            c += jn.charAt(p[o]);
          if (b) {
            if (f > 1)
              if (t == 16 || t == 8) {
                for (o = t == 16 ? 4 : 3, --f; f % o; f++)
                  c += "0";
                for (p = dr(c, i, t), f = p.length; !p[f - 1]; --f)
                  ;
                for (o = 1, c = "1."; o < f; o++)
                  c += jn.charAt(p[o]);
              } else
                c = c.charAt(0) + "." + c.slice(1);
            c = c + (a < 0 ? "p" : "p+") + a;
          } else if (a < 0) {
            for (; ++a; )
              c = "0" + c;
            c = "0." + c;
          } else if (++a > f)
            for (a -= f; a--; )
              c += "0";
          else
            a < f && (c = c.slice(0, a) + "." + c.slice(a));
        }
        c = (t == 16 ? "0x" : t == 2 ? "0b" : t == 8 ? "0o" : "") + c;
      }
      return e2.s < 0 ? "-" + c : c;
    }
    y(Dr, "ho");
    d(Dr, "toStringBinary");
    function Cn(e2, t) {
      if (e2.length > t)
        return e2.length = t, true;
    }
    y(Cn, "Ys");
    d(Cn, "truncate");
    function xo(e2) {
      return new this(e2).abs();
    }
    y(xo, "Qc");
    d(xo, "abs");
    function Po(e2) {
      return new this(e2).acos();
    }
    y(Po, "Kc");
    d(Po, "acos");
    function jo(e2) {
      return new this(e2).acosh();
    }
    y(jo, "Zc");
    d(jo, "acosh");
    function No(e2, t) {
      return new this(e2).plus(t);
    }
    y(No, "Xc");
    d(No, "add");
    function ko(e2) {
      return new this(e2).asin();
    }
    y(ko, "ef");
    d(ko, "asin");
    function Io(e2) {
      return new this(e2).asinh();
    }
    y(Io, "tf");
    d(Io, "asinh");
    function $o(e2) {
      return new this(e2).atan();
    }
    y($o, "rf");
    d($o, "atan");
    function Mo(e2) {
      return new this(e2).atanh();
    }
    y(Mo, "nf");
    d(Mo, "atanh");
    function Fo(e2, t) {
      e2 = new this(e2), t = new this(t);
      var r, n = this.precision, i = this.rounding, a = n + 4;
      return !e2.s || !t.s ? r = new this(NaN) : !e2.d && !t.d ? (r = He(this, a, 1).times(t.s > 0 ? 0.25 : 0.75), r.s = e2.s) : !t.d || e2.isZero() ? (r = t.s < 0 ? He(this, n, i) : new this(0), r.s = e2.s) : !e2.d || t.isZero() ? (r = He(this, a, 1).times(0.5), r.s = e2.s) : t.s < 0 ? (this.precision = a, this.rounding = 1, r = this.atan(Ee(e2, t, a, 1)), t = He(this, a, 1), this.precision = n, this.rounding = i, r = e2.s < 0 ? r.minus(t) : r.plus(t)) : r = this.atan(Ee(e2, t, a, 1)), r;
    }
    y(Fo, "of");
    d(Fo, "atan2");
    function Ro(e2) {
      return new this(e2).cbrt();
    }
    y(Ro, "sf");
    d(Ro, "cbrt");
    function Bo(e2) {
      return te(e2 = new this(e2), e2.e + 1, 2);
    }
    y(Bo, "af");
    d(Bo, "ceil");
    function Co(e2, t, r) {
      return new this(e2).clamp(t, r);
    }
    y(Co, "uf");
    d(Co, "clamp");
    function qo(e2) {
      if (!e2 || typeof e2 != "object")
        throw Error(qr + "Object expected");
      var t, r, n, i = e2.defaults === true, a = ["precision", 1, Tt, "rounding", 0, 8, "toExpNeg", -zt, 0, "toExpPos", 0, zt, "maxE", 0, zt, "minE", -zt, 0, "modulo", 0, 9];
      for (t = 0; t < a.length; t += 3)
        if (r = a[t], i && (this[r] = Nn[r]), (n = e2[r]) !== void 0)
          if (Me(n) === n && n >= a[t + 1] && n <= a[t + 2])
            this[r] = n;
          else
            throw Error(St + r + ": " + n);
      if (r = "crypto", i && (this[r] = Nn[r]), (n = e2[r]) !== void 0)
        if (n === true || n === false || n === 0 || n === 1)
          if (n)
            if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes))
              this[r] = true;
            else
              throw Error(_o);
          else
            this[r] = false;
        else
          throw Error(St + r + ": " + n);
      return this;
    }
    y(qo, "lf");
    d(qo, "config");
    function Lo(e2) {
      return new this(e2).cos();
    }
    y(Lo, "cf");
    d(Lo, "cos");
    function Uo(e2) {
      return new this(e2).cosh();
    }
    y(Uo, "ff");
    d(Uo, "cosh");
    function qn(e2) {
      var t, r, n;
      function i(a) {
        var o, l, f, s = this;
        if (!(s instanceof i))
          return new i(a);
        if (s.constructor = i, Ln(a)) {
          s.s = a.s, ae ? !a.d || a.e > i.maxE ? (s.e = NaN, s.d = null) : a.e < i.minE ? (s.e = 0, s.d = [0]) : (s.e = a.e, s.d = a.d.slice()) : (s.e = a.e, s.d = a.d ? a.d.slice() : a.d);
          return;
        }
        if (f = typeof a, f === "number") {
          if (a === 0) {
            s.s = 1 / a < 0 ? -1 : 1, s.e = 0, s.d = [0];
            return;
          }
          if (a < 0 ? (a = -a, s.s = -1) : s.s = 1, a === ~~a && a < 1e7) {
            for (o = 0, l = a; l >= 10; l /= 10)
              o++;
            ae ? o > i.maxE ? (s.e = NaN, s.d = null) : o < i.minE ? (s.e = 0, s.d = [0]) : (s.e = o, s.d = [a]) : (s.e = o, s.d = [a]);
            return;
          } else if (a * 0 != 0) {
            a || (s.s = NaN), s.e = NaN, s.d = null;
            return;
          }
          return Ur(s, a.toString());
        } else if (f !== "string")
          throw Error(St + a);
        return (l = a.charCodeAt(0)) === 45 ? (a = a.slice(1), s.s = -1) : (l === 43 && (a = a.slice(1)), s.s = 1), Ao.test(a) ? Ur(s, a) : To(s, a);
      }
      if (y(i, "o"), d(i, "Decimal"), i.prototype = D, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.EUCLID = 9, i.config = i.set = qo, i.clone = qn, i.isDecimal = Ln, i.abs = xo, i.acos = Po, i.acosh = jo, i.add = No, i.asin = ko, i.asinh = Io, i.atan = $o, i.atanh = Mo, i.atan2 = Fo, i.cbrt = Ro, i.ceil = Bo, i.clamp = Co, i.cos = Lo, i.cosh = Uo, i.div = Do, i.exp = Vo, i.floor = Go, i.hypot = Jo, i.ln = Wo, i.log = zo, i.log10 = Ho, i.log2 = Yo, i.max = Zo, i.min = Ko, i.mod = Qo, i.mul = Xo, i.pow = ea, i.random = ta, i.round = ra, i.sign = na, i.sin = ia, i.sinh = oa, i.sqrt = aa, i.sub = sa, i.sum = ua, i.tan = la, i.tanh = ca, i.trunc = fa, e2 === void 0 && (e2 = {}), e2 && e2.defaults !== true)
        for (n = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], t = 0; t < n.length; )
          e2.hasOwnProperty(r = n[t++]) || (e2[r] = this[r]);
      return i.config(e2), i;
    }
    y(qn, "Qs");
    d(qn, "clone");
    function Do(e2, t) {
      return new this(e2).div(t);
    }
    y(Do, "pf");
    d(Do, "div");
    function Vo(e2) {
      return new this(e2).exp();
    }
    y(Vo, "df");
    d(Vo, "exp");
    function Go(e2) {
      return te(e2 = new this(e2), e2.e + 1, 3);
    }
    y(Go, "gf");
    d(Go, "floor");
    function Jo() {
      var e2, t, r = new this(0);
      for (ae = false, e2 = 0; e2 < arguments.length; )
        if (t = new this(arguments[e2++]), t.d)
          r.d && (r = r.plus(t.times(t)));
        else {
          if (t.s)
            return ae = true, new this(1 / 0);
          r = t;
        }
      return ae = true, r.sqrt();
    }
    y(Jo, "mf");
    d(Jo, "hypot");
    function Ln(e2) {
      return e2 instanceof mr || e2 && e2.toStringTag === Eo || false;
    }
    y(Ln, "Ks");
    d(Ln, "isDecimalInstance");
    function Wo(e2) {
      return new this(e2).ln();
    }
    y(Wo, "hf");
    d(Wo, "ln");
    function zo(e2, t) {
      return new this(e2).log(t);
    }
    y(zo, "yf");
    d(zo, "log");
    function Yo(e2) {
      return new this(e2).log(2);
    }
    y(Yo, "bf");
    d(Yo, "log2");
    function Ho(e2) {
      return new this(e2).log(10);
    }
    y(Ho, "wf");
    d(Ho, "log10");
    function Zo() {
      return Fn(this, arguments, "lt");
    }
    y(Zo, "vf");
    d(Zo, "max");
    function Ko() {
      return Fn(this, arguments, "gt");
    }
    y(Ko, "Ef");
    d(Ko, "min");
    function Qo(e2, t) {
      return new this(e2).mod(t);
    }
    y(Qo, "_f");
    d(Qo, "mod");
    function Xo(e2, t) {
      return new this(e2).mul(t);
    }
    y(Xo, "Af");
    d(Xo, "mul");
    function ea(e2, t) {
      return new this(e2).pow(t);
    }
    y(ea, "xf");
    d(ea, "pow");
    function ta(e2) {
      var t, r, n, i, a = 0, o = new this(1), l = [];
      if (e2 === void 0 ? e2 = this.precision : Ce(e2, 1, Tt), n = Math.ceil(e2 / oe), this.crypto)
        if (crypto.getRandomValues)
          for (t = crypto.getRandomValues(new Uint32Array(n)); a < n; )
            i = t[a], i >= 429e7 ? t[a] = crypto.getRandomValues(new Uint32Array(1))[0] : l[a++] = i % 1e7;
        else if (crypto.randomBytes) {
          for (t = crypto.randomBytes(n *= 4); a < n; )
            i = t[a] + (t[a + 1] << 8) + (t[a + 2] << 16) + ((t[a + 3] & 127) << 24), i >= 214e7 ? crypto.randomBytes(4).copy(t, a) : (l.push(i % 1e7), a += 4);
          a = n / 4;
        } else
          throw Error(_o);
      else
        for (; a < n; )
          l[a++] = Math.random() * 1e7 | 0;
      for (n = l[--a], e2 %= oe, n && e2 && (i = Pe(10, oe - e2), l[a] = (n / i | 0) * i); l[a] === 0; a--)
        l.pop();
      if (a < 0)
        r = 0, l = [0];
      else {
        for (r = -1; l[0] === 0; r -= oe)
          l.shift();
        for (n = 1, i = l[0]; i >= 10; i /= 10)
          n++;
        n < oe && (r -= oe - n);
      }
      return o.e = r, o.d = l, o;
    }
    y(ta, "Pf");
    d(ta, "random");
    function ra(e2) {
      return te(e2 = new this(e2), e2.e + 1, this.rounding);
    }
    y(ra, "Tf");
    d(ra, "round");
    function na(e2) {
      return e2 = new this(e2), e2.d ? e2.d[0] ? e2.s : 0 * e2.s : e2.s || NaN;
    }
    y(na, "Sf");
    d(na, "sign");
    function ia(e2) {
      return new this(e2).sin();
    }
    y(ia, "Mf");
    d(ia, "sin");
    function oa(e2) {
      return new this(e2).sinh();
    }
    y(oa, "Of");
    d(oa, "sinh");
    function aa(e2) {
      return new this(e2).sqrt();
    }
    y(aa, "If");
    d(aa, "sqrt");
    function sa(e2, t) {
      return new this(e2).sub(t);
    }
    y(sa, "kf");
    d(sa, "sub");
    function ua() {
      var e2 = 0, t = arguments, r = new this(t[e2]);
      for (ae = false; r.s && ++e2 < t.length; )
        r = r.plus(t[e2]);
      return ae = true, te(r, this.precision, this.rounding);
    }
    y(ua, "jf");
    d(ua, "sum");
    function la(e2) {
      return new this(e2).tan();
    }
    y(la, "Ff");
    d(la, "tan");
    function ca(e2) {
      return new this(e2).tanh();
    }
    y(ca, "Rf");
    d(ca, "tanh");
    function fa(e2) {
      return te(e2 = new this(e2), e2.e + 1, 1);
    }
    y(fa, "Nf");
    d(fa, "trunc");
    D[Symbol.for("nodejs.util.inspect.custom")] = D.toString;
    D[Symbol.toStringTag] = "Decimal";
    var mr = D.constructor = qn(Nn);
    Br = new mr(Br);
    Cr = new mr(Cr);
    var Vr = mr;
    var pa = Ae(so());
    var Uu = Ae(uo());
    var qe = d((e2, t) => {
      let r = {};
      for (let n of e2) {
        let i = n[t];
        r[i] = n;
      }
      return r;
    }, "keyBy");
    var vr = { String: true, Int: true, Float: true, Boolean: true, Long: true, DateTime: true, ID: true, UUID: true, Json: true, Bytes: true, Decimal: true, BigInt: true };
    var Du = { string: "String", boolean: "Boolean", object: "Json" };
    function Ht(e2) {
      return typeof e2 == "string" ? e2 : e2.name;
    }
    y(Ht, "Bt");
    d(Ht, "stringifyGraphQLType");
    function br(e2, t) {
      return t ? `List<${e2}>` : e2;
    }
    y(br, "pr");
    d(br, "wrapWithList");
    var Vu = /^(\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60))(\.\d{1,})?(([Z])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))$/;
    var Gu = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    function Zt(e2, t) {
      if (e2 === null)
        return "null";
      if (Object.prototype.toString.call(e2) === "[object BigInt]")
        return "BigInt";
      if (Vr.isDecimal(e2))
        return "Decimal";
      if (Ge.Buffer.isBuffer(e2))
        return "Bytes";
      if (Array.isArray(e2)) {
        let n = e2.reduce((i, a) => {
          let o = Zt(a, t);
          return i.includes(o) || i.push(o), i;
        }, []);
        return n.includes("Float") && n.includes("Int") && (n = ["Float"]), `List<${n.join(" | ")}>`;
      }
      let r = typeof e2;
      if (r === "number")
        return Math.trunc(e2) === e2 ? "Int" : "Float";
      if (Object.prototype.toString.call(e2) === "[object Date]")
        return "DateTime";
      if (r === "string") {
        if (Gu.test(e2))
          return "UUID";
        let n = new Date(e2);
        if (t && typeof t == "object" && t.values && t.values.includes(e2))
          return t.name;
        if (n.toString() === "Invalid Date")
          return "String";
        if (Vu.test(e2))
          return "DateTime";
      }
      return Du[r];
    }
    y(Zt, "Lt");
    d(Zt, "getGraphQLType");
    function Gr(e2, t) {
      return t.reduce((r, n) => {
        let i = (0, Uu.default)(e2, n);
        return i < r.distance ? { distance: i, str: n } : r;
      }, { distance: Math.min(Math.floor(e2.length) * 1.1, ...t.map((r) => r.length * 3)), str: null }).str;
    }
    y(Gr, "ln");
    d(Gr, "getSuggestion");
    function Kt(e2, t = false) {
      if (typeof e2 == "string")
        return e2;
      if (e2.values)
        return `enum ${e2.name} {
${(0, pa.default)(e2.values.join(", "), 2)}
}`;
      {
        let r = (0, pa.default)(e2.fields.map((n) => {
          let i = `${n.name}`, a = `${t ? It.default.green(i) : i}${n.isRequired ? "" : "?"}: ${It.default.white(n.inputTypes.map((o) => br(da(o.type) ? o.type.name : Ht(o.type), o.isList)).join(" | "))}`;
          return n.isRequired ? a : It.default.dim(a);
        }).join(`
`), 2);
        return `${It.default.dim("type")} ${It.default.bold.dim(e2.name)} ${It.default.dim("{")}
${r}
${It.default.dim("}")}`;
      }
    }
    y(Kt, "qt");
    d(Kt, "stringifyInputType");
    function da(e2) {
      return typeof e2 != "string";
    }
    y(da, "Bf");
    d(da, "argIsInputType");
    function wr(e2) {
      return typeof e2 == "string" ? e2 === "Null" ? "null" : e2 : e2.name;
    }
    y(wr, "dr");
    d(wr, "getInputTypeName");
    function Qt(e2) {
      return typeof e2 == "string" ? e2 : e2.name;
    }
    y(Qt, "wt");
    d(Qt, "getOutputTypeName");
    function Un(e2, t, r = false) {
      if (typeof e2 == "string")
        return e2 === "Null" ? "null" : e2;
      if (e2.values)
        return e2.values.join(" | ");
      let n = e2, i = t && n.fields.every((a) => {
        var o;
        return a.inputTypes[0].location === "inputObjectTypes" || ((o = a.inputTypes[1]) == null ? void 0 : o.location) === "inputObjectTypes";
      });
      return r ? wr(e2) : n.fields.reduce((a, o) => {
        let l = "";
        return !i && !o.isRequired ? l = o.inputTypes.map((f) => wr(f.type)).join(" | ") : l = o.inputTypes.map((f) => Un(f.type, o.isRequired, true)).join(" | "), a[o.name + (o.isRequired ? "" : "?")] = l, a;
      }, {});
    }
    y(Un, "vo");
    d(Un, "inputTypeToJson");
    function ha(e2, t, r) {
      let n = {};
      for (let i of e2)
        n[r(i)] = i;
      for (let i of t) {
        let a = r(i);
        n[a] || (n[a] = i);
      }
      return Object.values(n);
    }
    y(ha, "ta");
    d(ha, "unionBy");
    function ga(e2) {
      return e2.endsWith("GroupByOutputType");
    }
    y(ga, "ra");
    d(ga, "isGroupByOutputName");
    var Dn = y(class {
      constructor({ datamodel: e2, schema: t, mappings: r }) {
        this.outputTypeToMergedOutputType = (n) => ({ ...n, fields: n.fields }), this.datamodel = e2, this.schema = t, this.mappings = r, this.enumMap = this.getEnumMap(), this.datamodelEnumMap = this.getDatamodelEnumMap(), this.queryType = this.getQueryType(), this.mutationType = this.getMutationType(), this.modelMap = this.getModelMap(), this.typeMap = this.getTypeMap(), this.typeAndModelMap = this.getTypeModelMap(), this.outputTypes = this.getOutputTypes(), this.outputTypeMap = this.getMergedOutputTypeMap(), this.resolveOutputTypes(), this.inputObjectTypes = this.schema.inputObjectTypes, this.inputTypeMap = this.getInputTypeMap(), this.resolveInputTypes(), this.resolveFieldArgumentTypes(), this.mappingsMap = this.getMappingsMap(), this.queryType = this.outputTypeMap.Query, this.mutationType = this.outputTypeMap.Mutation, this.rootFieldMap = this.getRootFieldMap();
      }
      get [Symbol.toStringTag]() {
        return "DMMFClass";
      }
      resolveOutputTypes() {
        for (let e2 of this.outputTypes.model) {
          for (let t of e2.fields)
            typeof t.outputType.type == "string" && !vr[t.outputType.type] && (t.outputType.type = this.outputTypeMap[t.outputType.type] || this.outputTypeMap[t.outputType.type] || this.enumMap[t.outputType.type] || t.outputType.type);
          e2.fieldMap = qe(e2.fields, "name");
        }
        for (let e2 of this.outputTypes.prisma) {
          for (let t of e2.fields)
            typeof t.outputType.type == "string" && !vr[t.outputType.type] && (t.outputType.type = this.outputTypeMap[t.outputType.type] || this.outputTypeMap[t.outputType.type] || this.enumMap[t.outputType.type] || t.outputType.type);
          e2.fieldMap = qe(e2.fields, "name");
        }
      }
      resolveInputTypes() {
        let e2 = this.inputObjectTypes.prisma;
        this.inputObjectTypes.model && e2.push(...this.inputObjectTypes.model);
        for (let t of e2) {
          for (let r of t.fields)
            for (let n of r.inputTypes) {
              let i = n.type;
              typeof i == "string" && !vr[i] && (this.inputTypeMap[i] || this.enumMap[i]) && (n.type = this.inputTypeMap[i] || this.enumMap[i] || i);
            }
          t.fieldMap = qe(t.fields, "name");
        }
      }
      resolveFieldArgumentTypes() {
        for (let e2 of this.outputTypes.prisma)
          for (let t of e2.fields)
            for (let r of t.args)
              for (let n of r.inputTypes) {
                let i = n.type;
                typeof i == "string" && !vr[i] && (n.type = this.inputTypeMap[i] || this.enumMap[i] || i);
              }
        for (let e2 of this.outputTypes.model)
          for (let t of e2.fields)
            for (let r of t.args)
              for (let n of r.inputTypes) {
                let i = n.type;
                typeof i == "string" && !vr[i] && (n.type = this.inputTypeMap[i] || this.enumMap[i] || n.type);
              }
      }
      getQueryType() {
        return this.schema.outputObjectTypes.prisma.find((e2) => e2.name === "Query");
      }
      getMutationType() {
        return this.schema.outputObjectTypes.prisma.find((e2) => e2.name === "Mutation");
      }
      getOutputTypes() {
        return { model: this.schema.outputObjectTypes.model.map(this.outputTypeToMergedOutputType), prisma: this.schema.outputObjectTypes.prisma.map(this.outputTypeToMergedOutputType) };
      }
      getDatamodelEnumMap() {
        return qe(this.datamodel.enums, "name");
      }
      getEnumMap() {
        return { ...qe(this.schema.enumTypes.prisma, "name"), ...this.schema.enumTypes.model ? qe(this.schema.enumTypes.model, "name") : void 0 };
      }
      getModelMap() {
        return { ...qe(this.datamodel.models, "name") };
      }
      getTypeMap() {
        return { ...qe(this.datamodel.types, "name") };
      }
      getTypeModelMap() {
        return { ...this.getTypeMap(), ...this.getModelMap() };
      }
      getMergedOutputTypeMap() {
        return { ...qe(this.outputTypes.model, "name"), ...qe(this.outputTypes.prisma, "name") };
      }
      getInputTypeMap() {
        return { ...this.schema.inputObjectTypes.model ? qe(this.schema.inputObjectTypes.model, "name") : void 0, ...qe(this.schema.inputObjectTypes.prisma, "name") };
      }
      getMappingsMap() {
        return qe(this.mappings.modelOperations, "model");
      }
      getRootFieldMap() {
        return { ...qe(this.queryType.fields, "name"), ...qe(this.mutationType.fields, "name") };
      }
    }, "gr");
    d(Dn, "DMMFHelper");
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    var Vn;
    (function(e2) {
      let t;
      (function(r) {
        r.findUnique = "findUnique", r.findFirst = "findFirst", r.findMany = "findMany", r.create = "create", r.createMany = "createMany", r.update = "update", r.updateMany = "updateMany", r.upsert = "upsert", r.delete = "delete", r.deleteMany = "deleteMany", r.groupBy = "groupBy", r.count = "count", r.aggregate = "aggregate", r.findRaw = "findRaw", r.aggregateRaw = "aggregateRaw";
      })(t = e2.ModelAction || (e2.ModelAction = {}));
    })(Vn || (Vn = {}));
    j();
    N();
    I();
    k();
    var Gn = Ae(co());
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    var Ju = Object.defineProperty;
    var Wu = d((e2, t) => Ju(e2, "name", { value: t, configurable: true }), "__name");
    var Jr = y(class {
    }, "xt");
    d(Jr, "Engine");
    Wu(Jr, "Engine");
    j();
    N();
    I();
    k();
    var zu = Object.defineProperty;
    var Yu = d((e2, t) => zu(e2, "name", { value: t, configurable: true }), "__name");
    var Xt = y(class extends Error {
      constructor(e2, t, r) {
        super(e2);
        this.clientVersion = t, this.errorCode = r, Error.captureStackTrace(Xt);
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientInitializationError";
      }
    }, "Ue");
    d(Xt, "PrismaClientInitializationError");
    Yu(Xt, "PrismaClientInitializationError");
    j();
    N();
    I();
    k();
    var Hu = Object.defineProperty;
    var Zu = d((e2, t) => Hu(e2, "name", { value: t, configurable: true }), "__name");
    var _r = y(class extends Error {
      constructor(e2, t, r, n) {
        super(e2);
        this.code = t, this.clientVersion = r, this.meta = n;
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientKnownRequestError";
      }
    }, "We");
    d(_r, "PrismaClientKnownRequestError");
    Zu(_r, "PrismaClientKnownRequestError");
    j();
    N();
    I();
    k();
    var Ku = Object.defineProperty;
    var Qu = d((e2, t) => Ku(e2, "name", { value: t, configurable: true }), "__name");
    var er = y(class extends Error {
      constructor(e2, t) {
        super(e2);
        this.clientVersion = t;
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientRustPanicError";
      }
    }, "He");
    d(er, "PrismaClientRustPanicError");
    Qu(er, "PrismaClientRustPanicError");
    j();
    N();
    I();
    k();
    var Xu = Object.defineProperty;
    var el = d((e2, t) => Xu(e2, "name", { value: t, configurable: true }), "__name");
    var tr = y(class extends Error {
      constructor(e2, t) {
        super(e2);
        this.clientVersion = t;
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientUnknownRequestError";
      }
    }, "Ve");
    d(tr, "PrismaClientUnknownRequestError");
    el(tr, "PrismaClientUnknownRequestError");
    j();
    N();
    I();
    k();
    var tl = Object.defineProperty;
    var rl = d((e2, t) => tl(e2, "name", { value: t, configurable: true }), "__name");
    function Jn(e2, t) {
      return e2.user_facing_error.error_code ? new _r(e2.user_facing_error.message, e2.user_facing_error.error_code, t, e2.user_facing_error.meta) : new tr(e2.error, t);
    }
    y(Jn, "Qo");
    d(Jn, "prismaGraphQLToJSError");
    rl(Jn, "prismaGraphQLToJSError");
    j();
    N();
    I();
    k();
    var nl = Ae(Su());
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    var il = Object.defineProperty;
    var ol = d((e2, t) => il(e2, "name", { value: t, configurable: true }), "__name");
    var Wn = y(class extends Error {
      constructor(e2, t) {
        super(e2);
        this.clientVersion = t.clientVersion, this.cause = t.cause;
      }
      get [Symbol.toStringTag]() {
        return this.name;
      }
    }, "vr");
    d(Wn, "PrismaClientError");
    ol(Wn, "PrismaClientError");
    var al = Object.defineProperty;
    var sl = d((e2, t) => al(e2, "name", { value: t, configurable: true }), "__name");
    var Mt = y(class extends Wn {
      constructor(e2, t) {
        super(e2, t);
        var r;
        this.isRetryable = (r = t.isRetryable) != null ? r : true;
      }
    }, "Ae");
    d(Mt, "DataProxyError");
    sl(Mt, "DataProxyError");
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    var ul = Object.defineProperty;
    var ll = d((e2, t) => ul(e2, "name", { value: t, configurable: true }), "__name");
    function Ze(e2, t) {
      return { ...e2, isRetryable: t };
    }
    y(Ze, "ee");
    d(Ze, "setRetryable");
    ll(Ze, "setRetryable");
    var cl = Object.defineProperty;
    var fl = d((e2, t) => cl(e2, "name", { value: t, configurable: true }), "__name");
    var Wr = y(class extends Mt {
      constructor(e2) {
        super("This request must be retried", Ze(e2, true));
        this.name = "ForcedRetryError", this.code = "P5001";
      }
    }, "Ht");
    d(Wr, "ForcedRetryError");
    fl(Wr, "ForcedRetryError");
    j();
    N();
    I();
    k();
    var pl = Object.defineProperty;
    var dl = d((e2, t) => pl(e2, "name", { value: t, configurable: true }), "__name");
    var Er = y(class extends Mt {
      constructor(e2, t) {
        super(e2, Ze(t, false));
        this.name = "InvalidDatasourceError", this.code = "P5002";
      }
    }, "Pt");
    d(Er, "InvalidDatasourceError");
    dl(Er, "InvalidDatasourceError");
    j();
    N();
    I();
    k();
    var hl = Object.defineProperty;
    var gl = d((e2, t) => hl(e2, "name", { value: t, configurable: true }), "__name");
    var zr = y(class extends Mt {
      constructor(e2, t) {
        super(e2, Ze(t, false));
        this.name = "NotImplementedYetError", this.code = "P5004";
      }
    }, "Yt");
    d(zr, "NotImplementedYetError");
    gl(zr, "NotImplementedYetError");
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    var yl = Object.defineProperty;
    var ml = d((e2, t) => yl(e2, "name", { value: t, configurable: true }), "__name");
    var wt = y(class extends Mt {
      constructor(e2, t) {
        super(e2, t);
        this.response = t.response;
      }
    }, "ue");
    d(wt, "DataProxyAPIError");
    ml(wt, "DataProxyAPIError");
    var vl = Object.defineProperty;
    var bl = d((e2, t) => vl(e2, "name", { value: t, configurable: true }), "__name");
    var Yr = y(class extends wt {
      constructor(e2) {
        super("Schema needs to be uploaded", Ze(e2, true));
        this.name = "SchemaMissingError", this.code = "P5005";
      }
    }, "Tt");
    d(Yr, "SchemaMissingError");
    bl(Yr, "SchemaMissingError");
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    var wl = Object.defineProperty;
    var _l = d((e2, t) => wl(e2, "name", { value: t, configurable: true }), "__name");
    var El = "This request could not be understood by the server";
    var Hr = y(class extends wt {
      constructor(e2, t, r) {
        super(t || El, Ze(e2, false));
        this.name = "BadRequestError", this.code = "P5000", r && (this.code = r);
      }
    }, "Qt");
    d(Hr, "BadRequestError");
    _l(Hr, "BadRequestError");
    j();
    N();
    I();
    k();
    var Al = Object.defineProperty;
    var Ol = d((e2, t) => Al(e2, "name", { value: t, configurable: true }), "__name");
    var zn = y(class extends wt {
      constructor(e2) {
        super("Request timed out", Ze(e2, false));
        this.name = "GatewayTimeoutError", this.code = "P5009";
      }
    }, "Er");
    d(zn, "GatewayTimeoutError");
    Ol(zn, "GatewayTimeoutError");
    j();
    N();
    I();
    k();
    var Tl = Object.defineProperty;
    var Sl = d((e2, t) => Tl(e2, "name", { value: t, configurable: true }), "__name");
    var Zr = y(class extends wt {
      constructor(e2) {
        super("Requested resource does not exist", Ze(e2, false));
        this.name = "NotFoundError", this.code = "P5003";
      }
    }, "Kt");
    d(Zr, "NotFoundError");
    Sl(Zr, "NotFoundError");
    j();
    N();
    I();
    k();
    var xl = Object.defineProperty;
    var Pl = d((e2, t) => xl(e2, "name", { value: t, configurable: true }), "__name");
    var jl = "Unknown server error";
    var rr = y(class extends wt {
      constructor(e2, t, r) {
        super(t || jl, Ze(e2, true));
        this.name = "ServerError", this.code = "P5006", this.logs = r;
      }
    }, "at");
    d(rr, "ServerError");
    Pl(rr, "ServerError");
    j();
    N();
    I();
    k();
    var Nl = Object.defineProperty;
    var kl = d((e2, t) => Nl(e2, "name", { value: t, configurable: true }), "__name");
    var Yn = y(class extends wt {
      constructor(e2) {
        super("Unauthorized, check your connection string", Ze(e2, false));
        this.name = "UnauthorizedError", this.code = "P5007";
      }
    }, "_r");
    d(Yn, "UnauthorizedError");
    kl(Yn, "UnauthorizedError");
    j();
    N();
    I();
    k();
    var Il = Object.defineProperty;
    var $l = d((e2, t) => Il(e2, "name", { value: t, configurable: true }), "__name");
    var Hn = y(class extends wt {
      constructor(e2) {
        super("Usage exceeded, retry again later", Ze(e2, true));
        this.name = "UsageExceededError", this.code = "P5008";
      }
    }, "Ar");
    d(Hn, "UsageExceededError");
    $l(Hn, "UsageExceededError");
    var Ml = Object.defineProperty;
    var Fl = d((e2, t) => Ml(e2, "name", { value: t, configurable: true }), "__name");
    async function Kr(e2, t) {
      var n, i, a, o, l, f, s;
      if (e2.ok)
        return;
      let r = { clientVersion: t, response: e2 };
      if (e2.status === 400) {
        let c;
        try {
          c = (a = (i = (n = await e2.json()) == null ? void 0 : n.EngineNotStarted) == null ? void 0 : i.reason) == null ? void 0 : a.KnownEngineStartupError;
        } catch (p) {
        }
        if (c)
          throw new Hr(r, c.msg, c.error_code);
      }
      if (e2.status === 401)
        throw new Yn(r);
      if (e2.status === 404)
        try {
          return ((l = (o = await e2.json()) == null ? void 0 : o.EngineNotStarted) == null ? void 0 : l.reason) === "SchemaMissing" ? new Yr(r) : new Zr(r);
        } catch (c) {
          return new Zr(r);
        }
      if (e2.status === 429)
        throw new Hn(r);
      if (e2.status === 504)
        throw new zn(r);
      if (e2.status >= 500) {
        let c;
        try {
          c = await e2.json();
        } catch (p) {
          throw new rr(r);
        }
        if (typeof ((f = c == null ? void 0 : c.EngineNotStarted) == null ? void 0 : f.reason) == "string")
          throw new rr(r, c.EngineNotStarted.reason);
        if (typeof ((s = c == null ? void 0 : c.EngineNotStarted) == null ? void 0 : s.reason) == "object") {
          let p = Object.keys(c.EngineNotStarted.reason);
          if (p.length > 0) {
            let g = c.EngineNotStarted.reason[p[0]];
            throw new rr(r, p[0], g.logs);
          }
        }
        throw new rr(r);
      }
      if (e2.status >= 400)
        throw new Hr(r);
    }
    y(Kr, "Pn");
    d(Kr, "responseToError");
    Fl(Kr, "responseToError");
    j();
    N();
    I();
    k();
    var Rl = Object.defineProperty;
    var Bl = d((e2, t) => Rl(e2, "name", { value: t, configurable: true }), "__name");
    var Cl = 50;
    function Zn(e2) {
      let t = Math.pow(2, e2) * Cl, r = Math.ceil(Math.random() * t) - Math.ceil(t / 2), n = t + r;
      return new Promise((i) => setTimeout(() => i(n), n));
    }
    y(Zn, "Ko");
    d(Zn, "backOff");
    Bl(Zn, "backOff");
    j();
    N();
    I();
    k();
    var ql = Object.defineProperty;
    var Ll = d((e2, t) => ql(e2, "name", { value: t, configurable: true }), "__name");
    function Kn(e2) {
      var n, i;
      let [t, r] = (i = (n = e2.clientVersion) == null ? void 0 : n.split("-")) != null ? i : [];
      return !r && /^[1-9][0-9]*\.[0-9]+\.[0-9]+$/.test(t) ? t : "3.4.1";
    }
    y(Kn, "Zo");
    d(Kn, "getClientVersion");
    Ll(Kn, "getClientVersion");
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    var Ul = Object.defineProperty;
    var Dl = d((e2, t) => Ul(e2, "name", { value: t, configurable: true }), "__name");
    function Qn() {
      return typeof self == "undefined" ? "node" : "browser";
    }
    y(Qn, "Xo");
    d(Qn, "getJSRuntimeName");
    Dl(Qn, "getJSRuntimeName");
    var Vl = Object.defineProperty;
    var Ar = d((e2, t) => Vl(e2, "name", { value: t, configurable: true }), "__name");
    async function Or(e2, t = {}) {
      return Qn() === "browser" ? fetch(e2, t) : ri(e2, t);
    }
    y(Or, "Pr");
    d(Or, "request");
    Ar(Or, "request");
    function Xn(e2) {
      return { ...JSON.parse(JSON.stringify(e2.headers)), "Content-Type": "application/json" };
    }
    y(Xn, "Fa");
    d(Xn, "buildHeaders");
    Ar(Xn, "buildHeaders");
    function ei(e2) {
      return { method: e2.method, headers: Xn(e2) };
    }
    y(ei, "Ra");
    d(ei, "buildOptions");
    Ar(ei, "buildOptions");
    function ti(e2, t) {
      return { json: () => JSON.parse(Ge.Buffer.concat(e2).toString()), ok: t.statusCode >= 200 && t.statusCode < 300, status: t.statusCode, url: t.url };
    }
    y(ti, "Na");
    d(ti, "buildResponse");
    Ar(ti, "buildResponse");
    function ri(url, options = {}) {
      let httpsOptions = ei(options), incomingData = [];
      return new Promise((resolve, reject) => {
        var e;
        let https = eval("require('https')"), request = https.request(url, httpsOptions, (t) => {
          t.on("data", (r) => incomingData.push(r)), t.on("end", () => resolve(ti(incomingData, t))), t.on("error", reject);
        });
        request.on("error", reject), request.write((e = options.body) != null ? e : ""), request.end();
      });
    }
    y(ri, "Ca");
    d(ri, "nodeFetch");
    Ar(ri, "nodeFetch");
    var Gl = Object.defineProperty;
    var Jl = d((e2, t) => Gl(e2, "name", { value: t, configurable: true }), "__name");
    var Wl = 10;
    var ni = y(class extends Jr {
      constructor(e2) {
        super();
        var i, a, o, l, f;
        this.config = e2, this.env = (i = this.config.env) != null ? i : {}, this.inlineSchema = (a = e2.inlineSchema) != null ? a : "", this.inlineDatasources = (o = e2.inlineDatasources) != null ? o : {}, this.inlineSchemaHash = (l = e2.inlineSchemaHash) != null ? l : "", this.clientVersion = (f = e2.clientVersion) != null ? f : "unknown", this.logEmitter = new nl.default(), this.logEmitter.on("error", () => {
        });
        let [t, r] = this.extractHostAndApiKey();
        this.remoteClientVersion = Kn(this.config), this.headers = { Authorization: `Bearer ${r}` }, this.host = t;
        let n = Promise.resolve();
        this.pushPromise = n.then(() => this.pushSchema());
      }
      async pushSchema() {
        (await Or(this.url("schema"), { method: "GET", headers: this.headers })).status === 404 && await this.uploadSchema();
      }
      version() {
        return "unknown";
      }
      async start() {
      }
      async stop() {
      }
      on(e2, t) {
        if (e2 === "beforeExit")
          throw new zr("beforeExit event is not yet supported", { clientVersion: this.clientVersion });
        this.logEmitter.on(e2, t);
      }
      url(e2) {
        return `https://${this.host}/${this.remoteClientVersion}/${this.inlineSchemaHash}/${e2}`;
      }
      async getConfig() {
        return Promise.resolve({ datasources: [{ activeProvider: this.config.activeProvider }] });
      }
      async uploadSchema() {
        let e2 = await Or(this.url("schema"), { method: "PUT", headers: this.headers, body: this.inlineSchema }), t = await Kr(e2, this.clientVersion);
        if (t)
          throw this.logEmitter.emit("warn", { message: `Error while uploading schema: ${t.message}` }), t;
        this.logEmitter.emit("info", { message: `Schema (re)uploaded (hash: ${this.inlineSchemaHash})` });
      }
      request(e2, t, r = 0) {
        return this.logEmitter.emit("query", { query: e2 }), this.requestInternal({ query: e2, variables: {} }, t, r);
      }
      async requestBatch(e2, t, r = false, n = 0) {
        this.logEmitter.emit("query", { query: `Batch${r ? " in transaction" : ""} (${e2.length}):
${e2.join(`
`)}` });
        let i = { batch: e2.map((o) => ({ query: o, variables: {} })), transaction: r }, { batchResult: a } = await this.requestInternal(i, t, n);
        return a;
      }
      async requestInternal(e2, t, r) {
        var n;
        await this.pushPromise;
        try {
          this.logEmitter.emit("info", { message: `Calling ${this.url("graphql")} (n=${r})` });
          let i = await Or(this.url("graphql"), { method: "POST", headers: { ...t, ...this.headers }, body: JSON.stringify(e2) }), a = await Kr(i, this.clientVersion);
          if (a instanceof Yr)
            throw await this.uploadSchema(), new Wr({ clientVersion: this.clientVersion, cause: a });
          if (a)
            throw a;
          let o = await i.json();
          if (o.errors && o.errors.length === 1)
            throw Jn(o.errors[0], this.config.clientVersion);
          return o;
        } catch (i) {
          if (this.logEmitter.emit("error", { message: `Error while querying: ${(n = i.message) != null ? n : "(unknown)"}` }), !(i instanceof Mt) || !i.isRetryable)
            throw i;
          if (r >= Wl)
            throw i instanceof Wr ? i.cause : i;
          this.logEmitter.emit("warn", { message: "This request can be retried" });
          let a = await Zn(r);
          return this.logEmitter.emit("warn", { message: `Retrying after ${a}ms` }), this.requestInternal(e2, t, r + 1);
        }
      }
      transaction() {
        throw new zr("Interactive transactions are not yet supported", { clientVersion: this.clientVersion });
      }
      extractHostAndApiKey() {
        let e2 = Object.keys(this.inlineDatasources)[0], t = this.inlineDatasources[e2], r = t == null ? void 0 : t.url.value, n = t == null ? void 0 : t.url.fromEnvVar, i = this.env[n], a = r != null ? r : i, o;
        try {
          o = new URL(a != null ? a : "");
        } catch (p) {
          throw new Er("Could not parse URL of the datasource", { clientVersion: this.clientVersion });
        }
        let { protocol: l, host: f, searchParams: s } = o;
        if (l !== "prisma:")
          throw new Er("Datasource URL should use prisma:// protocol. If you are not using the Data Proxy, remove the `dataProxy` from the `previewFeatures` in your schema and ensure that `PRISMA_CLIENT_ENGINE_TYPE` environment variable is not set to `dataproxy`.", { clientVersion: this.clientVersion });
        let c = s.get("api_key");
        if (c === null || c.length < 1)
          throw new Er("No valid API key found in the datasource URL", { clientVersion: this.clientVersion });
        return [f, c];
      }
    }, "Zt");
    d(ni, "DataProxyEngine");
    Jl(ni, "DataProxyEngine");
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    var zl = Object.defineProperty;
    var ya = d((e2, t) => zl(e2, "name", { value: t, configurable: true }), "__name");
    var Ie;
    (function(e2) {
      e2.Library = "library", e2.Binary = "binary", e2.DataProxy = "dataproxy";
    })(Ie || (Ie = {}));
    var Yl = Ie.Library;
    function ii(e2) {
      return oi() || ((e2 == null ? void 0 : e2.config.engineType) === Ie.Library ? Ie.Library : (e2 == null ? void 0 : e2.config.engineType) === Ie.Binary ? Ie.Binary : (e2 == null ? void 0 : e2.config.engineType) === Ie.DataProxy ? Ie.DataProxy : Yl);
    }
    y(ii, "Tn");
    d(ii, "getClientEngineType");
    ya(ii, "getClientEngineType");
    function oi() {
      let e2 = we.env.PRISMA_CLIENT_ENGINE_TYPE;
      return e2 === Ie.Library ? Ie.Library : e2 === Ie.Binary ? Ie.Binary : e2 === Ie.DataProxy ? Ie.DataProxy : void 0;
    }
    y(oi, "La");
    d(oi, "getEngineTypeFromEnvVar");
    ya(oi, "getEngineTypeFromEnvVar");
    j();
    N();
    I();
    k();
    var Hl = Ae(Pu());
    var Zl = Ae(mo());
    var Kl = Object.defineProperty;
    var ai = d((e2, t) => Kl(e2, "name", { value: t, configurable: true }), "__name");
    function ma(e2 = "") {
      return (0, Zl.default)(e2).trimRight() + `
`;
    }
    y(ma, "Ha");
    d(ma, "format");
    ai(ma, "format");
    function va(e2, t, r = true, n = false) {
      try {
        return (0, Hl.default)(t, { argv: e2, stopAtPositional: r, permissive: n });
      } catch (i) {
        return i;
      }
    }
    y(va, "Ya");
    d(va, "arg");
    ai(va, "arg");
    function Qr(e2) {
      return e2 instanceof Error;
    }
    y(Qr, "Xt");
    d(Qr, "isError");
    ai(Qr, "isError");
    j();
    N();
    I();
    k();
    var Ql = Object.defineProperty;
    var Xl = d((e2, t) => Ql(e2, "name", { value: t, configurable: true }), "__name");
    var ec = { transactionApi: "transaction", aggregateApi: "aggregations" };
    function si(e2) {
      return Array.isArray(e2) && e2.length > 0 ? e2.map((t) => {
        var r;
        return (r = ec[t]) != null ? r : t;
      }) : [];
    }
    y(si, "Sn");
    d(si, "mapPreviewFeatures");
    Xl(si, "mapPreviewFeatures");
    var ui = {};
    io(ui, { error: () => pi, info: () => fi, log: () => li, query: () => di, should: () => ba, tags: () => Sr, warn: () => ci });
    j();
    N();
    I();
    k();
    var Xr = Ae(Wt());
    var tc = Object.defineProperty;
    var Tr = d((e2, t) => tc(e2, "name", { value: t, configurable: true }), "__name");
    var Sr = { error: Xr.default.red("prisma:error"), warn: Xr.default.yellow("prisma:warn"), info: Xr.default.cyan("prisma:info"), query: Xr.default.blue("prisma:query") };
    var ba = { warn: !we.env.PRISMA_DISABLE_WARNINGS };
    function li(...e2) {
      console.log(...e2);
    }
    y(li, "Ka");
    d(li, "log");
    Tr(li, "log");
    function ci(e2, ...t) {
      ba.warn && console.warn(`${Sr.warn} ${e2}`, ...t);
    }
    y(ci, "Za");
    d(ci, "warn");
    Tr(ci, "warn");
    function fi(e2, ...t) {
      console.info(`${Sr.info} ${e2}`, ...t);
    }
    y(fi, "Xa");
    d(fi, "info");
    Tr(fi, "info");
    function pi(e2, ...t) {
      console.error(`${Sr.error} ${e2}`, ...t);
    }
    y(pi, "eu");
    d(pi, "error");
    Tr(pi, "error");
    function di(e2, ...t) {
      console.log(`${Sr.query} ${e2}`, ...t);
    }
    y(di, "tu");
    d(di, "query");
    Tr(di, "query");
    var bf = Ae(Tu());
    var wf = Ae(Nu());
    go();
    var en = Ae(yo());
    var xr = Ae(vo());
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    var rc = typeof ct == "object" ? ct : pr;
    j();
    N();
    I();
    k();
    var nr = "1.0.3";
    j();
    N();
    I();
    k();
    var wa = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
    function _a(e2) {
      var t = /* @__PURE__ */ new Set([e2]), r = /* @__PURE__ */ new Set(), n = e2.match(wa);
      if (!n)
        return function() {
          return false;
        };
      var i = { major: +n[1], minor: +n[2], patch: +n[3], prerelease: n[4] };
      if (i.prerelease != null)
        return d(function(l) {
          return l === e2;
        }, "isExactmatch");
      function a(l) {
        return r.add(l), false;
      }
      y(a, "i"), d(a, "_reject");
      function o(l) {
        return t.add(l), true;
      }
      return y(o, "s"), d(o, "_accept"), d(function(l) {
        if (t.has(l))
          return true;
        if (r.has(l))
          return false;
        var f = l.match(wa);
        if (!f)
          return a(l);
        var s = { major: +f[1], minor: +f[2], patch: +f[3], prerelease: f[4] };
        return s.prerelease != null || i.major !== s.major ? a(l) : i.major === 0 ? i.minor === s.minor && i.patch <= s.patch ? o(l) : a(l) : i.minor <= s.minor ? o(l) : a(l);
      }, "isCompatible");
    }
    y(_a, "ng");
    d(_a, "_makeCompatibilityCheck");
    var nc = _a(nr);
    var ic = nr.split(".")[0];
    var Pr = Symbol.for("opentelemetry.js.api." + ic);
    var jr = rc;
    function Nr(e2, t, r, n) {
      var i;
      n === void 0 && (n = false);
      var a = jr[Pr] = (i = jr[Pr]) !== null && i !== void 0 ? i : { version: nr };
      if (!n && a[e2]) {
        var o = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + e2);
        return r.error(o.stack || o.message), false;
      }
      if (a.version !== nr) {
        var o = new Error("@opentelemetry/api: All API registration versions must match");
        return r.error(o.stack || o.message), false;
      }
      return a[e2] = t, r.debug("@opentelemetry/api: Registered a global for " + e2 + " v" + nr + "."), true;
    }
    y(Nr, "lt");
    d(Nr, "registerGlobal");
    function Ft(e2) {
      var t, r, n = (t = jr[Pr]) === null || t === void 0 ? void 0 : t.version;
      if (!(!n || !nc(n)))
        return (r = jr[Pr]) === null || r === void 0 ? void 0 : r[e2];
    }
    y(Ft, "Fe");
    d(Ft, "getGlobal");
    function kr(e2, t) {
      t.debug("@opentelemetry/api: Unregistering a global for " + e2 + " v" + nr + ".");
      var r = jr[Pr];
      r && delete r[e2];
    }
    y(kr, "ct");
    d(kr, "unregisterGlobal");
    var oc = function() {
      function e2(t) {
        this._namespace = t.namespace || "DiagComponentLogger";
      }
      return y(e2, "e"), d(e2, "DiagComponentLogger"), e2.prototype.debug = function() {
        for (var t = [], r = 0; r < arguments.length; r++)
          t[r] = arguments[r];
        return ir("debug", this._namespace, t);
      }, e2.prototype.error = function() {
        for (var t = [], r = 0; r < arguments.length; r++)
          t[r] = arguments[r];
        return ir("error", this._namespace, t);
      }, e2.prototype.info = function() {
        for (var t = [], r = 0; r < arguments.length; r++)
          t[r] = arguments[r];
        return ir("info", this._namespace, t);
      }, e2.prototype.warn = function() {
        for (var t = [], r = 0; r < arguments.length; r++)
          t[r] = arguments[r];
        return ir("warn", this._namespace, t);
      }, e2.prototype.verbose = function() {
        for (var t = [], r = 0; r < arguments.length; r++)
          t[r] = arguments[r];
        return ir("verbose", this._namespace, t);
      }, e2;
    }();
    function ir(e2, t, r) {
      var n = Ft("diag");
      if (n)
        return r.unshift(t), n[e2].apply(n, r);
    }
    y(ir, "Fr");
    d(ir, "logProxy");
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    var Ke;
    (function(e2) {
      e2[e2.NONE = 0] = "NONE", e2[e2.ERROR = 30] = "ERROR", e2[e2.WARN = 50] = "WARN", e2[e2.INFO = 60] = "INFO", e2[e2.DEBUG = 70] = "DEBUG", e2[e2.VERBOSE = 80] = "VERBOSE", e2[e2.ALL = 9999] = "ALL";
    })(Ke || (Ke = {}));
    function Ea(e2, t) {
      e2 < Ke.NONE ? e2 = Ke.NONE : e2 > Ke.ALL && (e2 = Ke.ALL), t = t || {};
      function r(n, i) {
        var a = t[n];
        return typeof a == "function" && e2 >= i ? a.bind(t) : function() {
        };
      }
      return y(r, "r"), d(r, "_filterFunc"), { error: r("error", Ke.ERROR), warn: r("warn", Ke.WARN), info: r("info", Ke.INFO), debug: r("debug", Ke.DEBUG), verbose: r("verbose", Ke.VERBOSE) };
    }
    y(Ea, "cu");
    d(Ea, "createLogLevelDiagLogger");
    var ac = "diag";
    var xt = function() {
      function e2() {
        function t(n) {
          return function() {
            var i = Ft("diag");
            if (i)
              return i[n].apply(i, arguments);
          };
        }
        y(t, "t"), d(t, "_logProxy");
        var r = this;
        r.setLogger = function(n, i) {
          var a, o;
          if (i === void 0 && (i = Ke.INFO), n === r) {
            var l = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
            return r.error((a = l.stack) !== null && a !== void 0 ? a : l.message), false;
          }
          var f = Ft("diag"), s = Ea(i, n);
          if (f) {
            var c = (o = new Error().stack) !== null && o !== void 0 ? o : "<failed to generate stacktrace>";
            f.warn("Current logger will be overwritten from " + c), s.warn("Current logger will overwrite one already registered from " + c);
          }
          return Nr("diag", s, r, true);
        }, r.disable = function() {
          kr(ac, r);
        }, r.createComponentLogger = function(n) {
          return new oc(n);
        }, r.verbose = t("verbose"), r.debug = t("debug"), r.info = t("info"), r.warn = t("warn"), r.error = t("error");
      }
      return y(e2, "e"), d(e2, "DiagAPI"), e2.instance = function() {
        return this._instance || (this._instance = new e2()), this._instance;
      }, e2;
    }();
    j();
    N();
    I();
    k();
    var sc = function() {
      function e2(t) {
        this._entries = t ? new Map(t) : /* @__PURE__ */ new Map();
      }
      return y(e2, "e"), d(e2, "BaggageImpl"), e2.prototype.getEntry = function(t) {
        var r = this._entries.get(t);
        if (r)
          return Object.assign({}, r);
      }, e2.prototype.getAllEntries = function() {
        return Array.from(this._entries.entries()).map(function(t) {
          var r = t[0], n = t[1];
          return [r, n];
        });
      }, e2.prototype.setEntry = function(t, r) {
        var n = new e2(this._entries);
        return n._entries.set(t, r), n;
      }, e2.prototype.removeEntry = function(t) {
        var r = new e2(this._entries);
        return r._entries.delete(t), r;
      }, e2.prototype.removeEntries = function() {
        for (var t = [], r = 0; r < arguments.length; r++)
          t[r] = arguments[r];
        for (var n = new e2(this._entries), i = 0, a = t; i < a.length; i++) {
          var o = a[i];
          n._entries.delete(o);
        }
        return n;
      }, e2.prototype.clear = function() {
        return new e2();
      }, e2;
    }();
    j();
    N();
    I();
    k();
    var _f = Symbol("BaggageEntryMetadata");
    var Ef = xt.instance();
    function Aa(e2) {
      return e2 === void 0 && (e2 = {}), new sc(new Map(Object.entries(e2)));
    }
    y(Aa, "pu");
    d(Aa, "createBaggage");
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    var hi = [{ n: "error", c: "error" }, { n: "warn", c: "warn" }, { n: "info", c: "info" }, { n: "debug", c: "debug" }, { n: "verbose", c: "trace" }];
    var Af = function() {
      function e2() {
        function t(n) {
          return function() {
            var i = arguments;
            if (console) {
              var a = console[n];
              if (typeof a != "function" && (a = console.log), typeof a == "function")
                return a.apply(console, i);
            }
          };
        }
        y(t, "t"), d(t, "_consoleFunc");
        for (var r = 0; r < hi.length; r++)
          this[hi[r].n] = t(hi[r].c);
      }
      return y(e2, "e"), d(e2, "DiagConsoleLogger"), e2;
    }();
    j();
    N();
    I();
    k();
    var uc = { get: function(e2, t) {
      if (e2 != null)
        return e2[t];
    }, keys: function(e2) {
      return e2 == null ? [] : Object.keys(e2);
    } };
    var lc = { set: function(e2, t, r) {
      e2 != null && (e2[t] = r);
    } };
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    function gi(e2) {
      return Symbol.for(e2);
    }
    y(gi, "Mn");
    d(gi, "createContextKey");
    var cc = function() {
      function e2(t) {
        var r = this;
        r._currentContext = t ? new Map(t) : /* @__PURE__ */ new Map(), r.getValue = function(n) {
          return r._currentContext.get(n);
        }, r.setValue = function(n, i) {
          var a = new e2(r._currentContext);
          return a._currentContext.set(n, i), a;
        }, r.deleteValue = function(n) {
          var i = new e2(r._currentContext);
          return i._currentContext.delete(n), i;
        };
      }
      return y(e2, "e"), d(e2, "BaseContext"), e2;
    }();
    var fc = new cc();
    var pc = y(function(e2, t) {
      for (var r = 0, n = t.length, i = e2.length; r < n; r++, i++)
        e2[i] = t[r];
      return e2;
    }, "ug");
    var dc = function() {
      function e2() {
      }
      return y(e2, "e"), d(e2, "NoopContextManager"), e2.prototype.active = function() {
        return fc;
      }, e2.prototype.with = function(t, r, n) {
        for (var i = [], a = 3; a < arguments.length; a++)
          i[a - 3] = arguments[a];
        return r.call.apply(r, pc([n], i));
      }, e2.prototype.bind = function(t, r) {
        return r;
      }, e2.prototype.enable = function() {
        return this;
      }, e2.prototype.disable = function() {
        return this;
      }, e2;
    }();
    var hc = y(function(e2, t) {
      for (var r = 0, n = t.length, i = e2.length; r < n; r++, i++)
        e2[i] = t[r];
      return e2;
    }, "lg");
    var yi = "context";
    var gc = new dc();
    var Oa = function() {
      function e2() {
      }
      return y(e2, "e"), d(e2, "ContextAPI"), e2.getInstance = function() {
        return this._instance || (this._instance = new e2()), this._instance;
      }, e2.prototype.setGlobalContextManager = function(t) {
        return Nr(yi, t, xt.instance());
      }, e2.prototype.active = function() {
        return this._getContextManager().active();
      }, e2.prototype.with = function(t, r, n) {
        for (var i, a = [], o = 3; o < arguments.length; o++)
          a[o - 3] = arguments[o];
        return (i = this._getContextManager()).with.apply(i, hc([t, r, n], a));
      }, e2.prototype.bind = function(t, r) {
        return this._getContextManager().bind(t, r);
      }, e2.prototype._getContextManager = function() {
        return Ft(yi) || gc;
      }, e2.prototype.disable = function() {
        this._getContextManager().disable(), kr(yi, xt.instance());
      }, e2;
    }();
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    var mi;
    (function(e2) {
      e2[e2.NONE = 0] = "NONE", e2[e2.SAMPLED = 1] = "SAMPLED";
    })(mi || (mi = {}));
    var Ta = "0000000000000000";
    var Sa = "00000000000000000000000000000000";
    var yc = { traceId: Sa, spanId: Ta, traceFlags: mi.NONE };
    var Ir = function() {
      function e2(t) {
        t === void 0 && (t = yc), this._spanContext = t;
      }
      return y(e2, "e"), d(e2, "NonRecordingSpan"), e2.prototype.spanContext = function() {
        return this._spanContext;
      }, e2.prototype.setAttribute = function(t, r) {
        return this;
      }, e2.prototype.setAttributes = function(t) {
        return this;
      }, e2.prototype.addEvent = function(t, r) {
        return this;
      }, e2.prototype.setStatus = function(t) {
        return this;
      }, e2.prototype.updateName = function(t) {
        return this;
      }, e2.prototype.end = function(t) {
      }, e2.prototype.isRecording = function() {
        return false;
      }, e2.prototype.recordException = function(t, r) {
      }, e2;
    }();
    var vi = gi("OpenTelemetry Context Key SPAN");
    function bi(e2) {
      return e2.getValue(vi) || void 0;
    }
    y(bi, "ui");
    d(bi, "getSpan");
    function tn(e2, t) {
      return e2.setValue(vi, t);
    }
    y(tn, "Rr");
    d(tn, "setSpan");
    function xa(e2) {
      return e2.deleteValue(vi);
    }
    y(xa, "yu");
    d(xa, "deleteSpan");
    function Pa(e2, t) {
      return tn(e2, new Ir(t));
    }
    y(Pa, "bu");
    d(Pa, "setSpanContext");
    function wi(e2) {
      var t;
      return (t = bi(e2)) === null || t === void 0 ? void 0 : t.spanContext();
    }
    y(wi, "Fn");
    d(wi, "getSpanContext");
    j();
    N();
    I();
    k();
    var mc = /^([0-9a-f]{32})$/i;
    var vc = /^[0-9a-f]{16}$/i;
    function ja(e2) {
      return mc.test(e2) && e2 !== Sa;
    }
    y(ja, "wu");
    d(ja, "isValidTraceId");
    function Na(e2) {
      return vc.test(e2) && e2 !== Ta;
    }
    y(Na, "vu");
    d(Na, "isValidSpanId");
    function _i(e2) {
      return ja(e2.traceId) && Na(e2.spanId);
    }
    y(_i, "Nr");
    d(_i, "isSpanContextValid");
    function ka(e2) {
      return new Ir(e2);
    }
    y(ka, "Eu");
    d(ka, "wrapSpanContext");
    var Ia = Oa.getInstance();
    var $a = function() {
      function e2() {
      }
      return y(e2, "e"), d(e2, "NoopTracer"), e2.prototype.startSpan = function(t, r, n) {
        var i = Boolean(r == null ? void 0 : r.root);
        if (i)
          return new Ir();
        var a = n && wi(n);
        return Ma(a) && _i(a) ? new Ir(a) : new Ir();
      }, e2.prototype.startActiveSpan = function(t, r, n, i) {
        var a, o, l;
        if (!(arguments.length < 2)) {
          arguments.length === 2 ? l = r : arguments.length === 3 ? (a = r, l = n) : (a = r, o = n, l = i);
          var f = o != null ? o : Ia.active(), s = this.startSpan(t, a, f), c = tn(f, s);
          return Ia.with(c, l, void 0, s);
        }
      }, e2;
    }();
    function Ma(e2) {
      return typeof e2 == "object" && typeof e2.spanId == "string" && typeof e2.traceId == "string" && typeof e2.traceFlags == "number";
    }
    y(Ma, "dg");
    d(Ma, "isSpanContext");
    var bc = new $a();
    var wc = function() {
      function e2(t, r, n) {
        this._provider = t, this.name = r, this.version = n;
      }
      return y(e2, "e"), d(e2, "ProxyTracer"), e2.prototype.startSpan = function(t, r, n) {
        return this._getTracer().startSpan(t, r, n);
      }, e2.prototype.startActiveSpan = function(t, r, n, i) {
        var a = this._getTracer();
        return Reflect.apply(a.startActiveSpan, a, arguments);
      }, e2.prototype._getTracer = function() {
        if (this._delegate)
          return this._delegate;
        var t = this._provider.getDelegateTracer(this.name, this.version);
        return t ? (this._delegate = t, this._delegate) : bc;
      }, e2;
    }();
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    var _c = function() {
      function e2() {
      }
      return y(e2, "e"), d(e2, "NoopTracerProvider"), e2.prototype.getTracer = function(t, r) {
        return new $a();
      }, e2;
    }();
    var Ec = new _c();
    var Fa = function() {
      function e2() {
      }
      return y(e2, "e"), d(e2, "ProxyTracerProvider"), e2.prototype.getTracer = function(t, r) {
        var n;
        return (n = this.getDelegateTracer(t, r)) !== null && n !== void 0 ? n : new wc(this, t, r);
      }, e2.prototype.getDelegate = function() {
        var t;
        return (t = this._delegate) !== null && t !== void 0 ? t : Ec;
      }, e2.prototype.setDelegate = function(t) {
        this._delegate = t;
      }, e2.prototype.getDelegateTracer = function(t, r) {
        var n;
        return (n = this._delegate) === null || n === void 0 ? void 0 : n.getTracer(t, r);
      }, e2;
    }();
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    var Ra;
    (function(e2) {
      e2[e2.NOT_RECORD = 0] = "NOT_RECORD", e2[e2.RECORD = 1] = "RECORD", e2[e2.RECORD_AND_SAMPLED = 2] = "RECORD_AND_SAMPLED";
    })(Ra || (Ra = {}));
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    var Ba;
    (function(e2) {
      e2[e2.INTERNAL = 0] = "INTERNAL", e2[e2.SERVER = 1] = "SERVER", e2[e2.CLIENT = 2] = "CLIENT", e2[e2.PRODUCER = 3] = "PRODUCER", e2[e2.CONSUMER = 4] = "CONSUMER";
    })(Ba || (Ba = {}));
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    var Ca;
    (function(e2) {
      e2[e2.UNSET = 0] = "UNSET", e2[e2.OK = 1] = "OK", e2[e2.ERROR = 2] = "ERROR";
    })(Ca || (Ca = {}));
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    var Ei = "trace";
    var Ac = function() {
      function e2() {
        this._proxyTracerProvider = new Fa(), this.wrapSpanContext = ka, this.isSpanContextValid = _i, this.deleteSpan = xa, this.getSpan = bi, this.getSpanContext = wi, this.setSpan = tn, this.setSpanContext = Pa;
      }
      return y(e2, "e"), d(e2, "TraceAPI"), e2.getInstance = function() {
        return this._instance || (this._instance = new e2()), this._instance;
      }, e2.prototype.setGlobalTracerProvider = function(t) {
        var r = Nr(Ei, this._proxyTracerProvider, xt.instance());
        return r && this._proxyTracerProvider.setDelegate(t), r;
      }, e2.prototype.getTracerProvider = function() {
        return Ft(Ei) || this._proxyTracerProvider;
      }, e2.prototype.getTracer = function(t, r) {
        return this.getTracerProvider().getTracer(t, r);
      }, e2.prototype.disable = function() {
        kr(Ei, xt.instance()), this._proxyTracerProvider = new Fa();
      }, e2;
    }();
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    var Oc = function() {
      function e2() {
      }
      return y(e2, "e"), d(e2, "NoopTextMapPropagator"), e2.prototype.inject = function(t, r) {
      }, e2.prototype.extract = function(t, r) {
        return t;
      }, e2.prototype.fields = function() {
        return [];
      }, e2;
    }();
    j();
    N();
    I();
    k();
    var Ai = gi("OpenTelemetry Baggage Key");
    function qa(e2) {
      return e2.getValue(Ai) || void 0;
    }
    y(qa, "Iu");
    d(qa, "getBaggage");
    function La(e2, t) {
      return e2.setValue(Ai, t);
    }
    y(La, "ku");
    d(La, "setBaggage");
    function Ua(e2) {
      return e2.deleteValue(Ai);
    }
    y(Ua, "ju");
    d(Ua, "deleteBaggage");
    var Oi = "propagation";
    var Tc = new Oc();
    var Sc = function() {
      function e2() {
        this.createBaggage = Aa, this.getBaggage = qa, this.setBaggage = La, this.deleteBaggage = Ua;
      }
      return y(e2, "e"), d(e2, "PropagationAPI"), e2.getInstance = function() {
        return this._instance || (this._instance = new e2()), this._instance;
      }, e2.prototype.setGlobalPropagator = function(t) {
        return Nr(Oi, t, xt.instance());
      }, e2.prototype.inject = function(t, r, n) {
        return n === void 0 && (n = lc), this._getGlobalPropagator().inject(t, r, n);
      }, e2.prototype.extract = function(t, r, n) {
        return n === void 0 && (n = uc), this._getGlobalPropagator().extract(t, r, n);
      }, e2.prototype.fields = function() {
        return this._getGlobalPropagator().fields();
      }, e2.prototype.disable = function() {
        kr(Oi, xt.instance());
      }, e2.prototype._getGlobalPropagator = function() {
        return Ft(Oi) || Tc;
      }, e2;
    }();
    var Da = Oa.getInstance();
    var Ti = Ac.getInstance();
    var Of = Sc.getInstance();
    var Tf = xt.instance();
    function Rt(e2) {
      let t = Da.active(), r, n = d((i, a) => {
        try {
          return r != null ? r : r = e2(i, a, t);
        } catch (o) {
          return Promise.reject(o);
        }
      }, "_callback");
      return { then(i, a, o) {
        return n(o).then(i, a, o);
      }, catch(i, a) {
        return n(a).catch(i, a);
      }, finally(i, a) {
        return n(a).finally(i, a);
      }, requestTransaction(i, a) {
        let o = n(i, a);
        return o.requestTransaction ? o.requestTransaction(i, a) : o;
      }, [Symbol.toStringTag]: "PrismaPromise" };
    }
    y(Rt, "pt");
    d(Rt, "createPrismaPromise");
    j();
    N();
    I();
    k();
    function Bt(e2) {
      if (e2 !== "minimal")
        return new Error().stack;
    }
    y(Bt, "Ye");
    d(Bt, "getCallSite");
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    var xc = { _avg: true, _count: true, _sum: true, _min: true, _max: true };
    function Si(e2) {
      let t = Va(e2);
      return Object.entries(t).reduce((r, [n, i]) => (xc[n] !== void 0 ? r.select[n] = { select: i } : r[n] = i, r), { select: {} });
    }
    y(Si, "di");
    d(Si, "desugarUserArgs");
    function Va(e2) {
      return typeof e2._count == "boolean" ? { ...e2, _count: { _all: e2._count } } : e2;
    }
    y(Va, "yg");
    d(Va, "desugarCountInUserArgs");
    function Ga(e2) {
      return (t) => (typeof e2._count == "boolean" && (t._count = t._count._all), t);
    }
    y(Ga, "bg");
    d(Ga, "createUnpacker");
    function rn(e2, t, r) {
      let n = Si(t != null ? t : {}), i = Ga(t != null ? t : {});
      return r({ action: "aggregate", unpacker: i })(n);
    }
    y(rn, "Dr");
    d(rn, "aggregate");
    j();
    N();
    I();
    k();
    function Ja(e2, t, r) {
      let { select: n, ...i } = t != null ? t : {};
      return typeof n == "object" ? rn(e2, { ...i, _count: n }, (a) => r({ ...a, action: "count", unpacker: (o) => {
        var l;
        return (l = a.unpacker) == null ? void 0 : l.call(a, o)._count;
      } })) : rn(e2, { ...i, _count: { _all: true } }, (a) => r({ ...a, action: "count", unpacker: (o) => {
        var l;
        return (l = a.unpacker) == null ? void 0 : l.call(a, o)._count._all;
      } }));
    }
    y(Ja, "Nu");
    d(Ja, "count");
    j();
    N();
    I();
    k();
    function Wa(e2) {
      let t = Si(e2);
      if (Array.isArray(e2.by))
        for (let r of e2.by)
          typeof r == "string" && (t.select[r] = true);
      return t;
    }
    y(Wa, "wg");
    d(Wa, "desugarUserArgs");
    function za(e2) {
      return (t) => (typeof e2._count == "boolean" && t.forEach((r) => {
        r._count = r._count._all;
      }), t);
    }
    y(za, "vg");
    d(za, "createUnpacker");
    function Ya(e2, t, r) {
      let n = Wa(t != null ? t : {}), i = za(t != null ? t : {});
      return r({ action: "groupBy", unpacker: i })(n);
    }
    y(Ya, "Cu");
    d(Ya, "groupBy");
    function Ha(e2, t, r) {
      if (t === "aggregate")
        return (n) => rn(e2, n, r);
      if (t === "count")
        return (n) => Ja(e2, n, r);
      if (t === "groupBy")
        return (n) => Ya(e2, n, r);
    }
    y(Ha, "Du");
    d(Ha, "applyAggregates");
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    var Za = d((e2) => Array.isArray(e2) ? e2 : e2.split("."), "keys");
    var Ka = d((e2, t) => Za(t).reduce((r, n) => r && r[n], e2), "deepGet");
    var Qa = d((e2, t, r) => Za(t).reduceRight((n, i, a, o) => Object.assign({}, Ka(e2, o.slice(0, a)), { [i]: n }), r), "deepSet");
    j();
    N();
    I();
    k();
    var Pc = { enumerable: true, configurable: true, writable: true };
    function nn(e2) {
      let t = new Set(e2);
      return { getOwnPropertyDescriptor: () => Pc, has: (r, n) => t.has(n), set: (r, n, i) => t.add(n) && Reflect.set(r, n, i), ownKeys: () => [...t] };
    }
    y(nn, "er");
    d(nn, "defaultProxyHandlers");
    function Xa(e2, t) {
      return e2 === void 0 || t === void 0 ? [] : [...t, "select", e2];
    }
    y(Xa, "_g");
    d(Xa, "getNextDataPath");
    function es(e2, t, r) {
      return t === void 0 ? e2 != null ? e2 : {} : Qa(t, r, e2 || true);
    }
    y(es, "Ag");
    d(es, "getNextUserArgs");
    function xi(e2, t, r, n, i, a) {
      let o = e2._dmmf.modelMap[t].fields.reduce((l, f) => ({ ...l, [f.name]: f }), {});
      return (l) => {
        let f = Bt(e2._errorFormat), s = Xa(n, i), c = es(l, a, s), p = r({ dataPath: s, callsite: f })(c), g = ts(e2, t);
        return new Proxy(p, { get(v, b) {
          if (!g.includes(b))
            return v[b];
          let w = [o[b].type, r, b], E = [s, c];
          return xi(e2, ...w, ...E);
        }, ...nn([...g, ...Object.getOwnPropertyNames(p)]) });
      };
    }
    y(xi, "mi");
    d(xi, "applyFluent");
    function ts(e2, t) {
      return e2._dmmf.modelMap[t].fields.filter((r) => r.kind === "object").map((r) => r.name);
    }
    y(ts, "xg");
    d(ts, "getOwnKeys");
    j();
    N();
    I();
    k();
    function Pi(e2) {
      return e2.replace(/^./, (t) => t.toLowerCase());
    }
    y(Pi, "Dn");
    d(Pi, "dmmfToJSModelName");
    var jc = ["findUnique", "findFirst", "create", "update", "upsert", "delete"];
    var Nc = ["aggregate", "count", "groupBy"];
    function ji(e2, t) {
      let r = Pi(t), n = Ni(e2, t), i = {};
      return new Proxy(i, { get(a, o) {
        if (o in a || typeof o == "symbol")
          return a[o];
        if (!rs(e2, t, o))
          return;
        let l = d((f) => (s) => {
          let c = Bt(e2._errorFormat);
          return Rt((p, g, v) => {
            let b = { args: s, dataPath: [] }, w = { action: o, model: t }, E = { clientMethod: `${r}.${o}` }, x = { ...b, ...w, ...E, runInTransaction: !!p, transactionId: p, lock: g, callsite: c, otelCtx: v };
            return e2._request({ ...x, ...f });
          });
        }, "action");
        return jc.includes(o) ? xi(e2, t, l) : Nc.includes(o) ? Ha(e2, o, l) : l({});
      }, ...nn(n) });
    }
    y(ji, "hi");
    d(ji, "applyModel");
    function Ni(e2, t) {
      return [...Object.keys(e2._dmmf.mappingsMap[t]), "count"].filter((r) => !["model", "plural"].includes(r));
    }
    y(Ni, "Bu");
    d(Ni, "getOwnKeys");
    function rs(e2, t, r) {
      return Ni(e2, t).includes(r);
    }
    y(rs, "Sg");
    d(rs, "isValidActionName");
    j();
    N();
    I();
    k();
    function ns(e2) {
      return e2.replace(/^./, (t) => t.toUpperCase());
    }
    y(ns, "Lu");
    d(ns, "jsToDMMFModelName");
    function is(e2) {
      let t = {}, r = os(e2);
      return new Proxy(e2, { get(n, i) {
        if (i in n || typeof i == "symbol")
          return n[i];
        let a = ns(i);
        if (t[a] !== void 0)
          return t[a];
        if (e2._dmmf.modelMap[a] !== void 0)
          return t[a] = ji(e2, a);
        if (e2._dmmf.modelMap[i] !== void 0)
          return t[a] = ji(e2, i);
      }, ...nn(r) });
    }
    y(is, "qu");
    d(is, "applyModels");
    function os(e2) {
      return [...Object.keys(e2._dmmf.modelMap).map(Pi), ...Object.keys(e2)];
    }
    y(os, "Mg");
    d(os, "getOwnKeys");
    j();
    N();
    I();
    k();
    function as(e2, t = () => {
    }) {
      let r, n = new Promise((i) => r = i);
      return { then(i) {
        return --e2 == 0 && r(t()), i == null ? void 0 : i(n);
      } };
    }
    y(as, "Uu");
    d(as, "getLockCountPromise");
    j();
    N();
    I();
    k();
    function ss(e2) {
      return typeof e2 == "string" ? e2 : e2.reduce((t, r) => {
        let n = typeof r == "string" ? r : r.level;
        return n === "query" ? t : t && (r === "info" || t === "info") ? "info" : n;
      }, void 0);
    }
    y(ss, "Vu");
    d(ss, "getLogLevel");
    j();
    N();
    I();
    k();
    function us(e2, t, r) {
      let n = ls(e2, r), i = ls(t, r), a = Object.values(i).map((l) => l[l.length - 1]), o = Object.keys(i);
      return Object.entries(n).forEach(([l, f]) => {
        o.includes(l) || a.push(f[f.length - 1]);
      }), a;
    }
    y(us, "Gu");
    d(us, "mergeBy");
    var ls = d((e2, t) => e2.reduce((r, n) => {
      let i = t(n);
      return r[i] || (r[i] = []), r[i].push(n), r;
    }, {}), "groupBy");
    j();
    N();
    I();
    k();
    var ki = y(class {
      constructor() {
        this._middlewares = [];
      }
      use(e2) {
        this._middlewares.push(e2);
      }
      get(e2) {
        return this._middlewares[e2];
      }
      has(e2) {
        return !!this._middlewares[e2];
      }
      length() {
        return this._middlewares.length;
      }
    }, "$n");
    d(ki, "MiddlewareHandler");
    var cs = y(class {
      constructor() {
        this.query = new ki(), this.engine = new ki();
      }
    }, "Bn");
    d(cs, "Middlewares");
    j();
    N();
    I();
    k();
    var K = Ae(Wt());
    var Ct = Ae(so());
    var fs = Ae(Pn());
    j();
    N();
    I();
    k();
    function Ii(e2) {
      return e2 instanceof Ge.Buffer || e2 instanceof Date || e2 instanceof RegExp;
    }
    y(Ii, "zu");
    d(Ii, "isSpecificValue");
    function $i(e2) {
      if (e2 instanceof Ge.Buffer) {
        let t = Ge.Buffer.alloc ? Ge.Buffer.alloc(e2.length) : new Ge.Buffer(e2.length);
        return e2.copy(t), t;
      } else {
        if (e2 instanceof Date)
          return new Date(e2.getTime());
        if (e2 instanceof RegExp)
          return new RegExp(e2);
        throw new Error("Unexpected situation");
      }
    }
    y($i, "Wu");
    d($i, "cloneSpecificValue");
    function Mi(e2) {
      let t = [];
      return e2.forEach(function(r, n) {
        typeof r == "object" && r !== null ? Array.isArray(r) ? t[n] = Mi(r) : Ii(r) ? t[n] = $i(r) : t[n] = on({}, r) : t[n] = r;
      }), t;
    }
    y(Mi, "Hu");
    d(Mi, "deepCloneArray");
    function Fi(e2, t) {
      return t === "__proto__" ? void 0 : e2[t];
    }
    y(Fi, "Yu");
    d(Fi, "safeGetProperty");
    var on = d(function(e2, ...t) {
      if (!e2 || typeof e2 != "object")
        return false;
      if (t.length === 0)
        return e2;
      let r, n;
      for (let i of t)
        if (!(typeof i != "object" || i === null || Array.isArray(i))) {
          for (let a of Object.keys(i))
            if (n = Fi(e2, a), r = Fi(i, a), r !== e2)
              if (typeof r != "object" || r === null) {
                e2[a] = r;
                continue;
              } else if (Array.isArray(r)) {
                e2[a] = Mi(r);
                continue;
              } else if (Ii(r)) {
                e2[a] = $i(r);
                continue;
              } else if (typeof n != "object" || n === null || Array.isArray(n)) {
                e2[a] = on({}, r);
                continue;
              } else {
                e2[a] = on(n, r);
                continue;
              }
        }
      return e2;
    }, "deepExtend");
    j();
    N();
    I();
    k();
    function ps(e2, t) {
      if (!e2 || typeof e2 != "object" || typeof e2.hasOwnProperty != "function")
        return e2;
      let r = {};
      for (let n in e2) {
        let i = e2[n];
        Object.hasOwnProperty.call(e2, n) && t(n, i) && (r[n] = i);
      }
      return r;
    }
    y(ps, "Qu");
    d(ps, "filterObject");
    j();
    N();
    I();
    k();
    function ds(e2) {
      return Array.prototype.concat.apply([], e2);
    }
    y(ds, "Og");
    d(ds, "flatten");
    function Ri(e2, t, r) {
      return ds(e2.map(t, r));
    }
    y(Ri, "yi");
    d(Ri, "flatMap");
    j();
    N();
    I();
    k();
    var kc = { "[object Date]": true, "[object BitInt]": true, "[object Uint8Array]": true, "[object Function]": true };
    function hs(e2) {
      return e2 && typeof e2 == "object" && !kc[Object.prototype.toString.call(e2)];
    }
    y(hs, "Ku");
    d(hs, "isObject");
    j();
    N();
    I();
    k();
    function gs(e2, t) {
      let r = {}, n = Array.isArray(t) ? t : [t];
      for (let i in e2)
        Object.hasOwnProperty.call(e2, i) && !n.includes(i) && (r[i] = e2[i]);
      return r;
    }
    y(gs, "Zu");
    d(gs, "omit");
    j();
    N();
    I();
    k();
    var Qe = Ae(Wt());
    var ys = Ae(Pn());
    j();
    N();
    I();
    k();
    var Ic = ku();
    var $c = Iu();
    var Mc = $u().default;
    var Fc = d((e2, t, r) => {
      let n = [];
      return d(y(function i(a, o = {}, l = "", f = []) {
        o.indent = o.indent || "	";
        let s;
        o.inlineCharacterLimit === void 0 ? s = { newLine: `
`, newLineOrSpace: `
`, pad: l, indent: l + o.indent } : s = { newLine: "@@__STRINGIFY_OBJECT_NEW_LINE__@@", newLineOrSpace: "@@__STRINGIFY_OBJECT_NEW_LINE_OR_SPACE__@@", pad: "@@__STRINGIFY_OBJECT_PAD__@@", indent: "@@__STRINGIFY_OBJECT_INDENT__@@" };
        let c = d((p) => {
          if (o.inlineCharacterLimit === void 0)
            return p;
          let g = p.replace(new RegExp(s.newLine, "g"), "").replace(new RegExp(s.newLineOrSpace, "g"), " ").replace(new RegExp(s.pad + "|" + s.indent, "g"), "");
          return g.length <= o.inlineCharacterLimit ? g : p.replace(new RegExp(s.newLine + "|" + s.newLineOrSpace, "g"), `
`).replace(new RegExp(s.pad, "g"), l).replace(new RegExp(s.indent, "g"), l + o.indent);
        }, "expandWhiteSpace");
        if (n.indexOf(a) !== -1)
          return '"[Circular]"';
        if (Ge.Buffer.isBuffer(a))
          return `Buffer(${Ge.Buffer.length})`;
        if (a == null || typeof a == "number" || typeof a == "boolean" || typeof a == "function" || typeof a == "symbol" || Ic(a))
          return String(a);
        if (a instanceof Date)
          return `new Date('${a.toISOString()}')`;
        if (Array.isArray(a)) {
          if (a.length === 0)
            return "[]";
          n.push(a);
          let p = "[" + s.newLine + a.map((g, v) => {
            let b = a.length - 1 === v ? s.newLine : "," + s.newLineOrSpace, w = i(g, o, l + o.indent, [...f, v]);
            return o.transformValue && (w = o.transformValue(a, v, w)), s.indent + w + b;
          }).join("") + s.pad + "]";
          return n.pop(), c(p);
        }
        if ($c(a)) {
          let p = Object.keys(a).concat(Mc(a));
          if (o.filter && (p = p.filter((v) => o.filter(a, v))), p.length === 0)
            return "{}";
          n.push(a);
          let g = "{" + s.newLine + p.map((v, b) => {
            let w = p.length - 1 === b ? s.newLine : "," + s.newLineOrSpace, E = typeof v == "symbol", x = !E && /^[a-z$_][a-z$_0-9]*$/i.test(v), S = E || x ? v : i(v, o, void 0, [...f, v]), A = i(a[v], o, l + o.indent, [...f, v]);
            o.transformValue && (A = o.transformValue(a, v, A));
            let F = s.indent + String(S) + ": " + A + w;
            return o.transformLine && (F = o.transformLine({ obj: a, indent: s.indent, key: S, stringifiedValue: A, value: a[v], eol: w, originalLine: F, path: f.concat(S) })), F;
          }).join("") + s.pad + "}";
          return n.pop(), c(g);
        }
        return a = String(a).replace(/[\r\n]/g, (p) => p === `
` ? "\\n" : "\\r"), o.singleQuotes === false ? (a = a.replace(/"/g, '\\"'), `"${a}"`) : (a = a.replace(/\\?'/g, "\\'"), `'${a}'`);
      }, "o"), "stringifyObject")(e2, t, r);
    }, "stringifyObject");
    var Bi = Fc;
    var Ci = "@@__DIM_POINTER__@@";
    function qi({ ast: e2, keyPaths: t, valuePaths: r, missingItems: n }) {
      let i = e2;
      for (let { path: a, type: o } of n)
        i = Qa(i, a, o);
      return Bi(i, { indent: "  ", transformLine: ({ indent: a, key: o, value: l, stringifiedValue: f, eol: s, path: c }) => {
        let p = c.join("."), g = t.includes(p), v = r.includes(p), b = n.find((E) => E.path === p), w = f;
        if (b) {
          typeof l == "string" && (w = w.slice(1, w.length - 1));
          let E = b.isRequired ? "" : "?", x = b.isRequired ? "+" : "?", S = (b.isRequired ? Qe.default.greenBright : Qe.default.green)(bs(o + E + ": " + w + s, a, x));
          return b.isRequired || (S = Qe.default.dim(S)), S;
        } else {
          let E = n.some((F) => p.startsWith(F.path)), x = o[o.length - 2] === "?";
          x && (o = o.slice(1, o.length - 1)), x && typeof l == "object" && l !== null && (w = w.split(`
`).map((F, q, R) => q === R.length - 1 ? F + Ci : F).join(`
`)), E && typeof l == "string" && (w = w.slice(1, w.length - 1), x || (w = Qe.default.bold(w))), (typeof l != "object" || l === null) && !v && !E && (w = Qe.default.dim(w));
          let S = g ? Qe.default.redBright(o) : o;
          w = v ? Qe.default.redBright(w) : w;
          let A = a + S + ": " + w + (E ? s : Qe.default.dim(s));
          if (g || v) {
            let F = A.split(`
`), q = String(o).length, R = g ? Qe.default.redBright("~".repeat(q)) : " ".repeat(q), C = v ? ms(a, o, l, f) : 0, B = Boolean(v && typeof l == "object" && l !== null), W = v ? "  " + Qe.default.redBright("~".repeat(C)) : "";
            R && R.length > 0 && !B && F.splice(1, 0, a + R + W), R && R.length > 0 && B && F.splice(F.length - 1, 0, a.slice(0, a.length - 2) + W), A = F.join(`
`);
          }
          return A;
        }
      } });
    }
    y(qi, "Ln");
    d(qi, "printJsonWithErrors");
    function ms(e2, t, r, n) {
      return r === null ? 4 : typeof r == "string" ? r.length + 2 : typeof r == "object" ? Math.abs(vs(`${t}: ${(0, ys.default)(n)}`) - e2.length) : String(r).length;
    }
    y(ms, "Ng");
    d(ms, "getValueLength");
    function vs(e2) {
      return e2.split(`
`).reduce((t, r) => r.length > t ? r.length : t, 0);
    }
    y(vs, "Cg");
    d(vs, "getLongestLine");
    function bs(e2, t, r) {
      return e2.split(`
`).map((n, i, a) => i === 0 ? r + t.slice(1) + n : i < a.length - 1 ? r + n.slice(1) : n).map((n) => (0, ys.default)(n).includes(Ci) ? Qe.default.dim(n.replace(Ci, "")) : n.includes("?") ? Qe.default.dim(n) : n).join(`
`);
    }
    y(bs, "Dg");
    d(bs, "prefixLines");
    j();
    N();
    I();
    k();
    var Xe = Ae(Wt());
    j();
    N();
    I();
    k();
    var $r = "<unknown>";
    function ws(e2) {
      var t = e2.split(`
`);
      return t.reduce(function(r, n) {
        var i = _s(n) || Es(n) || As(n) || Ts(n) || Os(n);
        return i && r.push(i), r;
      }, []);
    }
    y(ws, "ol");
    d(ws, "parse");
    var Rc = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
    var Bc = /\((\S*)(?::(\d+))(?::(\d+))\)/;
    function _s(e2) {
      var t = Rc.exec(e2);
      if (!t)
        return null;
      var r = t[2] && t[2].indexOf("native") === 0, n = t[2] && t[2].indexOf("eval") === 0, i = Bc.exec(t[2]);
      return n && i != null && (t[2] = i[1], t[3] = i[2], t[4] = i[3]), { file: r ? null : t[2], methodName: t[1] || $r, arguments: r ? [t[2]] : [], lineNumber: t[3] ? +t[3] : null, column: t[4] ? +t[4] : null };
    }
    y(_s, "Lg");
    d(_s, "parseChrome");
    var Cc = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
    function Es(e2) {
      var t = Cc.exec(e2);
      return t ? { file: t[2], methodName: t[1] || $r, arguments: [], lineNumber: +t[3], column: t[4] ? +t[4] : null } : null;
    }
    y(Es, "Ug");
    d(Es, "parseWinjs");
    var qc = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
    var Lc = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
    function As(e2) {
      var t = qc.exec(e2);
      if (!t)
        return null;
      var r = t[3] && t[3].indexOf(" > eval") > -1, n = Lc.exec(t[3]);
      return r && n != null && (t[3] = n[1], t[4] = n[2], t[5] = null), { file: t[3], methodName: t[1] || $r, arguments: t[2] ? t[2].split(",") : [], lineNumber: t[4] ? +t[4] : null, column: t[5] ? +t[5] : null };
    }
    y(As, "Jg");
    d(As, "parseGecko");
    var Uc = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
    function Os(e2) {
      var t = Uc.exec(e2);
      return t ? { file: t[3], methodName: t[1] || $r, arguments: [], lineNumber: +t[4], column: t[5] ? +t[5] : null } : null;
    }
    y(Os, "Wg");
    d(Os, "parseJSC");
    var Dc = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
    function Ts(e2) {
      var t = Dc.exec(e2);
      return t ? { file: t[2], methodName: t[1] || $r, arguments: [], lineNumber: +t[3], column: t[4] ? +t[4] : null } : null;
    }
    y(Ts, "Yg");
    d(Ts, "parseNode");
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    var qt = Ae(Wt());
    var Vc = qt.default.rgb(246, 145, 95);
    var Gc = qt.default.rgb(107, 139, 140);
    var an = qt.default.cyan;
    var Ss = qt.default.rgb(127, 155, 155);
    var Jc = d((e2) => e2, "identity");
    var Wc = { keyword: an, entity: an, value: Ss, punctuation: Gc, directive: an, function: an, variable: Ss, string: qt.default.greenBright, boolean: Vc, number: qt.default.cyan, comment: qt.default.grey };
    var sn = {};
    var zc = 0;
    var fe = { manual: sn.Prism && sn.Prism.manual, disableWorkerMessageHandler: sn.Prism && sn.Prism.disableWorkerMessageHandler, util: { encode: function(e2) {
      if (e2 instanceof it) {
        let t = e2;
        return new it(t.type, fe.util.encode(t.content), t.alias);
      } else
        return Array.isArray(e2) ? e2.map(fe.util.encode) : e2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
    }, type: function(e2) {
      return Object.prototype.toString.call(e2).slice(8, -1);
    }, objId: function(e2) {
      return e2.__id || Object.defineProperty(e2, "__id", { value: ++zc }), e2.__id;
    }, clone: d(y(function e2(t, r) {
      let n, i, a = fe.util.type(t);
      switch (r = r || {}, a) {
        case "Object":
          if (i = fe.util.objId(t), r[i])
            return r[i];
          n = {}, r[i] = n;
          for (let o in t)
            t.hasOwnProperty(o) && (n[o] = e2(t[o], r));
          return n;
        case "Array":
          return i = fe.util.objId(t), r[i] ? r[i] : (n = [], r[i] = n, t.forEach(function(o, l) {
            n[l] = e2(o, r);
          }), n);
        default:
          return t;
      }
    }, "e"), "deepClone") }, languages: { extend: function(e2, t) {
      let r = fe.util.clone(fe.languages[e2]);
      for (let n in t)
        r[n] = t[n];
      return r;
    }, insertBefore: function(e2, t, r, n) {
      n = n || fe.languages;
      let i = n[e2], a = {};
      for (let l in i)
        if (i.hasOwnProperty(l)) {
          if (l == t)
            for (let f in r)
              r.hasOwnProperty(f) && (a[f] = r[f]);
          r.hasOwnProperty(l) || (a[l] = i[l]);
        }
      let o = n[e2];
      return n[e2] = a, fe.languages.DFS(fe.languages, function(l, f) {
        f === o && l != e2 && (this[l] = a);
      }), a;
    }, DFS: d(y(function e2(t, r, n, i) {
      i = i || {};
      let a = fe.util.objId;
      for (let o in t)
        if (t.hasOwnProperty(o)) {
          r.call(t, o, t[o], n || o);
          let l = t[o], f = fe.util.type(l);
          f === "Object" && !i[a(l)] ? (i[a(l)] = true, e2(l, r, null, i)) : f === "Array" && !i[a(l)] && (i[a(l)] = true, e2(l, r, o, i));
        }
    }, "e"), "DFS") }, plugins: {}, highlight: function(e2, t, r) {
      let n = { code: e2, grammar: t, language: r };
      return fe.hooks.run("before-tokenize", n), n.tokens = fe.tokenize(n.code, n.grammar), fe.hooks.run("after-tokenize", n), it.stringify(fe.util.encode(n.tokens), n.language);
    }, matchGrammar: function(e2, t, r, n, i, a, o) {
      for (let w in r) {
        if (!r.hasOwnProperty(w) || !r[w])
          continue;
        if (w == o)
          return;
        let E = r[w];
        E = fe.util.type(E) === "Array" ? E : [E];
        for (let x = 0; x < E.length; ++x) {
          let S = E[x], A = S.inside, F = !!S.lookbehind, q = !!S.greedy, R = 0, C = S.alias;
          if (q && !S.pattern.global) {
            let B = S.pattern.toString().match(/[imuy]*$/)[0];
            S.pattern = RegExp(S.pattern.source, B + "g");
          }
          S = S.pattern || S;
          for (let B = n, W = i; B < t.length; W += t[B].length, ++B) {
            let G = t[B];
            if (t.length > e2.length)
              return;
            if (G instanceof it)
              continue;
            if (q && B != t.length - 1) {
              S.lastIndex = W;
              var p = S.exec(e2);
              if (!p)
                break;
              var c = p.index + (F ? p[1].length : 0), g = p.index + p[0].length, l = B, f = W;
              for (let le = t.length; l < le && (f < g || !t[l].type && !t[l - 1].greedy); ++l)
                f += t[l].length, c >= f && (++B, W = f);
              if (t[B] instanceof it)
                continue;
              s = l - B, G = e2.slice(W, f), p.index -= W;
            } else {
              S.lastIndex = 0;
              var p = S.exec(G), s = 1;
            }
            if (!p) {
              if (a)
                break;
              continue;
            }
            F && (R = p[1] ? p[1].length : 0);
            var c = p.index + R, p = p[0].slice(R), g = c + p.length, v = G.slice(0, c), b = G.slice(g);
            let pe = [B, s];
            v && (++B, W += v.length, pe.push(v));
            let H = new it(w, A ? fe.tokenize(p, A) : p, C, p, q);
            if (pe.push(H), b && pe.push(b), Array.prototype.splice.apply(t, pe), s != 1 && fe.matchGrammar(e2, t, r, B, W, true, w), a)
              break;
          }
        }
      }
    }, tokenize: function(e2, t) {
      let r = [e2], n = t.rest;
      if (n) {
        for (let i in n)
          t[i] = n[i];
        delete t.rest;
      }
      return fe.matchGrammar(e2, r, t, 0, 0, false), r;
    }, hooks: { all: {}, add: function(e2, t) {
      let r = fe.hooks.all;
      r[e2] = r[e2] || [], r[e2].push(t);
    }, run: function(e2, t) {
      let r = fe.hooks.all[e2];
      if (!(!r || !r.length))
        for (var n = 0, i; i = r[n++]; )
          i(t);
    } }, Token: it };
    fe.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: true }, "class-name": { pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i, lookbehind: true, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/, boolean: /\b(?:true|false)\b/, function: /\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/, punctuation: /[{}[\];(),.:]/ };
    fe.languages.javascript = fe.languages.extend("clike", { "class-name": [fe.languages.clike["class-name"], { pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/, lookbehind: true }], keyword: [{ pattern: /((?:^|})\s*)(?:catch|finally)\b/, lookbehind: true }, { pattern: /(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: true }], number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/, function: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, operator: /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/ });
    fe.languages.javascript["class-name"][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;
    fe.languages.insertBefore("javascript", "keyword", { regex: { pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/, lookbehind: true, greedy: true }, "function-variable": { pattern: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/, alias: "function" }, parameter: [{ pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/, lookbehind: true, inside: fe.languages.javascript }, { pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i, inside: fe.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/, lookbehind: true, inside: fe.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/, lookbehind: true, inside: fe.languages.javascript }], constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/ });
    fe.languages.markup && fe.languages.markup.tag.addInlined("script", "javascript");
    fe.languages.js = fe.languages.javascript;
    fe.languages.typescript = fe.languages.extend("javascript", { keyword: /\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/, builtin: /\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/ });
    fe.languages.ts = fe.languages.typescript;
    function it(e2, t, r, n, i) {
      this.type = e2, this.content = t, this.alias = r, this.length = (n || "").length | 0, this.greedy = !!i;
    }
    y(it, "Re");
    d(it, "Token");
    it.stringify = function(e2, t) {
      return typeof e2 == "string" ? e2 : Array.isArray(e2) ? e2.map(function(r) {
        return it.stringify(r, t);
      }).join("") : xs(e2.type)(e2.content);
    };
    function xs(e2) {
      return Wc[e2] || Jc;
    }
    y(xs, "Xg");
    d(xs, "getColorForSyntaxKind");
    function Ps(e2) {
      return js(e2, fe.languages.javascript);
    }
    y(Ps, "ul");
    d(Ps, "highlightTS");
    function js(e2, t) {
      return fe.tokenize(e2, t).map((r) => it.stringify(r)).join("");
    }
    y(js, "em");
    d(js, "highlight");
    j();
    N();
    I();
    k();
    var Yc = Ae(mo());
    function Ns(e2) {
      return (0, Yc.default)(e2);
    }
    y(Ns, "cl");
    d(Ns, "dedent");
    function ks(e2, t) {
      let r = String(t).length, n = String(e2).length;
      return n >= r ? String(e2) : " ".repeat(r - n) + e2;
    }
    y(ks, "tm");
    d(ks, "renderN");
    function Is(e2) {
      let t = 0;
      for (let r = 0; r < e2.length; r++) {
        if (e2.charAt(r) !== " ")
          return t;
        t++;
      }
      return t;
    }
    y(Is, "rm");
    d(Is, "getIndent");
    function $s({ callsite: e2, renderPathRelative: t, originalMethod: r, onUs: n, showColors: i, isValidationError: a }) {
      let o = { callsiteStr: ":", prevLines: `
`, functionName: `prisma.${r}()`, afterLines: "", indentValue: 0, lastErrorHeight: 20 };
      if (!e2 || typeof window != "undefined")
        return o;
      let l = ws(e2).find((f) => f.file && f.file !== "<anonymous>" && !f.file.includes("@prisma") && !f.file.includes("getPrismaClient") && !f.file.startsWith("internal/") && !f.methodName.includes("new ") && !f.methodName.includes("getCallSite") && !f.methodName.includes("Proxy.") && f.methodName.split(".").length < 4);
      if (we.env.NODE_ENV !== "production" && l && l.file && l.lineNumber && l.column) {
        let f = l.lineNumber, s = t ? yo().relative(we.cwd(), l.file) : l.file, c = Math.max(0, f - 4), p = (go(), fo);
        if (p.existsSync(l.file)) {
          let g = p.readFileSync(l.file, "utf-8").split(`
`).slice(c, f).map((w) => w.endsWith("\r") ? w.slice(0, -1) : w).join(`
`), v = Ns(g).split(`
`), b = v[v.length - 1];
          if (!b || b.trim() === "")
            o.callsiteStr = ":";
          else {
            let w = /(\S+(create|createMany|updateMany|deleteMany|update|delete|findMany|findUnique)\()/.exec(b);
            if (!w)
              return o;
            o.functionName = `${w[1]})`, o.callsiteStr = ` in
${Xe.default.underline(`${s}:${l.lineNumber}:${l.column}`)}`;
            let E = b.indexOf("{"), x = v.map((A, F, q) => !n && F === q.length - 1 ? A.slice(0, E > -1 ? E : A.length - 1) : A).join(`
`), S = i ? Ps(x).split(`
`) : x.split(`
`);
            o.prevLines = `
` + S.map((A, F) => Xe.default.grey(ks(F + c + 1, f + c + 1) + " ") + Xe.default.reset() + A).map((A, F, q) => F === q.length - 1 ? `${Xe.default.red.bold("\u2192")} ${Xe.default.dim(A)}` : Xe.default.dim("  " + A)).join(`
`), !w && !a && (o.prevLines += `

`), o.afterLines = ")", o.indentValue = String(f + c + 1).length + Is(b) + 1 + (w ? 2 : 0);
          }
        }
      }
      return o;
    }
    y($s, "nm");
    d($s, "parseStack");
    var Ms = d((e2) => {
      let { callsiteStr: t, prevLines: r, functionName: n, afterLines: i, indentValue: a, lastErrorHeight: o } = $s(e2), l = `
${e2.onUs ? Xe.default.red(`Oops, an unknown error occured! This is ${Xe.default.bold("on us")}, you did nothing wrong.
It occured in the ${Xe.default.bold(`\`${n}\``)} invocation${t}`) : Xe.default.red(`Invalid ${Xe.default.bold(`\`${n}\``)} invocation${t}`)}
${r}${Xe.default.reset()}`;
      return { indent: a, stack: l, afterLines: i, lastErrorHeight: o };
    }, "printStack");
    var Mr = 2;
    var Fs = y(class {
      constructor(e2, t) {
        this.type = e2, this.children = t, this.printFieldError = ({ error: r }, n, i) => {
          if (r.type === "emptySelect") {
            let a = i ? "" : ` Available options are listed in ${K.default.greenBright.dim("green")}.`;
            return `The ${K.default.redBright("`select`")} statement for type ${K.default.bold(Qt(r.field.outputType.type))} must not be empty.${a}`;
          }
          if (r.type === "emptyInclude") {
            if (n.length === 0)
              return `${K.default.bold(Qt(r.field.outputType.type))} does not have any relation and therefore can't have an ${K.default.redBright("`include`")} statement.`;
            let a = i ? "" : ` Available options are listed in ${K.default.greenBright.dim("green")}.`;
            return `The ${K.default.redBright("`include`")} statement for type ${K.default.bold(Qt(r.field.outputType.type))} must not be empty.${a}`;
          }
          if (r.type === "noTrueSelect")
            return `The ${K.default.redBright("`select`")} statement for type ${K.default.bold(Qt(r.field.outputType.type))} needs ${K.default.bold("at least one truthy value")}.`;
          if (r.type === "includeAndSelect")
            return `Please ${K.default.bold("either")} use ${K.default.greenBright("`include`")} or ${K.default.greenBright("`select`")}, but ${K.default.redBright("not both")} at the same time.`;
          if (r.type === "invalidFieldName") {
            let a = r.isInclude ? "include" : "select", o = r.isIncludeScalar ? "Invalid scalar" : "Unknown", l = i ? "" : r.isInclude && n.length === 0 ? `
This model has no relations, so you can't use ${K.default.redBright("include")} with it.` : ` Available options are listed in ${K.default.greenBright.dim("green")}.`, f = `${o} field ${K.default.redBright(`\`${r.providedName}\``)} for ${K.default.bold(a)} statement on model ${K.default.bold.white(r.modelName)}.${l}`;
            return r.didYouMean && (f += ` Did you mean ${K.default.greenBright(`\`${r.didYouMean}\``)}?`), r.isIncludeScalar && (f += `
Note, that ${K.default.bold("include")} statements only accept relation fields.`), f;
          }
          if (r.type === "invalidFieldType")
            return `Invalid value ${K.default.redBright(`${Bi(r.providedValue)}`)} of type ${K.default.redBright(Zt(r.providedValue, void 0))} for field ${K.default.bold(`${r.fieldName}`)} on model ${K.default.bold.white(r.modelName)}. Expected either ${K.default.greenBright("true")} or ${K.default.greenBright("false")}.`;
        }, this.printArgError = ({ error: r, path: n, id: i }, a, o) => {
          if (r.type === "invalidName") {
            let l = `Unknown arg ${K.default.redBright(`\`${r.providedName}\``)} in ${K.default.bold(n.join("."))} for type ${K.default.bold(r.outputType ? r.outputType.name : wr(r.originalType))}.`;
            return r.didYouMeanField ? l += `
\u2192 Did you forget to wrap it with \`${K.default.greenBright("select")}\`? ${K.default.dim("e.g. " + K.default.greenBright(`{ select: { ${r.providedName}: ${r.providedValue} } }`))}` : r.didYouMeanArg ? (l += ` Did you mean \`${K.default.greenBright(r.didYouMeanArg)}\`?`, !a && !o && (l += ` ${K.default.dim("Available args:")}
` + Kt(r.originalType, true))) : r.originalType.fields.length === 0 ? l += ` The field ${K.default.bold(r.originalType.name)} has no arguments.` : !a && !o && (l += ` Available args:

` + Kt(r.originalType, true)), l;
          }
          if (r.type === "invalidType") {
            let l = Bi(r.providedValue, { indent: "  " }), f = l.split(`
`).length > 1;
            if (f && (l = `
${l}
`), r.requiredType.bestFittingType.location === "enumTypes")
              return `Argument ${K.default.bold(r.argName)}: Provided value ${K.default.redBright(l)}${f ? "" : " "}of type ${K.default.redBright(Zt(r.providedValue))} on ${K.default.bold(`prisma.${this.children[0].name}`)} is not a ${K.default.greenBright(br(Ht(r.requiredType.bestFittingType.location), r.requiredType.bestFittingType.isList))}.
\u2192 Possible values: ${r.requiredType.bestFittingType.type.values.map((g) => K.default.greenBright(`${Ht(r.requiredType.bestFittingType.type)}.${g}`)).join(", ")}`;
            let s = ".";
            Lt(r.requiredType.bestFittingType.type) && (s = `:
` + Kt(r.requiredType.bestFittingType.type));
            let c = `${r.requiredType.inputType.map((g) => K.default.greenBright(br(Ht(g.type), r.requiredType.bestFittingType.isList))).join(" or ")}${s}`, p = r.requiredType.inputType.length === 2 && r.requiredType.inputType.find((g) => Lt(g.type)) || null;
            return p && (c += `
` + Kt(p.type, true)), `Argument ${K.default.bold(r.argName)}: Got invalid value ${K.default.redBright(l)}${f ? "" : " "}on ${K.default.bold(`prisma.${this.children[0].name}`)}. Provided ${K.default.redBright(Zt(r.providedValue))}, expected ${c}`;
          }
          if (r.type === "invalidNullArg") {
            let l = n.length === 1 && n[0] === r.name ? "" : ` for ${K.default.bold(`${n.join(".")}`)}`, f = ` Please use ${K.default.bold.greenBright("undefined")} instead.`;
            return `Argument ${K.default.greenBright(r.name)}${l} must not be ${K.default.bold("null")}.${f}`;
          }
          if (r.type === "missingArg") {
            let l = n.length === 1 && n[0] === r.missingName ? "" : ` for ${K.default.bold(`${n.join(".")}`)}`;
            return `Argument ${K.default.greenBright(r.missingName)}${l} is missing.`;
          }
          if (r.type === "atLeastOne") {
            let l = o ? "" : ` Available args are listed in ${K.default.dim.green("green")}.`;
            return `Argument ${K.default.bold(n.join("."))} of type ${K.default.bold(r.inputType.name)} needs ${K.default.greenBright("at least one")} argument.${l}`;
          }
          if (r.type === "atMostOne") {
            let l = o ? "" : ` Please choose one. ${K.default.dim("Available args:")} 
${Kt(r.inputType, true)}`;
            return `Argument ${K.default.bold(n.join("."))} of type ${K.default.bold(r.inputType.name)} needs ${K.default.greenBright("exactly one")} argument, but you provided ${r.providedKeys.map((f) => K.default.redBright(f)).join(" and ")}.${l}`;
          }
        }, this.type = e2, this.children = t;
      }
      get [Symbol.toStringTag]() {
        return "Document";
      }
      toString() {
        return `${this.type} {
${(0, Ct.default)(this.children.map(String).join(`
`), Mr)}
}`;
      }
      validate(e2, t = false, r, n, i) {
        var E;
        e2 || (e2 = {});
        let a = this.children.filter((x) => x.hasInvalidChild || x.hasInvalidArg);
        if (a.length === 0)
          return;
        let o = [], l = [], f = e2 && e2.select ? "select" : e2.include ? "include" : void 0;
        for (let x of a) {
          let S = x.collectErrors(f);
          o.push(...S.fieldErrors.map((A) => ({ ...A, path: t ? A.path : A.path.slice(1) }))), l.push(...S.argErrors.map((A) => ({ ...A, path: t ? A.path : A.path.slice(1) })));
        }
        let s = this.children[0].name, c = t ? this.type : s, p = [], g = [], v = [];
        for (let x of o) {
          let S = this.normalizePath(x.path, e2).join(".");
          if (x.error.type === "invalidFieldName") {
            p.push(S);
            let A = x.error.outputType, { isInclude: F } = x.error;
            A.fields.filter((q) => F ? q.outputType.location === "outputObjectTypes" : true).forEach((q) => {
              let R = S.split(".");
              v.push({ path: `${R.slice(0, R.length - 1).join(".")}.${q.name}`, type: "true", isRequired: false });
            });
          } else
            x.error.type === "includeAndSelect" ? (p.push("select"), p.push("include")) : g.push(S);
          if (x.error.type === "emptySelect" || x.error.type === "noTrueSelect" || x.error.type === "emptyInclude") {
            let A = this.normalizePath(x.path, e2), F = A.slice(0, A.length - 1).join(".");
            (E = x.error.field.outputType.type.fields) == null || E.filter((q) => x.error.type === "emptyInclude" ? q.outputType.location === "outputObjectTypes" : true).forEach((q) => {
              v.push({ path: `${F}.${q.name}`, type: "true", isRequired: false });
            });
          }
        }
        for (let x of l) {
          let S = this.normalizePath(x.path, e2).join(".");
          if (x.error.type === "invalidName")
            p.push(S);
          else if (x.error.type !== "missingArg" && x.error.type !== "atLeastOne")
            g.push(S);
          else if (x.error.type === "missingArg") {
            let A = x.error.missingArg.inputTypes.length === 1 ? x.error.missingArg.inputTypes[0].type : x.error.missingArg.inputTypes.map((F) => {
              let q = wr(F.type);
              return q === "Null" ? "null" : F.isList ? q + "[]" : q;
            }).join(" | ");
            v.push({ path: S, type: Un(A, true, S.split("where.").length === 2), isRequired: x.error.missingArg.isRequired });
          }
        }
        let b = d((x) => {
          let S = l.some((H) => H.error.type === "missingArg" && H.error.missingArg.isRequired), A = Boolean(l.find((H) => H.error.type === "missingArg" && !H.error.missingArg.isRequired)), F = A || S, q = "";
          S && (q += `
${K.default.dim("Note: Lines with ")}${K.default.reset.greenBright("+")} ${K.default.dim("are required")}`), A && (q.length === 0 && (q = `
`), S ? q += K.default.dim(`, lines with ${K.default.green("?")} are optional`) : q += K.default.dim(`Note: Lines with ${K.default.green("?")} are optional`), q += K.default.dim("."));
          let R = l.filter((H) => H.error.type !== "missingArg" || H.error.missingArg.isRequired).map((H) => this.printArgError(H, F, n === "minimal")).join(`
`);
          if (R += `
${o.map((H) => this.printFieldError(H, v, n === "minimal")).join(`
`)}`, n === "minimal")
            return (0, fs.default)(R);
          let { stack: C, indent: B, afterLines: W } = Ms({ callsite: x, originalMethod: r || c, showColors: n && n === "pretty", isValidationError: true }), G = { ast: t ? { [s]: e2 } : e2, keyPaths: p, valuePaths: g, missingItems: v };
          (r == null ? void 0 : r.endsWith("aggregate")) && (G = Vs(G));
          let pe = `${C}${(0, Ct.default)(qi(G), B).slice(B)}${K.default.dim(W)}

${R}${q}
`;
          return we.env.NO_COLOR || n === "colorless" ? (0, fs.default)(pe) : pe;
        }, "renderErrorStr"), w = new or(b(i));
        throw we.env.NODE_ENV !== "production" && Object.defineProperty(w, "render", { get: () => b, enumerable: false }), w;
      }
      normalizePath(e2, t) {
        let r = e2.slice(), n = [], i, a = t;
        for (; (i = r.shift()) !== void 0; )
          !Array.isArray(a) && i === 0 || (i === "select" ? a[i] ? a = a[i] : a = a.include : a && a[i] && (a = a[i]), n.push(i));
        return n;
      }
    }, "_i");
    d(Fs, "Document");
    var or = y(class extends Error {
      get [Symbol.toStringTag]() {
        return "PrismaClientValidationError";
      }
    }, "mt");
    d(or, "PrismaClientValidationError");
    var Fe = y(class extends Error {
      constructor(e2) {
        super(e2 + `
Read more at https://pris.ly/d/client-constructor`);
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientConstructorValidationError";
      }
    }, "ie");
    d(Fe, "PrismaClientConstructorValidationError");
    var Ue = y(class {
      constructor({ name: e2, args: t, children: r, error: n, schemaField: i }) {
        this.name = e2, this.args = t, this.children = r, this.error = n, this.schemaField = i, this.hasInvalidChild = r ? r.some((a) => Boolean(a.error || a.hasInvalidArg || a.hasInvalidChild)) : false, this.hasInvalidArg = t ? t.hasInvalidArg : false;
      }
      get [Symbol.toStringTag]() {
        return "Field";
      }
      toString() {
        let e2 = this.name;
        return this.error ? e2 + " # INVALID_FIELD" : (this.args && this.args.args && this.args.args.length > 0 && (this.args.args.length === 1 ? e2 += `(${this.args.toString()})` : e2 += `(
${(0, Ct.default)(this.args.toString(), Mr)}
)`), this.children && (e2 += ` {
${(0, Ct.default)(this.children.map(String).join(`
`), Mr)}
}`), e2);
      }
      collectErrors(e2 = "select") {
        let t = [], r = [];
        if (this.error && t.push({ path: [this.name], error: this.error }), this.children)
          for (let n of this.children) {
            let i = n.collectErrors(e2);
            t.push(...i.fieldErrors.map((a) => ({ ...a, path: [this.name, e2, ...a.path] }))), r.push(...i.argErrors.map((a) => ({ ...a, path: [this.name, e2, ...a.path] })));
          }
        return this.args && r.push(...this.args.collectErrors().map((n) => ({ ...n, path: [this.name, ...n.path] }))), { fieldErrors: t, argErrors: r };
      }
    }, "me");
    d(Ue, "Field");
    var Je = y(class {
      constructor(e2 = []) {
        this.args = e2, this.hasInvalidArg = e2 ? e2.some((t) => Boolean(t.hasError)) : false;
      }
      get [Symbol.toStringTag]() {
        return "Args";
      }
      toString() {
        return this.args.length === 0 ? "" : `${this.args.map((e2) => e2.toString()).filter((e2) => e2).join(`
`)}`;
      }
      collectErrors() {
        return this.hasInvalidArg ? Ri(this.args, (e2) => e2.collectErrors()) : [];
      }
    }, "he");
    d(Je, "Args");
    function un(e2, t) {
      return Ge.Buffer.isBuffer(e2) ? JSON.stringify(e2.toString("base64")) : Object.prototype.toString.call(e2) === "[object BigInt]" ? e2.toString() : typeof (t == null ? void 0 : t.type) == "string" && t.type === "Json" ? e2 === null ? "null" : e2 && e2.values && e2.__prismaRawParamaters__ ? JSON.stringify(e2.values) : (t == null ? void 0 : t.isList) && Array.isArray(e2) ? JSON.stringify(e2.map((r) => JSON.stringify(r))) : JSON.stringify(JSON.stringify(e2)) : e2 === void 0 ? null : e2 === null ? "null" : Vr.isDecimal(e2) ? e2.toString() : (t == null ? void 0 : t.location) === "enumTypes" && typeof e2 == "string" ? Array.isArray(e2) ? `[${e2.join(", ")}]` : e2 : JSON.stringify(e2, null, 2);
    }
    y(un, "Ai");
    d(un, "stringify");
    var ft = y(class {
      constructor({ key: e2, value: t, isEnum: r = false, error: n, schemaArg: i, inputType: a }) {
        this.inputType = a, this.key = e2, this.value = t, this.isEnum = r, this.error = n, this.schemaArg = i, this.isNullable = (i == null ? void 0 : i.inputTypes.reduce((o) => o && i.isNullable, true)) || false, this.hasError = Boolean(n) || (t instanceof Je ? t.hasInvalidArg : false) || Array.isArray(t) && t.some((o) => o instanceof Je ? o.hasInvalidArg : false);
      }
      get [Symbol.toStringTag]() {
        return "Arg";
      }
      _toString(e2, t) {
        var r;
        if (typeof e2 != "undefined") {
          if (e2 instanceof Je)
            return `${t}: {
${(0, Ct.default)(e2.toString(), 2)}
}`;
          if (Array.isArray(e2)) {
            if (((r = this.inputType) == null ? void 0 : r.type) === "Json")
              return `${t}: ${un(e2, this.inputType)}`;
            let n = !e2.some((i) => typeof i == "object");
            return `${t}: [${n ? "" : `
`}${(0, Ct.default)(e2.map((i) => i instanceof Je ? `{
${(0, Ct.default)(i.toString(), Mr)}
}` : un(i, this.inputType)).join(`,${n ? " " : `
`}`), n ? 0 : Mr)}${n ? "" : `
`}]`;
          }
          return `${t}: ${un(e2, this.inputType)}`;
        }
      }
      toString() {
        return this._toString(this.value, this.key);
      }
      collectErrors() {
        var t;
        if (!this.hasError)
          return [];
        let e2 = [];
        if (this.error) {
          let r = typeof ((t = this.inputType) == null ? void 0 : t.type) == "object" ? `${this.inputType.type.name}${this.inputType.isList ? "[]" : ""}` : void 0;
          e2.push({ error: this.error, path: [this.key], id: r });
        }
        return Array.isArray(this.value) && e2.push(...Ri(this.value, (r, n) => (r == null ? void 0 : r.collectErrors) ? r.collectErrors().map((i) => ({ ...i, path: [this.key, n, ...i.path] })) : [])), this.value instanceof Je && e2.push(...this.value.collectErrors().map((r) => ({ ...r, path: [this.key, ...r.path] }))), e2;
      }
    }, "Ne");
    d(ft, "Arg");
    function Li({ dmmf: e2, rootTypeName: t, rootField: r, select: n }) {
      n || (n = {});
      let i = t === "query" ? e2.queryType : e2.mutationType, a = { args: [], outputType: { isList: false, type: i, location: "outputObjectTypes" }, name: t }, o = Di(e2, { [r]: n }, a, [t]);
      return new Fs(t, o);
    }
    y(Li, "xi");
    d(Li, "makeDocument");
    function Ui(e2) {
      return e2;
    }
    y(Ui, "Pi");
    d(Ui, "transformDocument");
    function Di(e2, t, r, n) {
      let i = r.outputType.type;
      return Object.entries(t).reduce((a, [o, l]) => {
        let f = i.fieldMap ? i.fieldMap[o] : i.fields.find((E) => E.name === o);
        if (!f)
          return a.push(new Ue({ name: o, children: [], error: { type: "invalidFieldName", modelName: i.name, providedName: o, didYouMean: Gr(o, i.fields.map((E) => E.name)), outputType: i } })), a;
        if (typeof l != "boolean" && f.outputType.location === "scalar" && f.name !== "executeRaw" && f.name !== "queryRaw" && f.name !== "runCommandRaw" && i.name !== "Query" && !o.startsWith("aggregate") && f.name !== "count")
          return a.push(new Ue({ name: o, children: [], error: { type: "invalidFieldType", modelName: i.name, fieldName: o, providedValue: l } })), a;
        if (l === false)
          return a;
        let s = { name: f.name, fields: f.args, constraints: { minNumFields: null, maxNumFields: null } }, c = typeof l == "object" ? gs(l, ["include", "select"]) : void 0, p = c ? Fr(c, s, [], typeof f == "string" ? void 0 : f.outputType.type) : void 0, g = f.outputType.location === "outputObjectTypes";
        if (l) {
          if (l.select && l.include)
            a.push(new Ue({ name: o, children: [new Ue({ name: "include", args: new Je(), error: { type: "includeAndSelect", field: f } })] }));
          else if (l.include) {
            let E = Object.keys(l.include);
            if (E.length === 0)
              return a.push(new Ue({ name: o, children: [new Ue({ name: "include", args: new Je(), error: { type: "emptyInclude", field: f } })] })), a;
            if (f.outputType.location === "outputObjectTypes") {
              let x = f.outputType.type, S = x.fields.filter((F) => F.outputType.location === "outputObjectTypes").map((F) => F.name), A = E.filter((F) => !S.includes(F));
              if (A.length > 0)
                return a.push(...A.map((F) => new Ue({ name: F, children: [new Ue({ name: F, args: new Je(), error: { type: "invalidFieldName", modelName: x.name, outputType: x, providedName: F, didYouMean: Gr(F, S) || void 0, isInclude: true, isIncludeScalar: x.fields.some((q) => q.name === F) } })] }))), a;
            }
          } else if (l.select) {
            let E = Object.values(l.select);
            if (E.length === 0)
              return a.push(new Ue({ name: o, children: [new Ue({ name: "select", args: new Je(), error: { type: "emptySelect", field: f } })] })), a;
            if (E.filter((x) => x).length === 0)
              return a.push(new Ue({ name: o, children: [new Ue({ name: "select", args: new Je(), error: { type: "noTrueSelect", field: f } })] })), a;
          }
        }
        let v = g ? Bs(e2, f.outputType.type) : null, b = v;
        l && (l.select ? b = l.select : l.include ? b = on(v, l.include) : l.by && Array.isArray(l.by) && f.outputType.namespace === "prisma" && f.outputType.location === "outputObjectTypes" && ga(f.outputType.type.name) && (b = Rs(l.by)));
        let w = b !== false && g ? Di(e2, b, f, [...n, o]) : void 0;
        return a.push(new Ue({ name: o, args: p, children: w, schemaField: f })), a;
      }, []);
    }
    y(Di, "fl");
    d(Di, "selectionToFields");
    function Rs(e2) {
      let t = /* @__PURE__ */ Object.create(null);
      for (let r of e2)
        t[r] = true;
      return t;
    }
    y(Rs, "om");
    d(Rs, "byToSelect");
    function Bs(e2, t) {
      let r = /* @__PURE__ */ Object.create(null);
      for (let n of t.fields)
        e2.typeMap[n.outputType.type.name] !== void 0 && (r[n.name] = true), (n.outputType.location === "scalar" || n.outputType.location === "enumTypes") && (r[n.name] = true);
      return r;
    }
    y(Bs, "im");
    d(Bs, "getDefaultSelection");
    function ln(e2, t, r, n) {
      return new ft({ key: e2, value: t, isEnum: n.location === "enumTypes", inputType: n, error: { type: "invalidType", providedValue: t, argName: e2, requiredType: { inputType: r.inputTypes, bestFittingType: n } } });
    }
    y(ln, "Ti");
    d(ln, "getInvalidTypeArg");
    function Cs(e2, t, r) {
      let { type: n, isList: i } = r, a = br(Ht(n), i), o = Zt(e2, n);
      return !!(o === a || i && o === "List<>" || a === "Json" || o === "Int" && a === "BigInt" || o === "List<Int>" && a === "List<BigInt>" || o === "List<BigInt | Int>" && a === "List<BigInt>" || o === "List<Int | BigInt>" && a === "List<BigInt>" || (o === "Int" || o === "Float") && a === "Decimal" || (o === "List<Int>" || o === "List<Float>") && a === "List<Decimal>" || o === "DateTime" && a === "String" || o === "List<DateTime>" && a === "List<String>" || o === "UUID" && a === "String" || o === "List<UUID>" && a === "List<String>" || o === "String" && a === "ID" || o === "List<String>" && a === "List<ID>" || o === "List<String>" && a === "List<Json>" || a === "List<String>" && (o === "List<String | UUID>" || o === "List<UUID | String>") || o === "Int" && a === "Float" || o === "List<Int>" && a === "List<Float>" || o === "Int" && a === "Long" || o === "List<Int>" && a === "List<Long>" || o === "String" && a === "Decimal" && /^\-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i.test(e2) || e2 === null);
    }
    y(Cs, "sm");
    d(Cs, "hasCorrectScalarType");
    var cn = d((e2) => ps(e2, (t, r) => r !== void 0), "cleanObject");
    function qs(e2, t, r) {
      let n = null, i = [];
      for (let a of r.inputTypes) {
        if (n = Us(e2, t, r, a), (n == null ? void 0 : n.collectErrors().length) === 0)
          return n;
        if (n && (n == null ? void 0 : n.collectErrors())) {
          let o = n == null ? void 0 : n.collectErrors();
          o && o.length > 0 && i.push({ arg: n, errors: o });
        }
      }
      if ((n == null ? void 0 : n.hasError) && i.length > 0) {
        let a = i.map(({ arg: o, errors: l }) => {
          let f = l.map((s) => {
            let c = 1;
            return s.error.type === "invalidType" && (c = 2 * Math.exp(Vi(s.error.providedValue)) + 1), c += Math.log(s.path.length), s.error.type === "missingArg" && o.inputType && Lt(o.inputType.type) && o.inputType.type.name.includes("Unchecked") && (c *= 2), s.error.type === "invalidName" && Lt(s.error.originalType) && s.error.originalType.name.includes("Unchecked") && (c *= 2), c;
          });
          return { score: l.length + Ls(f), arg: o, errors: l };
        });
        return a.sort((o, l) => o.score < l.score ? -1 : 1), a[0].arg;
      }
      return n;
    }
    y(qs, "am");
    d(qs, "valueToArg");
    function Vi(e2) {
      let t = 1;
      if (!e2 || typeof e2 != "object")
        return t;
      for (let r in e2)
        if (!!Object.prototype.hasOwnProperty.call(e2, r) && typeof e2[r] == "object") {
          let n = Vi(e2[r]) + 1;
          t = Math.max(n, t);
        }
      return t;
    }
    y(Vi, "pl");
    d(Vi, "getDepth");
    function Ls(e2) {
      return e2.reduce((t, r) => t + r, 0);
    }
    y(Ls, "um");
    d(Ls, "sum");
    function Us(e2, t, r, n) {
      var f, s, c, p;
      if (typeof t == "undefined")
        return r.isRequired ? new ft({ key: e2, value: t, isEnum: n.location === "enumTypes", inputType: n, error: { type: "missingArg", missingName: e2, missingArg: r, atLeastOne: false, atMostOne: false } }) : null;
      let { isNullable: i, isRequired: a } = r;
      if (t === null && !i && !a && !(Lt(n.type) ? n.type.constraints.minNumFields !== null && n.type.constraints.minNumFields > 0 : false))
        return new ft({ key: e2, value: t, isEnum: n.location === "enumTypes", inputType: n, error: { type: "invalidNullArg", name: e2, invalidType: r.inputTypes, atLeastOne: false, atMostOne: false } });
      if (!n.isList)
        if (Lt(n.type)) {
          if (typeof t != "object" || Array.isArray(t) || n.location === "inputObjectTypes" && !hs(t))
            return ln(e2, t, r, n);
          {
            let g = cn(t), v, b = Object.keys(g || {}), w = b.length;
            return w === 0 && typeof n.type.constraints.minNumFields == "number" && n.type.constraints.minNumFields > 0 ? v = { type: "atLeastOne", key: e2, inputType: n.type } : w > 1 && typeof n.type.constraints.maxNumFields == "number" && n.type.constraints.maxNumFields < 2 && (v = { type: "atMostOne", key: e2, inputType: n.type, providedKeys: b }), new ft({ key: e2, value: g === null ? null : Fr(g, n.type, r.inputTypes), isEnum: n.location === "enumTypes", error: v, inputType: n, schemaArg: r });
          }
        } else
          return Gi(e2, t, r, n);
      if (!Array.isArray(t) && n.isList && e2 !== "updateMany" && (t = [t]), n.location === "enumTypes" || n.location === "scalar")
        return Gi(e2, t, r, n);
      let o = n.type, l = (typeof ((f = o.constraints) == null ? void 0 : f.minNumFields) == "number" && ((s = o.constraints) == null ? void 0 : s.minNumFields) > 0 ? Array.isArray(t) && t.some((g) => !g || Object.keys(cn(g)).length === 0) : false) ? { inputType: o, key: e2, type: "atLeastOne" } : void 0;
      if (!l) {
        let g = typeof ((c = o.constraints) == null ? void 0 : c.maxNumFields) == "number" && ((p = o.constraints) == null ? void 0 : p.maxNumFields) < 2 ? Array.isArray(t) && t.find((v) => !v || Object.keys(cn(v)).length !== 1) : false;
        g && (l = { inputType: o, key: e2, type: "atMostOne", providedKeys: Object.keys(g) });
      }
      if (!Array.isArray(t))
        for (let g of r.inputTypes) {
          let v = Fr(t, g.type);
          if (v.collectErrors().length === 0)
            return new ft({ key: e2, value: v, isEnum: false, schemaArg: r, inputType: g });
        }
      return new ft({ key: e2, value: t.map((g) => n.isList && typeof g != "object" ? g : typeof g != "object" || !t ? ln(e2, g, r, n) : Fr(g, o)), isEnum: false, inputType: n, schemaArg: r, error: l });
    }
    y(Us, "lm");
    d(Us, "tryInferArgs");
    function Lt(e2) {
      return !(typeof e2 == "string" || Object.hasOwnProperty.call(e2, "values"));
    }
    y(Lt, "tr");
    d(Lt, "isInputArgType");
    function Gi(e2, t, r, n) {
      return Cs(t, r, n) ? new ft({ key: e2, value: t, isEnum: n.location === "enumTypes", schemaArg: r, inputType: n }) : ln(e2, t, r, n);
    }
    y(Gi, "dl");
    d(Gi, "scalarToArg");
    function Fr(e2, t, r, n) {
      let i = cn(e2), { fields: a, fieldMap: o } = t, l = a.map((c) => [c.name, void 0]), f = Object.entries(i || {}), s = ha(f, l, (c) => c[0]).reduce((c, [p, g]) => {
        let v = o ? o[p] : a.find((w) => w.name === p);
        if (!v) {
          let w = typeof g == "boolean" && n && n.fields.some((E) => E.name === p) ? p : null;
          return c.push(new ft({ key: p, value: g, error: { type: "invalidName", providedName: p, providedValue: g, didYouMeanField: w, didYouMeanArg: !w && Gr(p, [...a.map((E) => E.name), "select"]) || void 0, originalType: t, possibilities: r, outputType: n } })), c;
        }
        let b = qs(p, g, v);
        return b && c.push(b), c;
      }, []);
      if (typeof t.constraints.minNumFields == "number" && f.length < t.constraints.minNumFields || s.find((c) => {
        var p, g;
        return ((p = c.error) == null ? void 0 : p.type) === "missingArg" || ((g = c.error) == null ? void 0 : g.type) === "atLeastOne";
      })) {
        let c = t.fields.filter((p) => !p.isRequired && i && (typeof i[p.name] == "undefined" || i[p.name] === null));
        s.push(...c.map((p) => {
          let g = p.inputTypes[0];
          return new ft({ key: p.name, value: void 0, isEnum: g.location === "enumTypes", error: { type: "missingArg", missingName: p.name, missingArg: p, atLeastOne: Boolean(t.constraints.minNumFields) || false, atMostOne: t.constraints.maxNumFields === 1 || false }, inputType: g });
        }));
      }
      return new Je(s);
    }
    y(Fr, "Jn");
    d(Fr, "objectToArgs");
    function Ji({ document: e2, path: t, data: r }) {
      let n = Ka(r, t);
      if (n === "undefined")
        return null;
      if (typeof n != "object")
        return n;
      let i = Ds(e2, t);
      return fn({ field: i, data: n });
    }
    y(Ji, "Si");
    d(Ji, "unpack");
    function fn({ field: e2, data: t }) {
      var n;
      if (!t || typeof t != "object" || !e2.children || !e2.schemaField)
        return t;
      let r = { DateTime: (i) => new Date(i), Json: (i) => JSON.parse(i), Bytes: (i) => Ge.Buffer.from(i, "base64"), Decimal: (i) => new Vr(i), BigInt: (i) => BigInt(i) };
      for (let i of e2.children) {
        let a = (n = i.schemaField) == null ? void 0 : n.outputType.type;
        if (a && typeof a == "string") {
          let o = r[a];
          if (o)
            if (Array.isArray(t))
              for (let l of t)
                typeof l[i.name] != "undefined" && l[i.name] !== null && (Array.isArray(l[i.name]) ? l[i.name] = l[i.name].map(o) : l[i.name] = o(l[i.name]));
            else
              typeof t[i.name] != "undefined" && t[i.name] !== null && (Array.isArray(t[i.name]) ? t[i.name] = t[i.name].map(o) : t[i.name] = o(t[i.name]));
        }
        if (i.schemaField && i.schemaField.outputType.location === "outputObjectTypes")
          if (Array.isArray(t))
            for (let o of t)
              fn({ field: i, data: o[i.name] });
          else
            fn({ field: i, data: t[i.name] });
      }
      return t;
    }
    y(fn, "Mi");
    d(fn, "mapScalars");
    function Ds(e2, t) {
      let r = t.slice(), n = r.shift(), i = e2.children.find((a) => a.name === n);
      if (!i)
        throw new Error(`Could not find field ${n} in document ${e2}`);
      for (; r.length > 0; ) {
        let a = r.shift();
        if (!i.children)
          throw new Error(`Can't get children for field ${i} with child ${a}`);
        let o = i.children.find((l) => l.name === a);
        if (!o)
          throw new Error(`Can't find child ${a} of field ${i}`);
        i = o;
      }
      return i;
    }
    y(Ds, "cm");
    d(Ds, "getField");
    function pn(e2) {
      return e2.split(".").filter((t) => t !== "select").join(".");
    }
    y(pn, "Oi");
    d(pn, "removeSelectFromPath");
    function dn(e2) {
      if (Object.prototype.toString.call(e2) === "[object Object]") {
        let t = {};
        for (let r in e2)
          if (r === "select")
            for (let n in e2.select)
              t[n] = dn(e2.select[n]);
          else
            t[r] = dn(e2[r]);
        return t;
      }
      return e2;
    }
    y(dn, "Ii");
    d(dn, "removeSelectFromObject");
    function Vs({ ast: e2, keyPaths: t, missingItems: r, valuePaths: n }) {
      let i = t.map(pn), a = n.map(pn), o = r.map((l) => ({ path: pn(l.path), isRequired: l.isRequired, type: l.type }));
      return { ast: dn(e2), keyPaths: i, missingItems: o, valuePaths: a };
    }
    y(Vs, "fm");
    d(Vs, "transformAggregatePrintJsonArgs");
    j();
    N();
    I();
    k();
    var Hc = Ae(co());
    var Zc = Ae(Pn());
    j();
    N();
    I();
    k();
    var Gs = y(class {
      constructor(e2) {
        this.options = e2, this.tickActive = false, this.batches = {};
      }
      request(e2) {
        let t = this.options.batchBy(e2);
        return t ? (this.batches[t] || (this.batches[t] = [], this.tickActive || (this.tickActive = true, we.nextTick(() => {
          this.dispatchBatches(), this.tickActive = false;
        }))), new Promise((r, n) => {
          this.batches[t].push({ request: e2, resolve: r, reject: n });
        })) : this.options.singleLoader(e2);
      }
      dispatchBatches() {
        for (let e2 in this.batches) {
          let t = this.batches[e2];
          delete this.batches[e2], t.length === 1 ? this.options.singleLoader(t[0].request).then((r) => {
            r instanceof Error ? t[0].reject(r) : t[0].resolve(r);
          }).catch((r) => {
            t[0].reject(r);
          }) : this.options.batchLoader(t.map((r) => r.request)).then((r) => {
            if (r instanceof Error)
              for (let n = 0; n < t.length; n++)
                t[n].reject(r);
            else
              for (let n = 0; n < t.length; n++) {
                let i = r[n];
                i instanceof Error ? t[n].reject(i) : t[n].resolve(i);
              }
          }).catch((r) => {
            for (let n = 0; n < t.length; n++)
              t[n].reject(r);
          });
        }
      }
      get [Symbol.toStringTag]() {
        return "DataLoader";
      }
    }, "zn");
    d(Gs, "DataLoader");
    j();
    N();
    I();
    k();
    var hn = y(class extends Error {
      constructor(e2) {
        super(e2);
        this.name = "NotFoundError";
      }
    }, "Ur");
    d(hn, "NotFoundError");
    function Wi(e2, t, r, n) {
      let i;
      if (r && typeof r == "object" && "rejectOnNotFound" in r && r.rejectOnNotFound !== void 0)
        i = r.rejectOnNotFound, delete r.rejectOnNotFound;
      else if (typeof n == "boolean")
        i = n;
      else if (n && typeof n == "object" && e2 in n) {
        let a = n[e2];
        if (a && typeof a == "object")
          return t in a ? a[t] : void 0;
        i = Wi(e2, t, r, a);
      } else
        typeof n == "function" ? i = n : i = false;
      return i;
    }
    y(Wi, "ki");
    d(Wi, "getRejectOnNotFound");
    var Kc = /(findUnique|findFirst)/;
    function Js(e2, t, r, n) {
      if (n && !e2 && Kc.exec(t))
        throw typeof n == "boolean" && n ? new hn(`No ${r} found`) : typeof n == "function" ? n(new hn(`No ${r} found`)) : Qr(n) ? n : new hn(`No ${r} found`);
    }
    y(Js, "gl");
    d(Js, "throwIfNotFound");
    var Qc = (0, Hc.default)("prisma:client:request_handler");
    function zi(e2) {
      let t = e2[0].transactionId, r = e2[0].runInTransaction, n = e2[0].headers;
      return { inTx: typeof t == "number" && r ? true : void 0, headers: { transactionId: typeof t == "string" && r ? t : void 0, ...n } };
    }
    y(zi, "yl");
    d(zi, "getRequestInfo");
    var Ws = y(class {
      constructor(e2, t) {
        this.client = e2, this.hooks = t, this.dataloader = new Gs({ batchLoader: (r) => {
          let n = zi(r), i = r.map((a) => String(a.document));
          return this.client._engine.requestBatch(i, n.headers, n.inTx);
        }, singleLoader: (r) => {
          let n = zi([r]), i = String(r.document);
          return this.client._engine.request(i, n.headers);
        }, batchBy: (r) => r.transactionId ? `transaction-${r.transactionId}` : zs(r) });
      }
      async request({ document: e2, dataPath: t = [], rootField: r, typeName: n, isList: i, callsite: a, rejectOnNotFound: o, clientMethod: l, runInTransaction: f, showColors: s, engineHook: c, args: p, headers: g, transactionId: v, unpacker: b }) {
        if (this.hooks && this.hooks.beforeRequest) {
          let w = String(e2);
          this.hooks.beforeRequest({ query: w, path: t, rootField: r, typeName: n, document: e2, isList: i, clientMethod: l, args: p });
        }
        try {
          let w, E;
          if (c) {
            let S = await c({ document: e2, runInTransaction: f }, (A) => this.dataloader.request(A));
            w = S.data, E = S.elapsed;
          } else {
            let S = await this.dataloader.request({ document: e2, runInTransaction: f, headers: g, transactionId: v });
            w = S == null ? void 0 : S.data, E = S == null ? void 0 : S.elapsed;
          }
          let x = this.unpack(e2, w, t, r, b);
          return Js(x, l, n, o), we.env.PRISMA_CLIENT_GET_TIME ? { data: x, elapsed: E } : x;
        } catch (w) {
          Qc(w);
          let E = w.message;
          if (a) {
            let { stack: x } = Ms({ callsite: a, originalMethod: l, onUs: w.isPanic, showColors: s });
            E = `${x}
  ${w.message}`;
          }
          throw E = this.sanitizeMessage(E), w.code ? new _r(E, w.code, this.client._clientVersion, w.meta) : w.isPanic ? new er(E, this.client._clientVersion) : w instanceof tr ? new tr(E, this.client._clientVersion) : w instanceof Xt ? new Xt(E, this.client._clientVersion) : w instanceof er ? new er(E, this.client._clientVersion) : (w.clientVersion = this.client._clientVersion, w);
        }
      }
      sanitizeMessage(e2) {
        return this.client._errorFormat && this.client._errorFormat !== "pretty" ? (0, Zc.default)(e2) : e2;
      }
      unpack(e2, t, r, n, i) {
        (t == null ? void 0 : t.data) && (t = t.data), i && (t[n] = i(t[n]));
        let a = [];
        return n && a.push(n), a.push(...r.filter((o) => o !== "select" && o !== "include")), Ji({ document: e2, data: t, path: a });
      }
      get [Symbol.toStringTag]() {
        return "RequestHandler";
      }
    }, "Wn");
    d(Ws, "RequestHandler");
    function zs(e2) {
      var n;
      if (!e2.document.children[0].name.startsWith("findUnique"))
        return;
      let t = (n = e2.document.children[0].args) == null ? void 0 : n.args.map((i) => i.value instanceof Je ? `${i.key}-${i.value.args.map((a) => a.key).join(",")}` : i.key).join(","), r = e2.document.children[0].children.join(",");
      return `${e2.document.children[0].name}|${t}|${r}`;
    }
    y(zs, "gm");
    d(zs, "batchFindUniqueBy");
    j();
    N();
    I();
    k();
    var Xc = Mu().version;
    j();
    N();
    I();
    k();
    var gn = d((e2) => e2.reduce((t, r, n) => `${t}@P${n}${r}`), "mssqlPreparedStatement");
    j();
    N();
    I();
    k();
    function Ys(e2, t) {
      let r = t && Ti.getSpanContext(t);
      return (r == null ? void 0 : r.traceFlags) === 1 ? { traceparent: `00-${r.traceId}-${r.spanId}-01`, ...e2 } : e2 != null ? e2 : {};
    }
    y(Ys, "vl");
    d(Ys, "applyTracingHeaders");
    j();
    N();
    I();
    k();
    async function Hs(e2, t, r) {
      if (t === void 0)
        return r(void 0);
      let n = Ti.getTracer("prisma").startSpan(e2, void 0, t), i = Ti.setSpan(t, n), a = await Da.with(i, () => r(n));
      return n == null || n.end(), a;
    }
    y(Hs, "El");
    d(Hs, "runInChildSpan");
    j();
    N();
    I();
    k();
    function ot(e2) {
      return JSON.stringify(mn(yn(e2)));
    }
    y(ot, "Ce");
    d(ot, "serializeRawParameters");
    function yn(e2) {
      let t = Object.prototype.toString.call(e2);
      if (t === "[object Date]")
        return { prisma__type: "date", prisma__value: e2.toJSON() };
      if (t === "[object Object]") {
        let r = {};
        for (let n in e2)
          n !== "__proto__" && (r[n] = yn(e2[n]));
        return r;
      }
      if (t === "[object Array]") {
        let r = e2.length, n;
        for (n = new Array(r); r--; )
          n[r] = yn(e2[r]);
        return n;
      }
      return e2;
    }
    y(yn, "ji");
    d(yn, "replaceDates");
    function mn(e2) {
      let t = Object.prototype.toString.call(e2);
      if (t === "[object BigInt]")
        return e2.toString();
      if (t === "[object Object]") {
        let r = {};
        for (let n in e2)
          n !== "__proto__" && (r[n] = mn(e2[n]));
        return r;
      }
      if (t === "[object Array]") {
        let r = e2.length, n;
        for (n = new Array(r); r--; )
          n[r] = mn(e2[r]);
        return n;
      }
      return e2;
    }
    y(mn, "Fi");
    d(mn, "serializeBigInt");
    j();
    N();
    I();
    k();
    var ef = Ae(uo());
    var Zs = ["datasources", "errorFormat", "log", "__internal", "rejectOnNotFound"];
    var Ks = ["pretty", "colorless", "minimal"];
    var Qs = ["info", "query", "warn", "error"];
    var tf = { datasources: (e2, t) => {
      if (e2) {
        if (typeof e2 != "object" || Array.isArray(e2))
          throw new Fe(`Invalid value ${JSON.stringify(e2)} for "datasources" provided to PrismaClient constructor`);
        for (let [r, n] of Object.entries(e2)) {
          if (!t.includes(r)) {
            let i = Ut(r, t) || `Available datasources: ${t.join(", ")}`;
            throw new Fe(`Unknown datasource ${r} provided to PrismaClient constructor.${i}`);
          }
          if (typeof n != "object" || Array.isArray(n))
            throw new Fe(`Invalid value ${JSON.stringify(e2)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
          if (n && typeof n == "object")
            for (let [i, a] of Object.entries(n)) {
              if (i !== "url")
                throw new Fe(`Invalid value ${JSON.stringify(e2)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
              if (typeof a != "string")
                throw new Fe(`Invalid value ${JSON.stringify(a)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
            }
        }
      }
    }, errorFormat: (e2) => {
      if (e2) {
        if (typeof e2 != "string")
          throw new Fe(`Invalid value ${JSON.stringify(e2)} for "errorFormat" provided to PrismaClient constructor.`);
        if (!Ks.includes(e2)) {
          let t = Ut(e2, Ks);
          throw new Fe(`Invalid errorFormat ${e2} provided to PrismaClient constructor.${t}`);
        }
      }
    }, log: (e2) => {
      if (!e2)
        return;
      if (!Array.isArray(e2))
        throw new Fe(`Invalid value ${JSON.stringify(e2)} for "log" provided to PrismaClient constructor.`);
      function t(r) {
        if (typeof r == "string" && !Qs.includes(r)) {
          let n = Ut(r, Qs);
          throw new Fe(`Invalid log level "${r}" provided to PrismaClient constructor.${n}`);
        }
      }
      y(t, "t"), d(t, "validateLogLevel");
      for (let r of e2) {
        t(r);
        let n = { level: t, emit: (i) => {
          let a = ["stdout", "event"];
          if (!a.includes(i)) {
            let o = Ut(i, a);
            throw new Fe(`Invalid value ${JSON.stringify(i)} for "emit" in logLevel provided to PrismaClient constructor.${o}`);
          }
        } };
        if (r && typeof r == "object")
          for (let [i, a] of Object.entries(r))
            if (n[i])
              n[i](a);
            else
              throw new Fe(`Invalid property ${i} for "log" provided to PrismaClient constructor`);
      }
    }, __internal: (e2) => {
      if (!e2)
        return;
      let t = ["debug", "hooks", "engine", "measurePerformance"];
      if (typeof e2 != "object")
        throw new Fe(`Invalid value ${JSON.stringify(e2)} for "__internal" to PrismaClient constructor`);
      for (let [r] of Object.entries(e2))
        if (!t.includes(r)) {
          let n = Ut(r, t);
          throw new Fe(`Invalid property ${JSON.stringify(r)} for "__internal" provided to PrismaClient constructor.${n}`);
        }
    }, rejectOnNotFound: (e2) => {
      if (e2) {
        if (Qr(e2) || typeof e2 == "boolean" || typeof e2 == "object" || typeof e2 == "function")
          return e2;
        throw new Fe(`Invalid rejectOnNotFound expected a boolean/Error/{[modelName: Error | boolean]} but received ${JSON.stringify(e2)}`);
      }
    } };
    function Xs(e2, t) {
      for (let [r, n] of Object.entries(e2)) {
        if (!Zs.includes(r)) {
          let i = Ut(r, Zs);
          throw new Fe(`Unknown property ${r} provided to PrismaClient constructor.${i}`);
        }
        tf[r](n, t);
      }
    }
    y(Xs, "Tl");
    d(Xs, "validatePrismaClientOptions");
    function Ut(e2, t) {
      if (t.length === 0 || typeof e2 != "string")
        return "";
      let r = eu(e2, t);
      return r ? ` Did you mean "${r}"?` : "";
    }
    y(Ut, "rr");
    d(Ut, "getDidYouMean");
    function eu(e2, t) {
      if (t.length === 0)
        return null;
      let r = t.map((i) => ({ value: i, distance: (0, ef.default)(e2, i) }));
      r.sort((i, a) => i.distance < a.distance ? -1 : 1);
      let n = r[0];
      return n.distance < 3 ? n.value : null;
    }
    y(eu, "ym");
    d(eu, "getAlternative");
    var Le = (0, Gn.default)("prisma:client");
    var rf = /^(\s*alter\s)/i;
    (globalThis = ct).NOT_PRISMA_DATA_PROXY = true;
    function Yi(e2) {
      return Array.isArray(e2);
    }
    y(Yi, "Sl");
    d(Yi, "isReadonlyArray");
    function vn(e2, t, r) {
      if (t.length > 0 && rf.exec(e2))
        throw new Error(`Running ALTER using ${r} is not supported
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.

Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)

More Information: https://pris.ly/d/execute-raw
`);
    }
    y(vn, "Ri");
    d(vn, "checkAlter");
    var nf = { findUnique: "query", findFirst: "query", findMany: "query", count: "query", create: "mutation", createMany: "mutation", update: "mutation", updateMany: "mutation", upsert: "mutation", delete: "mutation", deleteMany: "mutation", executeRaw: "mutation", queryRaw: "mutation", aggregate: "query", groupBy: "query", runCommandRaw: "mutation", findRaw: "query", aggregateRaw: "query" };
    var of = Symbol.for("prisma.client.transaction.id");
    function tu(e2) {
      class t {
        constructor(n) {
          var o, l, f, s, c, p, g, v;
          this._middlewares = new cs(), this._transactionId = 1, n && Xs(n, e2.datasourceNames), this._rejectOnNotFound = n == null ? void 0 : n.rejectOnNotFound, this._clientVersion = (o = e2.clientVersion) != null ? o : Xc, this._activeProvider = e2.activeProvider, this._clientEngineType = ii(e2.generator);
          let i = { rootEnvPath: e2.relativeEnvPaths.rootEnvPath && en.default.resolve(e2.dirname, e2.relativeEnvPaths.rootEnvPath), schemaEnvPath: e2.relativeEnvPaths.schemaEnvPath && en.default.resolve(e2.dirname, e2.relativeEnvPaths.schemaEnvPath) }, a = false;
          try {
            let b = n != null ? n : {}, w = (l = b.__internal) != null ? l : {}, E = w.debug === true;
            E && Gn.default.enable("prisma:client"), w.hooks && (this._hooks = w.hooks);
            let x = en.default.resolve(e2.dirname, e2.relativePath);
            xn.existsSync(x) || (x = e2.dirname), Le("dirname", e2.dirname), Le("relativePath", e2.relativePath), Le("cwd", x);
            let S = b.datasources || {}, A = Object.entries(S).filter(([R, C]) => C && C.url).map(([R, { url: C }]) => ({ name: R, url: C })), F = us([], A, (R) => R.name), q = w.engine || {};
            if (b.errorFormat ? this._errorFormat = b.errorFormat : we.env.NODE_ENV === "production" ? this._errorFormat = "minimal" : we.env.NO_COLOR ? this._errorFormat = "colorless" : this._errorFormat = "colorless", this._dmmf = new Dn(e2.document), this._previewFeatures = (s = (f = e2.generator) == null ? void 0 : f.previewFeatures) != null ? s : [], this._engineConfig = { cwd: x, dirname: e2.dirname, enableDebugLogs: E, allowTriggerPanic: q.allowTriggerPanic, datamodelPath: en.default.join(e2.dirname, (c = e2.filename) != null ? c : "schema.prisma"), prismaPath: (p = q.binaryPath) != null ? p : void 0, engineEndpoint: q.endpoint, datasources: F, generator: e2.generator, showColors: this._errorFormat === "pretty", logLevel: b.log && ss(b.log), logQueries: b.log && Boolean(typeof b.log == "string" ? b.log === "query" : b.log.find((R) => typeof R == "string" ? R === "query" : R.level === "query")), env: a ? a.parsed : (v = (g = e2.inlineEnv) == null ? void 0 : g.parsed) != null ? v : {}, flags: [], clientVersion: e2.clientVersion, previewFeatures: si(this._previewFeatures), activeProvider: e2.activeProvider, inlineSchema: e2.inlineSchema, inlineDatasources: e2.inlineDatasources, inlineSchemaHash: e2.inlineSchemaHash }, Le(`clientVersion: ${e2.clientVersion}`), Le(`clientEngineType: ${this._clientEngineType}`), this._engine = this.getEngine(), this._getActiveProvider(), this._fetcher = new Ws(this, this._hooks), b.log)
              for (let R of b.log) {
                let C = typeof R == "string" ? R : R.emit === "stdout" ? R.level : null;
                C && this.$on(C, (B) => {
                  var W;
                  ui.log(`${(W = ui.tags[C]) != null ? W : ""}`, B.message || B.query);
                });
              }
          } catch (b) {
            throw b.clientVersion = this._clientVersion, b;
          }
          return is(this);
        }
        get [Symbol.toStringTag]() {
          return "PrismaClient";
        }
        getEngine() {
          return this._clientEngineType === Ie.Library || this._clientEngineType === Ie.Binary ? false : new ni(this._engineConfig);
        }
        $use(n, i) {
          if (typeof n == "function")
            this._middlewares.query.use(n);
          else if (n === "all")
            this._middlewares.query.use(i);
          else if (n === "engine")
            this._middlewares.engine.use(i);
          else
            throw new Error(`Invalid middleware ${n}`);
        }
        $on(n, i) {
          n === "beforeExit" ? this._engine.on("beforeExit", i) : this._engine.on(n, (a) => {
            var l, f, s, c;
            let o = a.fields;
            return i(n === "query" ? { timestamp: a.timestamp, query: (l = o == null ? void 0 : o.query) != null ? l : a.query, params: (f = o == null ? void 0 : o.params) != null ? f : a.params, duration: (s = o == null ? void 0 : o.duration_ms) != null ? s : a.duration, target: a.target } : { timestamp: a.timestamp, message: (c = o == null ? void 0 : o.message) != null ? c : a.message, target: a.target });
          });
        }
        $connect() {
          try {
            return this._engine.start();
          } catch (n) {
            throw n.clientVersion = this._clientVersion, n;
          }
        }
        async _runDisconnect() {
          await this._engine.stop(), delete this._connectionPromise, this._engine = this.getEngine(), delete this._disconnectionPromise, delete this._getConfigPromise;
        }
        $disconnect() {
          try {
            return this._engine.stop();
          } catch (n) {
            throw n.clientVersion = this._clientVersion, n;
          }
        }
        async _getActiveProvider() {
          try {
            let n = await this._engine.getConfig();
            this._activeProvider = n.datasources[0].activeProvider;
          } catch (n) {
          }
        }
        $executeRawInternal(n, i, a, o, ...l) {
          let f = "", s;
          if (typeof o == "string")
            f = o, s = { values: ot(l || []), __prismaRawParamaters__: true }, vn(f, l, "prisma.$executeRawUnsafe(<SQL>, [...values])");
          else if (Yi(o))
            switch (this._activeProvider) {
              case "sqlite":
              case "mysql": {
                let p = xr.sqltag(o, ...l);
                f = p.sql, s = { values: ot(p.values), __prismaRawParamaters__: true };
                break;
              }
              case "cockroachdb":
              case "postgresql": {
                let p = xr.sqltag(o, ...l);
                f = p.text, vn(f, p.values, "prisma.$executeRaw`<SQL>`"), s = { values: ot(p.values), __prismaRawParamaters__: true };
                break;
              }
              case "sqlserver": {
                f = gn(o), s = { values: ot(l), __prismaRawParamaters__: true };
                break;
              }
              default:
                throw new Error(`The ${this._activeProvider} provider does not support $executeRaw`);
            }
          else {
            switch (this._activeProvider) {
              case "sqlite":
              case "mysql":
                f = o.sql;
                break;
              case "cockroachdb":
              case "postgresql":
                f = o.text, vn(f, o.values, "prisma.$executeRaw(sql`<SQL>`)");
                break;
              case "sqlserver":
                f = gn(o.strings);
                break;
              default:
                throw new Error(`The ${this._activeProvider} provider does not support $executeRaw`);
            }
            s = { values: ot(o.values), __prismaRawParamaters__: true };
          }
          (s == null ? void 0 : s.values) ? Le(`prisma.$executeRaw(${f}, ${s.values})`) : Le(`prisma.$executeRaw(${f})`);
          let c = { query: f, parameters: s };
          return Le("Prisma Client call:"), this._request({ args: c, clientMethod: "executeRaw", dataPath: [], action: "executeRaw", callsite: Bt(this._errorFormat), runInTransaction: !!n, transactionId: n, otelCtx: a, lock: i });
        }
        $executeRaw(n, ...i) {
          return Rt((a, o, l) => {
            if (n.raw || n.sql)
              return this.$executeRawInternal(a, o, l, n, ...i);
            throw new or("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n");
          });
        }
        $executeRawUnsafe(n, ...i) {
          return Rt((a, o, l) => this.$executeRawInternal(a, o, l, n, ...i));
        }
        $runCommandRaw(n) {
          if (e2.activeProvider !== "mongodb")
            throw new or(`The ${e2.activeProvider} provider does not support $runCommandRaw. Use the mongodb provider.`);
          return Rt((i, a, o) => this._request({ args: { command: n }, clientMethod: "runCommandRaw", dataPath: [], action: "runCommandRaw", callsite: Bt(this._errorFormat), runInTransaction: !!i, transactionId: i, otelCtx: o, lock: a }));
        }
        $queryRawInternal(n, i, a, o, ...l) {
          let f = "", s;
          if (typeof o == "string")
            f = o, s = { values: ot(l || []), __prismaRawParamaters__: true };
          else if (Yi(o))
            switch (this._activeProvider) {
              case "sqlite":
              case "mysql": {
                let p = xr.sqltag(o, ...l);
                f = p.sql, s = { values: ot(p.values), __prismaRawParamaters__: true };
                break;
              }
              case "cockroachdb":
              case "postgresql": {
                let p = xr.sqltag(o, ...l);
                f = p.text, s = { values: ot(p.values), __prismaRawParamaters__: true };
                break;
              }
              case "sqlserver": {
                let p = xr.sqltag(o, ...l);
                f = gn(p.strings), s = { values: ot(p.values), __prismaRawParamaters__: true };
                break;
              }
              default:
                throw new Error(`The ${this._activeProvider} provider does not support $queryRaw`);
            }
          else {
            switch (this._activeProvider) {
              case "sqlite":
              case "mysql":
                f = o.sql;
                break;
              case "cockroachdb":
              case "postgresql":
                f = o.text;
                break;
              case "sqlserver":
                f = gn(o.strings);
                break;
              default:
                throw new Error(`The ${this._activeProvider} provider does not support $queryRaw`);
            }
            s = { values: ot(o.values), __prismaRawParamaters__: true };
          }
          (s == null ? void 0 : s.values) ? Le(`prisma.queryRaw(${f}, ${s.values})`) : Le(`prisma.queryRaw(${f})`);
          let c = { query: f, parameters: s };
          return Le("Prisma Client call:"), this._request({ args: c, clientMethod: "queryRaw", dataPath: [], action: "queryRaw", callsite: Bt(this._errorFormat), runInTransaction: !!n, transactionId: n, otelCtx: a, lock: i });
        }
        $queryRaw(n, ...i) {
          return Rt((a, o, l) => {
            if (n.raw || n.sql)
              return this.$queryRawInternal(a, o, l, n, ...i);
            throw new or("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n");
          });
        }
        $queryRawUnsafe(n, ...i) {
          return Rt((a, o, l) => this.$queryRawInternal(a, o, l, n, ...i));
        }
        __internal_triggerPanic(n) {
          if (!this._engineConfig.allowTriggerPanic)
            throw new Error(`In order to use .__internal_triggerPanic(), please enable it like so:
new PrismaClient({
  __internal: {
    engine: {
      allowTriggerPanic: true
    }
  }
})`);
          let i = n ? { "X-DEBUG-FATAL": "1" } : { "X-DEBUG-NON-FATAL": "1" };
          return this._request({ action: "queryRaw", args: { query: "SELECT 1", parameters: void 0 }, clientMethod: "queryRaw", dataPath: [], runInTransaction: false, headers: i, callsite: Bt(this._errorFormat) });
        }
        _transactionWithArray(n) {
          let i = this._transactionId++, a = as(n.length), o = n.map((l) => {
            var f;
            if ((l == null ? void 0 : l[Symbol.toStringTag]) !== "PrismaPromise")
              throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");
            return (f = l.requestTransaction) == null ? void 0 : f.call(l, i, a);
          });
          return Promise.all(o);
        }
        async _transactionWithCallback(n, i) {
          let a = await this._engine.transaction("start", i), o;
          try {
            o = await n(bn(this, a.id)), await this._engine.transaction("commit", a);
          } catch (l) {
            throw await this._engine.transaction("rollback", a).catch(() => {
            }), l.clientVersion = this._clientVersion, l;
          }
          return o;
        }
        async $transaction(n, i) {
          return this._hasPreviewFlag("interactiveTransactions") ? typeof n == "function" ? this._transactionWithCallback(n, i) : this._transactionWithArray(n) : this._transactionWithArray(n);
        }
        async _request(n) {
          this._hasPreviewFlag("tracing") || delete n.otelCtx;
          try {
            let i = { args: n.args, dataPath: n.dataPath, runInTransaction: n.runInTransaction, action: n.action, model: n.model }, a = -1, o = d((l) => {
              let f = this._middlewares.query.get(++a);
              if (f)
                return f(l, o);
              let s = { ...n, ...l };
              return this._executeRequest(s);
            }, "consumer");
            return await Hs("request", n.otelCtx, () => o(i));
          } catch (i) {
            throw i.clientVersion = this._clientVersion, i;
          }
        }
        async _executeRequest({ args: n, clientMethod: i, dataPath: a, callsite: o, runInTransaction: l, action: f, model: s, headers: c, transactionId: p, otelCtx: g, lock: v, unpacker: b }) {
          let w, E = nf[f];
          (f === "executeRaw" || f === "queryRaw" || f === "runCommandRaw") && (w = f);
          let x;
          if (s !== void 0) {
            if (x = this._dmmf.mappingsMap[s], x === void 0)
              throw new Error(`Could not find mapping for model ${s}`);
            w = x[f === "count" ? "aggregate" : f];
          }
          if (E !== "query" && E !== "mutation")
            throw new Error(`Invalid operation ${E} for action ${f}`);
          let S = this._dmmf.rootFieldMap[w];
          if (S === void 0)
            throw new Error(`Could not find rootField ${w} for action ${f} for model ${s} on rootType ${E}`);
          let { isList: A } = S.outputType, F = Qt(S.outputType.type), q = Wi(f, F, n, this._rejectOnNotFound), R = Li({ dmmf: this._dmmf, rootField: w, rootTypeName: E, select: n });
          if (R.validate(n, false, i, this._errorFormat, o), R = Ui(R), Gn.default.enabled("prisma:client")) {
            let C = String(R);
            Le("Prisma Client call:"), Le(`prisma.${i}(${qi({ ast: n, keyPaths: [], valuePaths: [], missingItems: [] })})`), Le("Generated request:"), Le(C + `
`);
          }
          return c = Ys(c, g), await v, this._fetcher.request({ document: R, clientMethod: i, typeName: F, dataPath: a, rejectOnNotFound: q, isList: A, rootField: w, callsite: o, showColors: this._errorFormat === "pretty", args: n, engineHook: this._middlewares.engine.get(0), runInTransaction: l, headers: c, transactionId: p, unpacker: b });
        }
        _hasPreviewFlag(n) {
          var i;
          return !!((i = this._engineConfig.previewFeatures) == null ? void 0 : i.includes(n));
        }
      }
      return y(t, "t"), d(t, "PrismaClient"), t;
    }
    y(tu, "Em");
    d(tu, "getPrismaClient");
    var af = ["$connect", "$disconnect", "$on", "$transaction", "$use"];
    function bn(e2, t) {
      return typeof e2 != "object" ? e2 : new Proxy(e2, { get: (r, n) => {
        if (!af.includes(n))
          return n === of ? t : typeof r[n] == "function" ? (...i) => n === "then" ? r[n](i[0], i[1], t) : n === "catch" || n === "finally" ? r[n](i[0], t) : bn(r[n](...i), t) : bn(r[n], t);
      } });
    }
    y(bn, "Ni");
    d(bn, "transactionProxy");
    j();
    N();
    I();
    k();
    j();
    N();
    I();
    k();
    var Rr = Ae(vo());
    var sf = Fu.decompressFromBase64;
    var uf = Rr.Sql;
    var lf = Rr.empty;
    var cf = void 0;
    var ff = Rr.join;
    var pf = Rr.raw;
    var df = Rr.sqltag;
    var hf = void 0;
  }
});

// node_modules/.pnpm/@prisma+client@3.13.0_prisma@3.13.0/node_modules/.prisma/client/index.js
var require_client2 = __commonJS({
  "node_modules/.pnpm/@prisma+client@3.13.0_prisma@3.13.0/node_modules/.prisma/client/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var {
      PrismaClientKnownRequestError: PrismaClientKnownRequestError2,
      PrismaClientUnknownRequestError: PrismaClientUnknownRequestError2,
      PrismaClientRustPanicError: PrismaClientRustPanicError2,
      PrismaClientInitializationError: PrismaClientInitializationError2,
      PrismaClientValidationError: PrismaClientValidationError2,
      decompressFromBase64: decompressFromBase642,
      getPrismaClient: getPrismaClient2,
      sqltag: sqltag2,
      empty: empty2,
      join: join3,
      raw: raw2,
      Decimal: Decimal2
    } = require_proxy();
    var Prisma = {};
    exports2.Prisma = Prisma;
    Prisma.prismaVersion = {
      client: "3.13.0",
      engine: "efdf9b1183dddfd4258cd181a72125755215ab7b"
    };
    Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError2;
    Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError2;
    Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError2;
    Prisma.PrismaClientInitializationError = PrismaClientInitializationError2;
    Prisma.PrismaClientValidationError = PrismaClientValidationError2;
    Prisma.Decimal = Decimal2;
    Prisma.sql = sqltag2;
    Prisma.empty = empty2;
    Prisma.join = join3;
    Prisma.raw = raw2;
    Prisma.validator = () => (val) => val;
    Prisma.DbNull = "DbNull";
    Prisma.JsonNull = "JsonNull";
    Prisma.AnyNull = "AnyNull";
    var dirname = "/";
    function makeEnum(x) {
      return x;
    }
    exports2.Prisma.ColletableScalarFieldEnum = makeEnum({
      id: "id",
      createdAt: "createdAt",
      edition: "edition",
      name: "name",
      image: "image"
    });
    exports2.Prisma.SortOrder = makeEnum({
      asc: "asc",
      desc: "desc"
    });
    exports2.Prisma.QueryMode = makeEnum({
      default: "default",
      insensitive: "insensitive"
    });
    exports2.Prisma.ModelName = makeEnum({
      Colletable: "Colletable"
    });
    var compressedDMMF = "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";
    var decompressedDMMF = decompressFromBase642(compressedDMMF);
    var dmmf = JSON.parse(decompressedDMMF);
    exports2.Prisma.dmmf = JSON.parse(decompressedDMMF);
    var config2 = {
      "generator": {
        "name": "client",
        "provider": {
          "fromEnvVar": null,
          "value": "prisma-client-js"
        },
        "output": {
          "value": "/home/isak/code/prisma-data-cockroach/node_modules/.pnpm/@prisma+client@3.13.0_prisma@3.13.0/node_modules/@prisma/client",
          "fromEnvVar": null
        },
        "config": {
          "engineType": "dataproxy"
        },
        "binaryTargets": [],
        "previewFeatures": [
          "dataProxy",
          "cockroachdb"
        ]
      },
      "relativeEnvPaths": {
        "rootEnvPath": "../../../../../../.env",
        "schemaEnvPath": "../../../../../../.env"
      },
      "relativePath": "../../../../../../prisma",
      "clientVersion": "3.13.0",
      "engineVersion": "efdf9b1183dddfd4258cd181a72125755215ab7b",
      "datasourceNames": [
        "db"
      ],
      "activeProvider": "cockroachdb"
    };
    config2.document = dmmf;
    config2.dirname = dirname;
    config2.inlineDatasources = {
      "db": {
        "url": {
          "fromEnvVar": "DATABASE_URL",
          "value": null
        }
      }
    };
    config2.inlineSchema = "Ly8gVGhpcyBpcyB5b3VyIFByaXNtYSBzY2hlbWEgZmlsZSwKLy8gbGVhcm4gbW9yZSBhYm91dCBpdCBpbiB0aGUgZG9jczogaHR0cHM6Ly9wcmlzLmx5L2QvcHJpc21hLXNjaGVtYQoKZ2VuZXJhdG9yIGNsaWVudCB7CiAgcHJvdmlkZXIgICAgICAgID0gInByaXNtYS1jbGllbnQtanMiCiAgcHJldmlld0ZlYXR1cmVzID0gWyJkYXRhcHJveHkiLCAiY29ja3JvYWNoZGIiXQp9CgpnZW5lcmF0b3IgcG90aG9zIHsKICBwcm92aWRlciAgICAgPSAicHJpc21hLXBvdGhvcy10eXBlcyIKICBjbGllbnRPdXRwdXQgPSAiQHByaXNtYS9jbGllbnQiCiAgb3V0cHV0ICAgICAgID0gIi4vcG90aG9zLXR5cGVzLnRzIgp9CgpkYXRhc291cmNlIGRiIHsKICBwcm92aWRlciA9ICJjb2Nrcm9hY2hkYiIKICB1cmwgICAgICA9IGVudigiREFUQUJBU0VfVVJMIikKfQoKbW9kZWwgQ29sbGV0YWJsZSB7CiAgaWQgICAgICAgIEludCAgICAgIEBpZCBAZGVmYXVsdChhdXRvaW5jcmVtZW50KCkpCiAgY3JlYXRlZEF0IERhdGVUaW1lIEBkZWZhdWx0KG5vdygpKQogIGVkaXRpb24gICBJbnQKICBuYW1lICAgICAgU3RyaW5nCiAgaW1hZ2UgICAgIFN0cmluZwp9Cg==";
    config2.inlineSchemaHash = "47e438dde482ac871d3328e6c90175a2f5c236d570d7f85cccb70d7389c28d11";
    config2.inlineEnv = {
      parsed: {
        DATABASE_URL: typeof global !== "undefined" && global["DATABASE_URL"] || process.env["DATABASE_URL"] || "postgresql://moomintroll:9BLw6KGY-8p3XXCUjahdew@free-tier5.gcp-europe-west1.cockroachlabs.cloud:26257/defaultdb?sslmode=verify-full&options=--cluster%3Dmoomin-collector-3629"
      }
    };
    var PrismaClient2 = getPrismaClient2(config2);
    exports2.PrismaClient = PrismaClient2;
    Object.assign(exports2, Prisma);
  }
});

// node_modules/.pnpm/@prisma+client@3.13.0_prisma@3.13.0/node_modules/@prisma/client/index.js
var require_client3 = __commonJS({
  "node_modules/.pnpm/@prisma+client@3.13.0_prisma@3.13.0/node_modules/@prisma/client/index.js"(exports2, module2) {
    var prisma2 = require_client2();
    module2.exports = prisma2;
  }
});

// node_modules/.pnpm/@envelop+core@2.3.1_graphql@16.4.0/node_modules/@envelop/core/index.mjs
var import_graphql = __toESM(require_graphql2(), 1);
var EnableIfBranded;
(function(EnableIfBranded2) {
  EnableIfBranded2[EnableIfBranded2["DisabledPlugin"] = 0] = "DisabledPlugin";
})(EnableIfBranded || (EnableIfBranded = {}));
function isPluginEnabled(t) {
  return t !== EnableIfBranded.DisabledPlugin && t !== null;
}
function enableIf(condition, plugin) {
  if (condition) {
    return typeof plugin === "function" ? plugin() : plugin;
  } else {
    return EnableIfBranded.DisabledPlugin;
  }
}
var trackedSchemaSymbol = Symbol("TRACKED_SCHEMA");
var resolversHooksSymbol = Symbol("RESOLVERS_HOOKS");
function prepareTracedSchema(schema) {
  if (!schema || schema[trackedSchemaSymbol]) {
    return;
  }
  schema[trackedSchemaSymbol] = true;
  const entries = Object.values(schema.getTypeMap());
  for (const type of entries) {
    if (!(0, import_graphql.isIntrospectionType)(type) && (0, import_graphql.isObjectType)(type)) {
      const fields = Object.values(type.getFields());
      for (const field of fields) {
        let resolverFn = field.resolve || import_graphql.defaultFieldResolver;
        field.resolve = async (root, args, context, info) => {
          if (context && context[resolversHooksSymbol]) {
            const hooks = context[resolversHooksSymbol];
            const afterCalls = [];
            for (const hook of hooks) {
              const afterFn = await hook({
                root,
                args,
                context,
                info,
                resolverFn,
                replaceResolverFn: (newFn) => {
                  resolverFn = newFn;
                }
              });
              afterFn && afterCalls.push(afterFn);
            }
            try {
              let result = await resolverFn(root, args, context, info);
              for (const afterFn of afterCalls) {
                afterFn({
                  result,
                  setResult: (newResult) => {
                    result = newResult;
                  }
                });
              }
              return result;
            } catch (e2) {
              let resultErr = e2;
              for (const afterFn of afterCalls) {
                afterFn({
                  result: resultErr,
                  setResult: (newResult) => {
                    resultErr = newResult;
                  }
                });
              }
              throw resultErr;
            }
          } else {
            return resolverFn(root, args, context, info);
          }
        };
      }
    }
  }
}
var envelopIsIntrospectionSymbol = Symbol("ENVELOP_IS_INTROSPECTION");
function isIntrospectionOperationString(operation) {
  return (typeof operation === "string" ? operation : operation.body).indexOf("__schema") !== -1;
}
function getSubscribeArgs(args) {
  return args.length === 1 ? args[0] : {
    schema: args[0],
    document: args[1],
    rootValue: args[2],
    contextValue: args[3],
    variableValues: args[4],
    operationName: args[5],
    fieldResolver: args[6],
    subscribeFieldResolver: args[7]
  };
}
var makeSubscribe = (subscribeFn) => (...polyArgs) => subscribeFn(getSubscribeArgs(polyArgs));
function mapAsyncIterator(source, mapper) {
  const iterator = source[Symbol.asyncIterator]();
  async function mapResult(result) {
    var _a3;
    if (result.done) {
      return result;
    }
    try {
      return { value: await mapper(result.value), done: false };
    } catch (error2) {
      try {
        await ((_a3 = iterator.return) === null || _a3 === void 0 ? void 0 : _a3.call(iterator));
      } catch (_error) {
      }
      throw error2;
    }
  }
  const stream = {
    [Symbol.asyncIterator]() {
      return stream;
    },
    async next() {
      return await mapResult(await iterator.next());
    },
    async return() {
      var _a3;
      const promise = (_a3 = iterator.return) === null || _a3 === void 0 ? void 0 : _a3.call(iterator);
      return promise ? await mapResult(await promise) : { value: void 0, done: true };
    },
    async throw(error2) {
      var _a3;
      const promise = (_a3 = iterator.throw) === null || _a3 === void 0 ? void 0 : _a3.call(iterator);
      if (promise) {
        return await mapResult(await promise);
      }
      throw error2;
    }
  };
  return stream;
}
function getExecuteArgs(args) {
  return args.length === 1 ? args[0] : {
    schema: args[0],
    document: args[1],
    rootValue: args[2],
    contextValue: args[3],
    variableValues: args[4],
    operationName: args[5],
    fieldResolver: args[6],
    typeResolver: args[7]
  };
}
var makeExecute = (executeFn) => (...polyArgs) => executeFn(getExecuteArgs(polyArgs));
function isAsyncIterable(maybeAsyncIterable) {
  return typeof maybeAsyncIterable === "object" && maybeAsyncIterable != null && typeof maybeAsyncIterable[Symbol.asyncIterator] === "function";
}
function handleStreamOrSingleExecutionResult(payload, fn2) {
  if (isAsyncIterable(payload.result)) {
    return { onNext: fn2 };
  } else {
    fn2({
      args: payload.args,
      result: payload.result,
      setResult: payload.setResult
    });
    return void 0;
  }
}
function finalAsyncIterator(source, onFinal) {
  const iterator = source[Symbol.asyncIterator]();
  let isDone = false;
  const stream = {
    [Symbol.asyncIterator]() {
      return stream;
    },
    async next() {
      const result = await iterator.next();
      if (result.done && isDone === false) {
        isDone = true;
        onFinal();
      }
      return result;
    },
    async return() {
      var _a3;
      const promise = (_a3 = iterator.return) === null || _a3 === void 0 ? void 0 : _a3.call(iterator);
      if (isDone === false) {
        isDone = true;
        onFinal();
      }
      return promise ? await promise : { done: true, value: void 0 };
    },
    async throw(error2) {
      var _a3;
      const promise = (_a3 = iterator.throw) === null || _a3 === void 0 ? void 0 : _a3.call(iterator);
      if (promise) {
        return await promise;
      }
      throw error2;
    }
  };
  return stream;
}
function errorAsyncIterator(source, onError) {
  const iterator = source[Symbol.asyncIterator]();
  const stream = {
    [Symbol.asyncIterator]() {
      return stream;
    },
    async next() {
      try {
        return await iterator.next();
      } catch (error2) {
        onError(error2);
        return { done: true, value: void 0 };
      }
    },
    async return() {
      var _a3;
      const promise = (_a3 = iterator.return) === null || _a3 === void 0 ? void 0 : _a3.call(iterator);
      return promise ? await promise : { done: true, value: void 0 };
    },
    async throw(error2) {
      var _a3;
      const promise = (_a3 = iterator.throw) === null || _a3 === void 0 ? void 0 : _a3.call(iterator);
      if (promise) {
        return await promise;
      }
      throw error2;
    }
  };
  return stream;
}
function createEnvelopOrchestrator(plugins) {
  let schema = null;
  let initDone = false;
  const onResolversHandlers = [];
  for (const plugin of plugins) {
    if (plugin.onResolverCalled) {
      onResolversHandlers.push(plugin.onResolverCalled);
    }
  }
  const replaceSchema = (newSchema, ignorePluginIndex = -1) => {
    if (onResolversHandlers.length) {
      prepareTracedSchema(newSchema);
    }
    schema = newSchema;
    if (initDone) {
      for (const [i, plugin] of plugins.entries()) {
        if (i !== ignorePluginIndex) {
          plugin.onSchemaChange && plugin.onSchemaChange({
            schema,
            replaceSchema: (schemaToSet) => {
              replaceSchema(schemaToSet, i);
            }
          });
        }
      }
    }
  };
  const contextErrorHandlers = [];
  for (const [i, plugin] of plugins.entries()) {
    plugin.onPluginInit && plugin.onPluginInit({
      plugins,
      addPlugin: (newPlugin) => {
        plugins.push(newPlugin);
      },
      setSchema: (modifiedSchema) => replaceSchema(modifiedSchema, i),
      registerContextErrorHandler: (handler) => contextErrorHandlers.push(handler)
    });
  }
  const beforeCallbacks = {
    init: [],
    parse: [],
    validate: [],
    subscribe: [],
    execute: [],
    context: []
  };
  for (const { onContextBuilding, onExecute, onParse, onSubscribe, onValidate, onEnveloped } of plugins) {
    onEnveloped && beforeCallbacks.init.push(onEnveloped);
    onContextBuilding && beforeCallbacks.context.push(onContextBuilding);
    onExecute && beforeCallbacks.execute.push(onExecute);
    onParse && beforeCallbacks.parse.push(onParse);
    onSubscribe && beforeCallbacks.subscribe.push(onSubscribe);
    onValidate && beforeCallbacks.validate.push(onValidate);
  }
  const init = (initialContext) => {
    for (const [i, onEnveloped] of beforeCallbacks.init.entries()) {
      onEnveloped({
        context: initialContext,
        extendContext: (extension) => {
          if (!initialContext) {
            return;
          }
          Object.assign(initialContext, extension);
        },
        setSchema: (modifiedSchema) => replaceSchema(modifiedSchema, i)
      });
    }
  };
  const customParse = beforeCallbacks.parse.length ? (initialContext) => (source, parseOptions) => {
    let result = null;
    let parseFn = import_graphql.parse;
    const context = initialContext;
    const afterCalls = [];
    for (const onParse of beforeCallbacks.parse) {
      const afterFn = onParse({
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        params: { source, options: parseOptions },
        parseFn,
        setParseFn: (newFn) => {
          parseFn = newFn;
        },
        setParsedDocument: (newDoc) => {
          result = newDoc;
        }
      });
      afterFn && afterCalls.push(afterFn);
    }
    if (result === null) {
      try {
        result = parseFn(source, parseOptions);
      } catch (e2) {
        result = e2;
      }
    }
    for (const afterCb of afterCalls) {
      afterCb({
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        replaceParseResult: (newResult) => {
          result = newResult;
        },
        result
      });
    }
    if (result === null) {
      throw new Error(`Failed to parse document.`);
    }
    if (result instanceof Error) {
      throw result;
    }
    return result;
  } : () => import_graphql.parse;
  const customValidate = beforeCallbacks.validate.length ? (initialContext) => (schema2, documentAST, rules, typeInfo, validationOptions) => {
    let actualRules = rules ? [...rules] : void 0;
    let validateFn = import_graphql.validate;
    let result = null;
    const context = initialContext;
    const afterCalls = [];
    for (const onValidate of beforeCallbacks.validate) {
      const afterFn = onValidate({
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        params: {
          schema: schema2,
          documentAST,
          rules: actualRules,
          typeInfo,
          options: validationOptions
        },
        validateFn,
        addValidationRule: (rule) => {
          if (!actualRules) {
            actualRules = [...import_graphql.specifiedRules];
          }
          actualRules.push(rule);
        },
        setValidationFn: (newFn) => {
          validateFn = newFn;
        },
        setResult: (newResults) => {
          result = newResults;
        }
      });
      afterFn && afterCalls.push(afterFn);
    }
    if (!result) {
      result = validateFn(schema2, documentAST, actualRules, typeInfo, validationOptions);
    }
    const valid = result.length === 0;
    for (const afterCb of afterCalls) {
      afterCb({
        valid,
        result,
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        setResult: (newResult) => {
          result = newResult;
        }
      });
    }
    return result;
  } : () => import_graphql.validate;
  const customContextFactory = beforeCallbacks.context.length ? (initialContext) => async (orchestratorCtx) => {
    const afterCalls = [];
    let context = orchestratorCtx ? { ...initialContext, ...orchestratorCtx } : initialContext;
    try {
      let isBreakingContextBuilding = false;
      for (const onContext of beforeCallbacks.context) {
        const afterHookResult = await onContext({
          context,
          extendContext: (extension) => {
            context = { ...context, ...extension };
          },
          breakContextBuilding: () => {
            isBreakingContextBuilding = true;
          }
        });
        if (typeof afterHookResult === "function") {
          afterCalls.push(afterHookResult);
        }
        if (isBreakingContextBuilding === true) {
          break;
        }
      }
      for (const afterCb of afterCalls) {
        afterCb({
          context,
          extendContext: (extension) => {
            context = { ...context, ...extension };
          }
        });
      }
      return context;
    } catch (err2) {
      let error2 = err2;
      for (const errorCb of contextErrorHandlers) {
        errorCb({
          context,
          error: error2,
          setError: (err3) => {
            error2 = err3;
          }
        });
      }
      throw error2;
    }
  } : (initialContext) => (orchestratorCtx) => orchestratorCtx ? { ...initialContext, ...orchestratorCtx } : initialContext;
  const useCustomSubscribe = beforeCallbacks.subscribe.length || onResolversHandlers.length;
  const customSubscribe = useCustomSubscribe ? makeSubscribe(async (args) => {
    let subscribeFn = import_graphql.subscribe;
    const afterCalls = [];
    const subscribeErrorHandlers = [];
    let context = args.contextValue || {};
    let result;
    for (const onSubscribe of beforeCallbacks.subscribe) {
      const after = await onSubscribe({
        subscribeFn,
        setSubscribeFn: (newSubscribeFn) => {
          subscribeFn = newSubscribeFn;
        },
        extendContext: (extension) => {
          context = { ...context, ...extension };
        },
        args,
        setResultAndStopExecution: (stopResult) => {
          result = stopResult;
        }
      });
      if (after) {
        if (after.onSubscribeResult) {
          afterCalls.push(after.onSubscribeResult);
        }
        if (after.onSubscribeError) {
          subscribeErrorHandlers.push(after.onSubscribeError);
        }
      }
      if (result !== void 0) {
        break;
      }
    }
    if (onResolversHandlers.length) {
      context[resolversHooksSymbol] = onResolversHandlers;
    }
    if (result === void 0) {
      result = await subscribeFn({
        ...args,
        contextValue: context
      });
    }
    const onNextHandler = [];
    const onEndHandler = [];
    for (const afterCb of afterCalls) {
      const hookResult = afterCb({
        args,
        result,
        setResult: (newResult) => {
          result = newResult;
        }
      });
      if (hookResult) {
        if (hookResult.onNext) {
          onNextHandler.push(hookResult.onNext);
        }
        if (hookResult.onEnd) {
          onEndHandler.push(hookResult.onEnd);
        }
      }
    }
    if (onNextHandler.length && isAsyncIterable(result)) {
      result = mapAsyncIterator(result, async (result2) => {
        for (const onNext of onNextHandler) {
          await onNext({
            args,
            result: result2,
            setResult: (newResult) => result2 = newResult
          });
        }
        return result2;
      });
    }
    if (onEndHandler.length && isAsyncIterable(result)) {
      result = finalAsyncIterator(result, () => {
        for (const onEnd of onEndHandler) {
          onEnd();
        }
      });
    }
    if (subscribeErrorHandlers.length && isAsyncIterable(result)) {
      result = errorAsyncIterator(result, (err2) => {
        let error2 = err2;
        for (const handler of subscribeErrorHandlers) {
          handler({
            error: error2,
            setError: (err3) => {
              error2 = err3;
            }
          });
        }
        throw error2;
      });
    }
    return result;
  }) : makeSubscribe(import_graphql.subscribe);
  const useCustomExecute = beforeCallbacks.execute.length || onResolversHandlers.length;
  const customExecute = useCustomExecute ? makeExecute(async (args) => {
    let executeFn = import_graphql.execute;
    let result;
    const afterCalls = [];
    let context = args.contextValue || {};
    for (const onExecute of beforeCallbacks.execute) {
      const after = await onExecute({
        executeFn,
        setExecuteFn: (newExecuteFn) => {
          executeFn = newExecuteFn;
        },
        setResultAndStopExecution: (stopResult) => {
          result = stopResult;
        },
        extendContext: (extension) => {
          if (typeof extension === "object") {
            context = {
              ...context || {},
              ...extension
            };
          } else {
            throw new Error(`Invalid context extension provided! Expected "object", got: "${JSON.stringify(extension)}" (${typeof extension})`);
          }
        },
        args
      });
      if (after === null || after === void 0 ? void 0 : after.onExecuteDone) {
        afterCalls.push(after.onExecuteDone);
      }
      if (result !== void 0) {
        break;
      }
    }
    if (onResolversHandlers.length) {
      context[resolversHooksSymbol] = onResolversHandlers;
    }
    if (result === void 0) {
      result = await executeFn({
        ...args,
        contextValue: context
      });
    }
    const onNextHandler = [];
    const onEndHandler = [];
    for (const afterCb of afterCalls) {
      const hookResult = await afterCb({
        args,
        result,
        setResult: (newResult) => {
          result = newResult;
        }
      });
      if (hookResult) {
        if (hookResult.onNext) {
          onNextHandler.push(hookResult.onNext);
        }
        if (hookResult.onEnd) {
          onEndHandler.push(hookResult.onEnd);
        }
      }
    }
    if (onNextHandler.length && isAsyncIterable(result)) {
      result = mapAsyncIterator(result, async (result2) => {
        for (const onNext of onNextHandler) {
          await onNext({
            args,
            result: result2,
            setResult: (newResult) => {
              result2 = newResult;
            }
          });
        }
        return result2;
      });
    }
    if (onEndHandler.length && isAsyncIterable(result)) {
      result = finalAsyncIterator(result, () => {
        for (const onEnd of onEndHandler) {
          onEnd();
        }
      });
    }
    return result;
  }) : makeExecute(import_graphql.execute);
  initDone = true;
  if (schema) {
    for (const [i, plugin] of plugins.entries()) {
      plugin.onSchemaChange && plugin.onSchemaChange({
        schema,
        replaceSchema: (modifiedSchema) => replaceSchema(modifiedSchema, i)
      });
    }
  }
  return {
    getCurrentSchema() {
      return schema;
    },
    init,
    parse: customParse,
    validate: customValidate,
    execute: customExecute,
    subscribe: customSubscribe,
    contextFactory: customContextFactory
  };
}
var _a2;
var getTimestamp = typeof globalThis !== "undefined" && ((_a2 = globalThis === null || globalThis === void 0 ? void 0 : globalThis.performance) === null || _a2 === void 0 ? void 0 : _a2.now) ? () => performance.now() : () => Date.now();
var measure = () => {
  const start = getTimestamp();
  return () => {
    const end = getTimestamp();
    return end - start;
  };
};
var tracingSymbol = Symbol("envelopTracing");
function traceOrchestrator(orchestrator) {
  const createTracer = (name, ctx) => {
    const end = measure();
    return () => {
      ctx[tracingSymbol][name] = end();
    };
  };
  return {
    ...orchestrator,
    init: (ctx = {}) => {
      ctx[tracingSymbol] = ctx[tracingSymbol] || {};
      const done2 = createTracer("init", ctx || {});
      try {
        return orchestrator.init(ctx);
      } finally {
        done2();
      }
    },
    parse: (ctx = {}) => {
      ctx[tracingSymbol] = ctx[tracingSymbol] || {};
      const actualFn = orchestrator.parse(ctx);
      return (...args) => {
        const done2 = createTracer("parse", ctx);
        try {
          return actualFn(...args);
        } finally {
          done2();
        }
      };
    },
    validate: (ctx = {}) => {
      ctx[tracingSymbol] = ctx[tracingSymbol] || {};
      const actualFn = orchestrator.validate(ctx);
      return (...args) => {
        const done2 = createTracer("validate", ctx);
        try {
          return actualFn(...args);
        } finally {
          done2();
        }
      };
    },
    execute: async (argsOrSchema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver) => {
      const args = argsOrSchema instanceof import_graphql.GraphQLSchema ? {
        schema: argsOrSchema,
        document,
        rootValue,
        contextValue,
        variableValues,
        operationName,
        fieldResolver,
        typeResolver
      } : argsOrSchema;
      const done2 = createTracer("execute", args.contextValue || {});
      try {
        const result = await orchestrator.execute(args);
        done2();
        if (!isAsyncIterable(result)) {
          result.extensions = result.extensions || {};
          result.extensions.envelopTracing = args.contextValue[tracingSymbol];
        } else {
          console.warn(`"traceOrchestrator" encountered a AsyncIterator which is not supported yet, so tracing data is not available for the operation.`);
        }
        return result;
      } catch (e2) {
        done2();
        throw e2;
      }
    },
    subscribe: async (argsOrSchema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver) => {
      const args = argsOrSchema instanceof import_graphql.GraphQLSchema ? {
        schema: argsOrSchema,
        document,
        rootValue,
        contextValue,
        variableValues,
        operationName,
        fieldResolver,
        subscribeFieldResolver
      } : argsOrSchema;
      const done2 = createTracer("subscribe", args.contextValue || {});
      try {
        return await orchestrator.subscribe(args);
      } finally {
        done2();
      }
    },
    contextFactory: (ctx = {}) => {
      const actualFn = orchestrator.contextFactory(ctx);
      return async (childCtx) => {
        const done2 = createTracer("contextFactory", ctx);
        try {
          return await actualFn(childCtx);
        } finally {
          done2();
        }
      };
    }
  };
}
function envelop(options2) {
  const plugins = options2.plugins.filter(isPluginEnabled);
  let orchestrator = createEnvelopOrchestrator(plugins);
  if (options2.enableInternalTracing) {
    orchestrator = traceOrchestrator(orchestrator);
  }
  const getEnveloped = (initialContext = {}) => {
    const typedOrchestrator = orchestrator;
    typedOrchestrator.init(initialContext);
    return {
      parse: typedOrchestrator.parse(initialContext),
      validate: typedOrchestrator.validate(initialContext),
      contextFactory: typedOrchestrator.contextFactory(initialContext),
      execute: typedOrchestrator.execute,
      subscribe: typedOrchestrator.subscribe,
      schema: typedOrchestrator.getCurrentSchema()
    };
  };
  getEnveloped._plugins = plugins;
  return getEnveloped;
}
var DEFAULT_OPTIONS = {
  logFn: console.log
};
var useLogger = (rawOptions = DEFAULT_OPTIONS) => {
  const options2 = {
    DEFAULT_OPTIONS,
    ...rawOptions
  };
  return {
    onParse({ extendContext, params }) {
      if (options2.skipIntrospection && isIntrospectionOperationString(params.source)) {
        extendContext({
          [envelopIsIntrospectionSymbol]: true
        });
      }
    },
    onExecute({ args }) {
      if (args.contextValue[envelopIsIntrospectionSymbol]) {
        return;
      }
      options2.logFn("execute-start", { args });
      return {
        onExecuteDone: ({ result }) => {
          options2.logFn("execute-end", { args, result });
        }
      };
    },
    onSubscribe({ args }) {
      if (args.contextValue[envelopIsIntrospectionSymbol]) {
        return;
      }
      options2.logFn("subscribe-start", { args });
      return {
        onSubscribeResult: ({ result }) => {
          options2.logFn("subscribe-end", { args, result });
        }
      };
    }
  };
};
var useSchema = (schema) => {
  return {
    onPluginInit({ setSchema }) {
      setSchema(schema);
    }
  };
};
var useExtendContext = (contextFactory) => ({
  async onContextBuilding({ context, extendContext }) {
    extendContext(await contextFactory(context));
  }
});
var DEFAULT_ERROR_MESSAGE = "Unexpected error.";
var EnvelopError = class extends import_graphql.GraphQLError {
  constructor(message, extensions) {
    super(message, void 0, void 0, void 0, void 0, void 0, extensions);
  }
};
var formatError = (err2, message, isDev) => {
  var _a3, _b, _c2, _d;
  if (err2 instanceof import_graphql.GraphQLError) {
    if (err2.originalError && err2.originalError instanceof EnvelopError === false || err2.originalError === void 0 && err2 instanceof EnvelopError === false) {
      return new import_graphql.GraphQLError(message, err2.nodes, err2.source, err2.positions, err2.path, void 0, isDev ? {
        originalError: {
          message: (_b = (_a3 = err2.originalError) === null || _a3 === void 0 ? void 0 : _a3.message) !== null && _b !== void 0 ? _b : err2.message,
          stack: (_d = (_c2 = err2.originalError) === null || _c2 === void 0 ? void 0 : _c2.stack) !== null && _d !== void 0 ? _d : err2.stack
        }
      } : void 0);
    }
    return err2;
  }
  return new import_graphql.GraphQLError(message);
};
var makeHandleResult$2 = (format3, message, isDev) => ({ result, setResult }) => {
  if (result.errors != null) {
    setResult({ ...result, errors: result.errors.map((error2) => format3(error2, message, isDev)) });
  }
};
var useMaskedErrors = (opts) => {
  var _a3, _b;
  const format3 = (_a3 = opts === null || opts === void 0 ? void 0 : opts.formatError) !== null && _a3 !== void 0 ? _a3 : formatError;
  const message = (opts === null || opts === void 0 ? void 0 : opts.errorMessage) || DEFAULT_ERROR_MESSAGE;
  const isDev = (_b = opts === null || opts === void 0 ? void 0 : opts.isDev) !== null && _b !== void 0 ? _b : typeof process !== "undefined" ? process.env["NODE_ENV"] === "development" : false;
  const handleResult = makeHandleResult$2(format3, message, isDev);
  return {
    onParse: (opts === null || opts === void 0 ? void 0 : opts.handleParseErrors) === true ? function onParse() {
      return function onParseEnd({ result, replaceParseResult }) {
        if (result instanceof Error) {
          replaceParseResult(format3(result, message, isDev));
        }
      };
    } : void 0,
    onValidate: (opts === null || opts === void 0 ? void 0 : opts.handleValidationErrors) === true ? function onValidate() {
      return function onValidateEnd({ valid, result, setResult }) {
        if (valid === false) {
          setResult(result.map((error2) => format3(error2, message, isDev)));
        }
      };
    } : void 0,
    onPluginInit(context) {
      context.registerContextErrorHandler(({ error: error2, setError }) => {
        setError(formatError(error2, message, isDev));
      });
    },
    onExecute() {
      return {
        onExecuteDone(payload) {
          return handleStreamOrSingleExecutionResult(payload, handleResult);
        }
      };
    },
    onSubscribe() {
      return {
        onSubscribeResult(payload) {
          return handleStreamOrSingleExecutionResult(payload, handleResult);
        },
        onSubscribeError({ error: error2, setError }) {
          setError(formatError(error2, message, isDev));
        }
      };
    }
  };
};
var fastIntroSpectionSymbol = Symbol("fastIntrospection");

// node_modules/.pnpm/@graphql-tools+utils@8.6.9_graphql@16.4.0/node_modules/@graphql-tools/utils/index.mjs
var import_graphql2 = __toESM(require_graphql2(), 1);
var asArray = (fns) => Array.isArray(fns) ? fns : fns ? [fns] : [];
function compareStrings(a, b) {
  if (String(a) < String(b)) {
    return -1;
  }
  if (String(a) > String(b)) {
    return 1;
  }
  return 0;
}
function nodeToString(a) {
  var _a3, _b;
  let name;
  if ("alias" in a) {
    name = (_a3 = a.alias) === null || _a3 === void 0 ? void 0 : _a3.value;
  }
  if (name == null && "name" in a) {
    name = (_b = a.name) === null || _b === void 0 ? void 0 : _b.value;
  }
  if (name == null) {
    name = a.kind;
  }
  return name;
}
function compareNodes(a, b, customFn) {
  const aStr = nodeToString(a);
  const bStr = nodeToString(b);
  if (typeof customFn === "function") {
    return customFn(aStr, bStr);
  }
  return compareStrings(aStr, bStr);
}
function isSome(input) {
  return input != null;
}
var AggregateErrorImpl;
if (typeof AggregateError === "undefined") {
  class AggregateErrorClass extends Error {
    constructor(errors2, message = "") {
      super(message);
      this.errors = errors2;
      this.name = "AggregateError";
      Error.captureStackTrace(this, AggregateErrorClass);
    }
  }
  AggregateErrorImpl = function(errors2, message) {
    return new AggregateErrorClass(errors2, message);
  };
} else {
  AggregateErrorImpl = AggregateError;
}
function isAggregateError(error2) {
  return "errors" in error2 && Array.isArray(error2["errors"]);
}
var MAX_RECURSIVE_DEPTH = 3;
function inspect(value) {
  return formatValue(value, []);
}
function formatValue(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
}
function formatError2(value) {
  if (value instanceof import_graphql2.GraphQLError) {
    return value.toString();
  }
  return `${value.name}: ${value.message};
 ${value.stack}`;
}
function formatObjectValue(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (value instanceof Error) {
    if (isAggregateError(value)) {
      return formatError2(value) + "\n" + formatArray(value.errors, previouslySeenValues);
    }
    return formatError2(value);
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
}
function isJSONable(value) {
  return typeof value.toJSON === "function";
}
function formatObject(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  const properties = entries.map(([key, value]) => key + ": " + formatValue(value, seenValues));
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = array.length;
  const remaining = array.length;
  const items = [];
  for (let i = 0; i < len; ++i) {
    items.push(formatValue(array[i], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}
function getDirectivesInExtensions(node, pathToDirectivesInExtensions = ["directives"]) {
  return pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === void 0 ? void 0 : node.extensions);
}
function astFromType(type) {
  if ((0, import_graphql2.isNonNullType)(type)) {
    const innerType = astFromType(type.ofType);
    if (innerType.kind === import_graphql2.Kind.NON_NULL_TYPE) {
      throw new Error(`Invalid type node ${inspect(type)}. Inner type of non-null type cannot be a non-null type.`);
    }
    return {
      kind: import_graphql2.Kind.NON_NULL_TYPE,
      type: innerType
    };
  } else if ((0, import_graphql2.isListType)(type)) {
    return {
      kind: import_graphql2.Kind.LIST_TYPE,
      type: astFromType(type.ofType)
    };
  }
  return {
    kind: import_graphql2.Kind.NAMED_TYPE,
    name: {
      kind: import_graphql2.Kind.NAME,
      value: type.name
    }
  };
}
function astFromValueUntyped(value) {
  if (value === null) {
    return { kind: import_graphql2.Kind.NULL };
  }
  if (value === void 0) {
    return null;
  }
  if (Array.isArray(value)) {
    const valuesNodes = [];
    for (const item of value) {
      const itemNode = astFromValueUntyped(item);
      if (itemNode != null) {
        valuesNodes.push(itemNode);
      }
    }
    return { kind: import_graphql2.Kind.LIST, values: valuesNodes };
  }
  if (typeof value === "object") {
    const fieldNodes = [];
    for (const fieldName in value) {
      const fieldValue = value[fieldName];
      const ast = astFromValueUntyped(fieldValue);
      if (ast) {
        fieldNodes.push({
          kind: import_graphql2.Kind.OBJECT_FIELD,
          name: { kind: import_graphql2.Kind.NAME, value: fieldName },
          value: ast
        });
      }
    }
    return { kind: import_graphql2.Kind.OBJECT, fields: fieldNodes };
  }
  if (typeof value === "boolean") {
    return { kind: import_graphql2.Kind.BOOLEAN, value };
  }
  if (typeof value === "number" && isFinite(value)) {
    const stringNum = String(value);
    return integerStringRegExp.test(stringNum) ? { kind: import_graphql2.Kind.INT, value: stringNum } : { kind: import_graphql2.Kind.FLOAT, value: stringNum };
  }
  if (typeof value === "string") {
    return { kind: import_graphql2.Kind.STRING, value };
  }
  throw new TypeError(`Cannot convert value to AST: ${value}.`);
}
var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
function memoize1(fn2) {
  const memoize1cache = /* @__PURE__ */ new WeakMap();
  return function memoized(a1) {
    const cachedValue = memoize1cache.get(a1);
    if (cachedValue === void 0) {
      const newValue = fn2(a1);
      memoize1cache.set(a1, newValue);
      return newValue;
    }
    return cachedValue;
  };
}
function memoize2(fn2) {
  const memoize2cache = /* @__PURE__ */ new WeakMap();
  return function memoized(a1, a2) {
    let cache2 = memoize2cache.get(a1);
    if (!cache2) {
      cache2 = /* @__PURE__ */ new WeakMap();
      memoize2cache.set(a1, cache2);
      const newValue = fn2(a1, a2);
      cache2.set(a2, newValue);
      return newValue;
    }
    const cachedValue = cache2.get(a2);
    if (cachedValue === void 0) {
      const newValue = fn2(a1, a2);
      cache2.set(a2, newValue);
      return newValue;
    }
    return cachedValue;
  };
}
function memoize5(fn2) {
  const memoize5Cache = /* @__PURE__ */ new WeakMap();
  return function memoized(a1, a2, a3, a4, a5) {
    let cache2 = memoize5Cache.get(a1);
    if (!cache2) {
      cache2 = /* @__PURE__ */ new WeakMap();
      memoize5Cache.set(a1, cache2);
      const cache32 = /* @__PURE__ */ new WeakMap();
      cache2.set(a2, cache32);
      const cache42 = /* @__PURE__ */ new WeakMap();
      cache32.set(a3, cache42);
      const cache52 = /* @__PURE__ */ new WeakMap();
      cache42.set(a4, cache52);
      const newValue = fn2(a1, a2, a3, a4, a5);
      cache52.set(a5, newValue);
      return newValue;
    }
    let cache3 = cache2.get(a2);
    if (!cache3) {
      cache3 = /* @__PURE__ */ new WeakMap();
      cache2.set(a2, cache3);
      const cache42 = /* @__PURE__ */ new WeakMap();
      cache3.set(a3, cache42);
      const cache52 = /* @__PURE__ */ new WeakMap();
      cache42.set(a4, cache52);
      const newValue = fn2(a1, a2, a3, a4, a5);
      cache52.set(a5, newValue);
      return newValue;
    }
    let cache4 = cache3.get(a3);
    if (!cache4) {
      cache4 = /* @__PURE__ */ new WeakMap();
      cache3.set(a3, cache4);
      const cache52 = /* @__PURE__ */ new WeakMap();
      cache4.set(a4, cache52);
      const newValue = fn2(a1, a2, a3, a4, a5);
      cache52.set(a5, newValue);
      return newValue;
    }
    let cache5 = cache4.get(a4);
    if (!cache5) {
      cache5 = /* @__PURE__ */ new WeakMap();
      cache4.set(a4, cache5);
      const newValue = fn2(a1, a2, a3, a4, a5);
      cache5.set(a5, newValue);
      return newValue;
    }
    const cachedValue = cache5.get(a5);
    if (cachedValue === void 0) {
      const newValue = fn2(a1, a2, a3, a4, a5);
      cache5.set(a5, newValue);
      return newValue;
    }
    return cachedValue;
  };
}
var getRootTypeNames = memoize1(function getRootTypeNames2(schema) {
  const rootTypes = getRootTypes(schema);
  return new Set([...rootTypes].map((type) => type.name));
});
var getRootTypes = memoize1(function getRootTypes2(schema) {
  const rootTypeMap = getRootTypeMap(schema);
  return new Set(rootTypeMap.values());
});
var getRootTypeMap = memoize1(function getRootTypeMap2(schema) {
  const rootTypeMap = /* @__PURE__ */ new Map();
  const queryType = schema.getQueryType();
  if (queryType) {
    rootTypeMap.set("query", queryType);
  }
  const mutationType = schema.getMutationType();
  if (mutationType) {
    rootTypeMap.set("mutation", mutationType);
  }
  const subscriptionType = schema.getSubscriptionType();
  if (subscriptionType) {
    rootTypeMap.set("subscription", subscriptionType);
  }
  return rootTypeMap;
});
function getDocumentNodeFromSchema(schema, options2 = {}) {
  const pathToDirectivesInExtensions = options2.pathToDirectivesInExtensions;
  const typesMap = schema.getTypeMap();
  const schemaNode = astFromSchema(schema, pathToDirectivesInExtensions);
  const definitions = schemaNode != null ? [schemaNode] : [];
  const directives = schema.getDirectives();
  for (const directive of directives) {
    if ((0, import_graphql2.isSpecifiedDirective)(directive)) {
      continue;
    }
    definitions.push(astFromDirective(directive, schema, pathToDirectivesInExtensions));
  }
  for (const typeName in typesMap) {
    const type = typesMap[typeName];
    const isPredefinedScalar = (0, import_graphql2.isSpecifiedScalarType)(type);
    const isIntrospection = (0, import_graphql2.isIntrospectionType)(type);
    if (isPredefinedScalar || isIntrospection) {
      continue;
    }
    if ((0, import_graphql2.isObjectType)(type)) {
      definitions.push(astFromObjectType(type, schema, pathToDirectivesInExtensions));
    } else if ((0, import_graphql2.isInterfaceType)(type)) {
      definitions.push(astFromInterfaceType(type, schema, pathToDirectivesInExtensions));
    } else if ((0, import_graphql2.isUnionType)(type)) {
      definitions.push(astFromUnionType(type, schema, pathToDirectivesInExtensions));
    } else if ((0, import_graphql2.isInputObjectType)(type)) {
      definitions.push(astFromInputObjectType(type, schema, pathToDirectivesInExtensions));
    } else if ((0, import_graphql2.isEnumType)(type)) {
      definitions.push(astFromEnumType(type, schema, pathToDirectivesInExtensions));
    } else if ((0, import_graphql2.isScalarType)(type)) {
      definitions.push(astFromScalarType(type, schema, pathToDirectivesInExtensions));
    } else {
      throw new Error(`Unknown type ${type}.`);
    }
  }
  return {
    kind: import_graphql2.Kind.DOCUMENT,
    definitions
  };
}
function astFromSchema(schema, pathToDirectivesInExtensions) {
  var _a3, _b;
  const operationTypeMap = /* @__PURE__ */ new Map([
    ["query", void 0],
    ["mutation", void 0],
    ["subscription", void 0]
  ]);
  const nodes = [];
  if (schema.astNode != null) {
    nodes.push(schema.astNode);
  }
  if (schema.extensionASTNodes != null) {
    for (const extensionASTNode of schema.extensionASTNodes) {
      nodes.push(extensionASTNode);
    }
  }
  for (const node of nodes) {
    if (node.operationTypes) {
      for (const operationTypeDefinitionNode of node.operationTypes) {
        operationTypeMap.set(operationTypeDefinitionNode.operation, operationTypeDefinitionNode);
      }
    }
  }
  const rootTypeMap = getRootTypeMap(schema);
  for (const [operationTypeNode, operationTypeDefinitionNode] of operationTypeMap) {
    const rootType = rootTypeMap.get(operationTypeNode);
    if (rootType != null) {
      const rootTypeAST = astFromType(rootType);
      if (operationTypeDefinitionNode != null) {
        operationTypeDefinitionNode.type = rootTypeAST;
      } else {
        operationTypeMap.set(operationTypeNode, {
          kind: import_graphql2.Kind.OPERATION_TYPE_DEFINITION,
          operation: operationTypeNode,
          type: rootTypeAST
        });
      }
    }
  }
  const operationTypes = [...operationTypeMap.values()].filter(isSome);
  const directives = getDirectiveNodes(schema, schema, pathToDirectivesInExtensions);
  if (!operationTypes.length && !directives.length) {
    return null;
  }
  const schemaNode = {
    kind: operationTypes != null ? import_graphql2.Kind.SCHEMA_DEFINITION : import_graphql2.Kind.SCHEMA_EXTENSION,
    operationTypes,
    directives
  };
  schemaNode.description = ((_b = (_a3 = schema.astNode) === null || _a3 === void 0 ? void 0 : _a3.description) !== null && _b !== void 0 ? _b : schema.description != null) ? {
    kind: import_graphql2.Kind.STRING,
    value: schema.description,
    block: true
  } : void 0;
  return schemaNode;
}
function astFromDirective(directive, schema, pathToDirectivesInExtensions) {
  var _a3, _b, _c2, _d;
  return {
    kind: import_graphql2.Kind.DIRECTIVE_DEFINITION,
    description: (_b = (_a3 = directive.astNode) === null || _a3 === void 0 ? void 0 : _a3.description) !== null && _b !== void 0 ? _b : directive.description ? {
      kind: import_graphql2.Kind.STRING,
      value: directive.description
    } : void 0,
    name: {
      kind: import_graphql2.Kind.NAME,
      value: directive.name
    },
    arguments: (_c2 = directive.args) === null || _c2 === void 0 ? void 0 : _c2.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
    repeatable: directive.isRepeatable,
    locations: ((_d = directive.locations) === null || _d === void 0 ? void 0 : _d.map((location) => ({
      kind: import_graphql2.Kind.NAME,
      value: location
    }))) || []
  };
}
function getDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
  const directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);
  let nodes = [];
  if (entity.astNode != null) {
    nodes.push(entity.astNode);
  }
  if ("extensionASTNodes" in entity && entity.extensionASTNodes != null) {
    nodes = nodes.concat(entity.extensionASTNodes);
  }
  let directives;
  if (directivesInExtensions != null) {
    directives = makeDirectiveNodes(schema, directivesInExtensions);
  } else {
    directives = [];
    for (const node of nodes) {
      if (node.directives) {
        directives.push(...node.directives);
      }
    }
  }
  return directives;
}
function getDeprecatableDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
  var _a3, _b;
  let directiveNodesBesidesDeprecated = [];
  let deprecatedDirectiveNode = null;
  const directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);
  let directives;
  if (directivesInExtensions != null) {
    directives = makeDirectiveNodes(schema, directivesInExtensions);
  } else {
    directives = (_a3 = entity.astNode) === null || _a3 === void 0 ? void 0 : _a3.directives;
  }
  if (directives != null) {
    directiveNodesBesidesDeprecated = directives.filter((directive) => directive.name.value !== "deprecated");
    if (entity.deprecationReason != null) {
      deprecatedDirectiveNode = (_b = directives.filter((directive) => directive.name.value === "deprecated")) === null || _b === void 0 ? void 0 : _b[0];
    }
  }
  if (entity.deprecationReason != null && deprecatedDirectiveNode == null) {
    deprecatedDirectiveNode = makeDeprecatedDirective(entity.deprecationReason);
  }
  return deprecatedDirectiveNode == null ? directiveNodesBesidesDeprecated : [deprecatedDirectiveNode].concat(directiveNodesBesidesDeprecated);
}
function astFromArg(arg, schema, pathToDirectivesInExtensions) {
  var _a3, _b, _c2;
  return {
    kind: import_graphql2.Kind.INPUT_VALUE_DEFINITION,
    description: (_b = (_a3 = arg.astNode) === null || _a3 === void 0 ? void 0 : _a3.description) !== null && _b !== void 0 ? _b : arg.description ? {
      kind: import_graphql2.Kind.STRING,
      value: arg.description,
      block: true
    } : void 0,
    name: {
      kind: import_graphql2.Kind.NAME,
      value: arg.name
    },
    type: astFromType(arg.type),
    defaultValue: arg.defaultValue !== void 0 ? (_c2 = (0, import_graphql2.astFromValue)(arg.defaultValue, arg.type)) !== null && _c2 !== void 0 ? _c2 : void 0 : void 0,
    directives: getDeprecatableDirectiveNodes(arg, schema, pathToDirectivesInExtensions)
  };
}
function astFromObjectType(type, schema, pathToDirectivesInExtensions) {
  var _a3, _b;
  return {
    kind: import_graphql2.Kind.OBJECT_TYPE_DEFINITION,
    description: (_b = (_a3 = type.astNode) === null || _a3 === void 0 ? void 0 : _a3.description) !== null && _b !== void 0 ? _b : type.description ? {
      kind: import_graphql2.Kind.STRING,
      value: type.description,
      block: true
    } : void 0,
    name: {
      kind: import_graphql2.Kind.NAME,
      value: type.name
    },
    fields: Object.values(type.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
    interfaces: Object.values(type.getInterfaces()).map((iFace) => astFromType(iFace)),
    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
  };
}
function astFromInterfaceType(type, schema, pathToDirectivesInExtensions) {
  var _a3, _b;
  const node = {
    kind: import_graphql2.Kind.INTERFACE_TYPE_DEFINITION,
    description: (_b = (_a3 = type.astNode) === null || _a3 === void 0 ? void 0 : _a3.description) !== null && _b !== void 0 ? _b : type.description ? {
      kind: import_graphql2.Kind.STRING,
      value: type.description,
      block: true
    } : void 0,
    name: {
      kind: import_graphql2.Kind.NAME,
      value: type.name
    },
    fields: Object.values(type.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
  };
  if ("getInterfaces" in type) {
    node.interfaces = Object.values(type.getInterfaces()).map((iFace) => astFromType(iFace));
  }
  return node;
}
function astFromUnionType(type, schema, pathToDirectivesInExtensions) {
  var _a3, _b;
  return {
    kind: import_graphql2.Kind.UNION_TYPE_DEFINITION,
    description: (_b = (_a3 = type.astNode) === null || _a3 === void 0 ? void 0 : _a3.description) !== null && _b !== void 0 ? _b : type.description ? {
      kind: import_graphql2.Kind.STRING,
      value: type.description,
      block: true
    } : void 0,
    name: {
      kind: import_graphql2.Kind.NAME,
      value: type.name
    },
    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),
    types: type.getTypes().map((type2) => astFromType(type2))
  };
}
function astFromInputObjectType(type, schema, pathToDirectivesInExtensions) {
  var _a3, _b;
  return {
    kind: import_graphql2.Kind.INPUT_OBJECT_TYPE_DEFINITION,
    description: (_b = (_a3 = type.astNode) === null || _a3 === void 0 ? void 0 : _a3.description) !== null && _b !== void 0 ? _b : type.description ? {
      kind: import_graphql2.Kind.STRING,
      value: type.description,
      block: true
    } : void 0,
    name: {
      kind: import_graphql2.Kind.NAME,
      value: type.name
    },
    fields: Object.values(type.getFields()).map((field) => astFromInputField(field, schema, pathToDirectivesInExtensions)),
    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
  };
}
function astFromEnumType(type, schema, pathToDirectivesInExtensions) {
  var _a3, _b;
  return {
    kind: import_graphql2.Kind.ENUM_TYPE_DEFINITION,
    description: (_b = (_a3 = type.astNode) === null || _a3 === void 0 ? void 0 : _a3.description) !== null && _b !== void 0 ? _b : type.description ? {
      kind: import_graphql2.Kind.STRING,
      value: type.description,
      block: true
    } : void 0,
    name: {
      kind: import_graphql2.Kind.NAME,
      value: type.name
    },
    values: Object.values(type.getValues()).map((value) => astFromEnumValue(value, schema, pathToDirectivesInExtensions)),
    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
  };
}
function astFromScalarType(type, schema, pathToDirectivesInExtensions) {
  var _a3, _b, _c2;
  const directivesInExtensions = getDirectivesInExtensions(type, pathToDirectivesInExtensions);
  const directives = directivesInExtensions ? makeDirectiveNodes(schema, directivesInExtensions) : ((_a3 = type.astNode) === null || _a3 === void 0 ? void 0 : _a3.directives) || [];
  const specifiedByValue = type["specifiedByUrl"] || type["specifiedByURL"];
  if (specifiedByValue && !directives.some((directiveNode) => directiveNode.name.value === "specifiedBy")) {
    const specifiedByArgs = {
      url: specifiedByValue
    };
    directives.push(makeDirectiveNode("specifiedBy", specifiedByArgs));
  }
  return {
    kind: import_graphql2.Kind.SCALAR_TYPE_DEFINITION,
    description: (_c2 = (_b = type.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c2 !== void 0 ? _c2 : type.description ? {
      kind: import_graphql2.Kind.STRING,
      value: type.description,
      block: true
    } : void 0,
    name: {
      kind: import_graphql2.Kind.NAME,
      value: type.name
    },
    directives
  };
}
function astFromField(field, schema, pathToDirectivesInExtensions) {
  var _a3, _b;
  return {
    kind: import_graphql2.Kind.FIELD_DEFINITION,
    description: (_b = (_a3 = field.astNode) === null || _a3 === void 0 ? void 0 : _a3.description) !== null && _b !== void 0 ? _b : field.description ? {
      kind: import_graphql2.Kind.STRING,
      value: field.description,
      block: true
    } : void 0,
    name: {
      kind: import_graphql2.Kind.NAME,
      value: field.name
    },
    arguments: field.args.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
    type: astFromType(field.type),
    directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions)
  };
}
function astFromInputField(field, schema, pathToDirectivesInExtensions) {
  var _a3, _b, _c2;
  return {
    kind: import_graphql2.Kind.INPUT_VALUE_DEFINITION,
    description: (_b = (_a3 = field.astNode) === null || _a3 === void 0 ? void 0 : _a3.description) !== null && _b !== void 0 ? _b : field.description ? {
      kind: import_graphql2.Kind.STRING,
      value: field.description,
      block: true
    } : void 0,
    name: {
      kind: import_graphql2.Kind.NAME,
      value: field.name
    },
    type: astFromType(field.type),
    directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions),
    defaultValue: (_c2 = (0, import_graphql2.astFromValue)(field.defaultValue, field.type)) !== null && _c2 !== void 0 ? _c2 : void 0
  };
}
function astFromEnumValue(value, schema, pathToDirectivesInExtensions) {
  var _a3, _b;
  return {
    kind: import_graphql2.Kind.ENUM_VALUE_DEFINITION,
    description: (_b = (_a3 = value.astNode) === null || _a3 === void 0 ? void 0 : _a3.description) !== null && _b !== void 0 ? _b : value.description ? {
      kind: import_graphql2.Kind.STRING,
      value: value.description,
      block: true
    } : void 0,
    name: {
      kind: import_graphql2.Kind.NAME,
      value: value.name
    },
    directives: getDeprecatableDirectiveNodes(value, schema, pathToDirectivesInExtensions)
  };
}
function makeDeprecatedDirective(deprecationReason) {
  return makeDirectiveNode("deprecated", { reason: deprecationReason }, import_graphql2.GraphQLDeprecatedDirective);
}
function makeDirectiveNode(name, args, directive) {
  const directiveArguments = [];
  if (directive != null) {
    for (const arg of directive.args) {
      const argName = arg.name;
      const argValue = args[argName];
      if (argValue !== void 0) {
        const value = (0, import_graphql2.astFromValue)(argValue, arg.type);
        if (value) {
          directiveArguments.push({
            kind: import_graphql2.Kind.ARGUMENT,
            name: {
              kind: import_graphql2.Kind.NAME,
              value: argName
            },
            value
          });
        }
      }
    }
  } else {
    for (const argName in args) {
      const argValue = args[argName];
      const value = astFromValueUntyped(argValue);
      if (value) {
        directiveArguments.push({
          kind: import_graphql2.Kind.ARGUMENT,
          name: {
            kind: import_graphql2.Kind.NAME,
            value: argName
          },
          value
        });
      }
    }
  }
  return {
    kind: import_graphql2.Kind.DIRECTIVE,
    name: {
      kind: import_graphql2.Kind.NAME,
      value: name
    },
    arguments: directiveArguments
  };
}
function makeDirectiveNodes(schema, directiveValues) {
  const directiveNodes = [];
  for (const directiveName in directiveValues) {
    const arrayOrSingleValue = directiveValues[directiveName];
    const directive = schema === null || schema === void 0 ? void 0 : schema.getDirective(directiveName);
    if (Array.isArray(arrayOrSingleValue)) {
      for (const value of arrayOrSingleValue) {
        directiveNodes.push(makeDirectiveNode(directiveName, value, directive));
      }
    } else {
      directiveNodes.push(makeDirectiveNode(directiveName, arrayOrSingleValue, directive));
    }
  }
  return directiveNodes;
}
var MAX_LINE_LENGTH = 80;
var commentsRegistry = {};
function resetComments() {
  commentsRegistry = {};
}
function collectComment(node) {
  var _a3;
  const entityName = (_a3 = node.name) === null || _a3 === void 0 ? void 0 : _a3.value;
  if (entityName == null) {
    return;
  }
  pushComment(node, entityName);
  switch (node.kind) {
    case "EnumTypeDefinition":
      if (node.values) {
        for (const value of node.values) {
          pushComment(value, entityName, value.name.value);
        }
      }
      break;
    case "ObjectTypeDefinition":
    case "InputObjectTypeDefinition":
    case "InterfaceTypeDefinition":
      if (node.fields) {
        for (const field of node.fields) {
          pushComment(field, entityName, field.name.value);
          if (isFieldDefinitionNode(field) && field.arguments) {
            for (const arg of field.arguments) {
              pushComment(arg, entityName, field.name.value, arg.name.value);
            }
          }
        }
      }
      break;
  }
}
function pushComment(node, entity, field, argument) {
  const comment = getComment(node);
  if (typeof comment !== "string" || comment.length === 0) {
    return;
  }
  const keys2 = [entity];
  if (field) {
    keys2.push(field);
    if (argument) {
      keys2.push(argument);
    }
  }
  const path = keys2.join(".");
  if (!commentsRegistry[path]) {
    commentsRegistry[path] = [];
  }
  commentsRegistry[path].push(comment);
}
function printComment(comment) {
  return "\n# " + comment.replace(/\n/g, "\n# ");
}
function join2(maybeArray, separator) {
  return maybeArray ? maybeArray.filter((x) => x).join(separator || "") : "";
}
function hasMultilineItems(maybeArray) {
  var _a3;
  return (_a3 = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _a3 !== void 0 ? _a3 : false;
}
function addDescription(cb) {
  return (node, _key, _parent, path, ancestors) => {
    var _a3;
    const keys2 = [];
    const parent = path.reduce((prev, key2) => {
      if (["fields", "arguments", "values"].includes(key2) && prev.name) {
        keys2.push(prev.name.value);
      }
      return prev[key2];
    }, ancestors[0]);
    const key = [...keys2, (_a3 = parent === null || parent === void 0 ? void 0 : parent.name) === null || _a3 === void 0 ? void 0 : _a3.value].filter(Boolean).join(".");
    const items = [];
    if (node.kind.includes("Definition") && commentsRegistry[key]) {
      items.push(...commentsRegistry[key]);
    }
    return join2([...items.map(printComment), node.description, cb(node, _key, _parent, path, ancestors)], "\n");
  };
}
function indent(maybeString) {
  return maybeString && `  ${maybeString.replace(/\n/g, "\n  ")}`;
}
function block(array) {
  return array && array.length !== 0 ? `{
${indent(join2(array, "\n"))}
}` : "";
}
function wrap(start, maybeString, end) {
  return maybeString ? start + maybeString + (end || "") : "";
}
function printBlockString(value, isDescription = false) {
  const escaped = value.replace(/"""/g, '\\"""');
  return (value[0] === " " || value[0] === "	") && value.indexOf("\n") === -1 ? `"""${escaped.replace(/"$/, '"\n')}"""` : `"""
${isDescription ? escaped : indent(escaped)}
"""`;
}
var printDocASTReducer = {
  Name: { leave: (node) => node.value },
  Variable: { leave: (node) => "$" + node.name },
  Document: {
    leave: (node) => join2(node.definitions, "\n\n")
  },
  OperationDefinition: {
    leave: (node) => {
      const varDefs = wrap("(", join2(node.variableDefinitions, ", "), ")");
      const prefix = join2([node.operation, join2([node.name, varDefs]), join2(node.directives, " ")], " ");
      return prefix + " " + node.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join2(directives, " "))
  },
  SelectionSet: { leave: ({ selections }) => block(selections) },
  Field: {
    leave({ alias, name, arguments: args, directives, selectionSet }) {
      const prefix = wrap("", alias, ": ") + name;
      let argsLine = prefix + wrap("(", join2(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap("(\n", indent(join2(args, "\n")), "\n)");
      }
      return join2([argsLine, join2(directives, " "), selectionSet], " ");
    }
  },
  Argument: { leave: ({ name, value }) => name + ": " + value },
  FragmentSpread: {
    leave: ({ name, directives }) => "..." + name + wrap(" ", join2(directives, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives, selectionSet }) => join2(["...", wrap("on ", typeCondition), join2(directives, " "), selectionSet], " ")
  },
  FragmentDefinition: {
    leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => `fragment ${name}${wrap("(", join2(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join2(directives, " "), " ")}` + selectionSet
  },
  IntValue: { leave: ({ value }) => value },
  FloatValue: { leave: ({ value }) => value },
  StringValue: {
    leave: ({ value, block: isBlockString }) => {
      if (isBlockString) {
        return printBlockString(value);
      }
      return JSON.stringify(value);
    }
  },
  BooleanValue: { leave: ({ value }) => value ? "true" : "false" },
  NullValue: { leave: () => "null" },
  EnumValue: { leave: ({ value }) => value },
  ListValue: { leave: ({ values }) => "[" + join2(values, ", ") + "]" },
  ObjectValue: { leave: ({ fields }) => "{" + join2(fields, ", ") + "}" },
  ObjectField: { leave: ({ name, value }) => name + ": " + value },
  Directive: {
    leave: ({ name, arguments: args }) => "@" + name + wrap("(", join2(args, ", "), ")")
  },
  NamedType: { leave: ({ name }) => name },
  ListType: { leave: ({ type }) => "[" + type + "]" },
  NonNullType: { leave: ({ type }) => type + "!" },
  SchemaDefinition: {
    leave: ({ directives, operationTypes }) => join2(["schema", join2(directives, " "), block(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type }) => operation + ": " + type
  },
  ScalarTypeDefinition: {
    leave: ({ name, directives }) => join2(["scalar", name, join2(directives, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ name, interfaces, directives, fields }) => join2(["type", name, wrap("implements ", join2(interfaces, " & ")), join2(directives, " "), block(fields)], " ")
  },
  FieldDefinition: {
    leave: ({ name, arguments: args, type, directives }) => name + (hasMultilineItems(args) ? wrap("(\n", indent(join2(args, "\n")), "\n)") : wrap("(", join2(args, ", "), ")")) + ": " + type + wrap(" ", join2(directives, " "))
  },
  InputValueDefinition: {
    leave: ({ name, type, defaultValue, directives }) => join2([name + ": " + type, wrap("= ", defaultValue), join2(directives, " ")], " ")
  },
  InterfaceTypeDefinition: {
    leave: ({ name, interfaces, directives, fields }) => join2(["interface", name, wrap("implements ", join2(interfaces, " & ")), join2(directives, " "), block(fields)], " ")
  },
  UnionTypeDefinition: {
    leave: ({ name, directives, types }) => join2(["union", name, join2(directives, " "), wrap("= ", join2(types, " | "))], " ")
  },
  EnumTypeDefinition: {
    leave: ({ name, directives, values }) => join2(["enum", name, join2(directives, " "), block(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ name, directives }) => join2([name, join2(directives, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ name, directives, fields }) => join2(["input", name, join2(directives, " "), block(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ name, arguments: args, repeatable, locations }) => "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join2(args, "\n")), "\n)") : wrap("(", join2(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join2(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives, operationTypes }) => join2(["extend schema", join2(directives, " "), block(operationTypes)], " ")
  },
  ScalarTypeExtension: {
    leave: ({ name, directives }) => join2(["extend scalar", name, join2(directives, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join2(["extend type", name, wrap("implements ", join2(interfaces, " & ")), join2(directives, " "), block(fields)], " ")
  },
  InterfaceTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join2(["extend interface", name, wrap("implements ", join2(interfaces, " & ")), join2(directives, " "), block(fields)], " ")
  },
  UnionTypeExtension: {
    leave: ({ name, directives, types }) => join2(["extend union", name, join2(directives, " "), wrap("= ", join2(types, " | "))], " ")
  },
  EnumTypeExtension: {
    leave: ({ name, directives, values }) => join2(["extend enum", name, join2(directives, " "), block(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name, directives, fields }) => join2(["extend input", name, join2(directives, " "), block(fields)], " ")
  }
};
var printDocASTReducerWithComments = Object.keys(printDocASTReducer).reduce((prev, key) => ({
  ...prev,
  [key]: {
    leave: addDescription(printDocASTReducer[key].leave)
  }
}), {});
function printWithComments(ast) {
  return (0, import_graphql2.visit)(ast, printDocASTReducerWithComments);
}
function isFieldDefinitionNode(node) {
  return node.kind === "FieldDefinition";
}
function getComment(node) {
  const rawValue = getLeadingCommentBlock(node);
  if (rawValue !== void 0) {
    return dedentBlockStringValue(`
${rawValue}`);
  }
}
function getLeadingCommentBlock(node) {
  const loc = node.loc;
  if (!loc) {
    return;
  }
  const comments = [];
  let token = loc.startToken.prev;
  while (token != null && token.kind === import_graphql2.TokenKind.COMMENT && token.next != null && token.prev != null && token.line + 1 === token.next.line && token.line !== token.prev.line) {
    const value = String(token.value);
    comments.push(value);
    token = token.prev;
  }
  return comments.length > 0 ? comments.reverse().join("\n") : void 0;
}
function dedentBlockStringValue(rawString) {
  const lines = rawString.split(/\r\n|[\n\r]/g);
  const commonIndent = getBlockStringIndentation(lines);
  if (commonIndent !== 0) {
    for (let i = 1; i < lines.length; i++) {
      lines[i] = lines[i].slice(commonIndent);
    }
  }
  while (lines.length > 0 && isBlank(lines[0])) {
    lines.shift();
  }
  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
    lines.pop();
  }
  return lines.join("\n");
}
function getBlockStringIndentation(lines) {
  let commonIndent = null;
  for (let i = 1; i < lines.length; i++) {
    const line = lines[i];
    const indent2 = leadingWhitespace(line);
    if (indent2 === line.length) {
      continue;
    }
    if (commonIndent === null || indent2 < commonIndent) {
      commonIndent = indent2;
      if (commonIndent === 0) {
        break;
      }
    }
  }
  return commonIndent === null ? 0 : commonIndent;
}
function leadingWhitespace(str) {
  let i = 0;
  while (i < str.length && (str[i] === " " || str[i] === "	")) {
    i++;
  }
  return i;
}
function isBlank(str) {
  return leadingWhitespace(str) === str.length;
}
var MapperKind;
(function(MapperKind2) {
  MapperKind2["TYPE"] = "MapperKind.TYPE";
  MapperKind2["SCALAR_TYPE"] = "MapperKind.SCALAR_TYPE";
  MapperKind2["ENUM_TYPE"] = "MapperKind.ENUM_TYPE";
  MapperKind2["COMPOSITE_TYPE"] = "MapperKind.COMPOSITE_TYPE";
  MapperKind2["OBJECT_TYPE"] = "MapperKind.OBJECT_TYPE";
  MapperKind2["INPUT_OBJECT_TYPE"] = "MapperKind.INPUT_OBJECT_TYPE";
  MapperKind2["ABSTRACT_TYPE"] = "MapperKind.ABSTRACT_TYPE";
  MapperKind2["UNION_TYPE"] = "MapperKind.UNION_TYPE";
  MapperKind2["INTERFACE_TYPE"] = "MapperKind.INTERFACE_TYPE";
  MapperKind2["ROOT_OBJECT"] = "MapperKind.ROOT_OBJECT";
  MapperKind2["QUERY"] = "MapperKind.QUERY";
  MapperKind2["MUTATION"] = "MapperKind.MUTATION";
  MapperKind2["SUBSCRIPTION"] = "MapperKind.SUBSCRIPTION";
  MapperKind2["DIRECTIVE"] = "MapperKind.DIRECTIVE";
  MapperKind2["FIELD"] = "MapperKind.FIELD";
  MapperKind2["COMPOSITE_FIELD"] = "MapperKind.COMPOSITE_FIELD";
  MapperKind2["OBJECT_FIELD"] = "MapperKind.OBJECT_FIELD";
  MapperKind2["ROOT_FIELD"] = "MapperKind.ROOT_FIELD";
  MapperKind2["QUERY_ROOT_FIELD"] = "MapperKind.QUERY_ROOT_FIELD";
  MapperKind2["MUTATION_ROOT_FIELD"] = "MapperKind.MUTATION_ROOT_FIELD";
  MapperKind2["SUBSCRIPTION_ROOT_FIELD"] = "MapperKind.SUBSCRIPTION_ROOT_FIELD";
  MapperKind2["INTERFACE_FIELD"] = "MapperKind.INTERFACE_FIELD";
  MapperKind2["INPUT_OBJECT_FIELD"] = "MapperKind.INPUT_OBJECT_FIELD";
  MapperKind2["ARGUMENT"] = "MapperKind.ARGUMENT";
  MapperKind2["ENUM_VALUE"] = "MapperKind.ENUM_VALUE";
})(MapperKind || (MapperKind = {}));
function getObjectTypeFromTypeMap(typeMap, type) {
  if (type) {
    const maybeObjectType = typeMap[type.name];
    if ((0, import_graphql2.isObjectType)(maybeObjectType)) {
      return maybeObjectType;
    }
  }
}
function isNamedStub(type) {
  if ("getFields" in type) {
    const fields = type.getFields();
    for (const fieldName in fields) {
      const field = fields[fieldName];
      return field.name === "_fake";
    }
  }
  return false;
}
function getBuiltInForStub(type) {
  switch (type.name) {
    case import_graphql2.GraphQLInt.name:
      return import_graphql2.GraphQLInt;
    case import_graphql2.GraphQLFloat.name:
      return import_graphql2.GraphQLFloat;
    case import_graphql2.GraphQLString.name:
      return import_graphql2.GraphQLString;
    case import_graphql2.GraphQLBoolean.name:
      return import_graphql2.GraphQLBoolean;
    case import_graphql2.GraphQLID.name:
      return import_graphql2.GraphQLID;
    default:
      return type;
  }
}
function rewireTypes(originalTypeMap, directives) {
  const referenceTypeMap = /* @__PURE__ */ Object.create(null);
  for (const typeName in originalTypeMap) {
    referenceTypeMap[typeName] = originalTypeMap[typeName];
  }
  const newTypeMap = /* @__PURE__ */ Object.create(null);
  for (const typeName in referenceTypeMap) {
    const namedType = referenceTypeMap[typeName];
    if (namedType == null || typeName.startsWith("__")) {
      continue;
    }
    const newName = namedType.name;
    if (newName.startsWith("__")) {
      continue;
    }
    if (newTypeMap[newName] != null) {
      throw new Error(`Duplicate schema type name ${newName}`);
    }
    newTypeMap[newName] = namedType;
  }
  for (const typeName in newTypeMap) {
    newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);
  }
  const newDirectives = directives.map((directive) => rewireDirective(directive));
  return {
    typeMap: newTypeMap,
    directives: newDirectives
  };
  function rewireDirective(directive) {
    if ((0, import_graphql2.isSpecifiedDirective)(directive)) {
      return directive;
    }
    const directiveConfig = directive.toConfig();
    directiveConfig.args = rewireArgs(directiveConfig.args);
    return new import_graphql2.GraphQLDirective(directiveConfig);
  }
  function rewireArgs(args) {
    const rewiredArgs = {};
    for (const argName in args) {
      const arg = args[argName];
      const rewiredArgType = rewireType(arg.type);
      if (rewiredArgType != null) {
        arg.type = rewiredArgType;
        rewiredArgs[argName] = arg;
      }
    }
    return rewiredArgs;
  }
  function rewireNamedType(type) {
    if ((0, import_graphql2.isObjectType)(type)) {
      const config2 = type.toConfig();
      const newConfig = {
        ...config2,
        fields: () => rewireFields(config2.fields),
        interfaces: () => rewireNamedTypes(config2.interfaces)
      };
      return new import_graphql2.GraphQLObjectType(newConfig);
    } else if ((0, import_graphql2.isInterfaceType)(type)) {
      const config2 = type.toConfig();
      const newConfig = {
        ...config2,
        fields: () => rewireFields(config2.fields)
      };
      if ("interfaces" in newConfig) {
        newConfig.interfaces = () => rewireNamedTypes(config2.interfaces);
      }
      return new import_graphql2.GraphQLInterfaceType(newConfig);
    } else if ((0, import_graphql2.isUnionType)(type)) {
      const config2 = type.toConfig();
      const newConfig = {
        ...config2,
        types: () => rewireNamedTypes(config2.types)
      };
      return new import_graphql2.GraphQLUnionType(newConfig);
    } else if ((0, import_graphql2.isInputObjectType)(type)) {
      const config2 = type.toConfig();
      const newConfig = {
        ...config2,
        fields: () => rewireInputFields(config2.fields)
      };
      return new import_graphql2.GraphQLInputObjectType(newConfig);
    } else if ((0, import_graphql2.isEnumType)(type)) {
      const enumConfig = type.toConfig();
      return new import_graphql2.GraphQLEnumType(enumConfig);
    } else if ((0, import_graphql2.isScalarType)(type)) {
      if ((0, import_graphql2.isSpecifiedScalarType)(type)) {
        return type;
      }
      const scalarConfig = type.toConfig();
      return new import_graphql2.GraphQLScalarType(scalarConfig);
    }
    throw new Error(`Unexpected schema type: ${type}`);
  }
  function rewireFields(fields) {
    const rewiredFields = {};
    for (const fieldName in fields) {
      const field = fields[fieldName];
      const rewiredFieldType = rewireType(field.type);
      if (rewiredFieldType != null && field.args) {
        field.type = rewiredFieldType;
        field.args = rewireArgs(field.args);
        rewiredFields[fieldName] = field;
      }
    }
    return rewiredFields;
  }
  function rewireInputFields(fields) {
    const rewiredFields = {};
    for (const fieldName in fields) {
      const field = fields[fieldName];
      const rewiredFieldType = rewireType(field.type);
      if (rewiredFieldType != null) {
        field.type = rewiredFieldType;
        rewiredFields[fieldName] = field;
      }
    }
    return rewiredFields;
  }
  function rewireNamedTypes(namedTypes) {
    const rewiredTypes = [];
    for (const namedType of namedTypes) {
      const rewiredType = rewireType(namedType);
      if (rewiredType != null) {
        rewiredTypes.push(rewiredType);
      }
    }
    return rewiredTypes;
  }
  function rewireType(type) {
    if ((0, import_graphql2.isListType)(type)) {
      const rewiredType = rewireType(type.ofType);
      return rewiredType != null ? new import_graphql2.GraphQLList(rewiredType) : null;
    } else if ((0, import_graphql2.isNonNullType)(type)) {
      const rewiredType = rewireType(type.ofType);
      return rewiredType != null ? new import_graphql2.GraphQLNonNull(rewiredType) : null;
    } else if ((0, import_graphql2.isNamedType)(type)) {
      let rewiredType = referenceTypeMap[type.name];
      if (rewiredType === void 0) {
        rewiredType = isNamedStub(type) ? getBuiltInForStub(type) : rewireNamedType(type);
        newTypeMap[rewiredType.name] = referenceTypeMap[type.name] = rewiredType;
      }
      return rewiredType != null ? newTypeMap[rewiredType.name] : null;
    }
    return null;
  }
}
function transformInputValue(type, value, inputLeafValueTransformer = null, inputObjectValueTransformer = null) {
  if (value == null) {
    return value;
  }
  const nullableType = (0, import_graphql2.getNullableType)(type);
  if ((0, import_graphql2.isLeafType)(nullableType)) {
    return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value) : value;
  } else if ((0, import_graphql2.isListType)(nullableType)) {
    return value.map((listMember) => transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));
  } else if ((0, import_graphql2.isInputObjectType)(nullableType)) {
    const fields = nullableType.getFields();
    const newValue = {};
    for (const key in value) {
      const field = fields[key];
      if (field != null) {
        newValue[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);
      }
    }
    return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue) : newValue;
  }
}
function serializeInputValue(type, value) {
  return transformInputValue(type, value, (t, v) => {
    try {
      return t.serialize(v);
    } catch (_a3) {
      return v;
    }
  });
}
function parseInputValue(type, value) {
  return transformInputValue(type, value, (t, v) => {
    try {
      return t.parseValue(v);
    } catch (_a3) {
      return v;
    }
  });
}
function mapSchema(schema, schemaMapper = {}) {
  const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, serializeInputValue), schema, schemaMapper, (type) => (0, import_graphql2.isLeafType)(type)), schema, schemaMapper), schema, parseInputValue), schema, schemaMapper, (type) => !(0, import_graphql2.isLeafType)(type)), schema, schemaMapper), schema, schemaMapper);
  const originalDirectives = schema.getDirectives();
  const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);
  const { typeMap, directives } = rewireTypes(newTypeMap, newDirectives);
  return new import_graphql2.GraphQLSchema({
    ...schema.toConfig(),
    query: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getQueryType())),
    mutation: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getMutationType())),
    subscription: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getSubscriptionType())),
    types: Object.values(typeMap),
    directives
  });
}
function mapTypes(originalTypeMap, schema, schemaMapper, testFn = () => true) {
  const newTypeMap = {};
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__")) {
      const originalType = originalTypeMap[typeName];
      if (originalType == null || !testFn(originalType)) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const typeMapper = getTypeMapper(schema, schemaMapper, typeName);
      if (typeMapper == null) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const maybeNewType = typeMapper(originalType, schema);
      if (maybeNewType === void 0) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      newTypeMap[typeName] = maybeNewType;
    }
  }
  return newTypeMap;
}
function mapEnumValues(originalTypeMap, schema, schemaMapper) {
  const enumValueMapper = getEnumValueMapper(schemaMapper);
  if (!enumValueMapper) {
    return originalTypeMap;
  }
  return mapTypes(originalTypeMap, schema, {
    [MapperKind.ENUM_TYPE]: (type) => {
      const config2 = type.toConfig();
      const originalEnumValueConfigMap = config2.values;
      const newEnumValueConfigMap = {};
      for (const externalValue in originalEnumValueConfigMap) {
        const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];
        const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema, externalValue);
        if (mappedEnumValue === void 0) {
          newEnumValueConfigMap[externalValue] = originalEnumValueConfig;
        } else if (Array.isArray(mappedEnumValue)) {
          const [newExternalValue, newEnumValueConfig] = mappedEnumValue;
          newEnumValueConfigMap[newExternalValue] = newEnumValueConfig === void 0 ? originalEnumValueConfig : newEnumValueConfig;
        } else if (mappedEnumValue !== null) {
          newEnumValueConfigMap[externalValue] = mappedEnumValue;
        }
      }
      return correctASTNodes(new import_graphql2.GraphQLEnumType({
        ...config2,
        values: newEnumValueConfigMap
      }));
    }
  }, (type) => (0, import_graphql2.isEnumType)(type));
}
function mapDefaultValues(originalTypeMap, schema, fn2) {
  const newTypeMap = mapArguments(originalTypeMap, schema, {
    [MapperKind.ARGUMENT]: (argumentConfig) => {
      if (argumentConfig.defaultValue === void 0) {
        return argumentConfig;
      }
      const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);
      if (maybeNewType != null) {
        return {
          ...argumentConfig,
          defaultValue: fn2(maybeNewType, argumentConfig.defaultValue)
        };
      }
    }
  });
  return mapFields(newTypeMap, schema, {
    [MapperKind.INPUT_OBJECT_FIELD]: (inputFieldConfig) => {
      if (inputFieldConfig.defaultValue === void 0) {
        return inputFieldConfig;
      }
      const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);
      if (maybeNewType != null) {
        return {
          ...inputFieldConfig,
          defaultValue: fn2(maybeNewType, inputFieldConfig.defaultValue)
        };
      }
    }
  });
}
function getNewType(newTypeMap, type) {
  if ((0, import_graphql2.isListType)(type)) {
    const newType = getNewType(newTypeMap, type.ofType);
    return newType != null ? new import_graphql2.GraphQLList(newType) : null;
  } else if ((0, import_graphql2.isNonNullType)(type)) {
    const newType = getNewType(newTypeMap, type.ofType);
    return newType != null ? new import_graphql2.GraphQLNonNull(newType) : null;
  } else if ((0, import_graphql2.isNamedType)(type)) {
    const newType = newTypeMap[type.name];
    return newType != null ? newType : null;
  }
  return null;
}
function mapFields(originalTypeMap, schema, schemaMapper) {
  const newTypeMap = {};
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__")) {
      const originalType = originalTypeMap[typeName];
      if (!(0, import_graphql2.isObjectType)(originalType) && !(0, import_graphql2.isInterfaceType)(originalType) && !(0, import_graphql2.isInputObjectType)(originalType)) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);
      if (fieldMapper == null) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const config2 = originalType.toConfig();
      const originalFieldConfigMap = config2.fields;
      const newFieldConfigMap = {};
      for (const fieldName in originalFieldConfigMap) {
        const originalFieldConfig = originalFieldConfigMap[fieldName];
        const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);
        if (mappedField === void 0) {
          newFieldConfigMap[fieldName] = originalFieldConfig;
        } else if (Array.isArray(mappedField)) {
          const [newFieldName, newFieldConfig] = mappedField;
          if (newFieldConfig.astNode != null) {
            newFieldConfig.astNode = {
              ...newFieldConfig.astNode,
              name: {
                ...newFieldConfig.astNode.name,
                value: newFieldName
              }
            };
          }
          newFieldConfigMap[newFieldName] = newFieldConfig === void 0 ? originalFieldConfig : newFieldConfig;
        } else if (mappedField !== null) {
          newFieldConfigMap[fieldName] = mappedField;
        }
      }
      if ((0, import_graphql2.isObjectType)(originalType)) {
        newTypeMap[typeName] = correctASTNodes(new import_graphql2.GraphQLObjectType({
          ...config2,
          fields: newFieldConfigMap
        }));
      } else if ((0, import_graphql2.isInterfaceType)(originalType)) {
        newTypeMap[typeName] = correctASTNodes(new import_graphql2.GraphQLInterfaceType({
          ...config2,
          fields: newFieldConfigMap
        }));
      } else {
        newTypeMap[typeName] = correctASTNodes(new import_graphql2.GraphQLInputObjectType({
          ...config2,
          fields: newFieldConfigMap
        }));
      }
    }
  }
  return newTypeMap;
}
function mapArguments(originalTypeMap, schema, schemaMapper) {
  const newTypeMap = {};
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__")) {
      const originalType = originalTypeMap[typeName];
      if (!(0, import_graphql2.isObjectType)(originalType) && !(0, import_graphql2.isInterfaceType)(originalType)) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const argumentMapper = getArgumentMapper(schemaMapper);
      if (argumentMapper == null) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const config2 = originalType.toConfig();
      const originalFieldConfigMap = config2.fields;
      const newFieldConfigMap = {};
      for (const fieldName in originalFieldConfigMap) {
        const originalFieldConfig = originalFieldConfigMap[fieldName];
        const originalArgumentConfigMap = originalFieldConfig.args;
        if (originalArgumentConfigMap == null) {
          newFieldConfigMap[fieldName] = originalFieldConfig;
          continue;
        }
        const argumentNames = Object.keys(originalArgumentConfigMap);
        if (!argumentNames.length) {
          newFieldConfigMap[fieldName] = originalFieldConfig;
          continue;
        }
        const newArgumentConfigMap = {};
        for (const argumentName of argumentNames) {
          const originalArgumentConfig = originalArgumentConfigMap[argumentName];
          const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);
          if (mappedArgument === void 0) {
            newArgumentConfigMap[argumentName] = originalArgumentConfig;
          } else if (Array.isArray(mappedArgument)) {
            const [newArgumentName, newArgumentConfig] = mappedArgument;
            newArgumentConfigMap[newArgumentName] = newArgumentConfig;
          } else if (mappedArgument !== null) {
            newArgumentConfigMap[argumentName] = mappedArgument;
          }
        }
        newFieldConfigMap[fieldName] = {
          ...originalFieldConfig,
          args: newArgumentConfigMap
        };
      }
      if ((0, import_graphql2.isObjectType)(originalType)) {
        newTypeMap[typeName] = new import_graphql2.GraphQLObjectType({
          ...config2,
          fields: newFieldConfigMap
        });
      } else if ((0, import_graphql2.isInterfaceType)(originalType)) {
        newTypeMap[typeName] = new import_graphql2.GraphQLInterfaceType({
          ...config2,
          fields: newFieldConfigMap
        });
      } else {
        newTypeMap[typeName] = new import_graphql2.GraphQLInputObjectType({
          ...config2,
          fields: newFieldConfigMap
        });
      }
    }
  }
  return newTypeMap;
}
function mapDirectives(originalDirectives, schema, schemaMapper) {
  const directiveMapper = getDirectiveMapper(schemaMapper);
  if (directiveMapper == null) {
    return originalDirectives.slice();
  }
  const newDirectives = [];
  for (const directive of originalDirectives) {
    const mappedDirective = directiveMapper(directive, schema);
    if (mappedDirective === void 0) {
      newDirectives.push(directive);
    } else if (mappedDirective !== null) {
      newDirectives.push(mappedDirective);
    }
  }
  return newDirectives;
}
function getTypeSpecifiers(schema, typeName) {
  var _a3, _b, _c2;
  const type = schema.getType(typeName);
  const specifiers = [MapperKind.TYPE];
  if ((0, import_graphql2.isObjectType)(type)) {
    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.OBJECT_TYPE);
    if (typeName === ((_a3 = schema.getQueryType()) === null || _a3 === void 0 ? void 0 : _a3.name)) {
      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.QUERY);
    } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.MUTATION);
    } else if (typeName === ((_c2 = schema.getSubscriptionType()) === null || _c2 === void 0 ? void 0 : _c2.name)) {
      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.SUBSCRIPTION);
    }
  } else if ((0, import_graphql2.isInputObjectType)(type)) {
    specifiers.push(MapperKind.INPUT_OBJECT_TYPE);
  } else if ((0, import_graphql2.isInterfaceType)(type)) {
    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.INTERFACE_TYPE);
  } else if ((0, import_graphql2.isUnionType)(type)) {
    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.UNION_TYPE);
  } else if ((0, import_graphql2.isEnumType)(type)) {
    specifiers.push(MapperKind.ENUM_TYPE);
  } else if ((0, import_graphql2.isScalarType)(type)) {
    specifiers.push(MapperKind.SCALAR_TYPE);
  }
  return specifiers;
}
function getTypeMapper(schema, schemaMapper, typeName) {
  const specifiers = getTypeSpecifiers(schema, typeName);
  let typeMapper;
  const stack = [...specifiers];
  while (!typeMapper && stack.length > 0) {
    const next = stack.pop();
    typeMapper = schemaMapper[next];
  }
  return typeMapper != null ? typeMapper : null;
}
function getFieldSpecifiers(schema, typeName) {
  var _a3, _b, _c2;
  const type = schema.getType(typeName);
  const specifiers = [MapperKind.FIELD];
  if ((0, import_graphql2.isObjectType)(type)) {
    specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.OBJECT_FIELD);
    if (typeName === ((_a3 = schema.getQueryType()) === null || _a3 === void 0 ? void 0 : _a3.name)) {
      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.QUERY_ROOT_FIELD);
    } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.MUTATION_ROOT_FIELD);
    } else if (typeName === ((_c2 = schema.getSubscriptionType()) === null || _c2 === void 0 ? void 0 : _c2.name)) {
      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.SUBSCRIPTION_ROOT_FIELD);
    }
  } else if ((0, import_graphql2.isInterfaceType)(type)) {
    specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.INTERFACE_FIELD);
  } else if ((0, import_graphql2.isInputObjectType)(type)) {
    specifiers.push(MapperKind.INPUT_OBJECT_FIELD);
  }
  return specifiers;
}
function getFieldMapper(schema, schemaMapper, typeName) {
  const specifiers = getFieldSpecifiers(schema, typeName);
  let fieldMapper;
  const stack = [...specifiers];
  while (!fieldMapper && stack.length > 0) {
    const next = stack.pop();
    fieldMapper = schemaMapper[next];
  }
  return fieldMapper !== null && fieldMapper !== void 0 ? fieldMapper : null;
}
function getArgumentMapper(schemaMapper) {
  const argumentMapper = schemaMapper[MapperKind.ARGUMENT];
  return argumentMapper != null ? argumentMapper : null;
}
function getDirectiveMapper(schemaMapper) {
  const directiveMapper = schemaMapper[MapperKind.DIRECTIVE];
  return directiveMapper != null ? directiveMapper : null;
}
function getEnumValueMapper(schemaMapper) {
  const enumValueMapper = schemaMapper[MapperKind.ENUM_VALUE];
  return enumValueMapper != null ? enumValueMapper : null;
}
function correctASTNodes(type) {
  if ((0, import_graphql2.isObjectType)(type)) {
    const config2 = type.toConfig();
    if (config2.astNode != null) {
      const fields = [];
      for (const fieldName in config2.fields) {
        const fieldConfig = config2.fields[fieldName];
        if (fieldConfig.astNode != null) {
          fields.push(fieldConfig.astNode);
        }
      }
      config2.astNode = {
        ...config2.astNode,
        kind: import_graphql2.Kind.OBJECT_TYPE_DEFINITION,
        fields
      };
    }
    if (config2.extensionASTNodes != null) {
      config2.extensionASTNodes = config2.extensionASTNodes.map((node) => ({
        ...node,
        kind: import_graphql2.Kind.OBJECT_TYPE_EXTENSION,
        fields: void 0
      }));
    }
    return new import_graphql2.GraphQLObjectType(config2);
  } else if ((0, import_graphql2.isInterfaceType)(type)) {
    const config2 = type.toConfig();
    if (config2.astNode != null) {
      const fields = [];
      for (const fieldName in config2.fields) {
        const fieldConfig = config2.fields[fieldName];
        if (fieldConfig.astNode != null) {
          fields.push(fieldConfig.astNode);
        }
      }
      config2.astNode = {
        ...config2.astNode,
        kind: import_graphql2.Kind.INTERFACE_TYPE_DEFINITION,
        fields
      };
    }
    if (config2.extensionASTNodes != null) {
      config2.extensionASTNodes = config2.extensionASTNodes.map((node) => ({
        ...node,
        kind: import_graphql2.Kind.INTERFACE_TYPE_EXTENSION,
        fields: void 0
      }));
    }
    return new import_graphql2.GraphQLInterfaceType(config2);
  } else if ((0, import_graphql2.isInputObjectType)(type)) {
    const config2 = type.toConfig();
    if (config2.astNode != null) {
      const fields = [];
      for (const fieldName in config2.fields) {
        const fieldConfig = config2.fields[fieldName];
        if (fieldConfig.astNode != null) {
          fields.push(fieldConfig.astNode);
        }
      }
      config2.astNode = {
        ...config2.astNode,
        kind: import_graphql2.Kind.INPUT_OBJECT_TYPE_DEFINITION,
        fields
      };
    }
    if (config2.extensionASTNodes != null) {
      config2.extensionASTNodes = config2.extensionASTNodes.map((node) => ({
        ...node,
        kind: import_graphql2.Kind.INPUT_OBJECT_TYPE_EXTENSION,
        fields: void 0
      }));
    }
    return new import_graphql2.GraphQLInputObjectType(config2);
  } else if ((0, import_graphql2.isEnumType)(type)) {
    const config2 = type.toConfig();
    if (config2.astNode != null) {
      const values = [];
      for (const enumKey in config2.values) {
        const enumValueConfig = config2.values[enumKey];
        if (enumValueConfig.astNode != null) {
          values.push(enumValueConfig.astNode);
        }
      }
      config2.astNode = {
        ...config2.astNode,
        values
      };
    }
    if (config2.extensionASTNodes != null) {
      config2.extensionASTNodes = config2.extensionASTNodes.map((node) => ({
        ...node,
        values: void 0
      }));
    }
    return new import_graphql2.GraphQLEnumType(config2);
  } else {
    return type;
  }
}
function healSchema(schema) {
  healTypes(schema.getTypeMap(), schema.getDirectives());
  return schema;
}
function healTypes(originalTypeMap, directives) {
  const actualNamedTypeMap = /* @__PURE__ */ Object.create(null);
  for (const typeName in originalTypeMap) {
    const namedType = originalTypeMap[typeName];
    if (namedType == null || typeName.startsWith("__")) {
      continue;
    }
    const actualName = namedType.name;
    if (actualName.startsWith("__")) {
      continue;
    }
    if (actualName in actualNamedTypeMap) {
      throw new Error(`Duplicate schema type name ${actualName}`);
    }
    actualNamedTypeMap[actualName] = namedType;
  }
  for (const typeName in actualNamedTypeMap) {
    const namedType = actualNamedTypeMap[typeName];
    originalTypeMap[typeName] = namedType;
  }
  for (const decl of directives) {
    decl.args = decl.args.filter((arg) => {
      arg.type = healType(arg.type);
      return arg.type !== null;
    });
  }
  for (const typeName in originalTypeMap) {
    const namedType = originalTypeMap[typeName];
    if (!typeName.startsWith("__") && typeName in actualNamedTypeMap) {
      if (namedType != null) {
        healNamedType(namedType);
      }
    }
  }
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__") && !(typeName in actualNamedTypeMap)) {
      delete originalTypeMap[typeName];
    }
  }
  function healNamedType(type) {
    if ((0, import_graphql2.isObjectType)(type)) {
      healFields(type);
      healInterfaces(type);
      return;
    } else if ((0, import_graphql2.isInterfaceType)(type)) {
      healFields(type);
      if ("getInterfaces" in type) {
        healInterfaces(type);
      }
      return;
    } else if ((0, import_graphql2.isUnionType)(type)) {
      healUnderlyingTypes(type);
      return;
    } else if ((0, import_graphql2.isInputObjectType)(type)) {
      healInputFields(type);
      return;
    } else if ((0, import_graphql2.isLeafType)(type)) {
      return;
    }
    throw new Error(`Unexpected schema type: ${type}`);
  }
  function healFields(type) {
    const fieldMap = type.getFields();
    for (const [key, field] of Object.entries(fieldMap)) {
      field.args.map((arg) => {
        arg.type = healType(arg.type);
        return arg.type === null ? null : arg;
      }).filter(Boolean);
      field.type = healType(field.type);
      if (field.type === null) {
        delete fieldMap[key];
      }
    }
  }
  function healInterfaces(type) {
    if ("getInterfaces" in type) {
      const interfaces = type.getInterfaces();
      interfaces.push(...interfaces.splice(0).map((iface) => healType(iface)).filter(Boolean));
    }
  }
  function healInputFields(type) {
    const fieldMap = type.getFields();
    for (const [key, field] of Object.entries(fieldMap)) {
      field.type = healType(field.type);
      if (field.type === null) {
        delete fieldMap[key];
      }
    }
  }
  function healUnderlyingTypes(type) {
    const types = type.getTypes();
    types.push(...types.splice(0).map((t) => healType(t)).filter(Boolean));
  }
  function healType(type) {
    if ((0, import_graphql2.isListType)(type)) {
      const healedType = healType(type.ofType);
      return healedType != null ? new import_graphql2.GraphQLList(healedType) : null;
    } else if ((0, import_graphql2.isNonNullType)(type)) {
      const healedType = healType(type.ofType);
      return healedType != null ? new import_graphql2.GraphQLNonNull(healedType) : null;
    } else if ((0, import_graphql2.isNamedType)(type)) {
      const officialType = originalTypeMap[type.name];
      if (officialType && type !== officialType) {
        return officialType;
      }
    }
    return type;
  }
}
function forEachField(schema, fn2) {
  const typeMap = schema.getTypeMap();
  for (const typeName in typeMap) {
    const type = typeMap[typeName];
    if (!(0, import_graphql2.getNamedType)(type).name.startsWith("__") && (0, import_graphql2.isObjectType)(type)) {
      const fields = type.getFields();
      for (const fieldName in fields) {
        const field = fields[fieldName];
        fn2(field, typeName, fieldName);
      }
    }
  }
}
function forEachDefaultValue(schema, fn2) {
  const typeMap = schema.getTypeMap();
  for (const typeName in typeMap) {
    const type = typeMap[typeName];
    if (!(0, import_graphql2.getNamedType)(type).name.startsWith("__")) {
      if ((0, import_graphql2.isObjectType)(type)) {
        const fields = type.getFields();
        for (const fieldName in fields) {
          const field = fields[fieldName];
          for (const arg of field.args) {
            arg.defaultValue = fn2(arg.type, arg.defaultValue);
          }
        }
      } else if ((0, import_graphql2.isInputObjectType)(type)) {
        const fields = type.getFields();
        for (const fieldName in fields) {
          const field = fields[fieldName];
          field.defaultValue = fn2(field.type, field.defaultValue);
        }
      }
    }
  }
}
function pruneSchema(schema, options2 = {}) {
  const { skipEmptyCompositeTypePruning, skipEmptyUnionPruning, skipPruning, skipUnimplementedInterfacesPruning, skipUnusedTypesPruning } = options2;
  let prunedTypes = [];
  let prunedSchema = schema;
  do {
    let visited = visitSchema(prunedSchema);
    if (skipPruning) {
      const revisit = [];
      for (const typeName in prunedSchema.getTypeMap()) {
        if (typeName.startsWith("__")) {
          continue;
        }
        const type = prunedSchema.getType(typeName);
        if (type && skipPruning(type)) {
          revisit.push(typeName);
        }
      }
      visited = visitQueue(revisit, prunedSchema, visited);
    }
    prunedTypes = [];
    prunedSchema = mapSchema(prunedSchema, {
      [MapperKind.TYPE]: (type) => {
        if (!visited.has(type.name) && !(0, import_graphql2.isSpecifiedScalarType)(type)) {
          if ((0, import_graphql2.isUnionType)(type) || (0, import_graphql2.isInputObjectType)(type) || (0, import_graphql2.isInterfaceType)(type) || (0, import_graphql2.isObjectType)(type) || (0, import_graphql2.isScalarType)(type)) {
            if (skipUnusedTypesPruning) {
              return type;
            }
            if ((0, import_graphql2.isUnionType)(type) && skipEmptyUnionPruning && !Object.keys(type.getTypes()).length) {
              return type;
            }
            if ((0, import_graphql2.isInputObjectType)(type) || (0, import_graphql2.isInterfaceType)(type) || (0, import_graphql2.isObjectType)(type)) {
              if (skipEmptyCompositeTypePruning && !Object.keys(type.getFields()).length) {
                return type;
              }
            }
            if ((0, import_graphql2.isInterfaceType)(type) && skipUnimplementedInterfacesPruning) {
              return type;
            }
          }
          prunedTypes.push(type.name);
          visited.delete(type.name);
          return null;
        }
        return type;
      }
    });
  } while (prunedTypes.length);
  return prunedSchema;
}
function visitSchema(schema) {
  const queue = [];
  for (const type of getRootTypes(schema)) {
    queue.push(type.name);
  }
  return visitQueue(queue, schema);
}
function visitQueue(queue, schema, visited = /* @__PURE__ */ new Set()) {
  while (queue.length) {
    const typeName = queue.pop();
    if (visited.has(typeName)) {
      continue;
    }
    const type = schema.getType(typeName);
    if (type) {
      if ((0, import_graphql2.isUnionType)(type)) {
        queue.push(...type.getTypes().map((type2) => type2.name));
      }
      if ("getFields" in type) {
        const fields = type.getFields();
        const entries = Object.entries(fields);
        if (!entries.length) {
          continue;
        }
        for (const [, field] of entries) {
          if ((0, import_graphql2.isObjectType)(type)) {
            for (const arg of field.args) {
              queue.push((0, import_graphql2.getNamedType)(arg.type).name);
            }
          }
          queue.push((0, import_graphql2.getNamedType)(field.type).name);
        }
      }
      if ("getInterfaces" in type) {
        queue.push(...type.getInterfaces().map((iface) => iface.name));
      }
      visited.add(typeName);
    }
  }
  return visited;
}
function mergeDeep(sources, respectPrototype = false) {
  const target = sources[0] || {};
  const output = {};
  if (respectPrototype) {
    Object.setPrototypeOf(output, Object.create(Object.getPrototypeOf(target)));
  }
  for (const source of sources) {
    if (isObject(target) && isObject(source)) {
      if (respectPrototype) {
        const outputPrototype = Object.getPrototypeOf(output);
        const sourcePrototype = Object.getPrototypeOf(source);
        if (sourcePrototype) {
          for (const key of Object.getOwnPropertyNames(sourcePrototype)) {
            const descriptor = Object.getOwnPropertyDescriptor(sourcePrototype, key);
            if (isSome(descriptor)) {
              Object.defineProperty(outputPrototype, key, descriptor);
            }
          }
        }
      }
      for (const key in source) {
        if (isObject(source[key])) {
          if (!(key in output)) {
            Object.assign(output, { [key]: source[key] });
          } else {
            output[key] = mergeDeep([output[key], source[key]], respectPrototype);
          }
        } else {
          Object.assign(output, { [key]: source[key] });
        }
      }
    }
  }
  return output;
}
function isObject(item) {
  return item && typeof item === "object" && !Array.isArray(item);
}
function getOperationASTFromDocument(documentNode, operationName) {
  const doc = (0, import_graphql2.getOperationAST)(documentNode, operationName);
  if (!doc) {
    throw new Error(`Cannot infer operation ${operationName || ""}`);
  }
  return doc;
}
var getOperationASTFromRequest = memoize1(function getOperationASTFromRequest2(request3) {
  return getOperationASTFromDocument(request3.document, request3.operationName);
});
function collectFields(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case import_graphql2.Kind.FIELD: {
        if (!shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        const name = getFieldEntryKey(selection);
        const fieldList = fields.get(name);
        if (fieldList !== void 0) {
          fieldList.push(selection);
        } else {
          fields.set(name, [selection]);
        }
        break;
      }
      case import_graphql2.Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
          continue;
        }
        collectFields(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
        break;
      }
      case import_graphql2.Kind.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        visitedFragmentNames.add(fragName);
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
          continue;
        }
        collectFields(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
        break;
      }
    }
  }
  return fields;
}
function shouldIncludeNode(variableValues, node) {
  const skip = (0, import_graphql2.getDirectiveValues)(import_graphql2.GraphQLSkipDirective, node, variableValues);
  if ((skip === null || skip === void 0 ? void 0 : skip["if"]) === true) {
    return false;
  }
  const include = (0, import_graphql2.getDirectiveValues)(import_graphql2.GraphQLIncludeDirective, node, variableValues);
  if ((include === null || include === void 0 ? void 0 : include["if"]) === false) {
    return false;
  }
  return true;
}
function doesFragmentConditionMatch(schema, fragment, type) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = (0, import_graphql2.typeFromAST)(schema, typeConditionNode);
  if (conditionalType === type) {
    return true;
  }
  if ((0, import_graphql2.isAbstractType)(conditionalType)) {
    const possibleTypes = schema.getPossibleTypes(conditionalType);
    return possibleTypes.includes(type);
  }
  return false;
}
function getFieldEntryKey(node) {
  return node.alias ? node.alias.value : node.name.value;
}
var collectSubFields = memoize5(function collectSubFields2(schema, fragments, variableValues, type, fieldNodes) {
  const subFieldNodes = /* @__PURE__ */ new Map();
  const visitedFragmentNames = /* @__PURE__ */ new Set();
  for (const fieldNode of fieldNodes) {
    if (fieldNode.selectionSet) {
      collectFields(schema, fragments, variableValues, type, fieldNode.selectionSet, subFieldNodes, visitedFragmentNames);
    }
  }
  return subFieldNodes;
});
function isAsyncIterable2(value) {
  return typeof value === "object" && value != null && Symbol.asyncIterator in value && typeof value[Symbol.asyncIterator] === "function";
}
function isDocumentNode(object) {
  return object && typeof object === "object" && "kind" in object && object.kind === import_graphql2.Kind.DOCUMENT;
}
var proxyMethodFactory = memoize2(function proxyMethodFactory2(target, targetMethod) {
  return function proxyMethod(...args) {
    return Reflect.apply(targetMethod, target, args);
  };
});

// node_modules/.pnpm/@graphql-yoga+common@2.3.0_graphql@16.4.0/node_modules/@graphql-yoga/common/index.mjs
var import_graphql7 = __toESM(require_graphql2(), 1);

// node_modules/.pnpm/@envelop+validation-cache@4.3.1_056633872f9a3c1f0603c1afd02af5e5/node_modules/@envelop/validation-cache/index.mjs
var import_graphql3 = __toESM(require_graphql2(), 1);
var import_tiny_lru = __toESM(require_tiny_lru_cjs(), 1);
var DEFAULT_MAX = 1e3;
var DEFAULT_TTL = 36e5;
var rawDocumentSymbol = Symbol("rawDocument");
var useValidationCache = (pluginOptions = {}) => {
  const resultCache = typeof pluginOptions.cache !== "undefined" ? pluginOptions.cache : (0, import_tiny_lru.default)(DEFAULT_MAX, DEFAULT_TTL);
  return {
    onSchemaChange() {
      resultCache.clear();
    },
    onParse({ params, extendContext }) {
      extendContext({ [rawDocumentSymbol]: params.source.toString() });
    },
    onValidate({ params, context, setResult }) {
      var _a3;
      const key = (_a3 = context[rawDocumentSymbol]) !== null && _a3 !== void 0 ? _a3 : (0, import_graphql3.print)(params.documentAST);
      const cachedResult = resultCache.get(key);
      if (cachedResult !== void 0) {
        setResult(cachedResult);
      }
      return ({ result }) => {
        resultCache.set(key, result);
      };
    }
  };
};

// node_modules/.pnpm/@envelop+parser-cache@4.3.1_056633872f9a3c1f0603c1afd02af5e5/node_modules/@envelop/parser-cache/index.mjs
var import_graphql4 = __toESM(require_graphql2(), 1);
var import_tiny_lru2 = __toESM(require_tiny_lru_cjs(), 1);
var DEFAULT_MAX2 = 1e3;
var DEFAULT_TTL2 = 36e5;
var useParserCache = (pluginOptions = {}) => {
  const documentCache = typeof pluginOptions.documentCache !== "undefined" ? pluginOptions.documentCache : (0, import_tiny_lru2.default)(DEFAULT_MAX2, DEFAULT_TTL2);
  const errorCache = typeof pluginOptions.errorCache !== "undefined" ? pluginOptions.errorCache : (0, import_tiny_lru2.default)(DEFAULT_MAX2, DEFAULT_TTL2);
  return {
    onParse({ params, setParsedDocument }) {
      const { source } = params;
      const key = source instanceof import_graphql4.Source ? source.body : source;
      const cachedError = errorCache.get(key);
      if (cachedError !== void 0) {
        throw cachedError;
      }
      const cachedDocument = documentCache.get(key);
      if (cachedDocument !== void 0) {
        setParsedDocument(cachedDocument);
      }
      return ({ result }) => {
        if (result instanceof Error) {
          errorCache.set(key, result);
        } else if (result !== null) {
          documentCache.set(key, result);
        }
      };
    }
  };
};

// node_modules/.pnpm/@graphql-tools+schema@8.3.10_graphql@16.4.0/node_modules/@graphql-tools/schema/index.mjs
var import_graphql6 = __toESM(require_graphql2(), 1);

// node_modules/.pnpm/@graphql-tools+merge@8.2.10_graphql@16.4.0/node_modules/@graphql-tools/merge/index.mjs
var import_graphql5 = __toESM(require_graphql2(), 1);
function mergeResolvers(resolversDefinitions, options2) {
  if (!resolversDefinitions || Array.isArray(resolversDefinitions) && resolversDefinitions.length === 0) {
    return {};
  }
  if (!Array.isArray(resolversDefinitions)) {
    return resolversDefinitions;
  }
  if (resolversDefinitions.length === 1) {
    return resolversDefinitions[0] || {};
  }
  const resolvers = new Array();
  for (let resolversDefinition of resolversDefinitions) {
    if (Array.isArray(resolversDefinition)) {
      resolversDefinition = mergeResolvers(resolversDefinition);
    }
    if (typeof resolversDefinition === "object" && resolversDefinition) {
      resolvers.push(resolversDefinition);
    }
  }
  const result = mergeDeep(resolvers, true);
  if (options2 === null || options2 === void 0 ? void 0 : options2.exclusions) {
    for (const exclusion of options2.exclusions) {
      const [typeName, fieldName] = exclusion.split(".");
      if (!fieldName || fieldName === "*") {
        delete result[typeName];
      } else if (result[typeName]) {
        delete result[typeName][fieldName];
      }
    }
  }
  return result;
}
function mergeArguments(args1, args2, config2) {
  const result = deduplicateArguments([...args2, ...args1].filter(isSome));
  if (config2 && config2.sort) {
    result.sort(compareNodes);
  }
  return result;
}
function deduplicateArguments(args) {
  return args.reduce((acc, current) => {
    const dup = acc.find((arg) => arg.name.value === current.name.value);
    if (!dup) {
      return acc.concat([current]);
    }
    return acc;
  }, []);
}
function directiveAlreadyExists(directivesArr, otherDirective) {
  return !!directivesArr.find((directive) => directive.name.value === otherDirective.name.value);
}
function nameAlreadyExists(name, namesArr) {
  return namesArr.some(({ value }) => value === name.value);
}
function mergeArguments$1(a1, a2) {
  const result = [...a2];
  for (const argument of a1) {
    const existingIndex = result.findIndex((a) => a.name.value === argument.name.value);
    if (existingIndex > -1) {
      const existingArg = result[existingIndex];
      if (existingArg.value.kind === "ListValue") {
        const source = existingArg.value.values;
        const target = argument.value.values;
        existingArg.value.values = deduplicateLists(source, target, (targetVal, source2) => {
          const value = targetVal.value;
          return !value || !source2.some((sourceVal) => sourceVal.value === value);
        });
      } else {
        existingArg.value = argument.value;
      }
    } else {
      result.push(argument);
    }
  }
  return result;
}
function deduplicateDirectives(directives) {
  return directives.map((directive, i, all) => {
    const firstAt = all.findIndex((d2) => d2.name.value === directive.name.value);
    if (firstAt !== i) {
      const dup = all[firstAt];
      directive.arguments = mergeArguments$1(directive.arguments, dup.arguments);
      return null;
    }
    return directive;
  }).filter(isSome);
}
function mergeDirectives(d1 = [], d2 = [], config2) {
  const reverseOrder = config2 && config2.reverseDirectives;
  const asNext = reverseOrder ? d1 : d2;
  const asFirst = reverseOrder ? d2 : d1;
  const result = deduplicateDirectives([...asNext]);
  for (const directive of asFirst) {
    if (directiveAlreadyExists(result, directive)) {
      const existingDirectiveIndex = result.findIndex((d3) => d3.name.value === directive.name.value);
      const existingDirective = result[existingDirectiveIndex];
      result[existingDirectiveIndex].arguments = mergeArguments$1(directive.arguments || [], existingDirective.arguments || []);
    } else {
      result.push(directive);
    }
  }
  return result;
}
function validateInputs(node, existingNode) {
  const printedNode = (0, import_graphql5.print)({
    ...node,
    description: void 0
  });
  const printedExistingNode = (0, import_graphql5.print)({
    ...existingNode,
    description: void 0
  });
  const leaveInputs = new RegExp("(directive @w*d*)|( on .*$)", "g");
  const sameArguments = printedNode.replace(leaveInputs, "") === printedExistingNode.replace(leaveInputs, "");
  if (!sameArguments) {
    throw new Error(`Unable to merge GraphQL directive "${node.name.value}". 
Existing directive:  
	${printedExistingNode} 
Received directive: 
	${printedNode}`);
  }
}
function mergeDirective(node, existingNode) {
  if (existingNode) {
    validateInputs(node, existingNode);
    return {
      ...node,
      locations: [
        ...existingNode.locations,
        ...node.locations.filter((name) => !nameAlreadyExists(name, existingNode.locations))
      ]
    };
  }
  return node;
}
function deduplicateLists(source, target, filterFn) {
  return source.concat(target.filter((val) => filterFn(val, source)));
}
function mergeEnumValues(first, second, config2) {
  if (config2 === null || config2 === void 0 ? void 0 : config2.consistentEnumMerge) {
    const reversed = [];
    if (first) {
      reversed.push(...first);
    }
    first = second;
    second = reversed;
  }
  const enumValueMap = /* @__PURE__ */ new Map();
  if (first) {
    for (const firstValue of first) {
      enumValueMap.set(firstValue.name.value, firstValue);
    }
  }
  if (second) {
    for (const secondValue of second) {
      const enumValue = secondValue.name.value;
      if (enumValueMap.has(enumValue)) {
        const firstValue = enumValueMap.get(enumValue);
        firstValue.description = secondValue.description || firstValue.description;
        firstValue.directives = mergeDirectives(secondValue.directives, firstValue.directives);
      } else {
        enumValueMap.set(enumValue, secondValue);
      }
    }
  }
  const result = [...enumValueMap.values()];
  if (config2 && config2.sort) {
    result.sort(compareNodes);
  }
  return result;
}
function mergeEnum(e1, e2, config2) {
  if (e2) {
    return {
      name: e1.name,
      description: e1["description"] || e2["description"],
      kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || e1.kind === "EnumTypeDefinition" || e2.kind === "EnumTypeDefinition" ? "EnumTypeDefinition" : "EnumTypeExtension",
      loc: e1.loc,
      directives: mergeDirectives(e1.directives, e2.directives, config2),
      values: mergeEnumValues(e1.values, e2.values, config2)
    };
  }
  return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
    ...e1,
    kind: import_graphql5.Kind.ENUM_TYPE_DEFINITION
  } : e1;
}
function isStringTypes(types) {
  return typeof types === "string";
}
function isSourceTypes(types) {
  return types instanceof import_graphql5.Source;
}
function extractType(type) {
  let visitedType = type;
  while (visitedType.kind === import_graphql5.Kind.LIST_TYPE || visitedType.kind === "NonNullType") {
    visitedType = visitedType.type;
  }
  return visitedType;
}
function isWrappingTypeNode(type) {
  return type.kind !== import_graphql5.Kind.NAMED_TYPE;
}
function isListTypeNode(type) {
  return type.kind === import_graphql5.Kind.LIST_TYPE;
}
function isNonNullTypeNode(type) {
  return type.kind === import_graphql5.Kind.NON_NULL_TYPE;
}
function printTypeNode(type) {
  if (isListTypeNode(type)) {
    return `[${printTypeNode(type.type)}]`;
  }
  if (isNonNullTypeNode(type)) {
    return `${printTypeNode(type.type)}!`;
  }
  return type.name.value;
}
var CompareVal;
(function(CompareVal2) {
  CompareVal2[CompareVal2["A_SMALLER_THAN_B"] = -1] = "A_SMALLER_THAN_B";
  CompareVal2[CompareVal2["A_EQUALS_B"] = 0] = "A_EQUALS_B";
  CompareVal2[CompareVal2["A_GREATER_THAN_B"] = 1] = "A_GREATER_THAN_B";
})(CompareVal || (CompareVal = {}));
function defaultStringComparator(a, b) {
  if (a == null && b == null) {
    return CompareVal.A_EQUALS_B;
  }
  if (a == null) {
    return CompareVal.A_SMALLER_THAN_B;
  }
  if (b == null) {
    return CompareVal.A_GREATER_THAN_B;
  }
  if (a < b)
    return CompareVal.A_SMALLER_THAN_B;
  if (a > b)
    return CompareVal.A_GREATER_THAN_B;
  return CompareVal.A_EQUALS_B;
}
function fieldAlreadyExists(fieldsArr, otherField, config2) {
  const result = fieldsArr.find((field) => field.name.value === otherField.name.value);
  if (result && !(config2 === null || config2 === void 0 ? void 0 : config2.ignoreFieldConflicts)) {
    const t1 = extractType(result.type);
    const t2 = extractType(otherField.type);
    if (t1.name.value !== t2.name.value) {
      throw new Error(`Field "${otherField.name.value}" already defined with a different type. Declared as "${t1.name.value}", but you tried to override with "${t2.name.value}"`);
    }
  }
  return !!result;
}
function mergeFields(type, f1, f2, config2) {
  const result = [];
  if (f2 != null) {
    result.push(...f2);
  }
  if (f1 != null) {
    for (const field of f1) {
      if (fieldAlreadyExists(result, field, config2)) {
        const existing = result.find((f) => f.name.value === field.name.value);
        if (!(config2 === null || config2 === void 0 ? void 0 : config2.ignoreFieldConflicts)) {
          if (config2 === null || config2 === void 0 ? void 0 : config2.throwOnConflict) {
            preventConflicts(type, existing, field, false);
          } else {
            preventConflicts(type, existing, field, true);
          }
          if (isNonNullTypeNode(field.type) && !isNonNullTypeNode(existing.type)) {
            existing.type = field.type;
          }
        }
        existing.arguments = mergeArguments(field["arguments"] || [], existing.arguments || [], config2);
        existing.directives = mergeDirectives(field.directives, existing.directives, config2);
        existing.description = field.description || existing.description;
      } else {
        result.push(field);
      }
    }
  }
  if (config2 && config2.sort) {
    result.sort(compareNodes);
  }
  if (config2 && config2.exclusions) {
    const exclusions = config2.exclusions;
    return result.filter((field) => !exclusions.includes(`${type.name.value}.${field.name.value}`));
  }
  return result;
}
function preventConflicts(type, a, b, ignoreNullability = false) {
  const aType = printTypeNode(a.type);
  const bType = printTypeNode(b.type);
  if (aType !== bType && !safeChangeForFieldType(a.type, b.type, ignoreNullability)) {
    throw new Error(`Field '${type.name.value}.${a.name.value}' changed type from '${aType}' to '${bType}'`);
  }
}
function safeChangeForFieldType(oldType, newType, ignoreNullability = false) {
  if (!isWrappingTypeNode(oldType) && !isWrappingTypeNode(newType)) {
    return oldType.toString() === newType.toString();
  }
  if (isNonNullTypeNode(newType)) {
    const ofType = isNonNullTypeNode(oldType) ? oldType.type : oldType;
    return safeChangeForFieldType(ofType, newType.type);
  }
  if (isNonNullTypeNode(oldType)) {
    return safeChangeForFieldType(newType, oldType, ignoreNullability);
  }
  if (isListTypeNode(oldType)) {
    return isListTypeNode(newType) && safeChangeForFieldType(oldType.type, newType.type) || isNonNullTypeNode(newType) && safeChangeForFieldType(oldType, newType["type"]);
  }
  return false;
}
function mergeInputType(node, existingNode, config2) {
  if (existingNode) {
    try {
      return {
        name: node.name,
        description: node["description"] || existingNode["description"],
        kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || node.kind === "InputObjectTypeDefinition" || existingNode.kind === "InputObjectTypeDefinition" ? "InputObjectTypeDefinition" : "InputObjectTypeExtension",
        loc: node.loc,
        fields: mergeFields(node, node.fields, existingNode.fields, config2),
        directives: mergeDirectives(node.directives, existingNode.directives, config2)
      };
    } catch (e2) {
      throw new Error(`Unable to merge GraphQL input type "${node.name.value}": ${e2.message}`);
    }
  }
  return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
    ...node,
    kind: import_graphql5.Kind.INPUT_OBJECT_TYPE_DEFINITION
  } : node;
}
function mergeInterface(node, existingNode, config2) {
  if (existingNode) {
    try {
      return {
        name: node.name,
        description: node["description"] || existingNode["description"],
        kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || node.kind === "InterfaceTypeDefinition" || existingNode.kind === "InterfaceTypeDefinition" ? "InterfaceTypeDefinition" : "InterfaceTypeExtension",
        loc: node.loc,
        fields: mergeFields(node, node.fields, existingNode.fields, config2),
        directives: mergeDirectives(node.directives, existingNode.directives, config2),
        interfaces: node["interfaces"] ? mergeNamedTypeArray(node["interfaces"], existingNode["interfaces"], config2) : void 0
      };
    } catch (e2) {
      throw new Error(`Unable to merge GraphQL interface "${node.name.value}": ${e2.message}`);
    }
  }
  return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
    ...node,
    kind: import_graphql5.Kind.INTERFACE_TYPE_DEFINITION
  } : node;
}
function alreadyExists(arr, other) {
  return !!arr.find((i) => i.name.value === other.name.value);
}
function mergeNamedTypeArray(first = [], second = [], config2 = {}) {
  const result = [...second, ...first.filter((d2) => !alreadyExists(second, d2))];
  if (config2 && config2.sort) {
    result.sort(compareNodes);
  }
  return result;
}
function mergeType(node, existingNode, config2) {
  if (existingNode) {
    try {
      return {
        name: node.name,
        description: node["description"] || existingNode["description"],
        kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || node.kind === "ObjectTypeDefinition" || existingNode.kind === "ObjectTypeDefinition" ? "ObjectTypeDefinition" : "ObjectTypeExtension",
        loc: node.loc,
        fields: mergeFields(node, node.fields, existingNode.fields, config2),
        directives: mergeDirectives(node.directives, existingNode.directives, config2),
        interfaces: mergeNamedTypeArray(node.interfaces, existingNode.interfaces, config2)
      };
    } catch (e2) {
      throw new Error(`Unable to merge GraphQL type "${node.name.value}": ${e2.message}`);
    }
  }
  return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
    ...node,
    kind: import_graphql5.Kind.OBJECT_TYPE_DEFINITION
  } : node;
}
function mergeScalar(node, existingNode, config2) {
  if (existingNode) {
    return {
      name: node.name,
      description: node["description"] || existingNode["description"],
      kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || node.kind === "ScalarTypeDefinition" || existingNode.kind === "ScalarTypeDefinition" ? "ScalarTypeDefinition" : "ScalarTypeExtension",
      loc: node.loc,
      directives: mergeDirectives(node.directives, existingNode.directives, config2)
    };
  }
  return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
    ...node,
    kind: import_graphql5.Kind.SCALAR_TYPE_DEFINITION
  } : node;
}
function mergeUnion(first, second, config2) {
  if (second) {
    return {
      name: first.name,
      description: first["description"] || second["description"],
      directives: mergeDirectives(first.directives, second.directives, config2),
      kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || first.kind === "UnionTypeDefinition" || second.kind === "UnionTypeDefinition" ? import_graphql5.Kind.UNION_TYPE_DEFINITION : import_graphql5.Kind.UNION_TYPE_EXTENSION,
      loc: first.loc,
      types: mergeNamedTypeArray(first.types, second.types, config2)
    };
  }
  return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
    ...first,
    kind: import_graphql5.Kind.UNION_TYPE_DEFINITION
  } : first;
}
var DEFAULT_OPERATION_TYPE_NAME_MAP = {
  query: "Query",
  mutation: "Mutation",
  subscription: "Subscription"
};
function mergeOperationTypes(opNodeList = [], existingOpNodeList = []) {
  const finalOpNodeList = [];
  for (const opNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {
    const opNode = opNodeList.find((n) => n.operation === opNodeType) || existingOpNodeList.find((n) => n.operation === opNodeType);
    if (opNode) {
      finalOpNodeList.push(opNode);
    }
  }
  return finalOpNodeList;
}
function mergeSchemaDefs(node, existingNode, config2) {
  if (existingNode) {
    return {
      kind: node.kind === import_graphql5.Kind.SCHEMA_DEFINITION || existingNode.kind === import_graphql5.Kind.SCHEMA_DEFINITION ? import_graphql5.Kind.SCHEMA_DEFINITION : import_graphql5.Kind.SCHEMA_EXTENSION,
      description: node["description"] || existingNode["description"],
      directives: mergeDirectives(node.directives, existingNode.directives, config2),
      operationTypes: mergeOperationTypes(node.operationTypes, existingNode.operationTypes)
    };
  }
  return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
    ...node,
    kind: import_graphql5.Kind.SCHEMA_DEFINITION
  } : node;
}
var schemaDefSymbol = "SCHEMA_DEF_SYMBOL";
function isNamedDefinitionNode(definitionNode) {
  return "name" in definitionNode;
}
function mergeGraphQLNodes(nodes, config2) {
  var _a3, _b, _c2;
  const mergedResultMap = {};
  for (const nodeDefinition of nodes) {
    if (isNamedDefinitionNode(nodeDefinition)) {
      const name = (_a3 = nodeDefinition.name) === null || _a3 === void 0 ? void 0 : _a3.value;
      if (config2 === null || config2 === void 0 ? void 0 : config2.commentDescriptions) {
        collectComment(nodeDefinition);
      }
      if (name == null) {
        continue;
      }
      if (((_b = config2 === null || config2 === void 0 ? void 0 : config2.exclusions) === null || _b === void 0 ? void 0 : _b.includes(name + ".*")) || ((_c2 = config2 === null || config2 === void 0 ? void 0 : config2.exclusions) === null || _c2 === void 0 ? void 0 : _c2.includes(name))) {
        delete mergedResultMap[name];
      } else {
        switch (nodeDefinition.kind) {
          case import_graphql5.Kind.OBJECT_TYPE_DEFINITION:
          case import_graphql5.Kind.OBJECT_TYPE_EXTENSION:
            mergedResultMap[name] = mergeType(nodeDefinition, mergedResultMap[name], config2);
            break;
          case import_graphql5.Kind.ENUM_TYPE_DEFINITION:
          case import_graphql5.Kind.ENUM_TYPE_EXTENSION:
            mergedResultMap[name] = mergeEnum(nodeDefinition, mergedResultMap[name], config2);
            break;
          case import_graphql5.Kind.UNION_TYPE_DEFINITION:
          case import_graphql5.Kind.UNION_TYPE_EXTENSION:
            mergedResultMap[name] = mergeUnion(nodeDefinition, mergedResultMap[name], config2);
            break;
          case import_graphql5.Kind.SCALAR_TYPE_DEFINITION:
          case import_graphql5.Kind.SCALAR_TYPE_EXTENSION:
            mergedResultMap[name] = mergeScalar(nodeDefinition, mergedResultMap[name], config2);
            break;
          case import_graphql5.Kind.INPUT_OBJECT_TYPE_DEFINITION:
          case import_graphql5.Kind.INPUT_OBJECT_TYPE_EXTENSION:
            mergedResultMap[name] = mergeInputType(nodeDefinition, mergedResultMap[name], config2);
            break;
          case import_graphql5.Kind.INTERFACE_TYPE_DEFINITION:
          case import_graphql5.Kind.INTERFACE_TYPE_EXTENSION:
            mergedResultMap[name] = mergeInterface(nodeDefinition, mergedResultMap[name], config2);
            break;
          case import_graphql5.Kind.DIRECTIVE_DEFINITION:
            mergedResultMap[name] = mergeDirective(nodeDefinition, mergedResultMap[name]);
            break;
        }
      }
    } else if (nodeDefinition.kind === import_graphql5.Kind.SCHEMA_DEFINITION || nodeDefinition.kind === import_graphql5.Kind.SCHEMA_EXTENSION) {
      mergedResultMap[schemaDefSymbol] = mergeSchemaDefs(nodeDefinition, mergedResultMap[schemaDefSymbol], config2);
    }
  }
  return mergedResultMap;
}
function mergeTypeDefs(typeSource, config2) {
  resetComments();
  const doc = {
    kind: import_graphql5.Kind.DOCUMENT,
    definitions: mergeGraphQLTypes(typeSource, {
      useSchemaDefinition: true,
      forceSchemaDefinition: false,
      throwOnConflict: false,
      commentDescriptions: false,
      ...config2
    })
  };
  let result;
  if (config2 === null || config2 === void 0 ? void 0 : config2.commentDescriptions) {
    result = printWithComments(doc);
  } else {
    result = doc;
  }
  resetComments();
  return result;
}
function visitTypeSources(typeSource, options2, allNodes = [], visitedTypeSources = /* @__PURE__ */ new Set()) {
  if (typeSource && !visitedTypeSources.has(typeSource)) {
    visitedTypeSources.add(typeSource);
    if (typeof typeSource === "function") {
      visitTypeSources(typeSource(), options2, allNodes, visitedTypeSources);
    } else if (Array.isArray(typeSource)) {
      for (const type of typeSource) {
        visitTypeSources(type, options2, allNodes, visitedTypeSources);
      }
    } else if ((0, import_graphql5.isSchema)(typeSource)) {
      const documentNode = getDocumentNodeFromSchema(typeSource, options2);
      visitTypeSources(documentNode.definitions, options2, allNodes, visitedTypeSources);
    } else if (isStringTypes(typeSource) || isSourceTypes(typeSource)) {
      const documentNode = (0, import_graphql5.parse)(typeSource, options2);
      visitTypeSources(documentNode.definitions, options2, allNodes, visitedTypeSources);
    } else if (typeof typeSource === "object" && (0, import_graphql5.isDefinitionNode)(typeSource)) {
      allNodes.push(typeSource);
    } else if (isDocumentNode(typeSource)) {
      visitTypeSources(typeSource.definitions, options2, allNodes, visitedTypeSources);
    } else {
      throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);
    }
  }
  return allNodes;
}
function mergeGraphQLTypes(typeSource, config2) {
  var _a3, _b, _c2;
  resetComments();
  const allNodes = visitTypeSources(typeSource, config2);
  const mergedNodes = mergeGraphQLNodes(allNodes, config2);
  if (config2 === null || config2 === void 0 ? void 0 : config2.useSchemaDefinition) {
    const schemaDef = mergedNodes[schemaDefSymbol] || {
      kind: import_graphql5.Kind.SCHEMA_DEFINITION,
      operationTypes: []
    };
    const operationTypes = schemaDef.operationTypes;
    for (const opTypeDefNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {
      const opTypeDefNode = operationTypes.find((operationType) => operationType.operation === opTypeDefNodeType);
      if (!opTypeDefNode) {
        const possibleRootTypeName = DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];
        const existingPossibleRootType = mergedNodes[possibleRootTypeName];
        if (existingPossibleRootType != null && existingPossibleRootType.name != null) {
          operationTypes.push({
            kind: import_graphql5.Kind.OPERATION_TYPE_DEFINITION,
            type: {
              kind: import_graphql5.Kind.NAMED_TYPE,
              name: existingPossibleRootType.name
            },
            operation: opTypeDefNodeType
          });
        }
      }
    }
    if (((_a3 = schemaDef === null || schemaDef === void 0 ? void 0 : schemaDef.operationTypes) === null || _a3 === void 0 ? void 0 : _a3.length) != null && schemaDef.operationTypes.length > 0) {
      mergedNodes[schemaDefSymbol] = schemaDef;
    }
  }
  if ((config2 === null || config2 === void 0 ? void 0 : config2.forceSchemaDefinition) && !((_c2 = (_b = mergedNodes[schemaDefSymbol]) === null || _b === void 0 ? void 0 : _b.operationTypes) === null || _c2 === void 0 ? void 0 : _c2.length)) {
    mergedNodes[schemaDefSymbol] = {
      kind: import_graphql5.Kind.SCHEMA_DEFINITION,
      operationTypes: [
        {
          kind: import_graphql5.Kind.OPERATION_TYPE_DEFINITION,
          operation: "query",
          type: {
            kind: import_graphql5.Kind.NAMED_TYPE,
            name: {
              kind: import_graphql5.Kind.NAME,
              value: "Query"
            }
          }
        }
      ]
    };
  }
  const mergedNodeDefinitions = Object.values(mergedNodes);
  if (config2 === null || config2 === void 0 ? void 0 : config2.sort) {
    const sortFn = typeof config2.sort === "function" ? config2.sort : defaultStringComparator;
    mergedNodeDefinitions.sort((a, b) => {
      var _a4, _b2;
      return sortFn((_a4 = a.name) === null || _a4 === void 0 ? void 0 : _a4.value, (_b2 = b.name) === null || _b2 === void 0 ? void 0 : _b2.value);
    });
  }
  return mergedNodeDefinitions;
}
function mergeExtensions(extensions) {
  return mergeDeep(extensions);
}
function applyExtensionObject(obj, extensions) {
  if (!obj) {
    return;
  }
  obj.extensions = mergeDeep([obj.extensions || {}, extensions || {}]);
}
function applyExtensions(schema, extensions) {
  applyExtensionObject(schema, extensions.schemaExtensions);
  for (const [typeName, data] of Object.entries(extensions.types || {})) {
    const type = schema.getType(typeName);
    if (type) {
      applyExtensionObject(type, data.extensions);
      if (data.type === "object" || data.type === "interface") {
        for (const [fieldName, fieldData] of Object.entries(data.fields)) {
          const field = type.getFields()[fieldName];
          if (field) {
            applyExtensionObject(field, fieldData.extensions);
            for (const [arg, argData] of Object.entries(fieldData.arguments)) {
              applyExtensionObject(field.args.find((a) => a.name === arg), argData);
            }
          }
        }
      } else if (data.type === "input") {
        for (const [fieldName, fieldData] of Object.entries(data.fields)) {
          const field = type.getFields()[fieldName];
          applyExtensionObject(field, fieldData.extensions);
        }
      } else if (data.type === "enum") {
        for (const [valueName, valueData] of Object.entries(data.values)) {
          const value = type.getValue(valueName);
          applyExtensionObject(value, valueData);
        }
      }
    }
  }
  return schema;
}

// node_modules/.pnpm/@graphql-tools+schema@8.3.10_graphql@16.4.0/node_modules/@graphql-tools/schema/index.mjs
function assertResolversPresent(schema, resolverValidationOptions = {}) {
  const { requireResolversForArgs, requireResolversForNonScalar, requireResolversForAllFields } = resolverValidationOptions;
  if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {
    throw new TypeError("requireResolversForAllFields takes precedence over the more specific assertions. Please configure either requireResolversForAllFields or requireResolversForArgs / requireResolversForNonScalar, but not a combination of them.");
  }
  forEachField(schema, (field, typeName, fieldName) => {
    if (requireResolversForAllFields) {
      expectResolver("requireResolversForAllFields", requireResolversForAllFields, field, typeName, fieldName);
    }
    if (requireResolversForArgs && field.args.length > 0) {
      expectResolver("requireResolversForArgs", requireResolversForArgs, field, typeName, fieldName);
    }
    if (requireResolversForNonScalar !== "ignore" && !(0, import_graphql6.isScalarType)((0, import_graphql6.getNamedType)(field.type))) {
      expectResolver("requireResolversForNonScalar", requireResolversForNonScalar, field, typeName, fieldName);
    }
  });
}
function expectResolver(validator, behavior, field, typeName, fieldName) {
  if (!field.resolve) {
    const message = `Resolver missing for "${typeName}.${fieldName}".
To disable this validator, use:
  resolverValidationOptions: {
    ${validator}: 'ignore'
  }`;
    if (behavior === "error") {
      throw new Error(message);
    }
    if (behavior === "warn") {
      console.warn(message);
    }
    return;
  }
  if (typeof field.resolve !== "function") {
    throw new Error(`Resolver "${typeName}.${fieldName}" must be a function`);
  }
}
function checkForResolveTypeResolver(schema, requireResolversForResolveType) {
  mapSchema(schema, {
    [MapperKind.ABSTRACT_TYPE]: (type) => {
      if (!type.resolveType) {
        const message = `Type "${type.name}" is missing a "__resolveType" resolver. Pass 'ignore' into "resolverValidationOptions.requireResolversForResolveType" to disable this error.`;
        if (requireResolversForResolveType === "error") {
          throw new Error(message);
        }
        if (requireResolversForResolveType === "warn") {
          console.warn(message);
        }
      }
      return void 0;
    }
  });
}
function extendResolversFromInterfaces(schema, resolvers) {
  const extendedResolvers = {};
  const typeMap = schema.getTypeMap();
  for (const typeName in typeMap) {
    const type = typeMap[typeName];
    if ("getInterfaces" in type) {
      extendedResolvers[typeName] = {};
      for (const iFace of type.getInterfaces()) {
        if (resolvers[iFace.name]) {
          for (const fieldName in resolvers[iFace.name]) {
            if (fieldName === "__isTypeOf" || !fieldName.startsWith("__")) {
              extendedResolvers[typeName][fieldName] = resolvers[iFace.name][fieldName];
            }
          }
        }
      }
      const typeResolvers = resolvers[typeName];
      extendedResolvers[typeName] = {
        ...extendedResolvers[typeName],
        ...typeResolvers
      };
    } else {
      const typeResolvers = resolvers[typeName];
      if (typeResolvers != null) {
        extendedResolvers[typeName] = typeResolvers;
      }
    }
  }
  return extendedResolvers;
}
function addResolversToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions) {
  const options2 = (0, import_graphql6.isSchema)(schemaOrOptions) ? {
    schema: schemaOrOptions,
    resolvers: legacyInputResolvers !== null && legacyInputResolvers !== void 0 ? legacyInputResolvers : {},
    resolverValidationOptions: legacyInputValidationOptions
  } : schemaOrOptions;
  let { schema, resolvers: inputResolvers, defaultFieldResolver: defaultFieldResolver5, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false } = options2;
  const { requireResolversToMatchSchema = "error", requireResolversForResolveType } = resolverValidationOptions;
  const resolvers = inheritResolversFromInterfaces ? extendResolversFromInterfaces(schema, inputResolvers) : inputResolvers;
  for (const typeName in resolvers) {
    const resolverValue = resolvers[typeName];
    const resolverType = typeof resolverValue;
    if (resolverType !== "object") {
      throw new Error(`"${typeName}" defined in resolvers, but has invalid value "${resolverValue}". The resolver's value must be of type object.`);
    }
    const type = schema.getType(typeName);
    if (type == null) {
      if (requireResolversToMatchSchema === "ignore") {
        continue;
      }
      throw new Error(`"${typeName}" defined in resolvers, but not in schema`);
    } else if ((0, import_graphql6.isSpecifiedScalarType)(type)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type[fieldName.substring(2)] = resolverValue[fieldName];
        } else {
          type[fieldName] = resolverValue[fieldName];
        }
      }
    } else if ((0, import_graphql6.isEnumType)(type)) {
      const values = type.getValues();
      for (const fieldName in resolverValue) {
        if (!fieldName.startsWith("__") && !values.some((value) => value.name === fieldName) && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
          throw new Error(`${type.name}.${fieldName} was defined in resolvers, but not present within ${type.name}`);
        }
      }
    } else if ((0, import_graphql6.isUnionType)(type)) {
      for (const fieldName in resolverValue) {
        if (!fieldName.startsWith("__") && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
          throw new Error(`${type.name}.${fieldName} was defined in resolvers, but ${type.name} is not an object or interface type`);
        }
      }
    } else if ((0, import_graphql6.isObjectType)(type) || (0, import_graphql6.isInterfaceType)(type)) {
      for (const fieldName in resolverValue) {
        if (!fieldName.startsWith("__")) {
          const fields = type.getFields();
          const field = fields[fieldName];
          if (field == null) {
            if (requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
              throw new Error(`${typeName}.${fieldName} defined in resolvers, but not in schema`);
            }
          } else {
            const fieldResolve = resolverValue[fieldName];
            if (typeof fieldResolve !== "function" && typeof fieldResolve !== "object") {
              throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);
            }
          }
        }
      }
    }
  }
  schema = updateResolversInPlace ? addResolversToExistingSchema(schema, resolvers, defaultFieldResolver5) : createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver5);
  if (requireResolversForResolveType && requireResolversForResolveType !== "ignore") {
    checkForResolveTypeResolver(schema, requireResolversForResolveType);
  }
  return schema;
}
function addResolversToExistingSchema(schema, resolvers, defaultFieldResolver5) {
  var _a3, _b, _c2, _d, _e, _f2, _g, _h, _j, _k, _l2, _m;
  const typeMap = schema.getTypeMap();
  for (const typeName in resolvers) {
    const type = schema.getType(typeName);
    const resolverValue = resolvers[typeName];
    if ((0, import_graphql6.isScalarType)(type)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type[fieldName.substring(2)] = resolverValue[fieldName];
        } else if (fieldName === "astNode" && type.astNode != null) {
          type.astNode = {
            ...type.astNode,
            description: (_b = (_a3 = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a3 === void 0 ? void 0 : _a3.description) !== null && _b !== void 0 ? _b : type.astNode.description,
            directives: ((_c2 = type.astNode.directives) !== null && _c2 !== void 0 ? _c2 : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
          };
        } else if (fieldName === "extensionASTNodes" && type.extensionASTNodes != null) {
          type.extensionASTNodes = type.extensionASTNodes.concat((_f2 = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f2 !== void 0 ? _f2 : []);
        } else if (fieldName === "extensions" && type.extensions != null && resolverValue.extensions != null) {
          type.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
        } else {
          type[fieldName] = resolverValue[fieldName];
        }
      }
    } else if ((0, import_graphql6.isEnumType)(type)) {
      const config2 = type.toConfig();
      const enumValueConfigMap = config2.values;
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          config2[fieldName.substring(2)] = resolverValue[fieldName];
        } else if (fieldName === "astNode" && config2.astNode != null) {
          config2.astNode = {
            ...config2.astNode,
            description: (_h = (_g = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _g === void 0 ? void 0 : _g.description) !== null && _h !== void 0 ? _h : config2.astNode.description,
            directives: ((_j = config2.astNode.directives) !== null && _j !== void 0 ? _j : []).concat((_l2 = (_k = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _k === void 0 ? void 0 : _k.directives) !== null && _l2 !== void 0 ? _l2 : [])
          };
        } else if (fieldName === "extensionASTNodes" && config2.extensionASTNodes != null) {
          config2.extensionASTNodes = config2.extensionASTNodes.concat((_m = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _m !== void 0 ? _m : []);
        } else if (fieldName === "extensions" && type.extensions != null && resolverValue.extensions != null) {
          type.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
        } else if (enumValueConfigMap[fieldName]) {
          enumValueConfigMap[fieldName].value = resolverValue[fieldName];
        }
      }
      typeMap[typeName] = new import_graphql6.GraphQLEnumType(config2);
    } else if ((0, import_graphql6.isUnionType)(type)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type[fieldName.substring(2)] = resolverValue[fieldName];
        }
      }
    } else if ((0, import_graphql6.isObjectType)(type) || (0, import_graphql6.isInterfaceType)(type)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type[fieldName.substring(2)] = resolverValue[fieldName];
          continue;
        }
        const fields = type.getFields();
        const field = fields[fieldName];
        if (field != null) {
          const fieldResolve = resolverValue[fieldName];
          if (typeof fieldResolve === "function") {
            field.resolve = fieldResolve.bind(resolverValue);
          } else {
            setFieldProperties(field, fieldResolve);
          }
        }
      }
    }
  }
  forEachDefaultValue(schema, serializeInputValue);
  healSchema(schema);
  forEachDefaultValue(schema, parseInputValue);
  if (defaultFieldResolver5 != null) {
    forEachField(schema, (field) => {
      if (!field.resolve) {
        field.resolve = defaultFieldResolver5;
      }
    });
  }
  return schema;
}
function createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver5) {
  schema = mapSchema(schema, {
    [MapperKind.SCALAR_TYPE]: (type) => {
      var _a3, _b, _c2, _d, _e, _f2;
      const config2 = type.toConfig();
      const resolverValue = resolvers[type.name];
      if (!(0, import_graphql6.isSpecifiedScalarType)(type) && resolverValue != null) {
        for (const fieldName in resolverValue) {
          if (fieldName.startsWith("__")) {
            config2[fieldName.substring(2)] = resolverValue[fieldName];
          } else if (fieldName === "astNode" && config2.astNode != null) {
            config2.astNode = {
              ...config2.astNode,
              description: (_b = (_a3 = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a3 === void 0 ? void 0 : _a3.description) !== null && _b !== void 0 ? _b : config2.astNode.description,
              directives: ((_c2 = config2.astNode.directives) !== null && _c2 !== void 0 ? _c2 : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
            };
          } else if (fieldName === "extensionASTNodes" && config2.extensionASTNodes != null) {
            config2.extensionASTNodes = config2.extensionASTNodes.concat((_f2 = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f2 !== void 0 ? _f2 : []);
          } else if (fieldName === "extensions" && config2.extensions != null && resolverValue.extensions != null) {
            config2.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
          } else {
            config2[fieldName] = resolverValue[fieldName];
          }
        }
        return new import_graphql6.GraphQLScalarType(config2);
      }
    },
    [MapperKind.ENUM_TYPE]: (type) => {
      var _a3, _b, _c2, _d, _e, _f2;
      const resolverValue = resolvers[type.name];
      const config2 = type.toConfig();
      const enumValueConfigMap = config2.values;
      if (resolverValue != null) {
        for (const fieldName in resolverValue) {
          if (fieldName.startsWith("__")) {
            config2[fieldName.substring(2)] = resolverValue[fieldName];
          } else if (fieldName === "astNode" && config2.astNode != null) {
            config2.astNode = {
              ...config2.astNode,
              description: (_b = (_a3 = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a3 === void 0 ? void 0 : _a3.description) !== null && _b !== void 0 ? _b : config2.astNode.description,
              directives: ((_c2 = config2.astNode.directives) !== null && _c2 !== void 0 ? _c2 : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
            };
          } else if (fieldName === "extensionASTNodes" && config2.extensionASTNodes != null) {
            config2.extensionASTNodes = config2.extensionASTNodes.concat((_f2 = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f2 !== void 0 ? _f2 : []);
          } else if (fieldName === "extensions" && config2.extensions != null && resolverValue.extensions != null) {
            config2.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
          } else if (enumValueConfigMap[fieldName]) {
            enumValueConfigMap[fieldName].value = resolverValue[fieldName];
          }
        }
        return new import_graphql6.GraphQLEnumType(config2);
      }
    },
    [MapperKind.UNION_TYPE]: (type) => {
      const resolverValue = resolvers[type.name];
      if (resolverValue != null) {
        const config2 = type.toConfig();
        if (resolverValue["__resolveType"]) {
          config2.resolveType = resolverValue["__resolveType"];
        }
        return new import_graphql6.GraphQLUnionType(config2);
      }
    },
    [MapperKind.OBJECT_TYPE]: (type) => {
      const resolverValue = resolvers[type.name];
      if (resolverValue != null) {
        const config2 = type.toConfig();
        if (resolverValue["__isTypeOf"]) {
          config2.isTypeOf = resolverValue["__isTypeOf"];
        }
        return new import_graphql6.GraphQLObjectType(config2);
      }
    },
    [MapperKind.INTERFACE_TYPE]: (type) => {
      const resolverValue = resolvers[type.name];
      if (resolverValue != null) {
        const config2 = type.toConfig();
        if (resolverValue["__resolveType"]) {
          config2.resolveType = resolverValue["__resolveType"];
        }
        return new import_graphql6.GraphQLInterfaceType(config2);
      }
    },
    [MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {
      const resolverValue = resolvers[typeName];
      if (resolverValue != null) {
        const fieldResolve = resolverValue[fieldName];
        if (fieldResolve != null) {
          const newFieldConfig = { ...fieldConfig };
          if (typeof fieldResolve === "function") {
            newFieldConfig.resolve = fieldResolve.bind(resolverValue);
          } else {
            setFieldProperties(newFieldConfig, fieldResolve);
          }
          return newFieldConfig;
        }
      }
    }
  });
  if (defaultFieldResolver5 != null) {
    schema = mapSchema(schema, {
      [MapperKind.OBJECT_FIELD]: (fieldConfig) => ({
        ...fieldConfig,
        resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver5
      })
    });
  }
  return schema;
}
function setFieldProperties(field, propertiesObj) {
  for (const propertyName in propertiesObj) {
    field[propertyName] = propertiesObj[propertyName];
  }
}
function makeExecutableSchema({ typeDefs, resolvers = {}, resolverValidationOptions = {}, parseOptions = {}, inheritResolversFromInterfaces = false, pruningOptions, updateResolversInPlace = false, schemaExtensions }) {
  if (typeof resolverValidationOptions !== "object") {
    throw new Error("Expected `resolverValidationOptions` to be an object");
  }
  if (!typeDefs) {
    throw new Error("Must provide typeDefs");
  }
  let schema;
  if ((0, import_graphql6.isSchema)(typeDefs)) {
    schema = typeDefs;
  } else if (parseOptions === null || parseOptions === void 0 ? void 0 : parseOptions.commentDescriptions) {
    const mergedTypeDefs = mergeTypeDefs(typeDefs, {
      ...parseOptions,
      commentDescriptions: true
    });
    schema = (0, import_graphql6.buildSchema)(mergedTypeDefs, parseOptions);
  } else {
    const mergedTypeDefs = mergeTypeDefs(typeDefs, parseOptions);
    schema = (0, import_graphql6.buildASTSchema)(mergedTypeDefs, parseOptions);
  }
  if (pruningOptions) {
    schema = pruneSchema(schema);
  }
  schema = addResolversToSchema({
    schema,
    resolvers: mergeResolvers(resolvers),
    resolverValidationOptions,
    inheritResolversFromInterfaces,
    updateResolversInPlace
  });
  if (Object.keys(resolverValidationOptions).length > 0) {
    assertResolversPresent(schema, resolverValidationOptions);
  }
  if (schemaExtensions) {
    schemaExtensions = mergeExtensions(asArray(schemaExtensions));
    applyExtensions(schema, schemaExtensions);
  }
  return schema;
}

// node_modules/.pnpm/@graphql-yoga+common@2.3.0_graphql@16.4.0/node_modules/@graphql-yoga/common/index.mjs
var import_cross_undici_fetch = __toESM(require_node_ponyfill(), 1);

// node_modules/.pnpm/dset@3.1.1/node_modules/dset/dist/index.mjs
function dset(obj, keys2, val) {
  keys2.split && (keys2 = keys2.split("."));
  var i = 0, l = keys2.length, t = obj, x, k2;
  while (i < l) {
    k2 = keys2[i++];
    if (k2 === "__proto__" || k2 === "constructor" || k2 === "prototype")
      break;
    t = t[k2] = i === l ? val : typeof (x = t[k2]) === typeof keys2 ? x : keys2[i] * 0 !== 0 || !!~("" + keys2[i]).indexOf(".") ? {} : [];
  }
}

// node_modules/.pnpm/@graphql-yoga+subscription@2.0.0/node_modules/@graphql-yoga/subscription/index.mjs
var import_repeater = __toESM(require_repeater(), 1);
var import_repeater2 = __toESM(require_repeater(), 1);

// node_modules/.pnpm/@graphql-yoga+common@2.3.0_graphql@16.4.0/node_modules/@graphql-yoga/common/index.mjs
var ANSI_CODES = {
  black: "\x1B[30m",
  red: "\x1B[31m",
  green: "\x1B[32m",
  yellow: "\x1B[33m",
  blue: "\x1B[34m",
  magenta: "\x1B[35m",
  cyan: "\x1B[36m",
  white: "\x1B[37m",
  reset: "\x1B[0m",
  bold: "\x1B[1m",
  orange: "\x1B[48:5:166m"
};
var warnColor = (msg) => ANSI_CODES.orange + msg + ANSI_CODES.reset;
var infoColor = (msg) => ANSI_CODES.cyan + msg + ANSI_CODES.reset;
var errorColor = (msg) => ANSI_CODES.red + msg + ANSI_CODES.reset;
var debugColor = (msg) => ANSI_CODES.magenta + msg + ANSI_CODES.reset;
var titleBold = (msg) => ANSI_CODES.bold + msg + ANSI_CODES.reset;
var isDebug = () => typeof process === "object" ? process.env.DEBUG : false;
function getPrefix() {
  return titleBold(`\u{1F9D8} Yoga -`);
}
function getLoggerMessage(...args) {
  return args.map((arg) => typeof arg === "string" ? arg : inspect(arg)).join(` `);
}
var defaultYogaLogger = {
  debug(...args) {
    if (isDebug()) {
      const message = getLoggerMessage(...args);
      const fullMessage = `${getPrefix()} \u{1F41B} ${debugColor(message)}`;
      if (console.debug) {
        console.debug(fullMessage);
      } else {
        console.log(fullMessage);
      }
    }
  },
  info(...args) {
    const message = getLoggerMessage(...args);
    const fullMessage = `${getPrefix()} \u{1F4A1} ${infoColor(message)}`;
    if (console.info) {
      console.info(fullMessage);
    } else {
      console.log(fullMessage);
    }
  },
  warn(...args) {
    const message = getLoggerMessage(...args);
    const fullMessage = `${getPrefix()} \u26A0\uFE0F ${warnColor(message)}`;
    if (console.warn) {
      console.warn(fullMessage);
    } else {
      console.log(fullMessage);
    }
  },
  error(...args) {
    const message = getLoggerMessage(...args);
    const fullMessage = `${getPrefix()} \u274C ${errorColor(message)}`;
    if (console.error) {
      console.error(fullMessage);
    } else {
      console.log(fullMessage);
    }
  }
};
var graphiqlHTML = '<!doctype html><html lang=en><meta charset=utf-8><title>__TITLE__</title><link href=https://www.graphql-yoga.com/favicon.ico rel=icon><link href=https://unpkg.com/@graphql-yoga/graphiql/dist/style.css rel=stylesheet><body class=no-focus-outline id=body><noscript>You need to enable JavaScript to run this app.</noscript><div id=root></div><script type=module>import{renderYogaGraphiQL as r}from"https://unpkg.com/@graphql-yoga/graphiql";r(root,__OPTS__);<\/script>';
function shouldRenderGraphiQL({ headers, method }) {
  var _a3;
  return method === "GET" && !!((_a3 = headers === null || headers === void 0 ? void 0 : headers.get("accept")) === null || _a3 === void 0 ? void 0 : _a3.includes("text/html"));
}
var renderGraphiQL = (opts) => graphiqlHTML.replace("__TITLE__", (opts === null || opts === void 0 ? void 0 : opts.title) || "Yoga GraphiQL").replace("__OPTS__", JSON.stringify(opts !== null && opts !== void 0 ? opts : {}));
var GETRequestParser = {
  is: (request3) => request3.method === "GET",
  parse: async (request3) => {
    const [, searchParamsStr] = request3.url.split("?");
    const searchParams = new URLSearchParams(searchParamsStr);
    const operationName = searchParams.get("operationName") || void 0;
    const query = searchParams.get("query") || void 0;
    const variables = searchParams.get("variables") || void 0;
    const extensions = searchParams.get("extensions") || void 0;
    return {
      operationName,
      query,
      variables: variables ? JSON.parse(variables) : void 0,
      extensions: extensions ? JSON.parse(extensions) : void 0
    };
  }
};
var POSTRequestParser = {
  is: (request3) => request3.method === "POST",
  parse: async (request3) => {
    const requestBody = await request3.json();
    return {
      operationName: requestBody.operationName,
      query: requestBody.query,
      variables: requestBody.variables,
      extensions: requestBody.extensions
    };
  }
};
var POSTMultipartFormDataRequestParser = {
  is: (request3) => {
    var _a3;
    return request3.method === "POST" && !!((_a3 = request3.headers.get("content-type")) === null || _a3 === void 0 ? void 0 : _a3.startsWith("multipart/form-data"));
  },
  parse: async (request3) => {
    var _a3, _b;
    const requestBody = await request3.formData();
    const operationsStr = ((_a3 = requestBody.get("operations")) === null || _a3 === void 0 ? void 0 : _a3.toString()) || "{}";
    const operations = JSON.parse(operationsStr);
    const mapStr = ((_b = requestBody.get("map")) === null || _b === void 0 ? void 0 : _b.toString()) || "{}";
    const map3 = JSON.parse(mapStr);
    for (const fileIndex in map3) {
      const file = requestBody.get(fileIndex);
      const [path] = map3[fileIndex];
      dset(operations, path, file);
    }
    return {
      operationName: operations.operationName,
      query: operations.query,
      variables: operations.variables,
      extensions: operations.extensions
    };
  }
};
function buildGetGraphQLParameters(parsers) {
  return async function getGraphQLParameters2(request3) {
    for (const parser of parsers) {
      if (parser.is(request3)) {
        return parser.parse(request3);
      }
    }
    return {
      operationName: void 0,
      query: void 0,
      variables: void 0,
      extensions: void 0
    };
  };
}
var getGraphQLParameters = buildGetGraphQLParameters([
  GETRequestParser,
  POSTMultipartFormDataRequestParser,
  POSTRequestParser
]);
var encodeString;
if (globalThis.Buffer) {
  encodeString = function encodeStringWithBuffer(str) {
    return globalThis.Buffer.from(str, "utf8");
  };
} else {
  const textEncoder = new TextEncoder();
  encodeString = function encodeStringWithTextEncoder(str) {
    return textEncoder.encode(str);
  };
}
async function* getSingleResult(payload) {
  yield payload;
}
function getExecutableOperation(document, operationName) {
  const operation = (0, import_graphql7.getOperationAST)(document, operationName);
  if (!operation) {
    throw new Error("Could not determine what operation to execute.");
  }
  return operation;
}
async function processRequest({ contextFactory, execute: execute2, operationName, parse: parse6, query, request: request3, schema, subscribe: subscribe2, validate: validate3, variables, extraHeaders, Response: Response2, ReadableStream: ReadableStream2 }) {
  var _a3;
  function getErrorResponse({ status: status2 = 500, headers, errors: errors2, isEventStream: isEventStream2 }) {
    const payload = {
      data: null,
      errors: errors2
    };
    if (isEventStream2) {
      return getPushResponse(getSingleResult(payload));
    }
    const decodedString = encodeString(JSON.stringify(payload));
    return new Response2(decodedString, {
      status: status2,
      headers: {
        ...headers,
        "Content-Type": "application/json",
        "Content-Length": decodedString.byteLength.toString()
      }
    });
  }
  function getRegularResponse(executionResult) {
    const responseBody = JSON.stringify(executionResult);
    const decodedString = encodeString(responseBody);
    const headersInit = {
      ...extraHeaders,
      "Content-Type": "application/json",
      "Content-Length": decodedString.byteLength.toString()
    };
    const responseInit = {
      headers: headersInit,
      status: 200
    };
    return new Response2(decodedString, responseInit);
  }
  function getMultipartResponse(asyncExecutionResult) {
    const headersInit = {
      ...extraHeaders,
      Connection: "keep-alive",
      "Content-Type": 'multipart/mixed; boundary="-"',
      "Transfer-Encoding": "chunked"
    };
    const responseInit = {
      headers: headersInit,
      status: 200
    };
    let iterator;
    const readableStream = new ReadableStream2({
      start(controller) {
        iterator = asyncExecutionResult[Symbol.asyncIterator]();
        controller.enqueue(encodeString(`---`));
      },
      async pull(controller) {
        const { done: done2, value } = await iterator.next();
        if (value != null) {
          controller.enqueue(encodeString("\r\n"));
          controller.enqueue(encodeString("Content-Type: application/json; charset=utf-8"));
          controller.enqueue(encodeString("\r\n"));
          const chunk = JSON.stringify(value);
          const encodedChunk = encodeString(chunk);
          controller.enqueue(encodeString("Content-Length: " + encodedChunk.byteLength));
          controller.enqueue(encodeString("\r\n"));
          controller.enqueue(encodeString("\r\n"));
          controller.enqueue(encodedChunk);
          controller.enqueue(encodeString("\r\n"));
          controller.enqueue(encodeString("---"));
        }
        if (done2) {
          controller.enqueue(encodeString("\r\n-----\r\n"));
          controller.close();
        }
      },
      async cancel(e2) {
        var _a4;
        await ((_a4 = iterator.return) === null || _a4 === void 0 ? void 0 : _a4.call(iterator, e2));
      }
    });
    return new Response2(readableStream, responseInit);
  }
  function getPushResponse(asyncExecutionResult) {
    const headersInit = {
      ...extraHeaders,
      "Content-Type": "text/event-stream",
      Connection: "keep-alive",
      "Cache-Control": "no-cache",
      "Content-Encoding": "none"
    };
    const responseInit = {
      headers: headersInit,
      status: 200
    };
    let iterator;
    const readableStream = new ReadableStream2({
      start() {
        iterator = asyncExecutionResult[Symbol.asyncIterator]();
      },
      async pull(controller) {
        const { done: done2, value } = await iterator.next();
        if (value != null) {
          const chunk = JSON.stringify(value);
          controller.enqueue(encodeString(`data: ${chunk}

`));
        }
        if (done2) {
          controller.close();
        }
      },
      async cancel(e2) {
        var _a4;
        await ((_a4 = iterator.return) === null || _a4 === void 0 ? void 0 : _a4.call(iterator, e2));
      }
    });
    return new Response2(readableStream, responseInit);
  }
  let contextValue;
  let document;
  let operation;
  const isEventStream = !!((_a3 = request3.headers.get("accept")) === null || _a3 === void 0 ? void 0 : _a3.includes("text/event-stream"));
  try {
    if (request3.method !== "GET" && request3.method !== "POST") {
      return getErrorResponse({
        status: 405,
        headers: {
          Allow: "GET, POST",
          ...extraHeaders
        },
        errors: [
          new import_graphql7.GraphQLError("GraphQL only supports GET and POST requests.")
        ],
        isEventStream
      });
    }
    if (query == null) {
      return getErrorResponse({
        status: 400,
        errors: [new import_graphql7.GraphQLError("Must provide query string.")],
        isEventStream,
        headers: extraHeaders
      });
    }
    try {
      if (typeof query !== "string" && query.kind === "Document") {
        document = query;
      } else {
        document = parse6(query);
      }
    } catch (e2) {
      return getErrorResponse({
        status: 400,
        errors: [e2],
        isEventStream,
        headers: extraHeaders
      });
    }
    const validationErrors = validate3(schema, document);
    if (validationErrors.length > 0) {
      return getErrorResponse({
        status: 400,
        errors: validationErrors,
        isEventStream,
        headers: extraHeaders
      });
    }
    operation = getExecutableOperation(document, operationName);
    if (operation.operation === "mutation" && request3.method === "GET") {
      return getErrorResponse({
        status: 405,
        errors: [
          new import_graphql7.GraphQLError("Can only perform a mutation operation from a POST request.")
        ],
        headers: {
          Allow: "POST",
          ...extraHeaders
        },
        isEventStream
      });
    }
    let variableValues;
    try {
      if (variables) {
        variableValues = typeof variables === "string" ? JSON.parse(variables) : variables;
      }
    } catch (_error) {
      return getErrorResponse({
        errors: [new import_graphql7.GraphQLError("Variables are invalid JSON.")],
        status: 400,
        isEventStream,
        headers: extraHeaders
      });
    }
    contextValue = await contextFactory();
    const executionArgs = {
      schema,
      document,
      contextValue,
      variableValues,
      operationName
    };
    if (operation.operation === "subscription") {
      const result = await subscribe2(executionArgs);
      if (isAsyncIterable2(result)) {
        return getPushResponse(result);
      } else {
        if (isEventStream) {
          return getPushResponse(result);
        } else {
          return getRegularResponse(result);
        }
      }
    } else {
      const result = await execute2(executionArgs);
      if (isAsyncIterable2(result)) {
        return isEventStream ? getPushResponse(result) : getMultipartResponse(result);
      } else {
        return getRegularResponse(result);
      }
    }
  } catch (error2) {
    const errors2 = [
      error2 instanceof import_graphql7.GraphQLError ? error2 : new import_graphql7.GraphQLError(error2.message, void 0, void 0, void 0, void 0, error2)
    ];
    return getErrorResponse({
      status: 500,
      errors: errors2,
      isEventStream,
      headers: extraHeaders
    });
  }
}
function getDefaultSchema() {
  return makeExecutableSchema({
    typeDefs: `
      """
      Greetings from GraphQL Yoga!
      """
      type Query {
        greetings: String
      }
      type Subscription {
        """
        Current Time
        """
        time: String
      }
    `,
    resolvers: {
      Query: {
        greetings: () => "This is the `greetings` field of the root `Query` type"
      },
      Subscription: {
        time: {
          subscribe: async function* () {
            while (true) {
              yield { time: new Date().toISOString() };
              await new Promise((resolve2) => setTimeout(resolve2, 1e3));
            }
          }
        }
      }
    }
  });
}
var YogaServer = class {
  constructor(options2) {
    var _a3, _b, _c2, _d, _e, _f2, _g, _h, _j, _k;
    this.corsOptionsFactory = () => ({});
    this.id = Date.now().toString();
    this.handleRequest = async (request3, ...args) => {
      const serverContext = args[0];
      try {
        if (request3.method === "OPTIONS") {
          return this.handleOptions(request3, ...args);
        }
        const requestPath = request3.url.split("?")[0];
        if (requestPath.endsWith("/health")) {
          return new this.fetchAPI.Response(`{ "message": "alive" }`, {
            status: 200,
            headers: {
              "Content-Type": "application/json",
              "x-yoga-id": this.id
            }
          });
        }
        if (requestPath.endsWith("/readiness")) {
          const readinessResponse = await this.fetchAPI.fetch(request3.url.replace("/readiness", "/health"));
          const { message } = await readinessResponse.json();
          if (readinessResponse.status === 200 && readinessResponse.headers.get("x-yoga-id") === this.id && message === "alive") {
            return new this.fetchAPI.Response(`{ "message": "ready" }`, {
              status: 200,
              headers: {
                "Content-Type": "application/json"
              }
            });
          }
          throw new Error(`Readiness check failed with status ${readinessResponse.status}`);
        }
        this.logger.debug(`Checking if GraphiQL Request`);
        if (this.endpoint != null && !requestPath.endsWith(this.endpoint)) {
          return new this.fetchAPI.Response(`Unable to ${request3.method} ${requestPath}`, {
            status: 404,
            statusText: `Not Found`
          });
        }
        if (shouldRenderGraphiQL(request3)) {
          let graphiqlOptions = this.graphiqlOptionsFactory(request3, ...args);
          if (graphiqlOptions) {
            const graphiQLBody = await this.renderGraphiQL({
              endpoint: this.endpoint,
              ...graphiqlOptions === true ? {} : graphiqlOptions
            });
            return new this.fetchAPI.Response(graphiQLBody, {
              headers: {
                "Content-Type": "text/html"
              },
              status: 200
            });
          }
        }
        this.logger.debug(`Extracting GraphQL Parameters`);
        const { query, variables, operationName, extensions } = await getGraphQLParameters(request3);
        const initialContext = {
          request: request3,
          query,
          variables,
          operationName,
          extensions,
          ...serverContext
        };
        const { execute: execute2, validate: validate3, subscribe: subscribe2, parse: parse6, contextFactory, schema: schema2 } = this.getEnveloped(initialContext);
        this.logger.debug(`Processing Request`);
        const corsHeaders = this.getCORSResponseHeaders(request3, initialContext);
        const response = await processRequest({
          request: request3,
          query,
          variables,
          operationName,
          execute: execute2,
          validate: validate3,
          subscribe: subscribe2,
          parse: parse6,
          contextFactory,
          schema: schema2,
          extraHeaders: corsHeaders,
          Response: this.fetchAPI.Response,
          ReadableStream: this.fetchAPI.ReadableStream
        });
        return response;
      } catch (err2) {
        this.logger.error(err2.message, err2.stack, err2);
        const response = new this.fetchAPI.Response(err2.message, {
          status: 500,
          statusText: "Internal Server Error"
        });
        return response;
      }
    };
    this.fetch = (input, init) => {
      let request3;
      if (typeof input === "string") {
        request3 = new this.fetchAPI.Request(input, init);
      } else {
        request3 = input;
      }
      return this.handleRequest(request3, init);
    };
    this.fetchEventListener = (event) => event.respondWith(this.handleRequest(event.request, event));
    this.fetchAPI = {
      Request: (_b = (_a3 = options2 === null || options2 === void 0 ? void 0 : options2.fetchAPI) === null || _a3 === void 0 ? void 0 : _a3.Request) !== null && _b !== void 0 ? _b : import_cross_undici_fetch.Request,
      Response: (_d = (_c2 = options2 === null || options2 === void 0 ? void 0 : options2.fetchAPI) === null || _c2 === void 0 ? void 0 : _c2.Response) !== null && _d !== void 0 ? _d : import_cross_undici_fetch.Response,
      fetch: (_f2 = (_e = options2 === null || options2 === void 0 ? void 0 : options2.fetchAPI) === null || _e === void 0 ? void 0 : _e.fetch) !== null && _f2 !== void 0 ? _f2 : import_cross_undici_fetch.fetch,
      ReadableStream: (_h = (_g = options2 === null || options2 === void 0 ? void 0 : options2.fetchAPI) === null || _g === void 0 ? void 0 : _g.ReadableStream) !== null && _h !== void 0 ? _h : import_cross_undici_fetch.ReadableStream
    };
    const schema = (options2 === null || options2 === void 0 ? void 0 : options2.schema) ? (0, import_graphql7.isSchema)(options2.schema) ? options2.schema : makeExecutableSchema({
      typeDefs: options2.schema.typeDefs,
      resolvers: options2.schema.resolvers
    }) : getDefaultSchema();
    const logger = (options2 === null || options2 === void 0 ? void 0 : options2.logging) != null ? options2.logging : true;
    this.logger = typeof logger === "boolean" ? logger === true ? defaultYogaLogger : {
      debug: () => {
      },
      error: () => {
      },
      warn: () => {
      },
      info: () => {
      }
    } : logger;
    const maskedErrors = (_j = options2 === null || options2 === void 0 ? void 0 : options2.maskedErrors) !== null && _j !== void 0 ? _j : true;
    this.getEnveloped = envelop({
      plugins: [
        enableIf(schema != null, useSchema(schema)),
        enableIf((options2 === null || options2 === void 0 ? void 0 : options2.parserCache) !== false, () => useParserCache(typeof (options2 === null || options2 === void 0 ? void 0 : options2.parserCache) === "object" ? options2 === null || options2 === void 0 ? void 0 : options2.parserCache : void 0)),
        enableIf((options2 === null || options2 === void 0 ? void 0 : options2.validationCache) !== false, () => useValidationCache({
          cache: typeof (options2 === null || options2 === void 0 ? void 0 : options2.validationCache) === "object" ? options2 === null || options2 === void 0 ? void 0 : options2.validationCache : void 0
        })),
        enableIf(logger !== false, useLogger({
          logFn: (eventName, events) => {
            this.logger.debug(eventName);
            switch (eventName) {
              case "execute-start":
                const { query, variables, operationName } = events.args.contextValue;
                this.logger.debug(query, "query");
                this.logger.debug(operationName, "headers");
                this.logger.debug(variables, "variables");
                break;
              case "execute-end":
                this.logger.debug(events.result, "response");
                break;
            }
          }
        })),
        enableIf((options2 === null || options2 === void 0 ? void 0 : options2.context) != null, useExtendContext(async (initialContext) => {
          if (options2 === null || options2 === void 0 ? void 0 : options2.context) {
            if (typeof options2.context === "function") {
              return options2.context(initialContext);
            } else {
              return options2.context;
            }
          }
        })),
        ...(_k = options2 === null || options2 === void 0 ? void 0 : options2.plugins) !== null && _k !== void 0 ? _k : [],
        enableIf(!!maskedErrors, useMaskedErrors(typeof maskedErrors === "object" ? maskedErrors : void 0))
      ]
    });
    if ((options2 === null || options2 === void 0 ? void 0 : options2.cors) != null) {
      if (typeof options2.cors === "function") {
        this.corsOptionsFactory = options2.cors;
      } else if (typeof options2.cors === "object") {
        const corsOptions = {
          ...options2.cors
        };
        this.corsOptionsFactory = () => corsOptions;
      }
    }
    if (typeof (options2 === null || options2 === void 0 ? void 0 : options2.graphiql) === "function") {
      this.graphiqlOptionsFactory = options2.graphiql;
    } else if (typeof (options2 === null || options2 === void 0 ? void 0 : options2.graphiql) === "object") {
      this.graphiqlOptionsFactory = () => options2.graphiql;
    } else if ((options2 === null || options2 === void 0 ? void 0 : options2.graphiql) === false) {
      this.graphiqlOptionsFactory = () => false;
    } else {
      this.graphiqlOptionsFactory = () => ({});
    }
    this.renderGraphiQL = (options2 === null || options2 === void 0 ? void 0 : options2.renderGraphiQL) || renderGraphiQL;
    this.endpoint = options2 === null || options2 === void 0 ? void 0 : options2.endpoint;
  }
  getCORSResponseHeaders(request3, ...args) {
    var _a3, _b, _c2;
    const corsOptions = this.corsOptionsFactory(request3, ...args);
    const headers = {};
    const currentOrigin = request3.headers.get("origin");
    headers["Access-Control-Allow-Origin"] = "*";
    if (currentOrigin) {
      const credentialsAsked = request3.headers.get("cookies");
      if (credentialsAsked) {
        headers["Access-Control-Allow-Origin"] = currentOrigin;
      }
    }
    if (currentOrigin != null && ((_a3 = corsOptions.origin) === null || _a3 === void 0 ? void 0 : _a3.length) && !corsOptions.origin.includes(currentOrigin) && !corsOptions.origin.includes("*")) {
      headers["Access-Control-Allow-Origin"] = "null";
    }
    if (headers["Access-Control-Allow-Origin"] !== "*") {
      headers["Vary"] = "Origin";
    }
    if ((_b = corsOptions.methods) === null || _b === void 0 ? void 0 : _b.length) {
      headers["Access-Control-Allow-Methods"] = corsOptions.methods.join(", ");
    } else {
      const requestMethod = request3.headers.get("access-control-request-method");
      if (requestMethod) {
        headers["Access-Control-Allow-Methods"] = requestMethod;
      }
    }
    if ((_c2 = corsOptions.allowedHeaders) === null || _c2 === void 0 ? void 0 : _c2.length) {
      headers["Access-Control-Allow-Headers"] = corsOptions.allowedHeaders.join(", ");
    } else {
      const requestHeaders = request3.headers.get("access-control-request-headers");
      if (requestHeaders) {
        headers["Access-Control-Allow-Headers"] = requestHeaders;
        if (headers["Vary"]) {
          headers["Vary"] += ", Access-Control-Request-Headers";
        }
        headers["Vary"] = "Access-Control-Request-Headers";
      }
    }
    if (corsOptions.credentials != null) {
      if (corsOptions.credentials === true) {
        headers["Access-Control-Allow-Credentials"] = "true";
      }
    } else if (headers["Access-Control-Allow-Origin"] !== "*") {
      headers["Access-Control-Allow-Credentials"] = "true";
    }
    if (corsOptions.exposedHeaders) {
      headers["Access-Control-Expose-Headers"] = corsOptions.exposedHeaders.join(", ");
    }
    if (corsOptions.maxAge) {
      headers["Access-Control-Max-Age"] = corsOptions.maxAge.toString();
    }
    headers["Server"] = "GraphQL Yoga";
    return headers;
  }
  handleOptions(request3, ...args) {
    const headers = this.getCORSResponseHeaders(request3, ...args);
    const optionsResponse = new this.fetchAPI.Response(null, {
      status: 204,
      headers
    });
    return optionsResponse;
  }
  async inject({ document, variables, operationName, headers, serverContext }) {
    const request3 = new this.fetchAPI.Request("http://localhost/graphql", {
      method: "POST",
      headers,
      body: JSON.stringify({
        query: document && (typeof document === "string" ? document : (0, import_graphql7.print)(document)),
        variables,
        operationName
      })
    });
    const response = await this.handleRequest(request3, serverContext);
    let executionResult = null;
    if (response.headers.get("content-type") === "application/json") {
      executionResult = await response.json();
    }
    return {
      response,
      executionResult
    };
  }
  start() {
    self.addEventListener("fetch", this.fetchEventListener);
  }
  stop() {
    self.removeEventListener("fetch", this.fetchEventListener);
  }
};
function createServer(options2) {
  const server = new YogaServer(options2);
  const fnHandler = (input) => {
    if (input.request) {
      return server.handleRequest(input.request, input);
    } else {
      return server.handleRequest(input, void 0);
    }
  };
  return new Proxy(fnHandler, {
    get: (_, prop) => {
      if (server[prop]) {
        if (server[prop].bind) {
          return server[prop].bind(server);
        }
        return server[prop];
      } else if (fnHandler[prop]) {
        if (fnHandler[prop].bind) {
          return fnHandler[prop].bind(fnHandler);
        }
        return fnHandler[prop];
      }
    },
    apply(_, __, [input]) {
      return fnHandler(input);
    }
  });
}

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/builder.js
var import_graphql10 = __toESM(require_graphql2(), 1);

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/build-cache.js
var import_graphql8 = __toESM(require_graphql2(), 1);

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/utils/context-cache.js
var contextCacheSymbol = Symbol.for("Pothos.contextCache");
function createContextCache(create) {
  const cache2 = /* @__PURE__ */ new WeakMap();
  return (context, ...args) => {
    const cacheKey2 = context[contextCacheSymbol] || context;
    if (cache2.has(cacheKey2)) {
      return cache2.get(cacheKey2);
    }
    const entry = create(context, ...args);
    cache2.set(cacheKey2, entry);
    return entry;
  };
}

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/plugins/plugin.js
var runCache = /* @__PURE__ */ new WeakMap();
var BasePlugin = class {
  onTypeConfig(typeConfig) {
    return typeConfig;
  }
  onOutputFieldConfig(fieldConfig) {
    return fieldConfig;
  }
  onInputFieldConfig(fieldConfig) {
    return fieldConfig;
  }
  onEnumValueConfig(valueConfig) {
    return valueConfig;
  }
  beforeBuild() {
  }
  afterBuild(schema) {
    return schema;
  }
  wrapResolve(resolver, fieldConfig) {
    return resolver;
  }
  wrapSubscribe(subscribe2, fieldConfig) {
    return subscribe2;
  }
  wrapResolveType(resolveType, typeConfig) {
    return resolveType;
  }
  wrapIsTypeOf(isTypeOf, typeConfig) {
    return isTypeOf;
  }
  runUnique(key, cb) {
    if (!runCache.has(this.builder)) {
      runCache.set(this.builder, /* @__PURE__ */ new Map());
    }
    if (!runCache.get(this.builder).has(key)) {
      const result = cb();
      runCache.get(this.builder).set(key, result);
      return result;
    }
    return runCache.get(this.builder).get(key);
  }
  createRequestData(context) {
    throw new Error("createRequestData not implemented");
  }
  requestData(context) {
    return this.requestDataMap(context);
  }
  constructor(buildCache, name) {
    this.requestDataMap = createContextCache((ctx) => this.createRequestData(ctx));
    this.name = name;
    this.builder = buildCache.builder;
    this.buildCache = buildCache;
    this.options = buildCache.options;
  }
};

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/plugins/merge-plugins.js
var MergedPlugins = class extends BasePlugin {
  onTypeConfig(typeConfig) {
    return this.plugins.reduceRight((config2, plugin) => config2 === null ? config2 : plugin.onTypeConfig(config2), typeConfig);
  }
  onInputFieldConfig(fieldConfig) {
    return this.plugins.reduceRight((config2, plugin) => config2 === null ? config2 : plugin.onInputFieldConfig(config2), fieldConfig);
  }
  onOutputFieldConfig(fieldConfig) {
    return this.plugins.reduceRight((config2, plugin) => config2 === null ? config2 : plugin.onOutputFieldConfig(config2), fieldConfig);
  }
  onEnumValueConfig(valueConfig) {
    return this.plugins.reduceRight((config2, plugin) => config2 === null ? config2 : plugin.onEnumValueConfig(config2), valueConfig);
  }
  beforeBuild() {
    for (const plugin of this.plugins) {
      plugin.beforeBuild();
    }
  }
  afterBuild(schema) {
    return this.plugins.reduceRight((nextSchema, plugin) => plugin.afterBuild(nextSchema), schema);
  }
  wrapResolve(resolve2, fieldConfig) {
    return this.plugins.reduceRight((nextResolve, plugin) => plugin.wrapResolve(nextResolve, fieldConfig), resolve2);
  }
  wrapSubscribe(subscribe2, fieldConfig) {
    return this.plugins.reduceRight((nextSubscribe, plugin) => plugin.wrapSubscribe(nextSubscribe, fieldConfig), subscribe2);
  }
  wrapResolveType(resolveType, typeConfig) {
    return this.plugins.reduceRight((nextResolveType, plugin) => plugin.wrapResolveType(nextResolveType, typeConfig), resolveType);
  }
  wrapIsTypeOf(isTypeOf, typeConfig) {
    return this.plugins.reduceRight((nextResolveType, plugin) => plugin.wrapIsTypeOf(nextResolveType, typeConfig), isTypeOf);
  }
  constructor(buildCache, plugins) {
    super(buildCache, "PothosMergedPlugin");
    this.plugins = plugins;
  }
};

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/types/type-params.js
var outputShapeKey = Symbol.for("Pothos.outputShapeKey");
var parentShapeKey = Symbol.for("Pothos.parentShapeKey");
var abstractReturnShapeKey = Symbol.for("Pothos.abstractReturnShapeKey");
var inputShapeKey = Symbol.for("Pothos.inputShapeKey");
var inputFieldShapeKey = Symbol.for("Pothos.inputFieldShapeKey");
var outputFieldShapeKey = Symbol.for("Pothos.outputFieldShapeKey");
var typeBrandKey = Symbol.for("Pothos.typeBrandKey");

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/refs/base.js
var BaseTypeRef = class {
  toString() {
    return `${this.kind}Ref<${this.name}>`;
  }
  constructor(kind, name) {
    this.kind = kind;
    this.name = name;
  }
};

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/refs/scalar.js
var ScalarRef = class extends BaseTypeRef {
  constructor(name) {
    super("Scalar", name);
    this.kind = "Scalar";
  }
};

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/refs/builtin-scalar.js
var BuiltinScalarRef = class extends ScalarRef {
  constructor(type) {
    super(type.name);
    this.type = type;
  }
};

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/utils/enums.js
function normalizeEnumValues(values) {
  const result = {};
  if (Array.isArray(values)) {
    values.forEach((key) => {
      result[String(key)] = {
        pothosOptions: {}
      };
    });
  } else {
    Object.entries(values).forEach(([key, value]) => {
      if (value && typeof value === "object") {
        result[key] = {
          ...value,
          pothosOptions: value
        };
      } else if (typeof value === "string") {
        result[value] = {
          pothosOptions: {}
        };
      }
    });
  }
  return result;
}
function valuesFromEnum(Enum) {
  const result = {};
  Object.keys(Enum).filter((key) => typeof Enum[Enum[key]] !== "number").forEach((key) => {
    result[key] = {
      value: Enum[key],
      pothosOptions: {}
    };
  });
  return result;
}

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/utils/params.js
function typeFromNonListParam(type, configStore, nullable) {
  const ref = configStore.getOutputTypeRef(type);
  const kind = ref instanceof BaseTypeRef ? ref.kind : configStore.getTypeConfig(ref).graphqlKind;
  const name = ref instanceof BaseTypeRef ? ref.name : configStore.getTypeConfig(ref).name;
  if (kind !== "InputObject") {
    return {
      kind,
      ref,
      nullable
    };
  }
  throw new Error(`Expected input param ${name} to be an InputObject, Enum, or Scalar but got ${kind}`);
}
function typeFromParam(param, configStore, nullable) {
  const itemNullable = typeof nullable === "object" ? nullable.items : false;
  const listNullable = typeof nullable === "object" ? nullable.list : !!nullable;
  if (Array.isArray(param)) {
    return {
      kind: "List",
      type: typeFromNonListParam(param[0], configStore, itemNullable),
      nullable: listNullable
    };
  }
  return typeFromNonListParam(param, configStore, listNullable);
}
function inputTypeFromNonListParam(type, configStore, required) {
  const ref = configStore.getInputTypeRef(type);
  const kind = ref instanceof BaseTypeRef ? ref.kind : configStore.getTypeConfig(ref).graphqlKind;
  const name = ref instanceof BaseTypeRef ? ref.name : configStore.getTypeConfig(ref).name;
  if (kind === "InputObject" || kind === "Enum" || kind === "Scalar") {
    return {
      kind,
      ref,
      required
    };
  }
  throw new Error(`Expected input param ${name} to be an InputObject, Enum, or Scalar but got ${kind}`);
}
function inputTypeFromParam(param, configStore, required) {
  const itemRequired = typeof required === "object" ? required.items : true;
  const listRequired = typeof required === "object" ? required.list : !!required;
  if (Array.isArray(param)) {
    return {
      kind: "List",
      type: inputTypeFromNonListParam(param[0], configStore, itemRequired),
      required: listRequired
    };
  }
  return inputTypeFromNonListParam(param, configStore, listRequired);
}

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/utils/index.js
function assertNever(value) {
  throw new TypeError(`Unexpected value: ${value}`);
}
function isThenable(value) {
  return !!(value && (typeof value === "object" || typeof value === "function") && typeof value.then === "function");
}
function verifyRef(ref) {
  if (ref === void 0) {
    throw new Error(`Received undefined as a type ref.
        
This is often caused by a circular import
If this ref is imported from a file that re-exports it (like index.ts)
you may be able to resolve this by importing it directly from the file that defines it.
`);
  }
}
function verifyInterfaces(interfaces) {
  if (!interfaces || typeof interfaces === "function") {
    return;
  }
  if (!Array.isArray(interfaces)) {
    throw new TypeError("interfaces must be an array or function");
  }
  for (const iface of interfaces) {
    if (iface === void 0) {
      throw new Error(`Received undefined in list of interfaces.
        
This is often caused by a circular import
If this ref is imported from a file that re-exports it (like index.ts)
you may be able to resolve this by importing it directly from the file that defines it.

Alternatively you can define interfaces with a function that will be lazily evaluated,
which may resolver issues with circular dependencies:

Example:
builder.objectType('MyObject', {
  interface: () => [Interface1, Interface2],
  ...
});
`);
    }
  }
}
function brandWithType(val, type) {
  if (typeof val !== "object" || val === null) {
    return;
  }
  Object.defineProperty(val, typeBrandKey, {
    enumerable: false,
    value: type
  });
}
function getTypeBrand(val) {
  if (typeof val === "object" && val !== null && typeBrandKey in val) {
    return val[typeBrandKey];
  }
  return null;
}

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/build-cache.js
var BuildCache = class {
  getTypeConfig(ref, kind) {
    const baseConfig = this.configStore.getTypeConfig(ref, kind);
    if (!this.typeConfigs.has(baseConfig.name)) {
      this.typeConfigs.set(baseConfig.name, this.plugin.onTypeConfig(baseConfig));
    }
    const typeConfig = this.typeConfigs.get(baseConfig.name);
    return typeConfig;
  }
  getInputTypeFieldConfigs(ref1) {
    const typeConfig = this.getTypeConfig(ref1, "InputObject");
    const builtType = this.types.get(typeConfig.name);
    if (!builtType) {
      throw new Error(`Input type ${typeConfig.name} has not been built yet`);
    }
    const fields = builtType.getFields();
    const fieldConfigs = {};
    Object.keys(fields).forEach((fieldName) => {
      var ref;
      fieldConfigs[fieldName] = (ref = fields[fieldName].extensions) === null || ref === void 0 ? void 0 : ref.pothosConfig;
    });
    return fieldConfigs;
  }
  getImplementers(iface) {
    if (this.implementers.has(iface.name)) {
      return this.implementers.get(iface.name);
    }
    const implementers = [
      ...this.configStore.typeConfigs.values()
    ].filter((type) => type.kind === "Object" && type.interfaces.find((i) => this.configStore.getTypeConfig(i).name === iface.name));
    this.implementers.set(iface.name, implementers);
    return implementers;
  }
  buildAll() {
    this.configStore.prepareForBuild();
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "Enum" || baseConfig.kind === "Scalar") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "InputObject") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.types.forEach((type) => {
      if (type instanceof import_graphql8.GraphQLInputObjectType) {
        type.getFields();
      }
    });
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "Interface") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "Object") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "Union") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "Query" || baseConfig.kind === "Mutation" || baseConfig.kind === "Subscription") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.types.forEach((type) => {
      if (type instanceof import_graphql8.GraphQLObjectType || type instanceof import_graphql8.GraphQLInterfaceType) {
        type.getFields();
      } else if (type instanceof import_graphql8.GraphQLUnionType) {
        type.getTypes();
      }
    });
  }
  buildTypeFromConfig(baseConfig) {
    const config2 = this.getTypeConfig(baseConfig.name);
    const { name } = config2;
    this.typeConfigs.set(name, config2);
    switch (config2.kind) {
      case "Enum":
        this.addType(name, this.buildEnum(config2));
        break;
      case "InputObject":
        this.addType(name, this.buildInputObject(config2));
        break;
      case "Interface":
        this.addType(name, this.buildInterface(config2));
        break;
      case "Scalar":
        this.addType(name, this.buildScalar(config2));
        break;
      case "Union":
        this.addType(name, this.buildUnion(config2));
        break;
      case "Object":
      case "Query":
      case "Mutation":
      case "Subscription":
        this.addType(name, this.buildObject(config2));
        break;
      default:
        assertNever(config2);
    }
  }
  addType(ref, type) {
    if (this.types.has(ref)) {
      throw new Error(`reference or name has already been used to create another type (${type.name})`);
    }
    this.types.set(ref, type);
  }
  buildOutputTypeParam(type) {
    if (type.kind === "List") {
      if (type.nullable) {
        return new import_graphql8.GraphQLList(this.buildOutputTypeParam(type.type));
      }
      return new import_graphql8.GraphQLNonNull(new import_graphql8.GraphQLList(this.buildOutputTypeParam(type.type)));
    }
    if (type.nullable) {
      return this.getOutputType(type.ref);
    }
    return new import_graphql8.GraphQLNonNull(this.getOutputType(type.ref));
  }
  buildInputTypeParam(type) {
    if (type.kind === "List") {
      if (type.required) {
        return new import_graphql8.GraphQLNonNull(new import_graphql8.GraphQLList(this.buildInputTypeParam(type.type)));
      }
      return new import_graphql8.GraphQLList(this.buildInputTypeParam(type.type));
    }
    if (type.required) {
      return new import_graphql8.GraphQLNonNull(this.getInputType(type.ref));
    }
    return this.getInputType(type.ref);
  }
  buildFields(fields) {
    const built = {};
    for (const [fieldName, originalConfig] of fields) {
      if (!this.outputFieldConfigs.has(originalConfig)) {
        this.outputFieldConfigs.set(originalConfig, this.plugin.onOutputFieldConfig(originalConfig));
      }
      const updatedConfig = this.outputFieldConfigs.get(originalConfig);
      if (!updatedConfig) {
        continue;
      }
      const config2 = {
        ...updatedConfig
      };
      const argMap = /* @__PURE__ */ new Map();
      Object.keys(config2.args).forEach((argName) => {
        argMap.set(argName, config2.args[argName]);
      });
      const args = this.buildInputFields(argMap);
      const argConfigs = {};
      Object.keys(config2.args).forEach((argName) => {
        argConfigs[argName] = this.inputFieldConfigs.get(config2.args[argName]);
      });
      config2.args = argConfigs;
      var _resolve;
      const resolve2 = this.plugin.wrapResolve((_resolve = config2.resolve) !== null && _resolve !== void 0 ? _resolve : import_graphql8.defaultFieldResolver, config2);
      const subscribe2 = this.plugin.wrapSubscribe(config2.subscribe, config2);
      var _resolve1;
      built[fieldName] = {
        ...config2,
        type: this.buildOutputTypeParam(config2.type),
        args,
        extensions: {
          ...config2.extensions,
          pothosResolveWrapped: resolve2 !== ((_resolve1 = config2.resolve) !== null && _resolve1 !== void 0 ? _resolve1 : import_graphql8.defaultFieldResolver),
          pothosSubscribeWrapped: subscribe2 !== config2.subscribe,
          pothosOptions: config2.pothosOptions,
          pothosConfig: config2
        },
        resolve: resolve2 === import_graphql8.defaultFieldResolver ? void 0 : resolve2,
        subscribe: subscribe2
      };
    }
    return built;
  }
  buildInputFields(fields) {
    const built = {};
    for (const [fieldName, originalConfig] of fields) {
      if (!this.inputFieldConfigs.has(originalConfig)) {
        this.inputFieldConfigs.set(originalConfig, this.plugin.onInputFieldConfig(originalConfig));
      }
      const config2 = this.inputFieldConfigs.get(originalConfig);
      if (config2) {
        built[fieldName] = {
          ...config2,
          type: this.buildInputTypeParam(config2.type),
          extensions: {
            ...config2.extensions,
            pothosOptions: config2.pothosOptions,
            pothosConfig: config2
          }
        };
      }
    }
    return built;
  }
  getInterfaceFields(type) {
    const interfaceFields = type.getInterfaces().reduce((all, iface) => ({
      ...this.getFields(iface),
      ...all
    }), {});
    const configs = this.configStore.getFields(type.name, "Interface");
    const fields = this.buildFields(configs);
    return {
      ...interfaceFields,
      ...fields
    };
  }
  getObjectFields(type) {
    const interfaceFields = type.getInterfaces().reduce((all, iface) => ({
      ...this.getFields(iface),
      ...all
    }), {});
    const objectFields = this.buildFields(this.configStore.getFields(type.name, "Object"));
    return {
      ...interfaceFields,
      ...objectFields
    };
  }
  getRootFields(type) {
    return this.buildFields(this.configStore.getFields(type.name, "Object"));
  }
  getFields(type) {
    if (type instanceof import_graphql8.GraphQLObjectType) {
      if (type.name === "Query" || type.name === "Mutation" || type.name === "Subscription") {
        return this.getRootFields(type);
      }
      return this.getObjectFields(type);
    }
    if (type instanceof import_graphql8.GraphQLInterfaceType) {
      return this.getInterfaceFields(type);
    }
    throw new Error(`Type ${type.name} does not have fields to resolve`);
  }
  getInputFields(type) {
    return this.buildInputFields(this.configStore.getFields(type.name, "InputObject"));
  }
  getType(ref) {
    if (ref instanceof BuiltinScalarRef) {
      return ref.type;
    }
    const typeConfig = this.configStore.getTypeConfig(ref);
    const type = this.types.get(typeConfig.name);
    if (!type) {
      this.buildTypeFromConfig(typeConfig);
      return this.types.get(typeConfig.name);
    }
    return type;
  }
  getOutputType(ref) {
    const type = this.getType(ref);
    if (type instanceof import_graphql8.GraphQLInputObjectType) {
      throw new TypeError(`Expected ${String(ref)} to be an output type but it was defined as an InputObject`);
    }
    return type;
  }
  getInputType(ref) {
    const type = this.getType(ref);
    if (!type) {
      throw new TypeError(`Missing implementation of for type ${String(ref)}`);
    }
    if (type instanceof import_graphql8.GraphQLObjectType) {
      throw new TypeError(`Expected ${ImplementableInputObjectRef} to be an input type but it was defined as a GraphQLObjectType`);
    }
    if (type instanceof import_graphql8.GraphQLInterfaceType) {
      throw new TypeError(`Expected ${ImplementableInputObjectRef} to be an input type but it was defined as a GraphQLInterfaceType`);
    }
    if (type instanceof import_graphql8.GraphQLUnionType) {
      throw new TypeError(`Expected ${String(ref)} to be an input type but it was defined as an GraphQLUnionType`);
    }
    return type;
  }
  getTypeOfKind(ref, kind) {
    const type = this.getType(ref);
    switch (kind) {
      case "Object":
      case "Query":
      case "Mutation":
      case "Subscription":
        if (type instanceof import_graphql8.GraphQLObjectType) {
          return type;
        }
        break;
      case "Interface":
        if (type instanceof import_graphql8.GraphQLInterfaceType) {
          return type;
        }
        break;
      case "Union":
        if (type instanceof import_graphql8.GraphQLUnionType) {
          return type;
        }
        break;
      case "Enum":
        if (type instanceof import_graphql8.GraphQLEnumType) {
          return type;
        }
        break;
      case "Scalar":
        if (type instanceof import_graphql8.GraphQLScalarType) {
          return type;
        }
        break;
      case "InputObject":
        if (type instanceof import_graphql8.GraphQLScalarType) {
          return type;
        }
        break;
      default:
        break;
    }
    throw new Error(`Expected ${String(ref)} to be of type ${kind}`);
  }
  buildObject(config2) {
    var _isTypeOf;
    const type = new import_graphql8.GraphQLObjectType({
      ...config2,
      extensions: {
        ...config2.extensions,
        pothosOptions: config2.pothosOptions,
        pothosConfig: config2
      },
      fields: () => this.getFields(type),
      isTypeOf: config2.kind === "Object" ? this.plugin.wrapIsTypeOf((_isTypeOf = config2.isTypeOf) !== null && _isTypeOf !== void 0 ? _isTypeOf : void 0, config2) : void 0,
      interfaces: config2.kind === "Object" ? () => config2.interfaces.map((iface) => this.getTypeOfKind(iface, "Interface")) : void 0
    });
    return type;
  }
  buildInterface(config2) {
    const resolveType = (parent, context, info) => {
      const typeBrand = getTypeBrand(parent);
      if (typeBrand) {
        if (typeof typeBrand === "string") {
          return typeBrand;
        }
        return this.getTypeConfig(typeBrand).name;
      }
      var _resolveType;
      const resolver = (_resolveType = config2.resolveType) !== null && _resolveType !== void 0 ? _resolveType : import_graphql8.defaultTypeResolver;
      return resolver(parent, context, info, type);
    };
    const type = new import_graphql8.GraphQLInterfaceType({
      ...config2,
      extensions: {
        ...config2.extensions,
        pothosOptions: config2.pothosOptions,
        pothosConfig: config2
      },
      interfaces: () => config2.interfaces.map((iface) => this.getTypeOfKind(iface, "Interface")),
      fields: () => this.getFields(type),
      resolveType: this.plugin.wrapResolveType(resolveType, config2)
    });
    return type;
  }
  buildUnion(config2) {
    const resolveType = (parent, context, info, type) => {
      if (typeof parent === "object" && parent !== null && typeBrandKey in parent) {
        const typeBrand = parent[typeBrandKey];
        if (typeof typeBrand === "string") {
          return typeBrand;
        }
        return this.getTypeConfig(typeBrand).name;
      }
      if (!config2.resolveType) {
        return (0, import_graphql8.defaultTypeResolver)(parent, context, info, type);
      }
      const resultOrPromise = config2.resolveType(parent, context, info, type);
      const getResult = (result) => {
        if (typeof result === "string" || !result) {
          return result;
        }
        if (result instanceof import_graphql8.GraphQLObjectType) {
          return result.name;
        }
        try {
          const typeConfig = this.configStore.getTypeConfig(result);
          return typeConfig.name;
        } catch {
        }
        return result;
      };
      return isThenable(resultOrPromise) ? resultOrPromise.then(getResult) : getResult(resultOrPromise);
    };
    return new import_graphql8.GraphQLUnionType({
      ...config2,
      extensions: {
        ...config2.extensions,
        pothosOptions: config2.pothosOptions,
        pothosConfig: config2
      },
      types: () => config2.types.map((member) => this.getTypeOfKind(member, "Object")),
      resolveType: this.plugin.wrapResolveType(resolveType, config2)
    });
  }
  buildInputObject(config2) {
    const type = new import_graphql8.GraphQLInputObjectType({
      ...config2,
      extensions: {
        ...config2.extensions,
        pothosOptions: config2.pothosOptions,
        pothosConfig: config2
      },
      fields: () => this.getInputFields(type)
    });
    return type;
  }
  buildScalar(config2) {
    if (config2.name === "ID") {
      return import_graphql8.GraphQLID;
    }
    if (config2.name === "Int") {
      return import_graphql8.GraphQLInt;
    }
    if (config2.name === "Float") {
      return import_graphql8.GraphQLFloat;
    }
    if (config2.name === "Boolean") {
      return import_graphql8.GraphQLBoolean;
    }
    if (config2.name === "String") {
      return import_graphql8.GraphQLString;
    }
    return new import_graphql8.GraphQLScalarType({
      ...config2,
      extensions: {
        ...config2.extensions,
        pothosOptions: config2.pothosOptions,
        pothosConfig: config2
      }
    });
  }
  buildEnum(config2) {
    const values = {};
    for (const key of Object.keys(config2.values)) {
      const original = config2.values[key];
      if (!this.enumValueConfigs.has(original)) {
        this.enumValueConfigs.set(original, this.plugin.onEnumValueConfig(original));
      }
      const valueConfig = this.enumValueConfigs.get(original);
      if (valueConfig) {
        values[key] = this.enumValueConfigs.get(original);
      }
    }
    return new import_graphql8.GraphQLEnumType({
      ...config2,
      values,
      extensions: {
        ...config2.extensions,
        pothosOptions: config2.pothosOptions,
        pothosConfig: config2
      }
    });
  }
  constructor(builder2, options2) {
    this.types = /* @__PURE__ */ new Map();
    this.implementers = /* @__PURE__ */ new Map();
    this.typeConfigs = /* @__PURE__ */ new Map();
    this.enumValueConfigs = /* @__PURE__ */ new Map();
    this.outputFieldConfigs = /* @__PURE__ */ new Map();
    this.inputFieldConfigs = /* @__PURE__ */ new Map();
    this.builder = builder2;
    this.configStore = builder2.configStore;
    this.options = options2;
    const plugins = {};
    var _plugins;
    this.pluginList = ((_plugins = builder2.options.plugins) !== null && _plugins !== void 0 ? _plugins : []).map((pluginName2) => {
      const Plugin = SchemaBuilder.plugins[pluginName2];
      if (!Plugin) {
        throw new Error(`No plugin named ${pluginName2} was registered`);
      }
      plugins[pluginName2] = new Plugin(this, pluginName2);
      return plugins[pluginName2];
    });
    this.pluginMap = plugins;
    this.plugin = new MergedPlugins(this, this.pluginList);
  }
};

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/config-store.js
var import_graphql9 = __toESM(require_graphql2(), 1);
var ConfigStore = class {
  hasConfig(typeParam) {
    if (typeof typeParam === "string") {
      return this.typeConfigs.has(typeParam);
    }
    return this.refsToName.has(typeParam);
  }
  addInterfaces(typeName, interfaces) {
    if (typeof interfaces === "function" && this.pending) {
      if (!this.pendingInterfaces.has(typeName)) {
        this.pendingInterfaces.set(typeName, [
          interfaces
        ]);
      } else {
        this.pendingInterfaces.get(typeName).push(interfaces);
      }
    } else {
      const typeConfig = this.getTypeConfig(typeName);
      if (typeConfig.graphqlKind !== "Object" && typeConfig.graphqlKind !== "Interface" || typeConfig.kind === "Query" || typeConfig.kind === "Mutation" || typeConfig.kind === "Subscription") {
        throw new Error(`Can not add interfaces to ${typeName} because it is a ${typeConfig.kind}`);
      }
      typeConfig.interfaces = [
        ...typeConfig.interfaces,
        ...typeof interfaces === "function" ? interfaces() : interfaces
      ];
    }
  }
  addFieldRef(ref, typeParam, args, getConfig) {
    if (this.fieldRefs.has(ref)) {
      throw new Error(`FieldRef ${String(ref)} has already been added to config store`);
    }
    const typeRefOrName = Array.isArray(typeParam) ? typeParam[0] : typeParam;
    const argRefs = Object.keys(args).map((argName) => {
      const argRef = args[argName];
      argRef.fieldName = argName;
      argRef.argFor = ref;
      return argRef;
    });
    const checkArgs = () => {
      for (const arg of argRefs) {
        if (this.pendingFields.has(arg)) {
          const unresolvedArgType = this.pendingFields.get(arg);
          this.pendingFields.set(ref, unresolvedArgType);
          this.onTypeConfig(unresolvedArgType, checkArgs);
          return;
        }
      }
      this.pendingFields.delete(ref);
      this.fieldRefs.set(ref, getConfig);
    };
    if (this.hasConfig(typeRefOrName) || typeRefOrName instanceof BaseTypeRef2 || this.scalarsToRefs.has(typeRefOrName)) {
      checkArgs();
    } else {
      this.pendingFields.set(ref, typeRefOrName);
      this.onTypeConfig(typeRefOrName, () => {
        checkArgs();
      });
    }
  }
  createFieldConfig(ref, name, typeConfig, parentField, kind) {
    if (!this.fieldRefs.has(ref)) {
      if (this.pendingFields.has(ref)) {
        throw new Error(`Missing implementation for ${this.describeRef(this.pendingFields.get(ref))}`);
      }
      throw new Error(`Missing definition for for ${String(ref)}`);
    }
    const config2 = this.fieldRefs.get(ref)(name, parentField, typeConfig);
    if (kind && config2.graphqlKind !== kind) {
      throw new TypeError(`Expected ref for field named ${name} to resolve to a ${kind} type, but got ${config2.graphqlKind}`);
    }
    return config2;
  }
  associateRefWithName(ref, name) {
    if (!this.typeConfigs.has(name)) {
      throw new Error(`${name} has not been implemented yet`);
    }
    this.refsToName.set(ref, name);
    if (this.pendingRefResolutions.has(ref)) {
      const cbs = this.pendingRefResolutions.get(ref);
      this.pendingRefResolutions.delete(ref);
      cbs.forEach((cb) => void cb(this.typeConfigs.get(name)));
    }
  }
  addTypeConfig(config2, ref) {
    const { name } = config2;
    if (this.typeConfigs.has(name)) {
      throw new Error(`Duplicate typename: Another type with name ${name} already exists.`);
    }
    this.typeConfigs.set(config2.name, config2);
    if (ref) {
      this.associateRefWithName(ref, name);
    }
    if (this.pendingRefResolutions.has(name)) {
      const cbs = this.pendingRefResolutions.get(name);
      this.pendingRefResolutions.delete(name);
      cbs.forEach((cb) => void cb(config2));
    }
  }
  getTypeConfig(ref, kind) {
    let config2;
    if (typeof ref === "string") {
      if (!this.typeConfigs.has(ref)) {
        throw new Error(`Type ${String(ref)} has not been implemented`);
      }
      config2 = this.typeConfigs.get(ref);
    } else if (this.refsToName.has(ref)) {
      config2 = this.typeConfigs.get(this.refsToName.get(ref));
    } else {
      throw new Error(`Ref ${String(ref)} has not been implemented`);
    }
    if (kind && config2.graphqlKind !== kind) {
      throw new TypeError(`Expected ref to resolve to a ${kind} type, but got ${config2.kind}`);
    }
    return config2;
  }
  getInputTypeRef(ref) {
    if (ref instanceof BaseTypeRef2) {
      if (ref.kind !== "InputObject" && ref.kind !== "Enum" && ref.kind !== "Scalar") {
        throw new TypeError(`Expected ${ref.name} to be an input type but got ${ref.kind}`);
      }
      return ref;
    }
    if (typeof ref === "string") {
      if (this.scalarsToRefs.has(ref)) {
        return this.scalarsToRefs.get(ref);
      }
      if (this.typeConfigs.has(ref)) {
        const config2 = this.typeConfigs.get(ref);
        if (config2.graphqlKind !== "InputObject" && config2.graphqlKind !== "Enum" && config2.graphqlKind !== "Scalar") {
          throw new TypeError(`Expected ${config2.name} to be an input type but got ${config2.graphqlKind}`);
        }
        const newRef = new InputTypeRef(config2.graphqlKind, config2.name);
        this.refsToName.set(newRef, config2.name);
        return newRef;
      }
    }
    return ref;
  }
  getOutputTypeRef(ref) {
    if (ref instanceof BaseTypeRef2) {
      if (ref.kind === "InputObject") {
        throw new TypeError(`Expected ${ref.name} to be an output type but got ${ref.name}`);
      }
      return ref;
    }
    if (typeof ref === "string") {
      if (this.scalarsToRefs.has(ref)) {
        return this.scalarsToRefs.get(ref);
      }
      if (this.typeConfigs.has(ref)) {
        const config2 = this.typeConfigs.get(ref);
        if (config2.graphqlKind === "InputObject") {
          throw new TypeError(`Expected ${config2.name} to be an output type but got ${config2.graphqlKind}`);
        }
        const newRef = new OutputTypeRef(config2.graphqlKind, config2.name);
        this.refsToName.set(newRef, config2.name);
        return newRef;
      }
    }
    return ref;
  }
  onTypeConfig(ref, cb) {
    if (!ref) {
      throw new Error(`${ref} is not a valid type ref`);
    }
    if (this.refsToName.has(ref)) {
      cb(this.getTypeConfig(ref));
    } else if (typeof ref === "string" && this.typeConfigs.has(ref)) {
      cb(this.typeConfigs.get(ref));
    } else if (!this.pending) {
      throw new Error(`Ref ${String(ref)} has not been implemented`);
    } else if (this.pendingRefResolutions.has(ref)) {
      this.pendingRefResolutions.get(ref).push(cb);
    } else {
      this.pendingRefResolutions.set(ref, [
        cb
      ]);
    }
  }
  onFieldUse(ref, cb) {
    if (!this.fieldRefCallbacks.has(ref)) {
      this.fieldRefCallbacks.set(ref, []);
    }
    this.fieldRefCallbacks.get(ref).push(cb);
    if (this.fieldRefsToConfigs.has(ref)) {
      this.fieldRefsToConfigs.get(ref).forEach((config2) => void cb(config2));
    }
  }
  getFields(name, kind) {
    const typeConfig = this.getTypeConfig(name);
    if (!this.fields.has(name)) {
      this.fields.set(name, /* @__PURE__ */ new Map());
    }
    const fields = this.fields.get(name);
    if (kind && typeConfig.graphqlKind !== kind) {
      throw new TypeError(`Expected ${name} to be a ${kind} type, but found ${typeConfig.graphqlKind}`);
    }
    return fields;
  }
  prepareForBuild() {
    this.pending = false;
    const fns = this.addFieldFns;
    this.addFieldFns = [];
    fns.forEach((fn2) => void fn2());
    if (this.pendingRefResolutions.size > 0) {
      throw new Error(`Missing implementations for some references (${[
        ...this.pendingRefResolutions.keys()
      ].map((ref) => this.describeRef(ref)).join(", ")}).`);
    }
    for (const [typeName, interfacesFns] of this.pendingInterfaces) {
      for (const fn2 of interfacesFns) {
        this.addInterfaces(typeName, fn2);
      }
    }
  }
  addFields(typeRef, fields) {
    if (this.pending) {
      this.addFieldFns.push(() => void this.addFields(typeRef, fields));
    } else {
      this.onTypeConfig(typeRef, (config2) => {
        this.buildFields(typeRef, typeof fields === "function" ? fields() : fields);
      });
    }
  }
  getImplementers(ref) {
    const typeConfig = this.getTypeConfig(ref, "Interface");
    const implementers = [
      ...this.typeConfigs.values()
    ].filter((type) => type.kind === "Object" && type.interfaces.find((i) => this.getTypeConfig(i).name === typeConfig.name));
    return implementers;
  }
  describeRef(ref) {
    var ref1;
    if (typeof ref === "string") {
      return ref;
    }
    if (ref.toString !== {}.toString) {
      return String(ref);
    }
    const usedBy = (ref1 = [
      ...this.pendingFields.entries()
    ].find(([fieldRef, typeRef]) => typeRef === ref)) === null || ref1 === void 0 ? void 0 : ref1[0];
    if (usedBy) {
      return `<unnamed ref or enum: used by ${usedBy}>`;
    }
    return `<unnamed ref or enum>`;
  }
  buildFields(typeRef, fields) {
    Object.keys(fields).forEach((fieldName) => {
      const fieldRef = fields[fieldName];
      fieldRef.fieldName = fieldName;
      if (this.pendingFields.has(fieldRef)) {
        this.onTypeConfig(this.pendingFields.get(fieldRef), () => {
          this.buildField(typeRef, fieldRef, fieldName);
        });
      } else {
        this.buildField(typeRef, fieldRef, fieldName);
      }
    });
  }
  buildField(typeRef, field, fieldName) {
    const typeConfig = this.getTypeConfig(typeRef);
    const fieldConfig = this.createFieldConfig(field, fieldName, typeConfig);
    const existingFields = this.getFields(typeConfig.name);
    if (existingFields.has(fieldName)) {
      throw new Error(`Duplicate field definition for field ${fieldName} in ${typeConfig.name}`);
    }
    if (fieldConfig.graphqlKind !== typeConfig.graphqlKind) {
      throw new TypeError(`${typeConfig.name}.${fieldName} was defined as a ${fieldConfig.graphqlKind} field but ${typeConfig.name} is a ${typeConfig.graphqlKind}`);
    }
    existingFields.set(fieldName, fieldConfig);
    if (!this.fieldRefsToConfigs.has(field)) {
      this.fieldRefsToConfigs.set(field, []);
    }
    this.fieldRefsToConfigs.get(field).push(fieldConfig);
    if (this.fieldRefCallbacks.has(field)) {
      this.fieldRefCallbacks.get(field).forEach((cb) => void cb(fieldConfig));
    }
  }
  constructor() {
    this.typeConfigs = /* @__PURE__ */ new Map();
    this.fieldRefs = /* @__PURE__ */ new WeakMap();
    this.fields = /* @__PURE__ */ new Map();
    this.addFieldFns = [];
    this.refsToName = /* @__PURE__ */ new Map();
    this.scalarsToRefs = /* @__PURE__ */ new Map();
    this.fieldRefsToConfigs = /* @__PURE__ */ new Map();
    this.pendingFields = /* @__PURE__ */ new Map();
    this.pendingInterfaces = /* @__PURE__ */ new Map();
    this.pendingRefResolutions = /* @__PURE__ */ new Map();
    this.fieldRefCallbacks = /* @__PURE__ */ new Map();
    this.pending = true;
    const scalars = [
      import_graphql9.GraphQLID,
      import_graphql9.GraphQLInt,
      import_graphql9.GraphQLFloat,
      import_graphql9.GraphQLString,
      import_graphql9.GraphQLBoolean
    ];
    scalars.forEach((scalar) => {
      const ref = new BuiltinScalarRef(scalar);
      this.scalarsToRefs.set(scalar.name, ref);
      this.refsToName.set(ref, scalar.name);
    });
  }
};

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/builder.js
var SchemaBuilder = class {
  static registerPlugin(name, plugin) {
    if (!this.allowPluginReRegistration && this.plugins[name]) {
      throw new Error(`Received multiple implementations for plugin ${name}`);
    }
    this.plugins[name] = plugin;
  }
  objectType(param, options2, fields) {
    verifyRef(param);
    verifyInterfaces(options2.interfaces);
    var _name;
    const name = typeof param === "string" ? param : (_name = options2.name) !== null && _name !== void 0 ? _name : param.name;
    if (name === "Query" || name === "Mutation" || name === "Subscription") {
      throw new Error(`Invalid object name ${name} use .create${name}Type() instead`);
    }
    const ref = param instanceof BaseTypeRef2 ? param : new ObjectRef(name);
    const config2 = {
      kind: "Object",
      graphqlKind: "Object",
      name,
      interfaces: [],
      description: options2.description,
      extensions: options2.extensions,
      isTypeOf: options2.isTypeOf,
      pothosOptions: options2
    };
    this.configStore.addTypeConfig(config2, ref);
    if (options2.interfaces) {
      this.configStore.addInterfaces(name, options2.interfaces);
    }
    if (typeof param === "function") {
      this.configStore.associateRefWithName(param, name);
    }
    if (fields) {
      this.configStore.addFields(ref, () => fields(new ObjectFieldBuilder(name, this)));
    }
    if (options2.fields) {
      this.configStore.addFields(ref, () => {
        const t = new ObjectFieldBuilder(name, this);
        return options2.fields(t);
      });
    }
    return ref;
  }
  objectFields(ref, fields) {
    verifyRef(ref);
    this.configStore.onTypeConfig(ref, ({ name }) => {
      this.configStore.addFields(ref, () => fields(new ObjectFieldBuilder(name, this)));
    });
  }
  objectField(ref, fieldName, field) {
    verifyRef(ref);
    this.configStore.onTypeConfig(ref, ({ name }) => {
      this.configStore.addFields(ref, () => ({
        [fieldName]: field(new ObjectFieldBuilder(name, this))
      }));
    });
  }
  queryType(options2, fields) {
    const config2 = {
      kind: "Query",
      graphqlKind: "Object",
      name: "Query",
      description: options2.description,
      pothosOptions: options2,
      extensions: options2.extensions
    };
    this.configStore.addTypeConfig(config2);
    if (fields) {
      this.configStore.addFields("Query", () => fields(new QueryFieldBuilder(this)));
    }
    if (options2.fields) {
      this.configStore.addFields("Query", () => options2.fields(new QueryFieldBuilder(this)));
    }
  }
  queryFields(fields) {
    this.configStore.addFields("Query", () => fields(new QueryFieldBuilder(this)));
  }
  queryField(name, field) {
    this.configStore.addFields("Query", () => ({
      [name]: field(new QueryFieldBuilder(this))
    }));
  }
  mutationType(options2, fields) {
    const config2 = {
      kind: "Mutation",
      graphqlKind: "Object",
      name: "Mutation",
      description: options2.description,
      pothosOptions: options2,
      extensions: options2.extensions
    };
    this.configStore.addTypeConfig(config2);
    if (fields) {
      this.configStore.addFields("Mutation", () => fields(new MutationFieldBuilder(this)));
    }
    if (options2.fields) {
      this.configStore.addFields("Mutation", () => options2.fields(new MutationFieldBuilder(this)));
    }
  }
  mutationFields(fields) {
    this.configStore.addFields("Mutation", () => fields(new MutationFieldBuilder(this)));
  }
  mutationField(name, field) {
    this.configStore.addFields("Mutation", () => ({
      [name]: field(new MutationFieldBuilder(this))
    }));
  }
  subscriptionType(options2, fields) {
    const config2 = {
      kind: "Subscription",
      graphqlKind: "Object",
      name: "Subscription",
      description: options2.description,
      pothosOptions: options2,
      extensions: options2.extensions
    };
    this.configStore.addTypeConfig(config2);
    if (fields) {
      this.configStore.addFields("Subscription", () => fields(new SubscriptionFieldBuilder(this)));
    }
    if (options2.fields) {
      this.configStore.addFields("Subscription", () => options2.fields(new SubscriptionFieldBuilder(this)));
    }
  }
  subscriptionFields(fields) {
    this.configStore.addFields("Subscription", () => fields(new SubscriptionFieldBuilder(this)));
  }
  subscriptionField(name, field) {
    this.configStore.addFields("Subscription", () => ({
      [name]: field(new SubscriptionFieldBuilder(this))
    }));
  }
  args(fields) {
    return fields(new InputFieldBuilder(this, "Arg", "[unknown]"));
  }
  interfaceType(param, options2, fields) {
    verifyRef(param);
    verifyInterfaces(options2.interfaces);
    var _name;
    const name = typeof param === "string" ? param : (_name = options2.name) !== null && _name !== void 0 ? _name : param.name;
    const ref = param instanceof BaseTypeRef2 ? param : new InterfaceRef(name);
    const typename = ref.name;
    const config2 = {
      kind: "Interface",
      graphqlKind: "Interface",
      name: typename,
      interfaces: [],
      description: options2.description,
      pothosOptions: options2,
      extensions: options2.extensions
    };
    this.configStore.addTypeConfig(config2, ref);
    if (options2.interfaces) {
      this.configStore.addInterfaces(typename, options2.interfaces);
    }
    if (typeof param === "function") {
      this.configStore.associateRefWithName(param, name);
    }
    if (fields) {
      this.configStore.addFields(ref, () => fields(new InterfaceFieldBuilder(typename, this)));
    }
    if (options2.fields) {
      this.configStore.addFields(ref, () => options2.fields(new InterfaceFieldBuilder(typename, this)));
    }
    return ref;
  }
  interfaceFields(ref, fields) {
    verifyRef(ref);
    this.configStore.onTypeConfig(ref, ({ name }) => {
      this.configStore.addFields(ref, () => fields(new InterfaceFieldBuilder(name, this)));
    });
  }
  interfaceField(ref, fieldName, field) {
    verifyRef(ref);
    this.configStore.onTypeConfig(ref, ({ name }) => {
      this.configStore.addFields(ref, () => ({
        [fieldName]: field(new InterfaceFieldBuilder(name, this))
      }));
    });
  }
  unionType(name, options2) {
    const ref = new UnionRef(name);
    options2.types.forEach((type) => {
      verifyRef(type);
    });
    const config2 = {
      kind: "Union",
      graphqlKind: "Union",
      name,
      types: options2.types || [],
      description: options2.description,
      resolveType: options2.resolveType,
      pothosOptions: options2,
      extensions: options2.extensions
    };
    this.configStore.addTypeConfig(config2, ref);
    return ref;
  }
  enumType(param, options2) {
    verifyRef(param);
    const name = typeof param === "string" ? param : options2.name;
    const ref = new EnumRef(name);
    const values = typeof param === "object" ? valuesFromEnum(param) : normalizeEnumValues(options2.values);
    const config2 = {
      kind: "Enum",
      graphqlKind: "Enum",
      name,
      values,
      description: options2.description,
      pothosOptions: options2,
      extensions: options2.extensions
    };
    this.configStore.addTypeConfig(config2, ref);
    if (typeof param !== "string") {
      this.configStore.associateRefWithName(param, name);
    }
    return ref;
  }
  scalarType(name, options2) {
    const ref = new ScalarRef2(name);
    const config2 = {
      kind: "Scalar",
      graphqlKind: "Scalar",
      name,
      description: options2.description,
      parseLiteral: options2.parseLiteral,
      parseValue: options2.parseValue,
      serialize: options2.serialize,
      pothosOptions: options2,
      extensions: options2.extensions
    };
    this.configStore.addTypeConfig(config2, ref);
    return ref;
  }
  addScalarType(name, scalar, options2) {
    const config2 = scalar.toConfig();
    return this.scalarType(name, {
      ...config2,
      ...options2,
      extensions: {
        ...config2.extensions,
        ...options2.extensions
      }
    });
  }
  inputType(param, options2) {
    verifyRef(param);
    const name = typeof param === "string" ? param : param.name;
    const ref = typeof param === "string" ? new InputObjectRef(name) : param;
    const config2 = {
      kind: "InputObject",
      graphqlKind: "InputObject",
      name,
      description: options2.description,
      pothosOptions: options2,
      extensions: options2.extensions
    };
    this.configStore.addTypeConfig(config2, ref);
    this.configStore.addFields(ref, () => options2.fields(new InputFieldBuilder(this, "InputObject", name)));
    return ref;
  }
  inputRef(name) {
    return new ImplementableInputObjectRef(this, name);
  }
  objectRef(name) {
    return new ImplementableObjectRef(this, name);
  }
  interfaceRef(name) {
    return new ImplementableInterfaceRef(this, name);
  }
  toSchema(options2) {
    const { directives, extensions } = options2;
    const scalars = [
      import_graphql10.GraphQLID,
      import_graphql10.GraphQLInt,
      import_graphql10.GraphQLFloat,
      import_graphql10.GraphQLString,
      import_graphql10.GraphQLBoolean
    ];
    scalars.forEach((scalar) => {
      if (!this.configStore.hasConfig(scalar.name)) {
        this.addScalarType(scalar.name, scalar, {});
      }
    });
    const buildCache = new BuildCache(this, options2);
    buildCache.plugin.beforeBuild();
    buildCache.buildAll();
    const builtTypes = [
      ...buildCache.types.values()
    ];
    const schema = new import_graphql10.GraphQLSchema({
      query: buildCache.types.get("Query"),
      mutation: buildCache.types.get("Mutation"),
      subscription: buildCache.types.get("Subscription"),
      extensions,
      directives,
      types: builtTypes
    });
    return (0, import_graphql10.lexicographicSortSchema)(buildCache.plugin.afterBuild(schema));
  }
  constructor(options2) {
    this.options = options2;
    this.configStore = new ConfigStore();
    var _defaultFieldNullability;
    this.defaultFieldNullability = (_defaultFieldNullability = options2.defaultFieldNullability) !== null && _defaultFieldNullability !== void 0 ? _defaultFieldNullability : false;
    var _defaultInputFieldRequiredness;
    this.defaultInputFieldRequiredness = (_defaultInputFieldRequiredness = options2.defaultInputFieldRequiredness) !== null && _defaultInputFieldRequiredness !== void 0 ? _defaultInputFieldRequiredness : false;
  }
};
SchemaBuilder.plugins = {};
SchemaBuilder.allowPluginReRegistration = false;

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/fieldUtils/base.js
var import_graphql11 = __toESM(require_graphql2(), 1);

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/refs/field.js
var FieldRef = class {
  toString() {
    if (this.fieldName) {
      return `${this.parentTypename}.${this.fieldName}`;
    }
    return this.parentTypename;
  }
  constructor(kind, parentTypename) {
    this.kind = kind;
    this.parentTypename = parentTypename;
  }
};

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/fieldUtils/base.js
var BaseFieldUtil = class {
  createField(options2) {
    const ref1 = new FieldRef(this.kind, this.typename);
    var _args;
    this.builder.configStore.addFieldRef(ref1, options2.type, (_args = options2.args) !== null && _args !== void 0 ? _args : {}, (name, parentField, typeConfig) => {
      var ref;
      const args = {};
      if (options2.args) {
        Object.keys(options2.args).forEach((argName) => {
          const argRef = options2.args[argName];
          args[argName] = this.builder.configStore.createFieldConfig(argRef, argName, typeConfig, name, "Arg");
        });
      }
      var _resolve;
      let resolve2 = (_resolve = options2.resolve) !== null && _resolve !== void 0 ? _resolve : () => {
        throw new Error(`Not implemented: No resolver found for ${this.typename}.${name}`);
      };
      if (((ref = options2.extensions) === null || ref === void 0 ? void 0 : ref.pothosExposedField) === name) {
        resolve2 = import_graphql11.defaultFieldResolver;
      }
      const { subscribe: subscribe2 } = options2;
      var _nullable;
      return {
        kind: this.kind,
        graphqlKind: this.graphqlKind,
        parentType: typeConfig.name,
        name,
        args,
        type: typeFromParam(options2.type, this.builder.configStore, (_nullable = options2.nullable) !== null && _nullable !== void 0 ? _nullable : this.builder.defaultFieldNullability),
        pothosOptions: options2,
        extensions: {
          pothosOriginalResolve: resolve2,
          pothosOriginalSubscribe: subscribe2,
          ...options2.extensions
        },
        description: options2.description,
        deprecationReason: options2.deprecationReason,
        resolve: resolve2,
        subscribe: subscribe2
      };
    });
    return ref1;
  }
  exposeField(name, { extensions, ...options2 }) {
    return this.createField({
      ...options2,
      extensions: {
        pothosExposedField: name,
        ...extensions
      },
      resolve: (parent) => parent[name]
    });
  }
  constructor(name, builder2, kind, graphqlKind) {
    this.typename = name;
    this.builder = builder2;
    this.kind = kind;
    this.graphqlKind = graphqlKind;
  }
};

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/refs/input-field.js
var InputFieldRef = class {
  toString() {
    var ref;
    if (this.kind !== "Arg") {
      if (this.fieldName) {
        return `${this.parentTypename}.${this.fieldName}`;
      }
      return this.parentTypename;
    }
    var ref1;
    const fieldName = (ref1 = (ref = this.argFor) === null || ref === void 0 ? void 0 : ref.fieldName) !== null && ref1 !== void 0 ? ref1 : "[unnamed filed]";
    var _fieldName;
    const argName = (_fieldName = this.fieldName) !== null && _fieldName !== void 0 ? _fieldName : "[unnamed argument]";
    return `${this.parentTypename}.${fieldName}(${argName})`;
  }
  constructor(kind, parentTypename) {
    this.kind = kind;
    this.parentTypename = parentTypename;
  }
};

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/fieldUtils/input.js
var InputFieldBuilder2 = class {
  argBuilder() {
    const builder2 = this.field.bind(this);
    const protoKeys = Object.keys(Object.getPrototypeOf(this)).filter((key) => typeof this[key] === "function" && Function.prototype[key] === void 0);
    [
      ...Object.keys(this),
      ...protoKeys
    ].forEach((key) => {
      builder2[key] = typeof this[key] === "function" ? this[key].bind(this) : this[key];
    });
    return builder2;
  }
  field(options2) {
    const ref = new InputFieldRef(this.kind, this.typename);
    var _required;
    this.builder.configStore.addFieldRef(ref, options2.type, {}, (name, parentField, typeConfig) => ({
      name,
      parentField,
      kind: this.kind,
      graphqlKind: this.kind,
      parentType: typeConfig.name,
      type: inputTypeFromParam(options2.type, this.builder.configStore, (_required = options2.required) !== null && _required !== void 0 ? _required : this.builder.defaultInputFieldRequiredness),
      pothosOptions: options2,
      description: options2.description,
      deprecationReason: options2.deprecationReason,
      defaultValue: options2.defaultValue,
      extensions: options2.extensions
    }));
    return ref;
  }
  helper(type) {
    return (...args) => {
      const [options2 = {}] = args;
      return this.field({
        ...options2,
        type
      });
    };
  }
  constructor(builder2, kind, typename) {
    this.boolean = this.helper("Boolean");
    this.float = this.helper("Float");
    this.id = this.helper("ID");
    this.int = this.helper("Int");
    this.string = this.helper("String");
    this.booleanList = this.helper([
      "Boolean"
    ]);
    this.floatList = this.helper([
      "Float"
    ]);
    this.idList = this.helper([
      "ID"
    ]);
    this.intList = this.helper([
      "Int"
    ]);
    this.stringList = this.helper([
      "String"
    ]);
    this.builder = builder2;
    this.kind = kind;
    this.typename = typename;
  }
};

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/fieldUtils/root.js
var RootFieldBuilder = class extends BaseFieldUtil {
  boolean(...args) {
    const [options2 = {}] = args;
    return this.createField({
      ...options2,
      type: "Boolean"
    });
  }
  float(...args) {
    const [options2 = {}] = args;
    return this.createField({
      ...options2,
      type: "Float"
    });
  }
  id(...args) {
    const [options2 = {}] = args;
    return this.createField({
      ...options2,
      type: "ID"
    });
  }
  int(...args) {
    const [options2 = {}] = args;
    return this.createField({
      ...options2,
      type: "Int"
    });
  }
  string(...args) {
    const [options2 = {}] = args;
    return this.createField({
      ...options2,
      type: "String"
    });
  }
  booleanList(...args) {
    const [options2 = {}] = args;
    return this.createField({
      ...options2,
      type: [
        "Boolean"
      ]
    });
  }
  floatList(...args) {
    const [options2 = {}] = args;
    return this.createField({
      ...options2,
      type: [
        "Float"
      ]
    });
  }
  idList(...args) {
    const [options2 = {}] = args;
    return this.createField({
      ...options2,
      type: [
        "ID"
      ]
    });
  }
  intList(...args) {
    const [options2 = {}] = args;
    return this.createField({
      ...options2,
      type: [
        "Int"
      ]
    });
  }
  stringList(...args) {
    const [options2 = {}] = args;
    return this.createField({
      ...options2,
      type: [
        "String"
      ]
    });
  }
  field(options2) {
    return this.createField(options2);
  }
  constructor(...args) {
    super(...args);
    this.arg = new InputFieldBuilder2(this.builder, "Arg", this.typename).argBuilder();
  }
};

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/fieldUtils/builder.js
var FieldBuilder = class extends RootFieldBuilder {
  exposeBoolean(...args) {
    const [name, options2 = {}] = args;
    return this.exposeField(name, {
      ...options2,
      type: "Boolean"
    });
  }
  exposeFloat(...args) {
    const [name, options2 = {}] = args;
    return this.exposeField(name, {
      ...options2,
      type: "Float"
    });
  }
  exposeID(...args) {
    const [name, options2 = {}] = args;
    return this.exposeField(name, {
      ...options2,
      type: "ID"
    });
  }
  exposeInt(...args) {
    const [name, options2 = {}] = args;
    return this.exposeField(name, {
      ...options2,
      type: "Int"
    });
  }
  exposeString(...args) {
    const [name, options2 = {}] = args;
    return this.exposeField(name, {
      ...options2,
      type: "String"
    });
  }
  exposeBooleanList(...args) {
    const [name, options2 = {}] = args;
    return this.exposeField(name, {
      ...options2,
      type: [
        "Boolean"
      ]
    });
  }
  exposeFloatList(...args) {
    const [name, options2 = {}] = args;
    return this.exposeField(name, {
      ...options2,
      type: [
        "Float"
      ]
    });
  }
  exposeIDList(...args) {
    const [name, options2 = {}] = args;
    return this.exposeField(name, {
      ...options2,
      type: [
        "ID"
      ]
    });
  }
  exposeIntList(...args) {
    const [name, options2 = {}] = args;
    return this.exposeField(name, {
      ...options2,
      type: [
        "Int"
      ]
    });
  }
  exposeStringList(...args) {
    const [name, options2 = {}] = args;
    return this.exposeField(name, {
      ...options2,
      type: [
        "String"
      ]
    });
  }
  expose(...args) {
    const [name, options2 = {}] = args;
    return this.exposeField(name, options2);
  }
};

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/fieldUtils/interface.js
var InterfaceFieldBuilder2 = class extends FieldBuilder {
  constructor(name, builder2) {
    super(name, builder2, "Interface", "Interface");
  }
};

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/fieldUtils/mutation.js
var MutationFieldBuilder2 = class extends RootFieldBuilder {
  constructor(builder2) {
    super("Mutation", builder2, "Mutation", "Object");
  }
};

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/fieldUtils/object.js
var ObjectFieldBuilder2 = class extends FieldBuilder {
  constructor(name, builder2) {
    super(name, builder2, "Object", "Object");
  }
};

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/fieldUtils/query.js
var QueryFieldBuilder2 = class extends RootFieldBuilder {
  constructor(builder2) {
    super("Query", builder2, "Query", "Object");
  }
};

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/fieldUtils/subscription.js
var SubscriptionFieldBuilder2 = class extends RootFieldBuilder {
  constructor(builder2) {
    super("Subscription", builder2, "Subscription", "Object");
  }
};

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/refs/enum.js
var EnumRef2 = class extends BaseTypeRef {
  constructor(name) {
    super("Enum", name);
    this.kind = "Enum";
  }
};

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/refs/input-object.js
var InputObjectRef2 = class extends BaseTypeRef {
  constructor(name) {
    super("InputObject", name);
    this.kind = "InputObject";
  }
};
var ImplementableInputObjectRef = class extends InputObjectRef2 {
  implement(options2) {
    this.builder.inputType(this, options2);
    return this;
  }
  constructor(builder2, name) {
    super(name);
    this.builder = builder2;
  }
};

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/refs/interface.js
var InterfaceRef2 = class extends BaseTypeRef {
  constructor(name) {
    super("Interface", name);
    this.kind = "Interface";
  }
};
var ImplementableInterfaceRef = class extends InterfaceRef2 {
  implement(options2) {
    return this.builder.interfaceType(this, options2);
  }
  constructor(builder2, name) {
    super(name);
    this.builder = builder2;
  }
};

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/refs/object.js
var ObjectRef2 = class extends BaseTypeRef {
  constructor(name) {
    super("Object", name);
    this.kind = "Object";
  }
};
var ImplementableObjectRef = class extends ObjectRef2 {
  implement(options2) {
    return this.builder.objectType(this, options2);
  }
  constructor(builder2, name) {
    super(name);
    this.builder = builder2;
  }
};

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/refs/union.js
var UnionRef2 = class extends BaseTypeRef {
  constructor(name) {
    super("Union", name);
    this.kind = "Union";
  }
};

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/refs/input.js
var InputTypeRef = class extends BaseTypeRef {
  constructor(kind, name) {
    super(kind, name);
    this.kind = kind;
  }
};

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/refs/output.js
var OutputTypeRef = class extends BaseTypeRef {
  constructor(kind, name) {
    super(kind, name);
    this.kind = kind;
  }
};

// node_modules/.pnpm/@pothos+core@3.10.0_graphql@16.4.0/node_modules/@pothos/core/esm/index.js
var SchemaBuilder2 = SchemaBuilder;
var esm_default = SchemaBuilder2;
var RootFieldBuilder2 = RootFieldBuilder;
var QueryFieldBuilder = QueryFieldBuilder2;
var MutationFieldBuilder = MutationFieldBuilder2;
var SubscriptionFieldBuilder = SubscriptionFieldBuilder2;
var ObjectFieldBuilder = ObjectFieldBuilder2;
var InterfaceFieldBuilder = InterfaceFieldBuilder2;
var InputFieldBuilder = InputFieldBuilder2;
var BaseTypeRef2 = BaseTypeRef;
var EnumRef = EnumRef2;
var InputObjectRef = InputObjectRef2;
var InterfaceRef = InterfaceRef2;
var ObjectRef = ObjectRef2;
var ScalarRef2 = ScalarRef;
var UnionRef = UnionRef2;

// node_modules/.pnpm/@pothos+plugin-prisma@3.6.1_37577a1ff16524cbc170c2bb11a0cb73/node_modules/@pothos/plugin-prisma/esm/util/cursors.js
var DEFAULT_MAX_SIZE = 100;
var DEFAULT_SIZE = 20;
function formatCursorChunk(value) {
  if (value instanceof Date) {
    return `D:${String(Number(value))}`;
  }
  switch (typeof value) {
    case "number":
      return `N:${value}`;
    case "string":
      return `S:${value}`;
    default:
      throw new TypeError(`Unsupported cursor type ${typeof value}`);
  }
}
function formatCursor(fields) {
  return (value) => {
    if (typeof fields === "string") {
      return Buffer.from(`GPC:${formatCursorChunk(value[fields])}`).toString("base64");
    }
    return Buffer.from(`GPC:J:${JSON.stringify(fields.map((name) => value[name]))}`).toString("base64");
  };
}
function parseRawCursor(cursor) {
  if (typeof cursor !== "string") {
    throw new TypeError("Cursor must be a string");
  }
  try {
    const decoded = Buffer.from(cursor, "base64").toString();
    const [, type, value] = decoded.match(/^GPC:(\w):(.*)/);
    switch (type) {
      case "S":
        return value;
      case "N":
        return Number.parseInt(value, 10);
      case "D":
        return new Date(Number.parseInt(value, 10));
      case "J":
        return JSON.parse(value);
      default:
        throw new TypeError(`Invalid cursor type ${type}`);
    }
  } catch {
    throw new Error(`Invalid cursor: ${cursor}`);
  }
}
function parseCompositeCursor(fields) {
  return (cursor) => {
    const parsed = parseRawCursor(cursor);
    if (!Array.isArray(parsed)) {
      throw new TypeError(`Expected compound cursor to contain an array, but got ${parsed}`);
    }
    const record = {};
    fields.forEach((field, i) => {
      record[field] = parsed[i];
    });
    return record;
  };
}
function prismaCursorConnectionQuery({ args: { before, after, first, last }, maxSize = DEFAULT_MAX_SIZE, defaultSize = DEFAULT_SIZE, parseCursor }) {
  if (first != null && first < 0) {
    throw new TypeError('Argument "first" must be a non-negative integer');
  }
  if (last != null && last < 0) {
    throw new Error('Argument "last" must be a non-negative integer');
  }
  if (before && after) {
    throw new Error('Arguments "before" and "after" are not supported at the same time');
  }
  if (before != null && last == null) {
    throw new Error('Argument "last" must be provided when using "before"');
  }
  if (before != null && first != null) {
    throw new Error('Arguments "before" and "first" are not supported at the same time');
  }
  if (after != null && last != null) {
    throw new Error('Arguments "after" and "last" are not supported at the same time');
  }
  const cursor = before !== null && before !== void 0 ? before : after;
  var ref;
  let take = Math.min((ref = first !== null && first !== void 0 ? first : last) !== null && ref !== void 0 ? ref : defaultSize, maxSize) + 1;
  if (before) {
    take = -take;
  }
  return cursor == null ? {
    take,
    skip: 0
  } : {
    cursor: parseCursor(cursor),
    take,
    skip: 1
  };
}
function wrapConnectionResult(results, args, take, cursor, totalCount) {
  var ref, ref1;
  const gotFullResults = results.length === Math.abs(take);
  const hasNextPage = args.before ? true : gotFullResults;
  const hasPreviousPage = args.after ? true : args.before ? gotFullResults : false;
  const nodes = gotFullResults ? results.slice(take < 0 ? 1 : 0, take < 0 ? results.length : -1) : results;
  const edges = nodes.map((value, index) => value == null ? null : {
    cursor: cursor(value),
    node: value
  });
  return {
    totalCount,
    edges,
    pageInfo: {
      startCursor: (ref = edges[0]) === null || ref === void 0 ? void 0 : ref.cursor,
      endCursor: (ref1 = edges[edges.length - 1]) === null || ref1 === void 0 ? void 0 : ref1.cursor,
      hasPreviousPage,
      hasNextPage
    }
  };
}
async function resolvePrismaCursorConnection(options2, cursor, resolve2) {
  const query = prismaCursorConnectionQuery(options2);
  const results = await resolve2({
    ...options2.query,
    ...query
  });
  return wrapConnectionResult(results, options2.args, query.take, cursor, options2.totalCount);
}

// node_modules/.pnpm/@pothos+plugin-prisma@3.6.1_37577a1ff16524cbc170c2bb11a0cb73/node_modules/@pothos/plugin-prisma/esm/object-ref.js
var prismaModelKey = Symbol.for("Pothos.prismaModelKey");
var PrismaObjectRef = class extends ObjectRef {
};

// node_modules/.pnpm/@pothos+plugin-prisma@3.6.1_37577a1ff16524cbc170c2bb11a0cb73/node_modules/@pothos/plugin-prisma/esm/util/get-client.js
var prismaClientCache = createContextCache((builder2) => createContextCache((context) => typeof builder2.options.prisma.client === "function" ? builder2.options.prisma.client(context) : builder2.options.prisma.client));
function getClient(builder2, context) {
  if (typeof builder2.options.prisma.client === "function") {
    return prismaClientCache(builder2)(context);
  }
  return builder2.options.prisma.client;
}
function getDMMF(builder2) {
  return "dmmf" in builder2.options.prisma ? builder2.options.prisma.dmmf : builder2.options.prisma.client._dmmf;
}

// node_modules/.pnpm/@pothos+plugin-prisma@3.6.1_37577a1ff16524cbc170c2bb11a0cb73/node_modules/@pothos/plugin-prisma/esm/util/datamodel.js
var refMap = /* @__PURE__ */ new WeakMap();
function getRefFromModel(name, builder2) {
  if (!refMap.has(builder2)) {
    refMap.set(builder2, /* @__PURE__ */ new Map());
  }
  const cache2 = refMap.get(builder2);
  if (!cache2.has(name)) {
    cache2.set(name, new PrismaObjectRef(name));
  }
  return cache2.get(name);
}
function getRelation(name, builder2, relation) {
  const modelData = getModel(name, builder2);
  const fieldData = modelData.fields.find((field) => field.name === relation);
  if (!fieldData) {
    throw new Error(`Field '${relation}' not found in model '${name}'`);
  }
  if (fieldData.kind !== "object") {
    throw new Error(`Field ${relation} of model '${name}' is not a relation (${fieldData.kind})`);
  }
  return fieldData;
}
function getModel(name, builder2) {
  const dmmf = getDMMF(builder2);
  const modelData = dmmf.modelMap[name];
  if (!modelData) {
    throw new Error(`Model '${name}' not found in DMMF`);
  }
  return modelData;
}
function getCursorFormatter(name, builder2, cursor) {
  var ref, ref1;
  const modelData = getModel(name, builder2);
  var ref2;
  const primaryKey = (ref2 = (ref = modelData.primaryKey) === null || ref === void 0 ? void 0 : ref.name) !== null && ref2 !== void 0 ? ref2 : (ref1 = modelData.primaryKey) === null || ref1 === void 0 ? void 0 : ref1.fields.join("_");
  return formatCursor(cursor === primaryKey ? modelData.primaryKey.fields : cursor);
}
function getCursorParser(name, builder2, cursor) {
  var ref, ref3;
  const modelData = getModel(name, builder2);
  var ref4;
  const primaryKey = (ref4 = (ref = modelData.primaryKey) === null || ref === void 0 ? void 0 : ref.name) !== null && ref4 !== void 0 ? ref4 : (ref3 = modelData.primaryKey) === null || ref3 === void 0 ? void 0 : ref3.fields.join("_");
  const parser = cursor === primaryKey ? parseCompositeCursor(modelData.primaryKey.fields) : parseRawCursor;
  return (rawCursor) => ({
    [cursor]: parser(rawCursor)
  });
}
function getDelegateFromModel(client, model) {
  const lowerCase = `${model.slice(0, 1).toLowerCase()}${model.slice(1)}`;
  const delegate = lowerCase in client ? client[lowerCase] : null;
  if (!delegate) {
    throw new Error(`Unable to find delegate for model ${model}`);
  }
  return delegate;
}

// node_modules/.pnpm/@pothos+plugin-prisma@3.6.1_37577a1ff16524cbc170c2bb11a0cb73/node_modules/@pothos/plugin-prisma/esm/util/map-query.js
var import_graphql12 = __toESM(require_graphql2(), 1);
var import_values = __toESM(require_values(), 1);

// node_modules/.pnpm/@pothos+plugin-prisma@3.6.1_37577a1ff16524cbc170c2bb11a0cb73/node_modules/@pothos/plugin-prisma/esm/util/loader-map.js
var cache = createContextCache((ctx) => /* @__PURE__ */ new Map());
function cacheKey(type, path, subPath) {
  let key = "";
  let current = path;
  while (current) {
    if (typeof current.key === "string") {
      key = key ? `${current.key}.${key}` : current.key;
    }
    current = current.prev;
  }
  for (const entry of subPath) {
    key = `${key}.${entry}`;
  }
  return `${type}@${key}`;
}
function setLoaderMappings(ctx, info, value, type) {
  Object.keys(value).forEach((field) => {
    const map3 = cache(ctx);
    const mapping = value[field];
    const subPath = [
      ...mapping.indirectPath,
      field
    ];
    const key = cacheKey(getIndirectType(type, info).name, info.path, subPath);
    map3.set(key, mapping.mappings);
  });
}
function getLoaderMapping(ctx, path, type) {
  const map3 = cache(ctx);
  const key = cacheKey(type, path, []);
  var ref;
  return (ref = map3.get(key)) !== null && ref !== void 0 ? ref : null;
}

// node_modules/.pnpm/@pothos+plugin-prisma@3.6.1_37577a1ff16524cbc170c2bb11a0cb73/node_modules/@pothos/plugin-prisma/esm/util/deep-equal.js
function deepEqual2(left, right, ignore) {
  if (left === right) {
    return true;
  }
  if (left && right && typeof left === "object" && typeof right === "object") {
    if (Array.isArray(left)) {
      if (!Array.isArray(right)) {
        return false;
      }
      const { length } = left;
      if (right.length !== length) {
        return false;
      }
      for (let i = 0; i < length; i += 1) {
        if (!deepEqual2(left[i], right[i])) {
          return false;
        }
      }
      return true;
    }
    const keys2 = Object.keys(left);
    const keyLength = keys2.length;
    if (keyLength !== Object.keys(right).length) {
      return false;
    }
    for (const key of keys2) {
      if (ignore === null || ignore === void 0 ? void 0 : ignore.has(key)) {
        continue;
      }
      if (!deepEqual2(left[key], right[key])) {
        return false;
      }
    }
    return true;
  }
  return false;
}

// node_modules/.pnpm/@pothos+plugin-prisma@3.6.1_37577a1ff16524cbc170c2bb11a0cb73/node_modules/@pothos/plugin-prisma/esm/util/selections.js
function selectionCompatible(state, selectionMap, ignoreQuery = false) {
  if (typeof selectionMap === "boolean") {
    return ignoreQuery || !selectionMap || Object.keys(state.query).length === 0;
  }
  const { select, include, ...query } = selectionMap;
  if (select && Object.keys(select).some((key) => compare2(key, select[key]))) {
    return false;
  }
  if (include && Object.keys(include).some((key) => compare2(key, include[key]))) {
    return false;
  }
  return ignoreQuery || deepEqual2(state.query, query);
  function compare2(key, value) {
    return value && state.fieldMap.relations.has(key) && state.relations.has(key) && !selectionCompatible(state.relations.get(key), value);
  }
}
function createState(fieldMap, mode, parent) {
  return {
    parent,
    mode,
    fieldMap,
    query: {},
    fields: /* @__PURE__ */ new Set(),
    counts: /* @__PURE__ */ new Set(),
    relations: /* @__PURE__ */ new Map(),
    mappings: {}
  };
}
function mergeSelection(state, { select, include, ...query }) {
  if (state.mode === "select" && !select) {
    state.mode = "include";
  }
  if (include) {
    Object.keys(include).forEach((key) => {
      merge(key, include[key]);
    });
  }
  if (select) {
    Object.keys(select).forEach((key) => {
      merge(key, select[key]);
    });
  }
  if (Object.keys(query).length > 0) {
    state.query = query;
  }
  function merge(key, value) {
    if (!value) {
      return;
    }
    if (key === "_count") {
      var _select;
      const counts = (_select = value.select) !== null && _select !== void 0 ? _select : {};
      Object.keys(counts).forEach((count) => {
        state.counts.add(count);
      });
      return;
    }
    const selection = value === true ? {
      include: {}
    } : value;
    const childMap = state.fieldMap.relations.get(key);
    if (childMap) {
      if (state.relations.has(key)) {
        mergeSelection(state.relations.get(key), selection);
      } else {
        const relatedState = createState(childMap, "select");
        mergeSelection(relatedState, selection);
        state.relations.set(key, relatedState);
      }
    } else {
      state.fields.add(key);
    }
  }
}
function selectionToQuery(state) {
  const nestedIncludes = {};
  const counts = {};
  let hasSelection = false;
  state.relations.forEach((sel, relation) => {
    hasSelection = true;
    const nested = selectionToQuery(sel);
    nestedIncludes[relation] = Object.keys(nested).length > 0 ? nested : true;
  });
  if (state.counts.size > 0) {
    hasSelection = true;
    for (const count of state.counts) {
      counts[count] = true;
    }
    nestedIncludes._count = {
      select: counts
    };
  }
  if (state.mode === "select") {
    state.fields.forEach((field) => {
      hasSelection = true;
      nestedIncludes[field] = true;
    });
    return {
      ...state.query,
      select: nestedIncludes
    };
  }
  return hasSelection ? {
    ...state.query,
    include: nestedIncludes
  } : state.query;
}

// node_modules/.pnpm/@pothos+plugin-prisma@3.6.1_37577a1ff16524cbc170c2bb11a0cb73/node_modules/@pothos/plugin-prisma/esm/util/map-query.js
function addTypeSelectionsForField(type, context, info, state, selection, indirectPath) {
  if (selection.name.value.startsWith("__")) {
    return;
  }
  var _extensions;
  const { pothosPrismaInclude, pothosPrismaSelect, pothosPrismaIndirectInclude, pothosPrismaModel } = (_extensions = type.extensions) !== null && _extensions !== void 0 ? _extensions : {};
  if (pothosPrismaIndirectInclude) {
    resolveIndirectInclude(type, info, selection, pothosPrismaIndirectInclude.path, indirectPath, (resolvedType, field, path) => {
      addTypeSelectionsForField(resolvedType, context, info, state, field, path);
    });
  }
  if (!(0, import_graphql12.isObjectType)(type)) {
    return;
  }
  if (pothosPrismaModel && !pothosPrismaSelect) {
    state.mode = "include";
  }
  if (pothosPrismaInclude || pothosPrismaSelect) {
    mergeSelection(state, {
      select: pothosPrismaSelect ? {
        ...pothosPrismaSelect
      } : void 0,
      include: pothosPrismaInclude ? {
        ...pothosPrismaInclude
      } : void 0
    });
  }
  if (selection.selectionSet) {
    addNestedSelections(type, context, info, state, selection.selectionSet, indirectPath);
  }
}
function resolveIndirectInclude(type, info, selection, includePath, path, resolve2) {
  const [include, ...rest] = includePath;
  if (!selection.selectionSet || !include) {
    return;
  }
  for (const sel of selection.selectionSet.selections) {
    switch (sel.kind) {
      case import_graphql12.Kind.FIELD:
        if (sel.name.value === include.name && (0, import_graphql12.isObjectType)(type)) {
          const returnType = (0, import_graphql12.getNamedType)(type.getFields()[sel.name.value].type);
          if (rest.length === 0) {
            var ref;
            var ref1;
            resolve2(returnType, sel, [
              ...path,
              (ref1 = (ref = sel.alias) === null || ref === void 0 ? void 0 : ref.value) !== null && ref1 !== void 0 ? ref1 : sel.name.value
            ]);
          } else {
            var ref2;
            var ref3;
            resolveIndirectInclude(returnType, info, sel, rest, [
              ...path,
              (ref3 = (ref2 = sel.alias) === null || ref2 === void 0 ? void 0 : ref2.value) !== null && ref3 !== void 0 ? ref3 : sel.name.value
            ], resolve2);
          }
        }
        continue;
      case import_graphql12.Kind.FRAGMENT_SPREAD:
        if (info.fragments[sel.name.value].typeCondition.name.value === include.type) {
          resolveIndirectInclude(info.schema.getType(include.type), info, info.fragments[sel.name.value], includePath, path, resolve2);
        }
        continue;
      case import_graphql12.Kind.INLINE_FRAGMENT:
        if (!sel.typeCondition || sel.typeCondition.name.value === include.type) {
          resolveIndirectInclude(sel.typeCondition ? info.schema.getType(sel.typeCondition.name.value) : type, info, sel, includePath, path, resolve2);
        }
        continue;
      default:
        throw new Error(`Unsupported selection kind ${selection.kind}`);
    }
  }
}
function addNestedSelections(type, context, info, state, selections, indirectPath) {
  for (const selection of selections.selections) {
    switch (selection.kind) {
      case import_graphql12.Kind.FIELD:
        addFieldSelection(type, context, info, state, selection, indirectPath);
        continue;
      case import_graphql12.Kind.FRAGMENT_SPREAD:
        if (info.fragments[selection.name.value].typeCondition.name.value !== type.name) {
          continue;
        }
        addNestedSelections(type, context, info, state, info.fragments[selection.name.value].selectionSet, indirectPath);
        continue;
      case import_graphql12.Kind.INLINE_FRAGMENT:
        if (selection.typeCondition && selection.typeCondition.name.value !== type.name) {
          continue;
        }
        addNestedSelections(type, context, info, state, selection.selectionSet, indirectPath);
        continue;
      default:
        throw new Error(`Unsupported selection kind ${selection.kind}`);
    }
  }
}
function addFieldSelection(type, context, info, state, selection, indirectPath) {
  var ref, ref4;
  if (selection.name.value.startsWith("__")) {
    return;
  }
  const field = type.getFields()[selection.name.value];
  if (!field) {
    throw new Error(`Unknown field ${selection.name.value} on ${type.name}`);
  }
  const fieldSelect = (ref = field.extensions) === null || ref === void 0 ? void 0 : ref.pothosPrismaSelect;
  let fieldSelectionMap;
  const fieldParentSelect = (ref4 = field.extensions) === null || ref4 === void 0 ? void 0 : ref4.pothosPrismaParentSelect;
  let mappings = {};
  if (typeof fieldSelect === "function") {
    const args = (0, import_values.getArgumentValues)(field, selection, info.variableValues);
    fieldSelectionMap = fieldSelect(args, context, (rawQuery) => {
      const returnType = (0, import_graphql12.getNamedType)(field.type);
      const query = typeof rawQuery === "function" ? rawQuery(args, context) : rawQuery;
      const fieldState = createStateForType(returnType, info, state);
      if (typeof query === "object" && Object.keys(query).length > 0) {
        mergeSelection(fieldState, {
          select: {},
          ...query
        });
      }
      addTypeSelectionsForField(returnType, context, info, fieldState, selection, []);
      mappings = fieldState.mappings;
      return selectionToQuery(fieldState);
    });
  } else {
    fieldSelectionMap = {
      select: fieldSelect
    };
  }
  if (fieldSelect && selectionCompatible(state, fieldSelectionMap, true)) {
    var ref5;
    mergeSelection(state, fieldSelectionMap);
    var ref6;
    state.mappings[(ref6 = (ref5 = selection.alias) === null || ref5 === void 0 ? void 0 : ref5.value) !== null && ref6 !== void 0 ? ref6 : selection.name.value] = {
      field: selection.name.value,
      mappings,
      indirectPath
    };
  } else if (fieldParentSelect && state.parent && selectionCompatible(state.parent, {
    select: fieldParentSelect
  }, true)) {
    var ref7;
    mergeSelection(state.parent, {
      select: fieldParentSelect
    });
    var ref8;
    state.mappings[(ref8 = (ref7 = selection.alias) === null || ref7 === void 0 ? void 0 : ref7.value) !== null && ref8 !== void 0 ? ref8 : selection.name.value] = {
      field: selection.name.value,
      mappings,
      indirectPath
    };
  }
}
function queryFromInfo(context, info, typeName) {
  const type = typeName ? info.schema.getTypeMap()[typeName] : (0, import_graphql12.getNamedType)(info.returnType);
  const state = createStateForType(type, info);
  addTypeSelectionsForField(type, context, info, state, info.fieldNodes[0], []);
  setLoaderMappings(context, info, state.mappings, type);
  return selectionToQuery(state);
}
function selectionStateFromInfo(context, info, typeName) {
  const type = typeName ? info.schema.getTypeMap()[typeName] : info.parentType;
  const state = createStateForType(type, info);
  if (!(0, import_graphql12.isObjectType)(type)) {
    throw new Error("Prisma plugin can only resolve includes for object types");
  }
  addFieldSelection(type, context, info, state, info.fieldNodes[0], []);
  return state;
}
function createStateForType(type, info, parent) {
  var ref, ref9;
  const targetType = getIndirectType(type, info);
  const fieldMap = (ref = targetType.extensions) === null || ref === void 0 ? void 0 : ref.pothosPrismaFieldMap;
  return createState(fieldMap, ((ref9 = targetType.extensions) === null || ref9 === void 0 ? void 0 : ref9.pothosPrismaSelect) ? "select" : "include", parent);
}
function getIndirectType(type, info) {
  var ref;
  let targetType = type;
  while ((ref = targetType.extensions) === null || ref === void 0 ? void 0 : ref.pothosPrismaIndirectInclude) {
    var ref10;
    targetType = info.schema.getType(((ref10 = targetType.extensions) === null || ref10 === void 0 ? void 0 : ref10.pothosPrismaIndirectInclude).getType());
  }
  return targetType;
}

// node_modules/.pnpm/@pothos+plugin-prisma@3.6.1_37577a1ff16524cbc170c2bb11a0cb73/node_modules/@pothos/plugin-prisma/esm/prisma-field-builder.js
var RootBuilder = RootFieldBuilder2;
var PrismaObjectFieldBuilder = class extends RootBuilder {
  relation(...allArgs) {
    const [name, options2 = {}] = allArgs;
    const relationField = getRelation(this.model, this.builder, name);
    var _type;
    const ref = (_type = options2.type) !== null && _type !== void 0 ? _type : getRefFromModel(relationField.type, this.builder);
    const { query = {}, resolve: resolve2, extensions, ...rest } = options2;
    const relationSelect = (args, context, nestedQuery) => ({
      select: {
        [name]: nestedQuery(query)
      }
    });
    return this.field({
      ...rest,
      type: relationField.isList ? [
        ref
      ] : ref,
      extensions: {
        ...extensions,
        pothosPrismaSelect: relationSelect,
        pothosPrismaLoaded: (value) => value[name] !== void 0,
        pothosPrismaFallback: resolve2 && ((q, parent, args, context, info) => resolve2({
          ...q,
          ...typeof query === "function" ? query(args, context) : query
        }, parent, args, context, info))
      },
      resolve: (parent) => parent[name]
    });
  }
  relationCount(...allArgs) {
    const [name, options2 = {}] = allArgs;
    const { resolve: resolve2, ...rest } = options2;
    const countSelect = {
      _count: {
        select: {
          [name]: true
        }
      }
    };
    return this.field({
      ...rest,
      type: "Int",
      nullable: false,
      select: countSelect,
      resolve: (parent, args, context, info) => {
        var ref;
        return (ref = parent._count) === null || ref === void 0 ? void 0 : ref[name];
      }
    });
  }
  variant(...allArgs) {
    const [variant, options2 = {}] = allArgs;
    const ref = typeof variant === "string" ? getRefFromModel(variant, this.builder) : variant;
    const selfSelect = (args, context, nestedQuery) => nestedQuery({});
    return this.field({
      ...options2,
      type: ref,
      extensions: {
        ...options2 === null || options2 === void 0 ? void 0 : options2.extensions,
        pothosPrismaSelect: selfSelect
      },
      resolve: (parent, args, context, info) => parent
    });
  }
  expose(...args) {
    var ref;
    const [name, options2 = {}] = args;
    const typeConfig = this.builder.configStore.getTypeConfig(this.typename, "Object");
    const usingSelect = !!((ref = typeConfig.extensions) === null || ref === void 0 ? void 0 : ref.pothosPrismaSelect);
    return this.exposeField(name, {
      ...options2,
      extensions: {
        ...options2.extensions,
        pothosPrismaVariant: name,
        pothosPrismaSelect: usingSelect && {
          [name]: true
        }
      }
    });
  }
  createExpose(type) {
    return (...args) => {
      const [name, options2 = {}] = args;
      return this.expose(name, {
        ...options2,
        type
      });
    };
  }
  constructor(name1, builder2, model, fieldMap) {
    super(name1, builder2, "PrismaObject", "Object");
    this.exposeBoolean = this.createExpose("Boolean");
    this.exposeFloat = this.createExpose("Float");
    this.exposeInt = this.createExpose("Int");
    this.exposeID = this.createExpose("ID");
    this.exposeString = this.createExpose("String");
    this.exposeBooleanList = this.createExpose([
      "Boolean"
    ]);
    this.exposeFloatList = this.createExpose([
      "Float"
    ]);
    this.exposeIntList = this.createExpose([
      "Int"
    ]);
    this.exposeIDList = this.createExpose([
      "ID"
    ]);
    this.exposeStringList = this.createExpose([
      "String"
    ]);
    this.relatedConnection = function relatedConnection(name, { maxSize, defaultSize, cursor, query, resolve: resolve2, extensions, totalCount, ...options2 }, connectionOptions = {}, edgeOptions = {}) {
      var ref2;
      const relationField = getRelation(this.model, this.builder, name);
      var _type;
      const ref1 = (_type = options2.type) !== null && _type !== void 0 ? _type : getRefFromModel(relationField.type, this.builder);
      let typeName;
      const formatCursor2 = getCursorFormatter(relationField.type, this.builder, cursor);
      const parseCursor = getCursorParser(relationField.type, this.builder, cursor);
      const getQuery = (args, ctx) => ({
        ...typeof query === "function" ? query(args, ctx) : query,
        ...prismaCursorConnectionQuery({
          parseCursor,
          maxSize,
          defaultSize,
          args
        })
      });
      const relationSelect = (args, context, nestedQuery) => ({
        select: {
          [name]: nestedQuery({
            ...typeof query === "function" ? query(args, context) : query,
            ...prismaCursorConnectionQuery({
              parseCursor,
              maxSize,
              defaultSize,
              args
            })
          })
        }
      });
      const fieldRef = this.connection({
        ...options2,
        extensions: {
          ...extensions,
          pothosPrismaSelect: relationSelect,
          pothosPrismaLoaded: (value) => value[name] !== void 0,
          pothosPrismaFallback: resolve2 && ((q, parent, args, context, info) => Promise.resolve(resolve2({
            ...q,
            ...typeof query === "function" ? query(args, context) : query
          }, parent, args, context, info)).then((result) => wrapConnectionResult(result, args, q.take, formatCursor2)))
        },
        type: ref1,
        resolve: (parent, args, context) => {
          var ref;
          const connectionQuery = getQuery(args, context);
          return wrapConnectionResult(parent[name], args, connectionQuery.take, formatCursor2, (ref = parent._count) === null || ref === void 0 ? void 0 : ref[name]);
        }
      }, {
        ...connectionOptions,
        fields: totalCount ? (t) => {
          var _obj, ref;
          return {
            totalCount: t.int({
              nullable: false,
              extensions: {
                pothosPrismaParentSelect: {
                  _count: {
                    select: {
                      [name]: true
                    }
                  }
                }
              },
              resolve: (parent, args, context) => parent.totalCount
            }),
            ...(ref = (_obj = connectionOptions).fields) === null || ref === void 0 ? void 0 : ref.call(_obj, t)
          };
        } : connectionOptions.fields,
        extensions: {
          ...(ref2 = connectionOptions) === null || ref2 === void 0 ? void 0 : ref2.extensions,
          pothosPrismaIndirectInclude: {
            getType: () => {
              if (!typeName) {
                typeName = this.builder.configStore.getTypeConfig(ref1).name;
              }
              return typeName;
            },
            path: [
              {
                name: "edges"
              },
              {
                name: "node"
              }
            ]
          }
        }
      }, edgeOptions);
      return fieldRef;
    };
    this.model = model;
    this.prismaFieldMap = fieldMap;
  }
};

// node_modules/.pnpm/@pothos+plugin-prisma@3.6.1_37577a1ff16524cbc170c2bb11a0cb73/node_modules/@pothos/plugin-prisma/esm/field-builder.js
var fieldBuilderProto = RootFieldBuilder2.prototype;
fieldBuilderProto.prismaField = function prismaField({ type, resolve: resolve2, ...options2 }) {
  const modelOrRef = Array.isArray(type) ? type[0] : type;
  const typeRef = typeof modelOrRef === "string" ? getRefFromModel(modelOrRef, this.builder) : modelOrRef;
  const typeParam = Array.isArray(type) ? [
    typeRef
  ] : typeRef;
  return this.field({
    ...options2,
    type: typeParam,
    resolve: (parent, args, ctx, info) => {
      const query = queryFromInfo(ctx, info);
      return resolve2(query, parent, args, ctx, info);
    }
  });
};
fieldBuilderProto.prismaConnection = function prismaConnection({ type, cursor, maxSize, defaultSize, resolve: resolve2, totalCount, ...options2 }, connectionOptions = {}, edgeOptions = {}) {
  var ref3, ref1;
  const ref2 = typeof type === "string" ? getRefFromModel(type, this.builder) : type;
  const typeName = this.builder.configStore.getTypeConfig(ref2).name;
  const model = (ref3 = this.builder.configStore.getTypeConfig(ref2).extensions) === null || ref3 === void 0 ? void 0 : ref3.pothosPrismaModel;
  const formatCursor2 = getCursorFormatter(model, this.builder, cursor);
  const parseCursor = getCursorParser(model, this.builder, cursor);
  const fieldRef = this.connection({
    ...options2,
    type: ref2,
    resolve: (parent, args, ctx, info) => resolvePrismaCursorConnection({
      query: queryFromInfo(ctx, info),
      parseCursor,
      maxSize,
      defaultSize,
      args,
      totalCount: totalCount && (() => totalCount(parent, args, ctx, info))
    }, formatCursor2, (query) => resolve2(query, parent, args, ctx, info))
  }, {
    ...connectionOptions,
    fields: totalCount ? (t) => {
      var _obj, ref4;
      return {
        totalCount: t.int({
          nullable: false,
          resolve: (parent, args, context) => {
            var ref;
            return (ref = parent.totalCount) === null || ref === void 0 ? void 0 : ref.call(parent);
          }
        }),
        ...(ref4 = (_obj = connectionOptions).fields) === null || ref4 === void 0 ? void 0 : ref4.call(_obj, t)
      };
    } : connectionOptions.fields,
    extensions: {
      ...(ref1 = connectionOptions) === null || ref1 === void 0 ? void 0 : ref1.extensions,
      pothosPrismaIndirectInclude: {
        getType: () => typeName,
        path: [
          {
            name: "edges"
          },
          {
            name: "node"
          }
        ]
      }
    }
  }, edgeOptions);
  return fieldRef;
};

// node_modules/.pnpm/@pothos+plugin-prisma@3.6.1_37577a1ff16524cbc170c2bb11a0cb73/node_modules/@pothos/plugin-prisma/esm/model-loader.js
var ModelLoader = class {
  static forRef(modelName, findUnique, builder2) {
    return createContextCache((model) => new ModelLoader(model, builder2, modelName, findUnique));
  }
  async loadSelection(selection, context) {
    const query = selectionToQuery(selection);
    for (const entry of this.staged) {
      if (selectionCompatible(entry.state, query)) {
        mergeSelection(entry.state, query);
        return entry.promise;
      }
    }
    return this.initLoad(selection, context);
  }
  async initLoad(state, context) {
    const entry = {
      promise: Promise.resolve().then(() => {
        this.staged.delete(entry);
        const delegate = getDelegateFromModel(getClient(this.builder, context), this.modelName);
        return delegate.findUnique({
          rejectOnNotFound: true,
          ...selectionToQuery(state),
          where: {
            ...this.findUnique(this.model, context)
          }
        });
      }),
      state
    };
    this.staged.add(entry);
    return entry.promise;
  }
  constructor(model, builder2, modelName, findUnique) {
    this.staged = /* @__PURE__ */ new Set();
    this.model = model;
    this.builder = builder2;
    this.findUnique = findUnique;
    this.modelName = modelName;
  }
};

// node_modules/.pnpm/@pothos+plugin-prisma@3.6.1_37577a1ff16524cbc170c2bb11a0cb73/node_modules/@pothos/plugin-prisma/esm/node-ref.js
var PrismaNodeRef = class extends PrismaObjectRef {
  addBrand(value) {
    if (Array.isArray(value)) {
      value.forEach((val) => void brandWithType(val, this.name));
      return value;
    }
    brandWithType(value, this.name);
    return value;
  }
  hasBrand(value) {
    return typeof value === "object" && value !== null && typeBrandKey in value && value[typeBrandKey] === this.name;
  }
};

// node_modules/.pnpm/@pothos+plugin-prisma@3.6.1_37577a1ff16524cbc170c2bb11a0cb73/node_modules/@pothos/plugin-prisma/esm/util/relation-map.js
var getRelationMap = createContextCache((dmmf) => createRelationMap(dmmf.datamodel));
function createRelationMap({ models }) {
  const relationMap = /* @__PURE__ */ new Map();
  models.forEach((model) => {
    relationMap.set(model.name, {
      model: model.name,
      relations: /* @__PURE__ */ new Map()
    });
  });
  models.forEach((model) => {
    const map3 = relationMap.get(model.name).relations;
    model.fields.forEach((field) => {
      if (field.kind === "object" && relationMap.has(field.type)) {
        map3.set(field.name, relationMap.get(field.type));
      }
    });
  });
  return relationMap;
}

// node_modules/.pnpm/@pothos+plugin-prisma@3.6.1_37577a1ff16524cbc170c2bb11a0cb73/node_modules/@pothos/plugin-prisma/esm/schema-builder.js
var schemaBuilderProto = esm_default.prototype;
schemaBuilderProto.prismaObject = function prismaObject(type, { fields, findUnique, ...options2 }) {
  const ref = options2.variant ? this.objectRef(options2.variant) : getRefFromModel(type, this);
  var _variant, ref1;
  const name = (ref1 = (_variant = options2.variant) !== null && _variant !== void 0 ? _variant : options2.name) !== null && ref1 !== void 0 ? ref1 : type;
  const fieldMap = getRelationMap(getDMMF(this)).get(type);
  ref.name = name;
  this.objectType(ref, {
    ...options2,
    extensions: {
      ...options2.extensions,
      pothosPrismaInclude: options2.include,
      pothosPrismaModel: type,
      pothosPrismaFieldMap: fieldMap,
      pothosPrismaSelect: options2.select,
      pothosPrismaLoader: ModelLoader.forRef(type, findUnique || (() => {
        throw new Error(`Missing findUnique for ${ref.name}`);
      }), this)
    },
    name,
    fields: fields ? () => fields(new PrismaObjectFieldBuilder(name, this, type, getRelationMap(getDMMF(this)).get(type))) : void 0
  });
  return ref;
};
schemaBuilderProto.prismaNode = function prismaNode(type, { findUnique, name, variant, ...options2 }) {
  var _obj, ref;
  const interfaceRef = (ref = (_obj = this).nodeInterfaceRef) === null || ref === void 0 ? void 0 : ref.call(_obj);
  if (!interfaceRef) {
    throw new TypeError("builder.prismaNode requires @pothos/plugin-relay to be installed");
  }
  var ref2;
  const typeName = (ref2 = variant !== null && variant !== void 0 ? variant : name) !== null && ref2 !== void 0 ? ref2 : type;
  const nodeRef = new PrismaNodeRef(typeName);
  const extendedOptions = {
    ...options2,
    variant,
    interfaces: [
      interfaceRef
    ],
    findUnique: (parent, context) => findUnique(options2.id.resolve(parent, context), context),
    loadWithoutCache: async (id, context, info) => {
      const query = queryFromInfo(context, info, typeName);
      const delegate = getDelegateFromModel(getClient(this, context), type);
      const record = await delegate.findUnique({
        ...query,
        rejectOnNotFound: true,
        where: findUnique(id, context)
      });
      brandWithType(record, typeName);
      return record;
    }
  };
  const ref3 = this.prismaObject(type, extendedOptions);
  if (options2.interfaces) {
    this.configStore.addInterfaces(typeName, options2.interfaces);
  }
  this.configStore.onTypeConfig(ref3, (nodeConfig) => {
    this.objectField(ref3, "id", (t) => t.globalID({
      ...options2.id,
      nullable: false,
      args: {},
      resolve: async (parent, args, context, info) => ({
        type: nodeConfig.name,
        id: await options2.id.resolve(parent, context)
      })
    }));
  });
  this.configStore.associateRefWithName(nodeRef, typeName);
  return nodeRef;
};

// node_modules/.pnpm/@pothos+plugin-prisma@3.6.1_37577a1ff16524cbc170c2bb11a0cb73/node_modules/@pothos/plugin-prisma/esm/index.js
var import_graphql13 = __toESM(require_graphql2(), 1);

// node_modules/.pnpm/@pothos+plugin-prisma@3.6.1_37577a1ff16524cbc170c2bb11a0cb73/node_modules/@pothos/plugin-prisma/esm/types.js
var prismaModelName = Symbol.for("Pothos.prismaModelName");

// node_modules/.pnpm/@pothos+plugin-prisma@3.6.1_37577a1ff16524cbc170c2bb11a0cb73/node_modules/@pothos/plugin-prisma/esm/index.js
var pluginName = "prisma";
var esm_default2 = pluginName;
var PrismaPlugin = class extends BasePlugin {
  onOutputFieldConfig(fieldConfig) {
    if (fieldConfig.kind === "PrismaObject" && fieldConfig.pothosOptions.select) {
      const { select } = fieldConfig.pothosOptions;
      return {
        ...fieldConfig,
        extensions: {
          ...fieldConfig.extensions,
          pothosPrismaSelect: typeof select === "function" ? (args, ctx) => ({
            select: select(args, ctx)
          }) : select
        }
      };
    }
    return fieldConfig;
  }
  wrapResolve(resolver, fieldConfig) {
    var ref, ref1, ref2, ref3;
    if (fieldConfig.kind !== "PrismaObject" || !((ref = fieldConfig.extensions) === null || ref === void 0 ? void 0 : ref.pothosPrismaSelect)) {
      return resolver;
    }
    const parentConfig = this.buildCache.getTypeConfig(fieldConfig.parentType, "Object");
    const loadedCheck = (ref1 = fieldConfig.extensions) === null || ref1 === void 0 ? void 0 : ref1.pothosPrismaLoaded;
    const loaderCache = (ref2 = parentConfig.extensions) === null || ref2 === void 0 ? void 0 : ref2.pothosPrismaLoader;
    const fallback = (ref3 = fieldConfig.extensions) === null || ref3 === void 0 ? void 0 : ref3.pothosPrismaFallback;
    return (parent, args, context, info) => {
      const mapping = getLoaderMapping(context, info.path, info.parentType.name);
      if ((!loadedCheck || loadedCheck(parent)) && mapping) {
        setLoaderMappings(context, info, mapping, (0, import_graphql13.getNamedType)(info.returnType));
        return resolver(parent, args, context, info);
      }
      if (fallback) {
        return fallback(queryFromInfo(context, info), parent, args, context, info);
      }
      const selectionState = selectionStateFromInfo(context, info);
      return loaderCache(parent).loadSelection(selectionState, context).then((result) => {
        const mappings = selectionState.mappings[info.path.key];
        if (mappings) {
          setLoaderMappings(context, info, mappings.mappings, (0, import_graphql13.getNamedType)(info.returnType));
        }
        return resolver(result, args, context, info);
      });
    };
  }
  constructor(cache2) {
    super(cache2, pluginName);
  }
};
esm_default.registerPlugin(pluginName, PrismaPlugin);

// src/main.ts
var import_client = __toESM(require_client3());
var prisma = new import_client.PrismaClient();
var builder = new esm_default({
  plugins: [esm_default2],
  prisma: {
    client: prisma
  }
});
builder.queryType({
  fields: (t) => ({
    hello: t.string({
      args: {
        name: t.arg.string()
      },
      resolve: (_parent, { name }) => `hello, ${name || "World"}`
    })
  })
});
var yoga = createServer({
  schema: builder.toSchema({})
});
yoga.start();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/*! Based on fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> & David Frank */
/*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
/*! https://mths.be/punycode v1.4.1 by @mathias */
/**
 * @license
 * web-streams-polyfill v4.0.0-beta.1
 * Copyright 2021 Mattias Buelens, Diwank Singh Tomer and other contributors.
 * This code is released under the MIT license.
 * SPDX-License-Identifier: MIT
 */
